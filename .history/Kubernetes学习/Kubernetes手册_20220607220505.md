#  1.  Kubernetes 入门

##  1.  Kubernetes 生产环境

###  1.  Kubernetes 容器运行时
容器运行时
-----

你需要在集群内每个节点上安装一个 容器运行时 以使 Pod 可以运行在上面。本文概述了所涉及的内容并描述了与节点设置相关的任务。

Kubernetes 1.24 要求你使用符合容器运行时接口 (CRI)的运行时。

有关详细信息，请参阅该文的 CRI 版本支持。 本页简要介绍在 Kubernetes 中几个常见的容器运行时的用法。

*   ​`containerd` ​
*   ​`CRI-O` ​
*   ​`Docker Engine` ​
*   ​`Mirantis Container Runtime`​

> Note:  
> 提示：v1.24 之前的 Kubernetes 版本包括与 Docker Engine 的直接集成，使用名为 dockershim 的组件。 这种特殊的直接整合不再是 Kubernetes 的一部分 （这次删除被作为 v1.20 发行版本的一部分宣布）。   
> 如果你正在运行 v1.24 以外的 Kubernetes 版本，检查该版本的文档。

安装和配置先决条件
---------

以下步骤将通用设置应用于 Linux 上的 Kubernetes 节点。

如果你确定不需要某个特定设置，则可以跳过它。

#### 转发 IPv4 并让 iptables 看到桥接流量

通过运行 ​`lsmod | grep br_netfilter`​ 来验证 ​`br_netfilter`​ 模块是否已加载。

若要显式加载此模块，请运行 ​`sudo modprobe br_netfilter`​。

为了让 Linux 节点的 iptables 能够正确查看桥接流量，请确认 ​`sysctl` ​配置中的 ​`net.bridge.bridge-nf-call-iptables`​ 设置为 1。 例如：

`cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF  sudo modprobe overlay sudo modprobe br_netfilter  # 设置所需的 sysctl 参数，参数在重新启动后保持不变 cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-iptables  = 1 net.bridge.bridge-nf-call-ip6tables = 1 net.ipv4.ip_forward                 = 1 EOF  # 应用 sysctl 参数而不重新启动 sudo sysctl --system`

Cgroup 驱动程序 
------------

在 Linux 上，控制组（CGroup）用于限制分配给进程的资源。

当某个 Linux 系统发行版使用 [systemd](https://www.freedesktop.org/wiki/Software/systemd/) 作为其初始化系统时，初始化进程会生成并使用一个 root 控制组（​`cgroup`​），并充当 cgroup 管理器。 Systemd 与 cgroup 集成紧密，并将为每个 systemd 单元分配一个 cgroup。 你也可以配置容器运行时和 kubelet 使用 ​`cgroupfs`​。 连同 systemd 一起使用 ​`cgroupfs` ​意味着将有两个不同的 cgroup 管理器。

单个 cgroup 管理器将简化分配资源的视图，并且默认情况下将对可用资源和使用 中的资源具有更一致的视图。 当有两个管理器共存于一个系统中时，最终将对这些资源产生两种视图。 在此领域人们已经报告过一些案例，某些节点配置让 kubelet 和 docker 使用 ​`cgroupfs`​，而节点上运行的其余进程则使用 systemd; 这类节点在资源压力下 会变得不稳定。

更改设置，令容器运行时和 kubelet 使用 ​`systemd` ​作为 cgroup 驱动，以此使系统更为稳定。 对于 Docker, 设置 ​`native.cgroupdriver=systemd`​ 选项。

注意：更改已加入集群的节点的 cgroup 驱动是一项敏感的操作。 如果 kubelet 已经使用某 cgroup 驱动的语义创建了 pod，更改运行时以使用 别的 cgroup 驱动，当为现有 Pods 重新创建 PodSandbox 时会产生错误。 重启 kubelet 也可能无法解决此类问题。 如果你有切实可行的自动化方案，使用其他已更新配置的节点来替换该节点， 或者使用自动化方案来重新安装。

#### Cgroup v2

Cgroup v2 是 cgroup Linux API 的下一个版本。与 cgroup v1 不同的是， Cgroup v2 只有一个层次结构，而不是每个控制器有一个不同的层次结构。

新版本对 cgroup v1 进行了多项改进，其中一些改进是：

*   更简洁、更易于使用的 API
*   可将安全子树委派给容器
*   更新的功能，如压力失速信息（Pressure Stall Information）

尽管内核支持混合配置，即其中一些控制器由 cgroup v1 管理，另一些由 cgroup v2 管理， Kubernetes 仅支持使用同一 cgroup 版本来管理所有控制器。

如果 systemd 默认不使用 cgroup v2，你可以通过在内核命令行中添加 ​`systemd.unified_cgroup_hierarchy=1`​ 来配置系统去使用它。

`# 此示例适用于使用 DNF 包管理器的 Linux 操作系统 # 你的系统可能使用不同的方法来设置 Linux 内核使用的命令行。 sudo dnf install -y grubby && \   sudo grubby \   --update-kernel=ALL \   --args="systemd.unified_cgroup_hierarchy=1"`

如果更改内核的命令行，则必须重新启动节点才能使更改生效。

切换到 cgroup v2 时，用户体验不应有任何明显差异， 除非用户直接在节点上或在容器内访问 cgroup 文件系统。 为了使用它，CRI 运行时也必须支持 cgroup v2。

#### 将 kubeadm 托管的集群迁移到 systemd 驱动

如果你希望将现有的由 kubeadm 管理的集群迁移到 systemd cgroup 驱动程序， 请按照配置 cgroup 驱动程序操作。

CRI 版本支持
--------

你的容器运行时必须至少支持容器运行时接口的 v1alpha2。

Kubernetes 1.24 默认使用 v1 的 CRI API。如果容器运行时不支持 v1 API， 则 kubelet 会回退到使用（已弃用的）v1alpha2 API。

容器运行时 
------

#### containerd

本节概述了使用 containerd 作为 CRI 运行时的必要步骤。

使用以下命令在系统上安装 Containerd：

按照[开始使用 containerd](https://github.com/containerd/containerd/blob/main/docs/getting-started.md) 的说明进行操作。 创建有效的配置文件 ​`config.toml`​ 后返回此步骤。

*   Linux

你可以在路径 ​`/etc/containerd/config.toml`​ 下找到此文件。

*   Windows

你可以在路径 \`​`C:\Program Files\containerd\config.toml`​\` 下找到此文件。

在 Linux 上，containerd 的默认 CRI 套接字是 ​`/run/containerd/containerd.sock`​。 在 Windows 上，默认 CRI 端点是 ​`npipe://./pipe/containerd-containerd`​。

#### 配置 systemd cgroup 驱动程序

结合 ​`runc` ​使用 ​`systemd` ​cgroup 驱动，在 ​`/etc/containerd/config.toml`​ 中设置

`[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]   ...   [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]     SystemdCgroup = true`

如果你应用此更改，请确保重新启动 containerd：

`sudo systemctl restart containerd`

当使用 kubeadm 时，请手动配置 kubelet 的 cgroup 驱动.

#### CRI-O

本节包含安装 CRI-O 作为容器运行时的必要步骤。

要安装 CRI-O，请按照 [CRI-O 安装说明](https://github.com/cri-o/cri-o/blob/main/install.md target=)执行操作。

#### cgroup 驱动程序

CRI-O 默认使用 systemd cgroup 驱动程序，这对你来说可能工作得很好。要切换到 ​`cgroupfs` ​cgroup 驱动程序， 请编辑 ​`/etc/crio/crio.conf`​ 或在 ​`/etc/crio/crio.conf.d/02-cgroup-manager.conf`​ 中放置一个插入式配置 ，例如：

`[crio.runtime] conmon_cgroup = "pod" cgroup_manager = "cgroupfs"`

你还应该注意到 ​`conmon_cgroup` ​被更改，当使用 CRI-O 和 ​`cgroupfs` ​时，必须将其设置为值 ​`pod`​。 通常需要保持 kubelet 的 cgroup 驱动配置（通常通过 kubeadm 完成）和 CRI-O 同步。

对于 CRI-O，CRI 套接字默认为 ​`/var/run/crio/crio.sock`​。

#### Docker Engine

> Note: 以下操作假设你使用 [cri-dockerd](https://github.com/Mirantis/cri-dockerd) 适配器来将 Docker Engine 与 Kubernetes 集成。

1.  在你的每个节点上，遵循[安装 Docker 引擎](https://docs.docker.com/engine/install/ target=)指南为你的 Linux 发行版安装 Docker。
2.  按照源代码仓库中的说明安装 [cri-dockerd](https://github.com/Mirantis/cri-dockerd)。

对于 ​`cri-dockerd`​，默认情况下，CRI 套接字是 ​`/run/cri-dockerd.sock`​。

#### Mirantis 容器运行时

[Mirantis Container Runtime](https://docs.mirantis.com/mcr/20.10/overview.html) (MCR) 是一种商用容器运行时，以前称为 Docker 企业版。 你可以使用 MCR 中包含的开源 ​[`cri-dockerd`​](https://github.com/Mirantis/cri-dockerd) 组件将 Mirantis Container Runtime 与 Kubernetes 一起使用。

要了解有关如何安装 Mirantis Container Runtime 的更多信息，请访问 [MCR 部署指南](https://docs.mirantis.com/mcr/20.10/install.html)。

检查名为 ​`cri-docker.socket`​ 的 systemd 单元以找出 CRI 套接字的路径。

##  2.  Kubernetes 使用部署工具安装Kubernetes

###  1.  Kubernetes 安装kubeadm
在开始之前
-----

*   一台兼容的 Linux 主机。Kubernetes 项目为基于 Debian 和 Red Hat 的 Linux 发行版以及一些不提供包管理器的发行版提供通用的指令
*   每台机器 2 GB 或更多的 RAM （如果少于这个数字将会影响你应用的运行内存)
*   2 CPU 核或更多
*   集群中的所有机器的网络彼此均能相互连接(公网和内网都可以)
*   节点之中不可以有重复的主机名、MAC 地址或 product\_uuid
*   开启机器上的某些端口
*   禁用交换分区。为了保证 kubelet 正常工作，你 必须 禁用交换分区

确保每个节点上 MAC 地址和 product\_uuid 的唯一性
----------------------------------

*   你可以使用命令 ​`ip link`​ 或 ​`ifconfig -a`​ 来获取网络接口的 MAC 地址
*   可以使用 ​`sudo cat /sys/class/dmi/id/product_uuid`​ 命令对 product\_uuid 校验

一般来讲，硬件设备会拥有唯一的地址，但是有些虚拟机的地址可能会重复。 Kubernetes 使用这些值来唯一确定集群中的节点。 如果这些值在每个节点上不唯一，可能会导致安装 [失败](https://github.com/kubernetes/kubeadm/issues/31)。

检查网络适配器
-------

如果你有一个以上的网络适配器，同时你的 Kubernetes 组件通过默认路由不可达，我们建议你预先添加 IP 路由规则，这样 Kubernetes 集群就可以通过对应的适配器完成连接。

允许 iptables 检查桥接流量
------------------

确保 ​`br_netfilter`​ 模块被加载。这一操作可以通过运行 ​`lsmod | grep br_netfilter`​ 来完成。若要显式加载该模块，可执行 ​`sudo modprobe br_netfilter`​。

为了让你的 Linux 节点上的 iptables 能够正确地查看桥接流量，你需要确保在你的 ​`sysctl` ​配置中将 ​`net.bridge.bridge-nf-call-iptables`​ 设置为 1。例如：

`cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF  cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system`

检查所需端口
------

启用必要的端口后才能使 Kubernetes 的各组件相互通信。可以使用 netcat 之类的工具来检查端口是否启用，例如：

`nc 127.0.0.1 6443`

你使用的 Pod 网络插件 (详见后续章节) 也可能需要开启某些特定端口。由于各个 Pod 网络插件的功能都有所不同， 请参阅他们各自文档中对端口的要求。

安装容器运行时
-------

为了在 Pod 中运行容器，Kubernetes 使用 容器运行时（Container Runtime）。

默认情况下，Kubernetes 使用 容器运行时接口（Container Runtime Interface，CRI） 来与你所选择的容器运行时交互。

如果你不指定运行时，kubeadm 会自动尝试通过扫描已知的端点列表来检测已安装的容器运行时。

如果检测到有多个或者没有容器运行时，kubeadm 将抛出一个错误并要求你指定一个想要使用的运行时。

###  2.  Kubernetes 对kubeadm进行故障排查
对 kubeadm 进行故障排查
----------------

与任何程序一样，你可能会在安装或者运行 kubeadm 时遇到错误。 本文列举了一些常见的故障场景，并提供可帮助你理解和解决这些问题的步骤。

如果你的问题未在下面列出，请执行以下步骤：

*   如果你认为问题是 kubeadm 的错误：

*   转到 [github.com/kubernetes/kubeadm](https://github.com/kubernetes/kubeadm/issues) 并搜索存在的问题。
*   如果没有问题，请 [打开](https://github.com/kubernetes/kubeadm/issues/new) 并遵循问题模板。

*   如果你对 kubeadm 的工作方式有疑问，可以在 [Slack](https://slack.k8s.io/) 上的 ​`#kubeadm`​ 频道提问， 或者在 [StackOverflow](https://stackoverflow.com/questions/tagged/kubernetes) 上提问。 请加入相关标签，例如 ​`#kubernetes`​ 和 ​`#kubeadm`​，这样其他人可以帮助你。

由于缺少 RBAC，无法将 v1.18 Node 加入 v1.17 集群
------------------------------------

自从 v1.18 后，如果集群中已存在同名 Node，kubeadm 将禁止 Node 加入集群。 这需要为 bootstrap-token 用户添加 RBAC 才能 GET Node 对象。

但这会导致一个问题，v1.18 的 ​`kubeadm join`​ 无法加入由 kubeadm v1.17 创建的集群。

要解决此问题，你有两种选择：

使用 kubeadm v1.18 在控制平面节点上执行 ​`kubeadm init phase bootstrap-token`​。 请注意，这也会启用 bootstrap-token 的其余权限。

或者，也可以使用 ​`kubectl apply -f ...`​ 手动应用以下 RBAC：

`apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata:   name: kubeadm:get-nodes rules: - apiGroups:   - ""   resources:   - nodes   verbs:   - get --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata:   name: kubeadm:get-nodes roleRef:   apiGroup: rbac.authorization.k8s.io   kind: ClusterRole   name: kubeadm:get-nodes subjects: - apiGroup: rbac.authorization.k8s.io   kind: Group   name: system:bootstrappers:kubeadm:default-node-token`

在安装过程中没有找到 ebtables 或者其他类似的可执行文件
--------------------------------

如果在运行 ​`kubeadm init`​ 命令时，遇到以下的警告

`[preflight] WARNING: ebtables not found in system path [preflight] WARNING: ethtool not found in system path`

那么或许在你的节点上缺失 ​`ebtables`​、​`ethtool` ​或者类似的可执行文件。 你可以使用以下命令安装它们：

*   对于 Ubuntu/Debian 用户，运行 ​`apt install ebtables ethtool`​ 命令。
*   对于 CentOS/Fedora 用户，运行 ​`yum install ebtables ethtool`​ 命令。

在安装过程中，kubeadm 一直等待控制平面就绪
-------------------------

如果你注意到 ​`kubeadm init`​ 在打印以下行后挂起：

`[apiclient] Created API client, waiting for the control plane to become ready`

这可能是由许多问题引起的。最常见的是：

*   网络连接问题。在继续之前，请检查你的计算机是否具有全部联通的网络连接。
*   容器运行时的 cgroup 驱动不同于 kubelet 使用的 cgroup 驱动。
*   控制平面上的 Docker 容器持续进入崩溃状态或（因其他原因）挂起。你可以运行 docker ps 命令来检查以及 docker logs 命令来检视每个容器的运行日志。 

当删除托管容器时 kubeadm 阻塞 
--------------------

如果容器运行时停止并且未删除 Kubernetes 所管理的容器，可能发生以下情况：

`sudo kubeadm reset`

`[preflight] Running pre-flight checks [reset] Stopping the kubelet service [reset] Unmounting mounted directories in "/var/lib/kubelet" [reset] Removing kubernetes-managed containers (block)`

一个可行的解决方案是重新启动 Docker 服务，然后重新运行 ​`kubeadm reset`​： 你也可以使用 ​`crictl` ​来调试容器运行时的状态。

Pods 处于 RunContainerError、CrashLoopBackOff 或者 Error 状态
------------------------------------------------------

在 ​`kubeadm init`​ 命令运行后，系统中不应该有 pods 处于这类状态。

*   在 ​`kubeadm init`​ 命令执行完后，如果有 pods 处于这些状态之一，请在 kubeadm 仓库提起一个 issue。​`coredns` ​(或者 ​`kube-dns`​) 应该处于 ​`Pending` ​状态， 直到你部署了网络插件为止。
*   如果在部署完网络插件之后，有 Pods 处于 ​`RunContainerError`​、​`CrashLoopBackOff` ​或 ​`Error` ​状态之一，并且 ​`coredns` ​（或者 ​`kube-dns`​）仍处于 ​`Pending` ​状态， 那很可能是你安装的网络插件由于某种原因无法工作。你或许需要授予它更多的 RBAC 特权或使用较新的版本。请在 Pod Network 提供商的问题跟踪器中提交问题， 然后在此处分类问题。
*   如果你安装的 Docker 版本早于 1.12.1，请在使用 ​`systemd` ​来启动 ​`dockerd` ​和重启 ​`docker` ​时， 删除 ​`MountFlags=slave`​ 选项。 你可以在 ​`/usr/lib/systemd/system/docker.service`​ 中看到 MountFlags。 MountFlags 可能会干扰 Kubernetes 挂载的卷，并使 Pods 处于 ​`CrashLoopBackOff` ​状态。 当 Kubernetes 不能找到 ​`var/run/secrets/kubernetes.io/serviceaccount`​ 文件时会发生错误。

coredns 停滞在 Pending 状态
----------------------

这一行为是 预期之中 的，因为系统就是这么设计的。 kubeadm 的网络供应商是中立的，因此管理员应该选择 安装 pod 的网络插件。 你必须完成 Pod 的网络配置，然后才能完全部署 CoreDNS。 在网络被配置好之前，DNS 组件会一直处于 ​`Pending` ​状态。

HostPort 服务无法工作
---------------

此 ​`HostPort` ​和 ​`HostIP` ​功能是否可用取决于你的 Pod 网络配置。请联系 Pod 网络插件的作者， 以确认 ​`HostPort` ​和 ​`HostIP` ​功能是否可用。

已验证 Calico、Canal 和 Flannel CNI 驱动程序支持 HostPort。

有关更多信息，请参考 [CNI portmap 文档](https://github.com/containernetworking/plugins/blob/main/plugins/meta/portmap/README.md).

如果你的网络提供商不支持 portmap CNI 插件，你或许需要使用 NodePort 服务的功能 或者使用 ​`HostNetwork=true`​。

无法通过其服务 IP 访问 Pod
-----------------

*   许多网络附加组件尚未启用 hairpin 模式 该模式允许 Pod 通过其服务 IP 进行访问。这是与 [CNI](https://github.com/containernetworking/cni/issues/476) 有关的问题。 请与网络附加组件提供商联系，以获取他们所提供的 hairpin 模式的最新状态。
*   如果你正在使用 VirtualBox (直接使用或者通过 Vagrant 使用)，你需要 确保 ​`hostname -i`​ 返回一个可路由的 IP 地址。默认情况下，第一个接口连接不能路由的仅主机网络。 解决方法是修改 ​`/etc/hosts`​，请参考示例 [Vagrantfile](https://github.com/errordeveloper/kubernetes-ansible-vagrant/blob/22dd39dfc06111235620e6c4404a96ae146f26fd/Vagrantfile target=)。

TLS 证书错误
--------

以下错误指出证书可能不匹配。

`# kubectl get pods Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of "crypto/rsa: verification error" while trying to verify candidate authority certificate "kubernetes")`

*   验证 ​`$HOME/.kube/config`​ 文件是否包含有效证书，并 在必要时重新生成证书。在 kubeconfig 文件中的证书是 base64 编码的。 该 ​`base64 --decode`​ 命令可以用来解码证书，​`openssl x509 -text -noout`​ 命令 可以用于查看证书信息。
*   使用如下方法取消设置 ​`KUBECONFIG` ​环境变量的值：

`unset KUBECONFIG`

或者将其设置为默认的 ​`KUBECONFIG` ​位置：

`export KUBECONFIG=/etc/kubernetes/admin.conf`

*   另一个方法是覆盖 ​`kubeconfig` ​的现有用户 "管理员"：

`mv  $HOME/.kube $HOME/.kube.bak mkdir $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config`

Kubelet 客户端证书轮换失败 
------------------

默认情况下，kubeadm 使用 ​`/etc/kubernetes/kubelet.conf`​ 中指定的 ​`/var/lib/kubelet/pki/kubelet-client-current.pem`​ 符号链接 来配置 kubelet 自动轮换客户端证书。如果此轮换过程失败，你可能会在 kube-apiserver 日志中看到 诸如 ​`x509: certificate has expired or is not yet valid`​ 之类的错误。要解决此问题，你必须执行以下步骤：

1.  从故障节点备份和删除 ​`/etc/kubernetes/kubelet.conf`​ 和 ​`/var/lib/kubelet/pki/kubelet-client*`​。
2.  在集群中具有 ​`/etc/kubernetes/pki/ca.key`​ 的、正常工作的控制平面节点上 执行 ​`kubeadm kubeconfig user --org system:nodes --client-name system:node:$NODE > kubelet.conf`​。 ​`$NODE`​ 必须设置为集群中现有故障节点的名称。 手动修改生成的 ​`kubelet.conf`​ 以调整集群名称和服务器端点， 或传递 ​`kubeconfig user --config`​（此命令接受 ​`InitConfiguration`​）。 如果你的集群没有 ​`ca.key`​，你必须在外部对 ​`kubelet.conf`​ 中的嵌入式证书进行签名。
3.  将得到的 ​`kubelet.conf`​ 文件复制到故障节点上，作为 ​`/etc/kubernetes/kubelet.conf`​。
4.  在故障节点上重启 kubelet（​`systemctl restart kubelet`​），等待 ​`/var/lib/kubelet/pki/kubelet-client-current.pem`​ 重新创建。
5.  手动编辑 ​`kubelet.conf`​ 指向轮换的 kubelet 客户端证书，方法是将 ​`client-certificate-data`​ 和 ​`client-key-data`​ 替换为：

`client-certificate: /var/lib/kubelet/pki/kubelet-client-current.pem client-key: /var/lib/kubelet/pki/kubelet-client-current.pem`

7.  重新启动 kubelet。
8.  确保节点状况变为 ​`Ready`​。

在 Vagrant 中使用 flannel 作为 pod 网络时的默认 NIC
---------------------------------------

以下错误可能表明 Pod 网络中出现问题：

`Error from server (NotFound): the server could not find the requested resource`

*   如果你正在 Vagrant 中使用 flannel 作为 pod 网络，则必须指定 flannel 的默认接口名称。

Vagrant 通常为所有 VM 分配两个接口。第一个为所有主机分配了 IP 地址 ​`10.0.2.15`​，用于获得 NATed 的外部流量。

这可能会导致 flannel 出现问题，它默认为主机上的第一个接口。这导致所有主机认为它们具有 相同的公共 IP 地址。为防止这种情况，传递 ​`--iface eth1`​ 标志给 flannel 以便选择第二个接口。

容器使用的非公共 IP
-----------

在某些情况下 ​`kubectl logs`​ 和 ​`kubectl run`​ 命令或许会返回以下错误，即便除此之外集群一切功能正常：

`Error from server: Get https://10.19.0.41:10250/containerLogs/default/mysql-ddc65b868-glc5m/mysql: dial tcp 10.19.0.41:10250: getsockopt: no route to host`

*   这或许是由于 Kubernetes 使用的 IP 无法与看似相同的子网上的其他 IP 进行通信的缘故， 可能是由机器提供商的政策所导致的。
*   DigitalOcean 既分配一个共有 IP 给 ​`eth0`​，也分配一个私有 IP 在内部用作其浮动 IP 功能的锚点， 然而 ​`kubelet` ​将选择后者作为节点的 ​`InternalIP` ​而不是公共 IP

使用 ​`ip addr show`​ 命令代替 ​`ifconfig` ​命令去检查这种情况，因为 ​`ifconfig` ​命令 不会显示有问题的别名 IP 地址。或者指定的 DigitalOcean 的 API 端口允许从 droplet 中 查询 anchor IP：

`curl http://169.254.169.254/metadata/v1/interfaces/public/0/anchor_ipv4/address`

解决方法是通知 ​`kubelet` ​使用哪个 ​`--node-ip`​。当使用 DigitalOcean 时，可以是公网IP（分配给 ​`eth0` ​的）， 或者是私网IP（分配给 ​`eth1` ​的）。私网 IP 是可选的。 kubadm ​`NodeRegistrationOptions` ​结构 的 ​`KubeletExtraArgs` ​部分被用来处理这种情况。

然后重启 ​`kubelet`​：

`systemctl daemon-reload systemctl restart kubelet`

coredns pods 有 CrashLoopBackOff 或者 Error 状态
-------------------------------------------

如果有些节点运行的是旧版本的 Docker，同时启用了 SELinux，你或许会遇到 ​`coredns` ​pods 无法启动的情况。 要解决此问题，你可以尝试以下选项之一：

*   升级到 Docker 的较新版本
*   [禁用 SELinux](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security-enhanced_linux/sect-security-enhanced_linux-enabling_and_disabling_selinux-disabling_selinux)
*   修改 ​`coredns` ​部署以设置 ​`allowPrivilegeEscalation` ​为 ​`true`​：

`kubectl -n kube-system get deployment coredns -o yaml | \   sed 's/allowPrivilegeEscalation: false/allowPrivilegeEscalation: true/g' | \   kubectl apply -f -`

CoreDNS 处于 ​`CrashLoopBackOff` ​时的另一个原因是当 Kubernetes 中部署的 CoreDNS Pod 检测 到环路时。[有许多解决方法](https://github.com/coredns/coredns/tree/master/plugin/loop target=) 可以避免在每次 CoreDNS 监测到循环并退出时，Kubernetes 尝试重启 CoreDNS Pod 的情况。

> Warning: 禁用 SELinux 或设置 ​`allowPrivilegeEscalation` ​为 ​`true` ​可能会损害集群的安全性。

etcd pods 持续重启
--------------

如果你遇到以下错误：

`rpc error: code = 2 desc = oci runtime error: exec failed: container_linux.go:247: starting container process caused "process_linux.go:110: decoding init error from pipe caused \"read parent: connection reset by peer\""`

如果你使用 Docker 1.13.1.84 运行 CentOS 7 就会出现这种问题。 此版本的 Docker 会阻止 kubelet 在 etcd 容器中执行。

为解决此问题，请选择以下选项之一：

*   回滚到早期版本的 Docker，例如 1.13.1-75

`yum downgrade docker-1.13.1-75.git8633870.el7.centos.x86_64 docker-client-1.13.1-75.git8633870.el7.centos.x86_64 docker-common-1.13.1-75.git8633870.el7.centos.x86_64`

*   安装较新的推荐版本之一，例如 18.06:

`sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo yum install docker-ce-18.06.1.ce-3.el7.x86_64`

无法将以逗号分隔的值列表传递给 --component-extra-args 标志内的参数
---------------------------------------------

​`kubeadm init`​ 标志例如 ​`--component-extra-args`​ 允许你将自定义参数传递给像 kube-apiserver 这样的控制平面组件。然而，由于解析 (​`mapStringString`​) 的基础类型值，此机制将受到限制。

如果你决定传递一个支持多个逗号分隔值（例如 ​`--apiserver-extra-args "enable-admission-plugins=LimitRanger,NamespaceExists"`​）参数， 将出现 ​`flag: malformed pair, expect string=string`​ 错误。 发生这种问题是因为参数列表 ​`--apiserver-extra-args`​ 预期的是 ​`key=value`​ 形式， 而这里的 ​`NamespacesExists`​ 被误认为是缺少取值的键名。

一种解决方法是尝试分离 ​`key=value`​ 对，像这样： ​`--apiserver-extra-args "enable-admission-plugins=LimitRanger,enable-admission-plugins=NamespaceExists"`​ 但这将导致键 ​`enable-admission-plugins`​ 仅有值 ​`NamespaceExists`​。

已知的解决方法是使用 kubeadm 配置文件。

在节点被云控制管理器初始化之前，kube-proxy 就被调度了
--------------------------------

在云环境场景中，可能出现在云控制管理器完成节点地址初始化之前，kube-proxy 就被调度到新节点了。 这会导致 kube-proxy 无法正确获取节点的 IP 地址，并对管理负载平衡器的代理功能产生连锁反应。

在 kube-proxy Pod 中可以看到以下错误：

`server.go:610] Failed to retrieve node IP: host IP unknown; known addresses: [] proxier.go:340] invalid nodeIP, initializing kube-proxy with 127.0.0.1 as nodeIP`

一种已知的解决方案是修补 kube-proxy DaemonSet，以允许在控制平面节点上调度它， 而不管它们的条件如何，将其与其他节点保持隔离，直到它们的初始保护条件消除：

`kubectl -n kube-system patch ds kube-proxy -p='{ "spec": { "template": { "spec": { "tolerations": [ { "key": "CriticalAddonsOnly", "operator": "Exists" }, { "effect": "NoSchedule", "key": "node-role.kubernetes.io/master" }, { "effect": "NoSchedule", "key": "node-role.kubernetes.io/control-plane" } ] } } } }'`

此问题的跟踪[在这里](https://github.com/kubernetes/kubeadm/issues/1027)。

节点上的 /usr 被以只读方式挂载
------------------

在类似 Fedora CoreOS 或者 Flatcar Container Linux 这类 Linux 发行版本中， 目录 ​`/usr`​ 是以只读文件系统的形式挂载的。 在支持 [FlexVolume](https://github.com/kubernetes/community/blob/ab55d85/contributors/devel/sig-storage/flexvolume.md)时， 类似 kubelet 和 kube-controller-manager 这类 Kubernetes 组件使用默认路径 ​`/usr/libexec/kubernetes/kubelet-plugins/volume/exec/`​， 而 FlexVolume 的目录 必须是可写入的，该功能特性才能正常工作。 （注意：FlexVolume 在 Kubernetes v1.23 版本中已被弃用）

为了解决这个问题，你可以使用 kubeadm 的配置文件 来配置 FlexVolume 的目录。

在（使用 ​`kubeadm init`​ 创建的）主控制节点上，使用 ​`--config`​ 参数传入如下文件：

`apiVersion: kubeadm.k8s.io/v1beta3 kind: InitConfiguration nodeRegistration:   kubeletExtraArgs:     volume-plugin-dir: "/opt/libexec/kubernetes/kubelet-plugins/volume/exec/" --- apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration controllerManager:   extraArgs:     flex-volume-plugin-dir: "/opt/libexec/kubernetes/kubelet-plugins/volume/exec/"`

在加入到集群中的节点上，使用下面的文件：

`apiVersion: kubeadm.k8s.io/v1beta3 kind: JoinConfiguration nodeRegistration:   kubeletExtraArgs:     volume-plugin-dir: "/opt/libexec/kubernetes/kubelet-plugins/volume/exec/"`

或者，你要可以更改 ​`/etc/fstab`​ 使得 ​`/usr`​ 目录能够以可写入的方式挂载，不过 请注意这样做本质上是在更改 Linux 发行版的某种设计原则。

kubeadm upgrade plan 输出错误信息 context deadline exceeded
-----------------------------------------------------

在使用 ​`kubeadm` ​来升级某运行外部 etcd 的 Kubernetes 集群时可能显示这一错误信息。 这并不是一个非常严重的一个缺陷，之所以出现此错误信息，原因是老的 kubeadm 版本会对外部 etcd 集群执行版本检查。你可以继续执行 ​`kubeadm upgrade apply ...`​。

这一问题已经在 1.19 版本中得到修复。

kubeadm reset 会卸载 /var/lib/kubelet
----------------------------------

如果已经挂载了 ​`/var/lib/kubelet`​ 目录，执行 ​`kubeadm reset`​ 操作的时候 会将其卸载。

要解决这一问题，可以在执行了 ​`kubeadm reset`​ 操作之后重新挂载 ​`/var/lib/kubelet`​ 目录。

这是一个在 1.15 中引入的故障，已经在 1.20 版本中修复。

无法在 kubeadm 集群中安全地使用 metrics-server 
------------------------------------

在 kubeadm 集群中可以通过为 [metrics-server](https://github.com/kubernetes-sigs/metrics-server) 设置 ​`--kubelet-insecure-tls`​ 来以不安全的形式使用该服务。 建议不要在生产环境集群中这样使用。

如果你需要在 metrics-server 和 kubelet 之间使用 TLS，会有一个问题， kubeadm 为 kubelet 部署的是自签名的服务证书。这可能会导致 metrics-server 端报告下面的错误信息：

`x509: certificate signed by unknown authority x509: certificate is valid for IP-foo not IP-bar`

另请参阅 [How to run the metrics-server securely](https://github.com/kubernetes-sigs/metrics-server/blob/master/FAQ.md target=)。

###  3.  Kubernetes 使用kubeadm创建集群
使用 kubeadm 创建集群
---------------

使用 ​`kubeadm`​，你能创建一个符合最佳实践的最小化 Kubernetes 集群。 事实上，你可以使用 ​`kubeadm` ​配置一个通过 Kubernetes 一致性测试的集群。 ​`kubeadm` ​还支持其他集群生命周期功能， 例如启动引导令牌和集群升级。

kubeadm 工具很棒，如果你需要：

*   一个尝试 Kubernetes 的简单方法。
*   一个现有用户可以自动设置集群并测试其应用程序的途径。
*   其他具有更大范围的生态系统和/或安装工具中的构建模块。

你可以在各种机器上安装和使用 ​`kubeadm`​：笔记本电脑， 一组云服务器，Raspberry Pi 等。无论是部署到云还是本地， 你都可以将 ​`kubeadm` ​集成到预配置系统中，例如 Ansible 或 Terraform。

在开始之前
-----

要遵循本指南，你需要：

*   一台或多台运行兼容 deb/rpm 的 Linux 操作系统的计算机；例如：Ubuntu 或 CentOS。
*   每台机器 2 GB 以上的内存，内存不足时应用会受限制。
*   用作控制平面节点的计算机上至少有2个 CPU。
*   集群中所有计算机之间具有完全的网络连接。你可以使用公共网络或专用网络。

你还需要使用可以在新集群中部署特定 Kubernetes 版本对应的 ​`kubeadm`​。

Kubernetes 版本及版本偏差策略适用于 ​`kubeadm` ​以及整个 Kubernetes。 查阅该策略以了解支持哪些版本的 Kubernetes 和 ​`kubeadm`​。 该页面是为 Kubernetes v1.24 编写的。

​`kubeadm` ​工具的整体功能状态为一般可用性（GA）。一些子功能仍在积极开发中。 随着工具的发展，创建集群的实现可能会略有变化，但总体实现应相当稳定。

> Note: 根据定义，在 ​`kubeadm alpha`​ 下的所有命令均在 alpha 级别上受支持。

目标
--

*   安装单个控制平面的 Kubernetes 集群
*   在集群上安装 Pod 网络，以便你的 Pod 可以相互连通

操作指南
----

#### 主机准备

在所有主机上安装 容器运行时 和 kubeadm。

> Note:  
> 如果你已经安装了kubeadm，执行 ​`apt-get update && apt-get upgrade`​ 或 ​`yum update`​ 以获取 kubeadm 的最新版本。  
> 升级时，kubelet 每隔几秒钟重新启动一次， 在 crashloop 状态中等待 kubeadm 发布指令。crashloop 状态是正常现象。 初始化控制平面后，kubelet 将正常运行。

#### 准备所需的容器镜像 

这个步骤是可选的，只适用于你希望 ​`kubeadm init`​ 和 ​`kubeadm join`​ 不去下载存放在 ​`k8s.gcr.io`​ 上的默认的容器镜像的情况。

当你在离线的节点上创建一个集群的时候，Kubeadm 有一些命令可以帮助你预拉取所需的镜像。

Kubeadm 允许你给所需要的镜像指定一个自定义的镜像仓库。

#### 初始化控制平面节点

控制平面节点是运行控制平面组件的机器， 包括 etcd （集群数据库） 和 API Server （命令行工具 kubectl 与之通信）。

1.  （推荐）如果计划将单个控制平面 kubeadm 集群升级成高可用， 你应该指定 ​`--control-plane-endpoint`​ 为所有控制平面节点设置共享端点。 端点可以是负载均衡器的 DNS 名称或 IP 地址。
2.  选择一个 Pod 网络插件，并验证是否需要为 ​`kubeadm init`​ 传递参数。 根据你选择的第三方网络插件，你可能需要设置 ​`--pod-network-cidr`​ 的值。 
3.  （可选）​`kubeadm` ​试图通过使用已知的端点列表来检测容器运行时。 使用不同的容器运行时或在预配置的节点上安装了多个容器运行时，请为 ​`kubeadm init`​ 指定 ​`--cri-socket`​ 参数。
4.  （可选）除非另有说明，否则 ​`kubeadm` ​使用与默认网关关联的网络接口来设置此控制平面节点 API server 的广播地址。 要使用其他网络接口，请为 ​`kubeadm init`​ 设置 ​`--apiserver-advertise-address=<ip-address>`​ 参数。 要部署使用 IPv6 地址的 Kubernetes 集群， 必须指定一个 IPv6 地址，例如 ​`--apiserver-advertise-address=fd00::101`​

要初始化控制平面节点，请运行：

`kubeadm init <args>`

#### 关于 apiserver-advertise-address 和 ControlPlaneEndpoint 的注意事项 

​`--apiserver-advertise-address`​ 可用于为控制平面节点的 API server 设置广播地址， ​`--control-plane-endpoint`​ 可用于为所有控制平面节点设置共享端点。

​`--control-plane-endpoint`​ 允许 IP 地址和可以映射到 IP 地址的 DNS 名称。 请与你的网络管理员联系，以评估有关此类映射的可能解决方案。

这是一个示例映射：

`192.168.0.102 cluster-endpoint`

其中 ​`192.168.0.102`​ 是此节点的 IP 地址，​`cluster-endpoint`​ 是映射到该 IP 的自定义 DNS 名称。 这将允许你将 ​`--control-plane-endpoint=cluster-endpoint`​ 传递给 ​`kubeadm init`​，并将相同的 DNS 名称传递给 ​`kubeadm join`​。 稍后你可以修改 ​`cluster-endpoint`​ 以指向高可用性方案中的负载均衡器的地址。

kubeadm 不支持将没有 ​`--control-plane-endpoint`​ 参数的单个控制平面集群转换为高可用性集群。

#### 更多信息

要再次运行 ​`kubeadm init`​，你必须首先卸载集群。

如果将具有不同架构的节点加入集群， 请确保已部署的 DaemonSet 对这种体系结构具有容器镜像支持。

​`kubeadm init`​ 首先运行一系列预检查以确保机器 准备运行 Kubernetes。这些预检查会显示警告并在错误时退出。然后 ​`kubeadm init`​ 下载并安装集群控制平面组件。这可能会需要几分钟。 完成之后你应该看到：

`Your Kubernetes control-plane has initialized successfully!  To start using your cluster, you need to run the following as a regular user:    mkdir -p $HOME/.kube   sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config   sudo chown $(id -u):$(id -g) $HOME/.kube/config  You should now deploy a Pod network to the cluster. Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:   /docs/concepts/cluster-administration/addons/  You can now join any number of machines by running the following on each node as root:    kubeadm join <control-plane-host>:<control-plane-port> --token <token> --discovery-token-ca-cert-hash sha256:<hash>`

要使非 root 用户可以运行 kubectl，请运行以下命令， 它们也是 ​`kubeadm init`​ 输出的一部分：

`mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config`

或者，如果你是 ​`root` ​用户，则可以运行：

`export KUBECONFIG=/etc/kubernetes/admin.conf`

> Warning:  
> kubeadm 对 ​`admin.conf`​ 中的证书进行签名时，将其配置为 ​`Subject: O = system:masters, CN = kubernetes-admin`​。 ​`system:masters`​ 是一个例外的、超级用户组，可以绕过鉴权层（例如 RBAC）。 不要将 ​`admin.conf`​ 文件与任何人共享，应该使用 ​`kubeadm kubeconfig user`​ 命令为其他用户生成 kubeconfig 文件，完成对他们的定制授权。

记录 ​`kubeadm init`​ 输出的 ​`kubeadm join`​ 命令。 你需要此命令将节点加入集群。

令牌用于控制平面节点和加入节点之间的相互身份验证。 这里包含的令牌是密钥。确保它的安全， 因为拥有此令牌的任何人都可以将经过身份验证的节点添加到你的集群中。 可以使用 ​`kubeadm token`​ 命令列出，创建和删除这些令牌。

#### 安装 Pod 网络附加组件 

> Caution:  
> 本节包含有关网络设置和部署顺序的重要信息。 在继续之前，请仔细阅读所有建议。  
> 你必须部署一个基于 Pod 网络插件的 容器网络接口 (CNI)，以便你的 Pod 可以相互通信。 在安装网络之前，集群 DNS (CoreDNS) 将不会启动。  
> 
> *   注意你的 Pod 网络不得与任何主机网络重叠： 如果有重叠，你很可能会遇到问题。 （如果你发现网络插件的首选 Pod 网络与某些主机网络之间存在冲突， 则应考虑使用一个合适的 CIDR 块来代替， 然后在执行 ​`kubeadm init`​ 时使用 ​`--pod-network-cidr`​ 参数并在你的网络插件的 YAML 中替换它）。
> *   默认情况下，​`kubeadm` ​将集群设置为使用和强制使用 RBAC（基于角色的访问控制）。 确保你的 Pod 网络插件支持 RBAC，以及用于部署它的 manifests 也是如此。
> *   如果要为集群使用 IPv6（双协议栈或仅单协议栈 IPv6 网络）， 请确保你的 Pod 网络插件支持 IPv6。 IPv6 支持已在 CNI [v0.6.0](https://github.com/containernetworking/cni/releases/tag/v0.6.0) 版本中添加。

> Note: kubeadm 应该是与 CNI 无关的，对 CNI 驱动进行验证目前不在我们的端到端测试范畴之内。 如果你发现与 CNI 插件相关的问题，应在其各自的问题跟踪器中记录而不是在 kubeadm 或 kubernetes 问题跟踪器中记录。

一些外部项目为 Kubernetes 提供使用 CNI 的 Pod 网络，其中一些还支持网络策略。

你可以使用以下命令在控制平面节点或具有 kubeconfig 凭据的节点上安装 Pod 网络附加组件：

`kubectl apply -f <add-on.yaml>`

每个集群只能安装一个 Pod 网络。

安装 Pod 网络后，你可以通过在 ​`kubectl get pods --all-namespaces`​ 输出中检查 CoreDNS Pod 是否 ​`Running` ​来确认其是否正常运行。 一旦 CoreDNS Pod 启用并运行，你就可以继续加入节点。

如果你的网络无法正常工作或 CoreDNS 不在“运行中”状态，请查看 ​`kubeadm` ​的 故障排除指南。

#### 托管节点标签 

默认情况下，kubeadm 启用 NodeRestriction 准入控制器来限制 kubelets 在节点注册时可以应用哪些标签。准入控制器文档描述 kubelet ​`--node-labels`​ 选项允许使用哪些标签。 其中 ​`node-role.kubernetes.io/control-plane`​ 标签就是这样一个受限制的标签， kubeadm 在节点创建后使用特权客户端手动应用此标签。 你可以使用一个有特权的 kubeconfig，比如由 kubeadm 管理的 ​`/etc/kubernetes/admin.conf`​， 通过执行 ​`kubectl label`​ 来手动完成操作。

#### 控制平面节点隔离

默认情况下，出于安全原因，你的集群不会在控制平面节点上调度 Pod。 如果你希望能够在控制平面节点上调度 Pod，例如单机 Kubernetes 集群，请运行:

`kubectl taint nodes --all node-role.kubernetes.io/control-plane- node-role.kubernetes.io/master-`

输出看起来像：

`node "test-01" untainted`

这将从任何拥有 ​`node-role.kubernetes.io/control-plane`​ 和 ​`node-role.kubernetes.io/master`​ 污点的节点上移除该污点。

包括控制平面节点，这意味着调度程序将能够在任何地方调度 Pods。

> Note: ​`node-role.kubernetes.io/master`​ 污点已被废弃，kubeadm 将在 1.25 版本中停止使用它。

#### 加入节点

节点是你的工作负载（容器和 Pod 等）运行的地方。要将新节点添加到集群，请对每台计算机执行以下操作：

*   SSH 到机器
*   成为 root （例如 ​`sudo su -`​）
*   运行 ​`kubeadm init`​ 输出的命令，例如：

`kubeadm join --token <token> <control-plane-host>:<control-plane-port> --discovery-token-ca-cert-hash sha256:<hash>`

如果没有令牌，可以通过在控制平面节点上运行以下命令来获取令牌：

`kubeadm token list`

输出类似于以下内容：

`TOKEN                    TTL  EXPIRES              USAGES           DESCRIPTION            EXTRA GROUPS 8ewj1p.9r9hcjoqgajrj4gi  23h  2018-06-12T02:51:28Z authentication,  The default bootstrap  system:                                                    signing          token generated by     bootstrappers:                                                                     'kubeadm init'.        kubeadm:                                                                                            default-node-token`

默认情况下，令牌会在 24 小时后过期。如果要在当前令牌过期后将节点加入集群， 则可以通过在控制平面节点上运行以下命令来创建新令牌：

`kubeadm token create`

输出类似于以下内容：

`5didvk.d09sbcov8ph2amjw`

如果你没有 ​`--discovery-token-ca-cert-hash`​ 的值，则可以通过在控制平面节点上执行以下命令链来获取它：

`openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2>/dev/null | \    openssl dgst -sha256 -hex | sed 's/^.* //'`

输出类似于以下内容：

`8cb2de97839780a412b93877f8507ad6c94f73add17d5d7058e91741c9d5ec78`

> Note: 要为 ​`<control-plane-host>:<control-plane-port>`​ 指定 IPv6 元组，必须将 IPv6 地址括在方括号中，例如：​`[fd00::101]:2073`​

输出应类似于：

`[preflight] Running pre-flight checks  ... (log output of join workflow) ...  Node join complete: * Certificate signing request sent to control-plane and response   received. * Kubelet informed of new secure connection details.  Run 'kubectl get nodes' on control-plane to see this machine join.`

几秒钟后，当你在控制平面节点上执行 ​`kubectl get nodes`​，你会注意到该节点出现在输出中。

> Note: 由于集群节点通常是按顺序初始化的，CoreDNS Pods 很可能都运行在第一个控制面节点上。 为了提供更高的可用性，请在加入至少一个新节点后 使用 ​`kubectl -n kube-system rollout restart deployment coredns`​ 命令，重新平衡 CoreDNS Pods。

#### （可选）从控制平面节点以外的计算机控制集群

为了使 kubectl 在其他计算机（例如笔记本电脑）上与你的集群通信， 你需要将管理员 kubeconfig 文件从控制平面节点复制到工作站，如下所示：

`scp root@<control-plane-host>:/etc/kubernetes/admin.conf . kubectl --kubeconfig ./admin.conf get nodes`

> Note:  
> 上面的示例假定为 root 用户启用了 SSH 访问。如果不是这种情况， 你可以使用 ​`scp`​ 将 ​`admin.conf`​ 文件复制给其他允许访问的用户。  
> admin.conf 文件为用户提供了对集群的超级用户特权。 该文件应谨慎使用。对于普通用户，建议生成一个你为其授予特权的唯一证书。 你可以使用 ​`kubeadm alpha kubeconfig user --client-name <CN>`​ 命令执行此操作。 该命令会将 KubeConfig 文件打印到 STDOUT，你应该将其保存到文件并分发给用户。 之后，使用 ​`kubectl create (cluster)rolebinding`​ 授予特权。

#### （可选）将 API 服务器代理到本地主机

如果要从集群外部连接到 API 服务器，则可以使用 ​`kubectl proxy`​：

`scp root@<control-plane-host>:/etc/kubernetes/admin.conf . kubectl --kubeconfig ./admin.conf proxy`

你现在可以在本地访问 API 服务器 ​`http://localhost:8001/api/v1`​。

清理
--

如果你在集群中使用了一次性服务器进行测试，则可以关闭这些服务器，而无需进一步清理。你可以使用 ​`kubectl config delete-cluster`​ 删除对集群的本地引用。

但是，如果要更干净地取消配置集群， 则应首先[清空节点](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=)并确保该节点为空， 然后取消配置该节点。

#### 删除节点

使用适当的凭证与控制平面节点通信，运行：

`kubectl drain <node name> --delete-emptydir-data --force --ignore-daemonsets`

在删除节点之前，请重置 ​`kubeadm` ​安装的状态：

`kubeadm reset`

重置过程不会重置或清除 iptables 规则或 IPVS 表。如果你希望重置 iptables，则必须手动进行：

`iptables -F && iptables -t nat -F && iptables -t mangle -F && iptables -X`

如果要重置 IPVS 表，则必须运行以下命令：

`ipvsadm -C`

现在删除节点：

`kubectl delete node <node name>`

如果你想重新开始，只需运行 ​`kubeadm init`​ 或 ​`kubeadm join`​ 并加上适当的参数。

#### 清理控制平面

你可以在控制平面主机上使用 ​`kubeadm reset`​ 来触发尽力而为的清理。

版本偏差策略
------

虽然 kubeadm 允许所管理的组件有一定程度的版本偏差， 但是建议你将 kubeadm 的版本与控制平面组件、kube-proxy 和 kubelet 的版本相匹配。

#### kubeadm 中的 Kubernetes 版本偏差

kubeadm 可以与 Kubernetes 组件一起使用，这些组件的版本与 kubeadm 相同，或者比它大一个版本。 Kubernetes 版本可以通过使用 ​`--kubeadm init`​ 的 ​`--kubernetes-version`​ 标志或使用 ​`--config`​ 时的 ​`ClusterConfiguration.kubernetesVersion`​ 字段指定给 kubeadm。 这个选项将控制 kube-apiserver、kube-controller-manager、kube-scheduler 和 kube-proxy 的版本。

例如：

*   kubeadm 的版本为 1.24。
*   ​`kubernetesVersion` ​必须为 1.24 或者 1.23。

#### kubeadm 中 kubelet 的版本偏差

与 Kubernetes 版本类似，kubeadm 可以使用与 kubeadm 相同版本的 kubelet， 或者比 kubeadm 老一个版本的 kubelet。

例如：

*   kubeadm 的版本为 1.24
*   主机上的 kubelet 版本必须为 1.24 或者 1.23

#### kubeadm 支持的 kubeadm 的版本偏差

kubeadm 命令在现有节点或由 kubeadm 管理的整个集群上的操作有一定限制。

如果新的节点加入到集群中，用于 ​`kubeadm join`​ 的 kubeadm 二进制文件必须与用 ​`kubeadm init`​ 创建集群或用 ​`kubeadm upgrade`​ 升级同一节点时所用的 kubeadm 版本一致。 类似的规则适用于除了 ​`kubeadm upgrade`​ 以外的其他 kubeadm 命令。

​`kubeadm join`​ 的例子：

*   使用 ​`kubeadm init`​ 创建集群时使用版本为 1.24 的 kubeadm。
*   加入的节点必须使用版本为 1.24 的 kubeadm 二进制文件。

对于正在升级的节点，所使用的的 kubeadm 必须与管理该节点的 kubeadm 具有相同的 MINOR 版本或比后者新一个 MINOR 版本。

​`kubeadm upgrade`​ 的例子:

*   用于创建或升级节点的 kubeadm 版本为 1.23。
*   用于升级节点的 kubeadm 版本必须为 1.23 或 1.24。

局限性
---

#### 集群弹性

此处创建的集群具有单个控制平面节点，运行单个 etcd 数据库。 这意味着如果控制平面节点发生故障，你的集群可能会丢失数据并且可能需要从头开始重新创建。

解决方法：

*   定期[备份 etcd](https://etcd.io/)。 kubeadm 配置的 etcd 数据目录位于控制平面节点上的 ​`/var/lib/etcd`​ 中。
*   使用多个控制平面节点。你可以阅读 可选的高可用性拓扑选择集群拓扑提供的 高可用性。

#### 平台兼容性

kubeadm deb/rpm 软件包和二进制文件是为 amd64、arm (32-bit)、arm64、ppc64le 和 s390x 构建的遵循[多平台提案](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/multi-platform.md)。

从 v1.12 开始还支持用于控制平面和附加组件的多平台容器镜像。

只有一些网络提供商为所有平台提供解决方案。请查阅上方的网络提供商清单或每个提供商的文档以确定提供商是否支持你选择的平台。

> Note:要为<control-plane-host>:<control-plane-port>指定IPv6元组，必须将IPv6地址括在方括号中，例如：\[fd00::101\]:2073

###  4.  Kubernetes 使用kubeadm API定制组件
使用 kubeadm API 定制组件
-------------------

本页面介绍了如何自定义 kubeadm 部署的组件。 你可以使用 ​`ClusterConfiguration` ​结构中定义的参数，或者在每个节点上应用补丁来定制控制平面组件。 你可以使用 ​`KubeletConfiguration` ​和 ​`KubeProxyConfiguration` ​结构分别定制 kubelet 和 kube-proxy 组件。

所有这些选项都可以通过 kubeadm 配置 API 实现。

> Note:  
> kubeadm 目前不支持对 CoreDNS 部署进行定制。 你必须手动更新 ​`kube-system/coredns`​ ConfigMap 并在更新后重新创建 CoreDNS Pods。 或者，你可以跳过默认的 CoreDNS 部署并部署你自己的 CoreDNS 变种。

使用 ClusterConfiguration 中的标志自定义控制平面 
------------------------------------

kubeadm ​`ClusterConfiguration` ​对象为用户提供了一种方法， 用以覆盖传递给控制平面组件（如 APIServer、ControllerManager、Scheduler 和 Etcd）的默认参数。 各组件配置使用如下字段定义：

*   ​`apiServer` ​
*   ​`controllerManager` ​
*   ​`scheduler` ​
*   ​`etcd`​

这些结构包含一个通用的 ​`extraArgs` ​字段，该字段由 ​`key: value`​ 组成。 要覆盖控制平面组件的参数：

1.  将适当的字段 ​`extraArgs` ​添加到配置中。
2.  向字段 ​`extraArgs` ​添加要覆盖的参数值。
3.  用 ​`--config <YOUR CONFIG YAML>`​ 运行 ​`kubeadm init`​。

> Note:  
> 你可以通过运行 ​`kubeadm config print init-defaults`​ 并将输出保存到你所选的文件中， 以默认值形式生成 ​`ClusterConfiguration` ​对象。

> Note:  
> ​`ClusterConfiguration` ​对象目前在 kubeadm 集群中是全局的。 这意味着你添加的任何标志都将应用于同一组件在不同节点上的所有实例。 要在不同节点上为每个组件应用单独的配置，你可以使用补丁。

> Note:  
> 当前不支持重复的参数（keys）或多次传递相同的参数 ​`--foo`​。 要解决此问题，你必须使用补丁。

#### APIServer 参数 

使用示例：

`apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration kubernetesVersion: v1.16.0 apiServer:   extraArgs:     anonymous-auth: "false"     enable-admission-plugins: AlwaysPullImages,DefaultStorageClass     audit-log-path: /home/johndoe/audit.log`

#### ControllerManager 参数 

使用示例：

`apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration kubernetesVersion: v1.16.0 controllerManager:   extraArgs:     cluster-signing-key-file: /home/johndoe/keys/ca.key     deployment-controller-sync-period: "50"`

Scheduler 参数 
-------------

使用示例：

`apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration kubernetesVersion: v1.16.0 scheduler:   extraArgs:     config: /etc/kubernetes/scheduler-config.yaml   extraVolumes:     - name: schedulerconfig       hostPath: /home/johndoe/schedconfig.yaml       mountPath: /etc/kubernetes/scheduler-config.yaml       readOnly: true       pathType: "File"`

#### Etcd 参数 

使用示例：

`apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration etcd:   local:     extraArgs:       election-timeout: 1000`

使用补丁定制控制平面 
-----------

FEATURE STATE: Kubernetes v1.22 \[beta\]

Kubeadm 允许将包含补丁文件的目录传递给各个节点上的 ​`InitConfiguration` ​和 ​`JoinConfiguration`​。 这些补丁可被用作控制平面组件清单写入磁盘之前的最后一个自定义步骤。

可以使用 ​`--config <你的 YAML 格式控制文件>`​ 将配置文件传递给 ​`kubeadm init`​：

`apiVersion: kubeadm.k8s.io/v1beta3 kind: InitConfiguration patches:   directory: /home/user/somedir`

> Note:  
> 对于 ​`kubeadm init`​，你可以传递一个包含 ​`ClusterConfiguration` ​和 ​`InitConfiguration` ​的文件，以 ​`---`​ 分隔。

你可以使用 ​`--config <你的 YAML 格式配置文件>`​ 将配置文件传递给 ​`kubeadm join`​：

`apiVersion: kubeadm.k8s.io/v1beta3 kind: JoinConfiguration patches:   directory: /home/user/somedir`

补丁目录必须包含名为 ​`target[suffix][+patchtype].extension`​ 的文件。 例如，​`kube-apiserver0+merge.yaml`​ 或只是 ​`etcd.json`​。

*   ​`target` ​可以是 ​`kube-apiserver`​、​`kube-controller-manager`​、​`kube-scheduler`​ 和 ​`etcd` ​之一。
*   ​`patchtype` ​可以是 ​`strategy`​、​`merge` ​或 ​`json` ​之一，并且这些必须匹配 kubectl 支持 的补丁格式。 默认补丁类型是 ​`strategic` ​的。
*   ​`extension` ​必须是 ​`json` ​或 ​`yaml`​。
*   ​`suffix` ​是一个可选字符串，可用于确定首先按字母数字应用哪些补丁。

> Note:  
> 如果你使用 ​`kubeadm upgrade`​ 升级 kubeadm 节点，你必须再次提供相同的补丁，以便在升级后保留自定义配置。 为此，你可以使用 ​`--patches`​ 参数，该参数必须指向同一目录。 ​`kubeadm upgrade`​ 目前不支持用于相同目的的 API 结构配置。

自定义 kubelet 
------------

要自定义 kubelet，你可以在同一配置文件中的 ​`ClusterConfiguration` ​或 ​`InitConfiguration` ​之外添加一个 ​`KubeletConfiguration`​，用 ​`---`​ 分隔。 然后可以将此文件传递给 ​`kubeadm init`​。

> Note:  
> kubeadm 将相同的 ​`KubeletConfiguration` ​配置应用于集群中的所有节点。 要应用节点特定设置，你可以使用 ​`kubelet` ​参数进行覆盖，方法是将它们传递到 ​`InitConfiguration` ​和 ​`JoinConfiguration` ​支持的 ​`nodeRegistration.kubeletExtraArgs`​ 字段中。

自定义 kube-proxy 
---------------

要自定义 kube-proxy，你可以在 ​`ClusterConfiguration` ​或 ​`InitConfiguration` ​之外添加一个 由 ​`---`​ 分隔的 ​`KubeProxyConfiguration`​， 传递给 ​`kubeadm init`​。

> Note:  
> kubeadm 将 kube-proxy 部署为 DaemonSet， 这意味着 ​`KubeProxyConfiguration` ​将应用于集群中的所有 kube-proxy 实例。

###  5.  Kubernetes 高可用拓扑选项
高可用拓扑选项
-------

本页面介绍了配置高可用（HA）Kubernetes 集群拓扑的两个选项。

你可以设置 HA 集群：

*   使用堆叠（stacked）控制平面节点，其中 etcd 节点与控制平面节点共存
*   使用外部 etcd 节点，其中 etcd 在与控制平面不同的节点上运行

在设置 HA 集群之前，你应该仔细考虑每种拓扑的优缺点。

> Note:  
> kubeadm 静态引导 etcd 集群。 阅读 etcd [集群指南](https://github.com/etcd-io/etcd/blob/release-3.4/Documentation/op-guide/clustering.md target=)以获得更多详细信息。

堆叠（Stacked）etcd 拓扑 
-------------------

堆叠（Stacked）HA 集群是一种这样的[拓扑](https://en.wikipedia.org/wiki/Network_topology)， 其中 etcd 分布式数据存储集群堆叠在 kubeadm 管理的控制平面节点上，作为控制平面的一个组件运行。

每个控制平面节点运行 ​`kube-apiserver`​、​`kube-scheduler`​ 和 ​`kube-controller-manager`​ 实例。

​`kube-apiserver`​ 使用负载均衡器暴露给工作节点。

每个控制平面节点创建一个本地 etcd 成员（member），这个 etcd 成员只与该节点的 ​`kube-apiserver`​ 通信。 这同样适用于本地 ​`kube-controller-manager`​ 和 ​`kube-scheduler`​ 实例。

这种拓扑将控制平面和 etcd 成员耦合在同一节点上。相对使用外部 etcd 集群， 设置起来更简单，而且更易于副本管理。

然而，堆叠集群存在耦合失败的风险。如果一个节点发生故障，则 etcd 成员和控制平面实例都将丢失， 并且冗余会受到影响。你可以通过添加更多控制平面节点来降低此风险。

因此，你应该为 HA 集群运行至少三个堆叠的控制平面节点。

这是 kubeadm 中的默认拓扑。当使用 ​`kubeadm init`​ 和 ​`kubeadm join --control-plane`​ 时， 在控制平面节点上会自动创建本地 etcd 成员。

![](https://atts.w3cschool.cn/attachments/image/20220531/1653965800244371.svg)  

外部 etcd 拓扑 
-----------

具有外部 etcd 的 HA 集群是一种这样的[拓扑](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91)， 其中 etcd 分布式数据存储集群在独立于控制平面节点的其他节点上运行。

就像堆叠的 etcd 拓扑一样，外部 etcd 拓扑中的每个控制平面节点都运行 ​`kube-apiserver`​，​`kube-scheduler`​ 和 ​`kube-controller-manager`​ 实例。 同样，​`kube-apiserver`​ 使用负载均衡器暴露给工作节点。但是 etcd 成员在不同的主机上运行， 每个 etcd 主机与每个控制平面节点的 ​`kube-apiserver`​ 通信。

这种拓扑结构解耦了控制平面和 etcd 成员。因此它提供了一种 HA 设置， 其中失去控制平面实例或者 etcd 成员的影响较小，并且不会像堆叠的 HA 拓扑那样影响集群冗余。

但此拓扑需要两倍于堆叠 HA 拓扑的主机数量。

具有此拓扑的 HA 集群至少需要三个用于控制平面节点的主机和三个用于 etcd 节点的主机。

![](https://atts.w3cschool.cn/attachments/image/20220531/1653965875455303.svg)

###  6.  Kubernetes 利用kubeadm创建高可用集群
利用 kubeadm 创建高可用集群
------------------

本文讲述了使用 kubeadm 设置一个高可用的 Kubernetes 集群的两种不同方式：

*   使用具有堆叠的控制平面节点。这种方法所需基础设施较少。etcd 成员和控制平面节点位于同一位置。
*   使用外部集群。这种方法所需基础设施较多。控制平面的节点和 etcd 成员是分开的。

如果你在安装 HA 集群时遇到问题，请在 kubeadm [问题跟踪](https://github.com/kubernetes/kubeadm/issues/new)里向我们提供反馈。

> Caution: 这篇文档没有讲述在云提供商上运行集群的问题。在云环境中，此处记录的方法不适用于类型为 LoadBalancer 的服务对象，或者具有动态的 PersistentVolumes。

在开始之前
-----

根据集群控制平面所选择的拓扑结构不同，准备工作也有所差异：

*   堆叠（Stacked） etcd 拓扑

需要准备：

*   配置满足 kubeadm 的最低要求 的三台机器作为控制面节点。奇数台控制平面节点有利于机器故障或者网络分区时进行重新选主。

*   机器已经安装好容器运行时，并正常运行

*   配置满足 kubeadm 的最低要求 的三台机器作为工作节点

*   机器已经安装好容器运行时，并正常运行

*   在集群中，确保所有计算机之间存在全网络连接（公网或私网）
*   在所有机器上具有 sudo 权限

*   可以使用其他工具；本教程以 ​`sudo` ​举例

*   从某台设备通过 SSH 访问系统中所有节点的能力
*   所有机器上已经安装 ​`kubeadm` ​和 ​`kubelet`​

*   外部 etcd 拓扑

需要准备：

*   配置满足 kubeadm 的最低要求 的三台机器作为控制面节点。奇数台控制平面节点有利于机器故障或者网络分区时进行重新选主。

*   机器已经安装好容器运行时，并正常运行

*   配置满足 kubeadm 的最低要求 的三台机器作为工作节点

*   机器已经安装好容器运行时，并正常运行

*   在集群中，确保所有计算机之间存在全网络连接（公网或私网）
*   在所有机器上具有 sudo 权限

*   可以使用其他工具；本教程以 ​`sudo` ​举例

*   从某台设备通过 SSH 访问系统中所有节点的能力
*   所有机器上已经安装 ​`kubeadm` ​和 ​`kubelet` ​

还需要准备：

*   给 etcd 集群使用的另外三台及以上机器。为了分布式一致性算法达到更好的投票效果，集群必须由奇数个节点组成。

*   机器上已经安装 ​`kubeadm` ​和 ​`kubelet`​。
*   机器上同样需要安装好容器运行时，并能正常运行。

#### 容器镜像

每台主机需要能够从 Kubernetes 容器镜像仓库（ ​`k8s.gcr.io`​ ）读取和拉取镜像。 想要在无法拉取 Kubernetes 仓库镜像的机器上部署高可用集群也是可行的。通过其他的手段保证主机上已经有对应的容器镜像即可。

#### 命令行 

一旦集群创建成功，需要在 PC 上安装 kubectl 用于管理 Kubernetes。为了方便故障排查，也可以在每个控制平面节点上安装 ​`kubectl`​。

这两种方法的第一步
---------

#### 为 kube-apiserver 创建负载均衡器

> Note: 使用负载均衡器需要许多配置。你的集群搭建可能需要不同的配置。 下面的例子只是其中的一方面配置。

1.  创建一个名为 kube-apiserver 的负载均衡器解析 DNS。

*   在云环境中，应该将控制平面节点放置在 TCP 转发负载平衡后面。 该负载均衡器将流量分配给目标列表中所有运行状况良好的控制平面节点。 API 服务器的健康检查是在 kube-apiserver 的监听端口（默认值 ​`:6443`​） 上进行的一个 TCP 检查。
*   不建议在云环境中直接使用 IP 地址。
*   负载均衡器必须能够在 API 服务器端口上与所有控制平面节点通信。 它还必须允许其监听端口的入站流量。
*   确保负载均衡器的地址始终匹配 kubeadm 的 ​`ControlPlaneEndpoint` ​地址。
*   阅读[软件负载平衡选项指南](https://github.com/kubernetes/kubeadm/blob/main/docs/ha-considerations.md target=) 以获取更多详细信息。

3.  添加第一个控制平面节点到负载均衡器并测试连接：

`nc -v LOAD_BALANCER_IP PORT`

由于 apiserver 尚未运行，预期会出现一个连接拒绝错误。 然而超时意味着负载均衡器不能和控制平面节点通信。 如果发生超时，请重新配置负载均衡器与控制平面节点进行通信。

6.  将其余控制平面节点添加到负载均衡器目标组。

使用堆控制平面和 etcd 节点
----------------

#### 控制平面节点的第一步

1.  初始化控制平面：

`sudo kubeadm init --control-plane-endpoint "LOAD_BALANCER_DNS:LOAD_BALANCER_PORT" --upload-certs`

*   你可以使用 ​`--kubernetes-version`​ 标志来设置要使用的 Kubernetes 版本。 建议将 kubeadm、kebelet、kubectl 和 Kubernetes 的版本匹配。
*   这个 ​`--control-plane-endpoint`​ 标志应该被设置成负载均衡器的地址或 DNS 和端口。
*   这个 ​`--upload-certs`​ 标志用来将在所有控制平面实例之间的共享证书上传到集群。

> Note: 标志 ​`kubeadm init`​、​`--config`​ 和 ​`--certificate-key`​ 不能混合使用， 因此如果你要使用 kubeadm 配置，你必须在相应的配置结构 （位于 ​`InitConfiguration` ​和 ​`JoinConfiguration: controlPlane`​）添加 ​`certificateKey` ​字段。

> Note: 一些 CNI 网络插件如 Calico 需要 CIDR 例如 ​`192.168.0.0/16`​ 和一些像 Weave 没有。通过传递 ​`--pod-network-cidr`​ 标志添加 pod CIDR，或者你可以使用 kubeadm 配置文件，在 ​`ClusterConfiguration` ​的 ​`networking` ​对象下设置 ​`podSubnet` ​字段。

*   输出类似于：

`... You can now join any number of control-plane node by running the following command on each as a root: kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866 --control-plane --certificate-key f8902e114ef118304e561c3ecd4d0b543adc226b7a07f675f56564185ffe0c07  Please note that the certificate-key gives access to cluster sensitive data, keep it secret! As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use kubeadm init phase upload-certs to reload certs afterward.  Then you can join any number of worker nodes by running the following on each as root:   kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866`

*   将此输出复制到文本文件。 稍后你将需要它来将控制平面节点和工作节点加入集群。
*   当使用 ​`--upload-certs`​ 调用 ​`kubeadm init`​ 时，主控制平面的证书被加密并上传到 ​`kubeadm-certs`​ Secret 中。
*   要重新上传证书并生成新的解密密钥，请在已加入集群节点的控制平面上使用以下命令：

`sudo kubeadm init phase upload-certs --upload-certs`

*   你还可以在 ​`init` ​期间指定自定义的 ​`--certificate-key`​，以后可以由 ​`join` ​使用。 要生成这样的密钥，可以使用以下命令：

`kubeadm certs certificate-key`

> Note: ​`kubeadm-certs`​ Secret 和解密密钥会在两个小时后失效。

> Caution: 正如命令输出中所述，证书密钥可访问集群敏感数据。请妥善保管！

11.  应用你所选择的 CNI 插件：安装 CNI 驱动。如果适用，请确保配置与 kubeadm 配置文件中指定的 Pod CIDR 相对应。

> Note: 在进行下一步之前，必须选择并部署合适的网络插件。 否则集群不会正常运行。

13.  输入以下内容，并查看控制平面组件的 Pods 启动：

`kubectl get pod -n kube-system -w`

#### 其余控制平面节点的步骤 

> Note: 从 kubeadm 1.15 版本开始，你可以并行加入多个控制平面节点。 在此版本之前，你必须在第一个节点初始化后才能依序的增加新的控制平面节点。

对于每个其他控制平面节点，你应该：

*   执行先前由第一个节点上的 ​`kubeadm init`​ 输出提供给你的 join 命令。 它看起来应该像这样：

`sudo kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866 --control-plane --certificate-key f8902e114ef118304e561c3ecd4d0b543adc226b7a07f675f56564185ffe0c07`

*   这个 ​`--control-plane`​ 标志通知 ​`kubeadm join`​ 创建一个新的控制平面。
*   ​`--certificate-key ...`​ 将导致从集群中的 ​`kubeadm-certs`​ Secret 下载控制平面证书并使用给定的密钥进行解密。

外部 etcd 节点
----------

使用外部 etcd 节点设置集群类似于用于堆叠 etcd 的过程， 不同之处在于你应该首先设置 etcd，并在 kubeadm 配置文件中传递 etcd 信息。

#### 设置 ectd 集群

1.  按照下文 去设置 etcd 集群。
2.  根据本章-手动证书分发 的描述配置 SSH。
3.  将以下文件从集群中的任何 etcd 节点复制到第一个控制平面节点：

`export CONTROL_PLANE="ubuntu@10.0.0.7" scp /etc/kubernetes/pki/etcd/ca.crt "${CONTROL_PLANE}": scp /etc/kubernetes/pki/apiserver-etcd-client.crt "${CONTROL_PLANE}": scp /etc/kubernetes/pki/apiserver-etcd-client.key "${CONTROL_PLANE}":`

*   用第一台控制平面机的 ​`user@host`​ 替换 ​`CONTROL_PLANE` ​的值。

#### 设置第一个控制平面节点 

*   用以下内容创建一个名为 ​`kubeadm-config.yaml`​ 的文件：

`--- apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration kubernetesVersion: stable controlPlaneEndpoint: "LOAD_BALANCER_DNS:LOAD_BALANCER_PORT" # change this (see below) etcd:   external:     endpoints:       - https://ETCD_0_IP:2379 # change ETCD_0_IP appropriately       - https://ETCD_1_IP:2379 # change ETCD_1_IP appropriately       - https://ETCD_2_IP:2379 # change ETCD_2_IP appropriately     caFile: /etc/kubernetes/pki/etcd/ca.crt     certFile: /etc/kubernetes/pki/apiserver-etcd-client.crt     keyFile: /etc/kubernetes/pki/apiserver-etcd-client.key`

> Note: 这里的堆叠（stacked）etcd 和外部 etcd 之前的区别在于设置外部 etcd 需要一个 ​`etcd` ​的 ​`external` ​对象下带有 etcd 端点的配置文件。 如果是内部 etcd，是自动管理的。

*   在你的集群中，将配置模板中的以下变量替换为适当值：

*   ​`LOAD_BALANCER_DNS`​
*   ​`LOAD_BALANCER_PORT`​
*   ​`ETCD_0_IP`​
*   ​`ETCD_1_IP`​
*   ​`ETCD_2_IP`​

以下的步骤与设置内置 etcd 的集群是相似的：

1.  在节点上运行 ​`sudo kubeadm init --config kubeadm-config.yaml --upload-certs`​ 命令。
2.  记下输出的 join 命令，这些命令将在以后使用。
3.  应用你选择的 CNI 插件。

> Note: 在进行下一步之前，必须选择并部署合适的网络插件。 否则集群不会正常运行。

#### 其他控制平面节点的步骤

步骤与设置内置 etcd 相同：

*   确保第一个控制平面节点已完全初始化。
*   使用保存到文本文件的 join 命令将每个控制平面节点连接在一起。 建议一次加入一个控制平面节点。
*   不要忘记默认情况下，​`--certificate-key`​ 中的解密秘钥会在两个小时后过期。

列举控制平面之后的常见任务
-------------

#### 安装工作节点

你可以使用之前存储的 ​`kubeadm init`​ 命令的输出将工作节点加入集群中：

`sudo kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866`

手动证书分发 
-------

如果你选择不将 ​`kubeadm init`​ 与 ​`--upload-certs`​ 命令一起使用， 则意味着你将必须手动将证书从主控制平面节点复制到 将要加入的控制平面节点上。

有许多方法可以实现这种操作。在下面的例子中我们使用 ​`ssh` ​和 ​`scp`​：

如果要在单独的一台计算机控制所有节点，则需要 SSH。

1.  在你的主设备上启用 ssh-agent，要求该设备能访问系统中的所有其他节点：

`eval $(ssh-agent)`

3.  将 SSH 身份添加到会话中：

`ssh-add ~/.ssh/path_to_private_key`

5.  检查节点间的 SSH 以确保连接是正常运行的

*   SSH 到任何节点时，请确保添加 ​`-A`​ 标志：

`ssh -A 10.0.0.7`

*   当在任何节点上使用 sudo 时，请确保保持环境变量设置，以便 SSH 转发能够正常工作：

`sudo -E -s`

7.  在所有节点上配置 SSH 之后，你应该在运行过 ​`kubeadm init`​ 命令的第一个 控制平面节点上运行以下脚本。 该脚本会将证书从第一个控制平面节点复制到另一个控制平面节点：

在以下示例中，用其他控制平面节点的 IP 地址替换 ​`CONTROL_PLANE_IPS`​。

`USER=ubuntu # 可定制 CONTROL_PLANE_IPS="10.0.0.7 10.0.0.8" for host in ${CONTROL_PLANE_IPS}; do     scp /etc/kubernetes/pki/ca.crt "${USER}"@$host:     scp /etc/kubernetes/pki/ca.key "${USER}"@$host:     scp /etc/kubernetes/pki/sa.key "${USER}"@$host:     scp /etc/kubernetes/pki/sa.pub "${USER}"@$host:     scp /etc/kubernetes/pki/front-proxy-ca.crt "${USER}"@$host:     scp /etc/kubernetes/pki/front-proxy-ca.key "${USER}"@$host:     scp /etc/kubernetes/pki/etcd/ca.crt "${USER}"@$host:etcd-ca.crt     scp /etc/kubernetes/pki/etcd/ca.key "${USER}"@$host:etcd-ca.key done`

> Caution: 只需要复制上面列表中的证书。kubeadm 将负责生成其余证书以及加入控制平面实例所需的 SAN。 如果你错误地复制了所有证书，由于缺少所需的 SAN，创建其他节点可能会失败。

11.  然后，在每个即将加入集群的控制平面节点上，你必须先运行以下脚本，然后 再运行 ​`kubeadm join`​。 该脚本会将先前复制的证书从主目录移动到 ​`/etc/kubernetes/pki`​：

`USER=ubuntu # 可定制 mkdir -p /etc/kubernetes/pki/etcd mv /home/${USER}/ca.crt /etc/kubernetes/pki/ mv /home/${USER}/ca.key /etc/kubernetes/pki/ mv /home/${USER}/sa.pub /etc/kubernetes/pki/ mv /home/${USER}/sa.key /etc/kubernetes/pki/ mv /home/${USER}/front-proxy-ca.crt /etc/kubernetes/pki/ mv /home/${USER}/front-proxy-ca.key /etc/kubernetes/pki/ mv /home/${USER}/etcd-ca.crt /etc/kubernetes/pki/etcd/ca.crt mv /home/${USER}/etcd-ca.key /etc/kubernetes/pki/etcd/ca.key`

###  7.  Kubernetes 使用kubeadm创建一个高可用etcd集群
使用 kubeadm 创建一个高可用 etcd 集群 
---------------------------

> Note:  
> 在本指南中，使用 kubeadm 作为外部 etcd 节点管理工具，请注意 kubeadm 不计划支持此类节点的证书更换或升级。 对于长期规划是使用 [etcdadm](https://github.com/kubernetes-sigs/etcdadm) 增强工具来管理这些方面。

默认情况下，kubeadm 在每个控制平面节点上运行一个本地 etcd 实例。也可以使用外部的 etcd 集群，并在不同的主机上提供 etcd 实例。

这个任务将指导你创建一个由三个成员组成的高可用外部 etcd 集群，该集群在创建过程中可被 kubeadm 使用。

在开始之前
-----

*   三个可以通过 2379 和 2380 端口相互通信的主机。本文档使用这些作为默认端口。不过，它们可以通过 kubeadm 的配置文件进行自定义。
*   每个主机必须安装 systemd 和 bash 兼容的 shell。
*   每台主机必须安装有容器运行时、kubelet 和 kubeadm。
*   一些可以用来在主机间复制文件的基础设施。例如 ssh 和 scp 就可以满足需求。

建立集群
----

一般来说，是在一个节点上生成所有证书并且只分发这些必要的文件到其它节点上。

> Note:  
> kubeadm 包含生成下述证书所需的所有必要的密码学工具；在这个例子中，不需要其他加密工具。

> Note: 下面的例子使用 IPv4 地址，但是你也可以使用 IPv6 地址配置 kubeadm、kubelet 和 etcd。一些 Kubernetes 选项支持双协议栈，但是 etcd 不支持。 

####  将 kubelet 配置为 etcd 的服务管理器。

> Note: 你必须在要运行 etcd 的所有主机上执行此操作。

由于 etcd 是首先创建的，因此你必须通过创建具有更高优先级的新文件来覆盖 kubeadm 提供的 kubelet 单元文件。

`cat << EOF > /etc/systemd/system/kubelet.service.d/20-etcd-service-manager.conf [Service] ExecStart= # 将下面的 "systemd" 替换为你的容器运行时所使用的 cgroup 驱动。 # kubelet 的默认值为 "cgroupfs"。 # 如果需要的话，将 "--container-runtime-endpoint " 的值替换为一个不同的容器运行时。 ExecStart=/usr/bin/kubelet --address=127.0.0.1 --pod-manifest-path=/etc/kubernetes/manifests --cgroup-driver=systemd Restart=always EOF  systemctl daemon-reload systemctl restart kubelet`

检查 kubelet 的状态以确保其处于运行状态：

`systemctl status kubelet`

####  为 kubeadm 创建配置文件。

使用以下脚本为每个将要运行 etcd 成员的主机生成一个 kubeadm 配置文件。

`# 使用你的主机 IP 替换 HOST0、HOST1 和 HOST2 的 IP 地址 export HOST0=10.0.0.6 export HOST1=10.0.0.7 export HOST2=10.0.0.8   # 使用你的主机名更新 NAME0, NAME1 和 NAME2  export NAME0="infra0"  export NAME1="infra1"  export NAME2="infra2"  # 创建临时目录来存储将被分发到其它主机上的文件 mkdir -p /tmp/${HOST0}/ /tmp/${HOST1}/ /tmp/${HOST2}/   HOSTS=(${HOST0} ${HOST1} ${HOST2})  NAMES=(${NAME0} ${NAME1} ${NAME2})   for i in "${!HOSTS[@]}"; do  HOST=${HOSTS[$i]}  NAME=${NAMES[$i]}  cat << EOF > /tmp/${HOST}/kubeadmcfg.yaml  ---  apiVersion: "kubeadm.k8s.io/v1beta3"  kind: InitConfiguration  nodeRegistration:      name: ${NAME}  localAPIEndpoint:      advertiseAddress: ${HOST}  ---  apiVersion: "kubeadm.k8s.io/v1beta3"  kind: ClusterConfiguration  etcd:      local:          serverCertSANs:          - "${HOST}"          peerCertSANs:          - "${HOST}"          extraArgs:              initial-cluster: ${NAMES[0]}=https://${HOSTS[0]}:2380,${NAMES[1]}=https://${HOSTS[1]}:2380,${NAMES[2]}=https://${HOSTS[2]}:2380              initial-cluster-state: new              name: ${NAME}              listen-peer-urls: https://${HOST}:2380              listen-client-urls: https://${HOST}:2379              advertise-client-urls: https://${HOST}:2379              initial-advertise-peer-urls: https://${HOST}:2380  EOF  done`

####  生成证书颁发机构

如果你已经拥有 CA，那么唯一的操作是复制 CA 的 ​`crt` ​和 ​`key` ​文件到 ​`etc/kubernetes/pki/etcd/ca.crt`​ 和 ​`/etc/kubernetes/pki/etcd/ca.key`​。 复制完这些文件后继续下一步，“为每个成员创建证书”。

如果你还没有 CA，则在 ​`$HOST0`​（你为 kubeadm 生成配置文件的位置）上运行此命令。

`kubeadm init phase certs etcd-ca`

这一操作创建如下两个文件

*   ​`/etc/kubernetes/pki/etcd/ca.crt` ​
*   ​`/etc/kubernetes/pki/etcd/ca.key`​

####  为每个成员创建证书

`kubeadm init phase certs etcd-server --config=/tmp/${HOST2}/kubeadmcfg.yaml kubeadm init phase certs etcd-peer --config=/tmp/${HOST2}/kubeadmcfg.yaml kubeadm init phase certs etcd-healthcheck-client --config=/tmp/${HOST2}/kubeadmcfg.yaml kubeadm init phase certs apiserver-etcd-client --config=/tmp/${HOST2}/kubeadmcfg.yaml cp -R /etc/kubernetes/pki /tmp/${HOST2}/ # 清理不可重复使用的证书 find /etc/kubernetes/pki -not -name ca.crt -not -name ca.key -type f -delete  kubeadm init phase certs etcd-server --config=/tmp/${HOST1}/kubeadmcfg.yaml kubeadm init phase certs etcd-peer --config=/tmp/${HOST1}/kubeadmcfg.yaml kubeadm init phase certs etcd-healthcheck-client --config=/tmp/${HOST1}/kubeadmcfg.yaml kubeadm init phase certs apiserver-etcd-client --config=/tmp/${HOST1}/kubeadmcfg.yaml cp -R /etc/kubernetes/pki /tmp/${HOST1}/ find /etc/kubernetes/pki -not -name ca.crt -not -name ca.key -type f -delete  kubeadm init phase certs etcd-server --config=/tmp/${HOST0}/kubeadmcfg.yaml kubeadm init phase certs etcd-peer --config=/tmp/${HOST0}/kubeadmcfg.yaml kubeadm init phase certs etcd-healthcheck-client --config=/tmp/${HOST0}/kubeadmcfg.yaml kubeadm init phase certs apiserver-etcd-client --config=/tmp/${HOST0}/kubeadmcfg.yaml # 不需要移动 certs 因为它们是给 HOST0 使用的  # 清理不应从此主机复制的证书 find /tmp/${HOST2} -name ca.key -type f -delete find /tmp/${HOST1} -name ca.key -type f -delete`

####  复制证书和 kubeadm 配置

证书已生成，现在必须将它们移动到对应的主机。

`USER=ubuntu HOST=${HOST1} scp -r /tmp/${HOST}/* ${USER}@${HOST}: ssh ${USER}@${HOST} USER@HOST $ sudo -Es root@HOST $ chown -R root:root pki root@HOST $ mv pki /etc/kubernetes/`

####  确保已经所有预期的文件都存在

​`$HOST0`​ 所需文件的完整列表如下：

`/tmp/${HOST0} └── kubeadmcfg.yaml --- /etc/kubernetes/pki ├── apiserver-etcd-client.crt ├── apiserver-etcd-client.key └── etcd     ├── ca.crt     ├── ca.key     ├── healthcheck-client.crt     ├── healthcheck-client.key     ├── peer.crt     ├── peer.key     ├── server.crt     └── server.key`

在 ​`$HOST1`​ 上：

`$HOME └── kubeadmcfg.yaml --- /etc/kubernetes/pki ├── apiserver-etcd-client.crt ├── apiserver-etcd-client.key └── etcd     ├── ca.crt     ├── healthcheck-client.crt     ├── healthcheck-client.key     ├── peer.crt     ├── peer.key     ├── server.crt     └── server.key`

在 ​`$HOST2`​ 上：

`$HOME └── kubeadmcfg.yaml --- /etc/kubernetes/pki ├── apiserver-etcd-client.crt ├── apiserver-etcd-client.key └── etcd     ├── ca.crt     ├── healthcheck-client.crt     ├── healthcheck-client.key     ├── peer.crt     ├── peer.key     ├── server.crt     └── server.key`

####  创建静态 Pod 清单

既然证书和配置已经就绪，是时候去创建清单了。 在每台主机上运行 ​`kubeadm` ​命令来生成 etcd 使用的静态清单。

 `root@HOST0 $ kubeadm init phase etcd local --config=/tmp/${HOST0}/kubeadmcfg.yaml  root@HOST1 $ kubeadm init phase etcd local --config=$HOME/kubeadmcfg.yaml  root@HOST2 $ kubeadm init phase etcd local --config=$HOME/kubeadmcfg.yaml`

####  可选：检查集群运行状况

`docker run --rm -it \ --net host \ -v /etc/kubernetes:/etc/kubernetes k8s.gcr.io/etcd:${ETCD_TAG} etcdctl \ --cert /etc/kubernetes/pki/etcd/peer.crt \ --key /etc/kubernetes/pki/etcd/peer.key \ --cacert /etc/kubernetes/pki/etcd/ca.crt \ --endpoints https://${HOST0}:2379 endpoint health --cluster ... https://[HOST0 IP]:2379 is healthy: successfully committed proposal: took = 16.283339ms https://[HOST1 IP]:2379 is healthy: successfully committed proposal: took = 19.44402ms https://[HOST2 IP]:2379 is healthy: successfully committed proposal: took = 35.926451ms`

*   将 ​`${ETCD_TAG}`​ 设置为你的 etcd 镜像的版本标签，例如 ​`3.4.3-0`​。 要查看 kubeadm 使用的 etcd 镜像和标签，请执行 ​`kubeadm config images list --kubernetes-version ${K8S_VERSION}`​， 例如，其中的 ​`${K8S_VERSION}`​ 可以是 ​`v1.17.0`​。
*   将 ​`${HOST0}`​ 设置为要测试的主机的 IP 地址。

###  8.  Kubernetes 使用kubeadm配置集群中的每个kubelet
使用 kubeadm 配置集群中的每个 kubelet
---------------------------

> Note: Dockershim 自 1.24 版起已从 Kubernetes 项目中删除。

FEATURE STATE: Kubernetes v1.11 \[stable\]

kubeadm CLI 工具的生命周期与 kubelet 解耦；kubelet 是一个守护程序，在 Kubernetes 集群中的每个节点上运行。 当 Kubernetes 初始化或升级时，kubeadm CLI 工具由用户执行，而 kubelet 始终在后台运行。

由于kubelet是守护程序，因此需要通过某种初始化系统或服务管理器进行维护。 当使用 DEB 或 RPM 安装 kubelet 时，配置系统去管理 kubelet。 你可以改用其他服务管理器，但需要手动地配置。

集群中涉及的所有 kubelet 的一些配置细节都必须相同， 而其他配置方面则需要基于每个 kubelet 进行设置，以适应给定机器的不同特性（例如操作系统、存储和网络）。 你可以手动地管理 kubelet 的配置，但是 kubeadm 现在提供一种 ​`KubeletConfiguration` ​API 类型 用于集中管理 kubelet 的配置。

Kubelet 配置模式 
-------------

以下各节讲述了通过使用 kubeadm 简化 kubelet 配置模式，而不是在每个节点上手动地管理 kubelet 配置。

#### 将集群级配置传播到每个 kubelet 中 

你可以通过 ​`kubeadm init`​ 和 ​`kubeadm join`​ 命令为 kubelet 提供默认值。 有趣的示例包括使用其他容器运行时或通过服务器设置不同的默认子网。

如果你想使用子网 ​`10.96.0.0/12`​ 作为服务的默认网段，你可以给 kubeadm 传递 ​`--service-cidr`​ 参数：

`kubeadm init --service-cidr 10.96.0.0/12`

现在，可以从该子网分配服务的虚拟 IP。 你还需要通过 kubelet 使用 ​`--cluster-dns`​ 标志设置 DNS 地址。 在集群中的每个管理器和节点上的 kubelet 的设置需要相同。 kubelet 提供了一个版本化的结构化 API 对象，该对象可以配置 kubelet 中的大多数参数，并将此配置推送到集群中正在运行的每个 kubelet 上。 此对象被称为 ​`KubeletConfiguration`​。 ​`KubeletConfiguration` ​允许用户指定标志，例如用骆峰值代表集群的 DNS IP 地址，如下所示：

`apiVersion: kubelet.config.k8s.io/v1beta1 kind: KubeletConfiguration clusterDNS: - 10.96.0.10`

#### 提供特定于某实例的配置细节 

由于硬件、操作系统、网络或者其他主机特定参数的差异。某些主机需要特定的 kubelet 配置。 以下列表提供了一些示例。

*   由 kubelet 配置标志 ​`--resolv-conf`​ 指定的 DNS 解析文件的路径在操作系统之间可能有所不同， 它取决于你是否使用 ​`systemd-resolved`​。 如果此路径错误，则在其 kubelet 配置错误的节点上 DNS 解析也将失败。
*   除非你使用云驱动，否则默认情况下 Node API 对象的 ​`.metadata.name`​ 会被设置为计算机的主机名。 如果你需要指定一个与机器的主机名不同的节点名称，你可以使用 ​`--hostname-override`​ 标志覆盖默认值。
*   当前，kubelet 无法自动检测容器运行时使用的 cgroup 驱动程序， 但是值 ​`--cgroup-driver`​ 必须与容器运行时使用的 cgroup 驱动程序匹配，以确保 kubelet 的健康运行状况。
*   要指定容器运行时，你必须用 ​`--container-runtime-endpoint=<path>`​ 标志来指定端点。

你可以在服务管理器（例如 systemd）中设定某个 kubelet 的配置来指定这些参数。

使用 kubeadm 配置 kubelet 
----------------------

如果自定义的 ​`KubeletConfiguration` ​API 对象使用像 ​`kubeadm ... --config some-config-file.yaml`​ 这样的配置文件进行传递，则可以配置 kubeadm 启动的 kubelet。

通过调用 ​`kubeadm config print init-defaults --component-configs KubeletConfiguration`​， 你可以看到此结构中的所有默认值。

#### 使用 kubeadm init 时的工作流程 

当调用 ​`kubeadm init`​ 时，kubelet 的配置会被写入磁盘 ​`/var/lib/kubelet/config.yaml`​， 并上传到集群 ​`kube-system`​ 命名空间的 ​`kubelet-config`​ ConfigMap。 kubelet 配置信息也被写入 ​`/etc/kubernetes/kubelet.conf`​，其中包含集群内所有 kubelet 的基线配置。 此配置文件指向允许 kubelet 与 API 服务器通信的客户端证书。 这解决了将集群级配置传播到每个 kubelet 的需求。

针对为特定实例提供配置细节的第二种模式， kubeadm 的解决方法是将环境文件写入 ​`/var/lib/kubelet/kubeadm-flags.env`​，其中包含了一个标志列表， 当 kubelet 启动时，该标志列表会传递给 kubelet 标志在文件中的显示方式如下：

`KUBELET_KUBEADM_ARGS="--flag1=value1 --flag2=value2 ..."`

除了启动 kubelet 时所使用的标志外，该文件还包含动态参数，例如 cgroup 驱动程序以及是否使用其他容器运行时套接字（​`--cri-socket`​）。

将这两个文件编组到磁盘后，如果使用 systemd，则 kubeadm 尝试运行以下两个命令：

`systemctl daemon-reload && systemctl restart kubelet`

如果重新加载和重新启动成功，则正常的 ​`kubeadm init`​ 工作流程将继续。

#### 使用 kubeadm join 时的工作流程 

当运行 ​`kubeadm join`​ 时，kubeadm 使用 Bootstrap Token 证书执行 TLS 引导，该引导会获取一份证书， 该证书需要下载 ​`kubelet-config`​ ConfigMap 并把它写入 ​`/var/lib/kubelet/config.yaml`​ 中。 动态环境文件的生成方式恰好与 ​`kubeadm init`​ 完全相同。

接下来，​`kubeadm` ​运行以下两个命令将新配置加载到 kubelet 中：

`systemctl daemon-reload && systemctl restart kubelet`

在 kubelet 加载新配置后，kubeadm 将写入 ​`/etc/kubernetes/bootstrap-kubelet.conf`​ KubeConfig 文件中， 该文件包含 CA 证书和引导程序令牌。 kubelet 使用这些证书执行 TLS 引导程序并获取唯一的凭据，该凭据被存储在 ​`/etc/kubernetes/kubelet.conf`​ 中。

当 ​`/etc/kubernetes/kubelet.conf`​ 文件被写入后，kubelet 就完成了 TLS 引导过程。 Kubeadm 在完成 TLS 引导过程后将删除 ​`/etc/kubernetes/bootstrap-kubelet.conf`​ 文件。

kubelet 的 systemd drop-in 文件 
-----------------------------

​`kubeadm` ​中附带了有关系统如何运行 kubelet 的 systemd 配置文件。 请注意 kubeadm CLI 命令不会修改此文件。

通过 ​`kubeadm` ​[DEB 包](https://github.com/kubernetes/release/blob/master/cmd/kubepkg/templates/latest/deb/kubeadm/10-kubeadm.conf) 或者 [RPM 包](https://github.com/kubernetes/release/blob/master/cmd/kubepkg/templates/latest/rpm/kubeadm/10-kubeadm.conf) 安装的配置文件被写入 ​`/etc/systemd/system/kubelet.service.d/10-kubeadm.conf`​ 并由 systemd 使用。 它对原来的 [RPM 版本 ​`kubelet.service`](https://github.com/kubernetes/release/blob/master/cmd/kubepkg/templates/latest/rpm/kubelet/kubelet.service)​ 或者 [DEB 版本 ​`kubelet.service`](https://github.com/kubernetes/release/blob/master/cmd/kubepkg/templates/latest/deb/kubelet/lib/systemd/system/kubelet.service)​ 作了增强：

`[Service] Environment="KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf" Environment="KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml" # 这是 "kubeadm init" 和 "kubeadm join" 运行时生成的文件，动态地填充 KUBELET_KUBEADM_ARGS 变量 EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env # 这是一个文件，用户在不得已下可以将其用作替代 kubelet args。 # 用户最好使用 .NodeRegistration.KubeletExtraArgs 对象在配置文件中替代。 # KUBELET_EXTRA_ARGS 应该从此文件中获取。 EnvironmentFile=-/etc/default/kubelet ExecStart= ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS`

此文件指定由 kubeadm 为 kubelet 管理的所有文件的默认位置。

*   用于 TLS 引导程序的 KubeConfig 文件为 ​`/etc/kubernetes/bootstrap-kubelet.conf`​， 但仅当 ​`/etc/kubernetes/kubelet.conf`​ 不存在时才能使用。
*   具有唯一 kubelet 标识的 KubeConfig 文件为 ​`/etc/kubernetes/kubelet.conf`​。
*   包含 kubelet 的组件配置的文件为 ​`/var/lib/kubelet/config.yaml`​。
*   包含的动态环境的文件 ​`KUBELET_KUBEADM_ARGS`​ 是来源于 ​`/var/lib/kubelet/kubeadm-flags.env`​。
*   包含用户指定标志替代的文件 ​`KUBELET_EXTRA_ARGS` ​是来源于 ​`/etc/default/kubelet`​（对于 DEB），或者 ​`/etc/sysconfig/kubelet`​（对于 RPM）。 ​`KUBELET_EXTRA_ARGS` ​在标志链中排在最后，并且在设置冲突时具有最高优先级。

Kubernetes 可执行文件和软件包内容 
-----------------------

Kubernetes 版本对应的 DEB 和 RPM 软件包是：

软件包名称

描述

`kubeadm`

给 kubelet 安装 `/usr/bin/kubeadm` CLI 工具和 kubelet 的 systemd drop-in 文件。

`kubelet`

安装 `/usr/bin/kubelet` 可执行文件。

`kubectl`

安装 `/usr/bin/kubectl` 可执行文件。

`cri-tools`

从 [cri-tools git 仓库](https://github.com/kubernetes-sigs/cri-tools)中安装 `/usr/bin/crictl` 可执行文件。

`kubernetes-cni`

从 [plugins git 仓库](https://github.com/containernetworking/plugins)中安装 `/opt/cni/bin` 可执行文件。

###  9.  Kubernetes 使用kubeadm支持双协议栈
使用 kubeadm 支持双协议栈
-----------------

FEATURE STATE: Kubernetes v1.23 \[stable\]

你的集群包含双协议栈组网支持， 这意味着集群网络允许你在两种地址族间任选其一。在集群中，控制面可以为同一个 Pod 或者 Service 同时赋予 IPv4 和 IPv6 地址。

在开始之前
-----

你需要已经遵从安装 kubeadm 中所给的步骤安装了 kubeadm 工具。

针对你要作为节点使用的每台服务器， 确保其允许 IPv6 转发。在 Linux 节点上，你可以通过以 root 用户在每台服务器上运行 ​`sysctl -w net.ipv6.conf.all.forwarding=1`​ 来完成设置。

你需要一个可以使用的 IPv4 和 IPv6 地址范围。集群操作人员通常为 IPv4 使用 私有地址范围。对于 IPv6，集群操作人员通常会基于分配给该操作人员的地址范围， 从 ​`2000::/3`​ 中选择一个全局的单播地址块。你不需要将集群的 IP 地址范围路由 到公众互联网。

> Note:  
> 如果你在使用 ​`kubeadm upgrade`​ 命令升级现有的集群，​`kubeadm` ​不允许更改 Pod 的 IP 地址范围（“集群 CIDR”），也不允许更改集群的服务地址范围（“Service CIDR”）。

#### 创建双协议栈集群 

要使用 ​`kubeadm init`​ 创建一个双协议栈集群，你可以传递与下面的例子类似的命令行参数：

`# 这里的地址范围仅作示例使用 kubeadm init --pod-network-cidr=10.244.0.0/16,2001:db8:42:0::/56 --service-cidr=10.96.0.0/16,2001:db8:42:1::/112`

为了更便于理解，参看下面的名为 ​`kubeadm-config.yaml`​ 的 kubeadm 配置文件， 该文件用于双协议栈控制面的主控制节点。

`--- apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration networking:   podSubnet: 10.244.0.0/16,2001:db8:42:0::/56   serviceSubnet: 10.96.0.0/16,2001:db8:42:1::/112 --- apiVersion: kubeadm.k8s.io/v1beta3 kind: InitConfiguration localAPIEndpoint:   advertiseAddress: "10.100.0.1"   bindPort: 6443 nodeRegistration:   kubeletExtraArgs:     node-ip: 10.100.0.2,fd00:1:2:3::2`

InitConfiguration 中的 ​`advertiseAddress` ​给出 API 服务器将公告自身要监听的 IP 地址。​`advertiseAddress` ​的取值与 ​`kubeadm init`​ 的标志 ​`--apiserver-advertise-address`​ 的取值相同。

运行 kubeadm 来实例化双协议栈控制面节点：

`kubeadm init --config=kubeadm-config.yaml`

kube-controller-manager 标志 ​`--node-cidr-mask-size-ipv4|--node-cidr-mask-size-ipv6`​ 是使用默认值来设置的。

> Note:  
> 标志 ​`--apiserver-advertise-address`​ 不支持双协议栈。

#### 向双协议栈集群添加节点 

在添加节点之前，请确保该节点具有 IPv6 可路由的网络接口并且启用了 IPv6 转发。

下面的名为 ​`kubeadm-config.yaml`​ 的 kubeadm 配置文件 示例用于向集群中添加工作节点。

`apiVersion: kubeadm.k8s.io/v1beta3 kind: JoinConfiguration discovery:   bootstrapToken:     apiServerEndpoint: 10.100.0.1:6443     token: "clvldh.vjjwg16ucnhp94qr"     caCertHashes:     - "sha256:a4863cde706cfc580a439f842cc65d5ef112b7b2be31628513a9881cf0d9fe0e"     # 请更改上面的认证信息，使之与你的集群中实际使用的令牌和 CA 证书匹配 nodeRegistration:   kubeletExtraArgs:     node-ip: 10.100.0.3,fd00:1:2:3::3`

下面的名为 ​`kubeadm-config.yaml`​ 的 kubeadm 配置文件 示例用于向集群中添加另一个控制面节点。

`apiVersion: kubeadm.k8s.io/v1beta3 kind: JoinConfiguration controlPlane:   localAPIEndpoint:     advertiseAddress: "10.100.0.2"     bindPort: 6443 discovery:   bootstrapToken:     apiServerEndpoint: 10.100.0.1:6443     token: "clvldh.vjjwg16ucnhp94qr"     caCertHashes:     - "sha256:a4863cde706cfc580a439f842cc65d5ef112b7b2be31628513a9881cf0d9fe0e"     # 请更改上面的认证信息，使之与你的集群中实际使用的令牌和 CA 证书匹配 nodeRegistration:   kubeletExtraArgs:     node-ip: 10.100.0.4,fd00:1:2:3::4`

JoinConfiguration.controlPlane 中的 ​`advertiseAddress` ​设定 API 服务器将公告自身要监听的 IP 地址。​`advertiseAddress` ​的取值与 ​`kubeadm join`​ 的标志 ​`--apiserver-advertise-address`​ 的取值相同。

`kubeadm join --config=kubeadm-config.yaml`

#### 创建单协议栈集群 

> Note:  
> 双协议栈支持并不意味着你需要使用双协议栈来寻址。 你可以部署一个启用了双协议栈联网特性的单协议栈集群。

为了更便于理解，参看下面的名为 ​`kubeadm-config.yaml`​ 的 kubeadm 配置文件示例， 该文件用于单协议栈控制面节点。

`apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration networking:   podSubnet: 10.244.0.0/16   serviceSubnet: 10.96.0.0/16`

###  10.  Kubernetes 使用Kops安装Kubernetes
使用 Kops 安装 Kubernetes
---------------------

本篇快速入门介绍了如何在 AWS 上轻松安装 Kubernetes 集群。 本篇使用了一个名为 ​`[kops](https://github.com/kubernetes/kops)`​ 的工具。

kops 是一个自动化的制备系统：

*   全自动安装流程
*   使用 DNS 识别集群
*   自我修复：一切都在自动扩缩组中运行
*   支持多种操作系统（如 Debian、Ubuntu 16.04、CentOS、RHEL、Amazon Linux 和 CoreOS） - 参考 [images.md](https://github.com/kubernetes/kops/blob/master/docs/operations/images.md)
*   支持高可用
*   可以直接提供或者生成 terraform 清单 - 参考 [terraform.md](https://github.com/kubernetes/kops/blob/master/docs/terraform.md)

在开始之前
-----

*   你必须安装 kubectl。
*   你必须安装 [kops](https://github.com/kubernetes/kops target=) 到 64 位的（AMD64 和 Intel 64）设备架构上。
*   你必须拥有一个 [AWS 账户](https://docs.aws.amazon.com/polly/latest/dg/setting-up.html)， 生成 [IAM 秘钥](https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html target=) 并 [配置](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html target=) 该秘钥。IAM 用户需要[足够的权限许可](https://github.com/kubernetes/kops/blob/master/docs/getting_started/aws.md target=)。

创建集群
----

#### (1/5) 安装 kops

##### 安装 

从[下载页面](https://github.com/kubernetes/kops/releases)下载 kops （从源代码构建也很方便）：

*   macOS

使用下面的命令下载最新发布版本：

`curl -LO https://github.com/kubernetes/kops/releases/download/$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d '"' -f 4)/kops-darwin-amd64`

要下载特定版本，使用特定的 kops 版本替换下面命令中的部分：

`$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d '"' -f 4)`

例如，要下载 kops v1.20.0，输入：

`curl -LO https://github.com/kubernetes/kops/releases/download/v1.20.0/kops-darwin-amd64`

令 kops 二进制文件可执行：

`chmod +x kops-darwin-amd64`

将 kops 二进制文件移到你的 PATH 下：

`sudo mv kops-darwin-amd64 /usr/local/bin/kops`

你也可以使用 [Homebrew](https://brew.sh/) 安装 kops：

`brew update && brew install kops`

*   Linux

使用命令下载最新发布版本：

`curl -LO https://github.com/kubernetes/kops/releases/download/$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d '"' -f 4)/kops-linux-amd64`

要下载 kops 的特定版本，用特定的 kops 版本替换下面命令中的部分：

`$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d '"' -f 4)`

例如，要下载 kops v1.20 版本，输入：

`curl -LO https://github.com/kubernetes/kops/releases/download/v1.20.0/kops-linux-amd64`

令 kops 二进制文件可执行：

`chmod +x kops-linux-amd64`

将 kops 二进制文件移到 PATH 下：

`sudo mv kops-linux-amd64 /usr/local/bin/kops`

你也可以使用 [Homebrew](https://docs.brew.sh/Homebrew-on-Linux) 来安装 kops：

`brew update && brew install kops`

#### (2/5) 为你的集群创建一个 route53 域名

kops 在集群内部和外部都使用 DNS 进行发现操作，这样你可以从客户端访问 kubernetes API 服务器。

kops 对集群名称有明显的要求：它应该是有效的 DNS 名称。这样一来，你就不会再使集群混乱， 可以与同事明确共享集群，并且无需依赖记住 IP 地址即可访问集群。

你可以，或许应该使用子域名来划分集群。作为示例，我们将使用域名 ​`useast1.dev.example.com`​。 这样，API 服务器端点域名将为 ​`api.useast1.dev.example.com`​。

Route53 托管区域可以服务子域名。你的托管区域可能是 ​`useast1.dev.example.com`​，还有 ​`dev.example.com`​ 甚至 ​`example.com`​。 kops 可以与以上任何一种配合使用，因此通常你出于组织原因选择不同的托管区域。 例如，允许你在 ​`dev.example.com`​ 下创建记录，但不能在 ​`example.com`​ 下创建记录。

假设你使用 ​`dev.example.com`​ 作为托管区域。你可以使用 [正常流程](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/CreatingNewSubdomain.html) 或者使用诸如 ​`aws route53 create-hosted-zone --name dev.example.com --caller-reference 1`​ 之类的命令来创建该托管区域。

然后，你必须在父域名中设置你的 DNS 记录，以便该域名中的记录可以被解析。 在这里，你将在 ​`example.com`​ 中为 dev 创建 DNS 记录。 如果它是根域名，则可以在域名注册机构配置 DNS 记录。 例如，你需要在购买 ​`example.com`​ 的地方配置 ​`example.com`​。

检查你的 route53 域已经被正确设置（这是导致问题的最常见原因！）。 如果你安装了 dig 工具，则可以通过运行以下步骤再次检查集群是否配置正确：

`dig DNS dev.example.com`

你应该看到 Route53 分配了你的托管区域的 4 条 DNS 记录。

#### (3/5) 创建一个 S3 存储桶来存储集群状态

kops 使你即使在安装后也可以管理集群。为此，它必须跟踪已创建的集群及其配置、所使用的密钥等。 此信息存储在 S3 存储桶中。S3 权限用于控制对存储桶的访问。

多个集群可以使用同一 S3 存储桶，并且你可以在管理同一集群的同事之间共享一个 S3 存储桶 - 这比传递 kubecfg 文件容易得多。 但是有权访问 S3 存储桶的任何人都将拥有对所有集群的管理访问权限， 因此你不想在运营团队之外共享它。

因此，通常每个运维团队都有一个 S3 存储桶（而且名称通常对应于上面托管区域的名称！）

在我们的示例中，我们选择 ​`dev.example.com`​ 作为托管区域，因此我们选择 ​`clusters.dev.example.com`​ 作为 S3 存储桶名称。

*   导出 ​`AWS_PROFILE`​ 文件（如果你需要选择一个配置文件用来使 AWS CLI 正常工作）
*   使用 ​`aws s3 mb s3://clusters.dev.example.com`​ 创建 S3 存储桶
*   你可以进行 ​`export KOPS_STATE_STORE=s3://clusters.dev.example.com`​ 操作， 然后 kops 将默认使用此位置。 我们建议将其放入你的 bash profile 文件或类似文件中。

#### (4/5) 建立你的集群配置

运行 ​`kops create cluster`​ 以创建你的集群配置：

​`kops create cluster --zones=us-east-1c useast1.dev.example.com` ​

kops 将为你的集群创建配置。请注意，它\_仅\_创建配置，实际上并没有创建云资源 - 你将在下一步中使用 kops update cluster 进行配置。 这使你有机会查看配置或进行更改。

它打印出可用于进一步探索的命令：

*   使用以下命令列出集群：​`kops get cluster` ​
*   使用以下命令编辑该集群：​`kops edit cluster useast1.dev.example.com` ​
*   使用以下命令编辑你的节点实例组：​`kops edit ig --name = useast1.dev.example.com nodes` ​
*   使用以下命令编辑你的主实例组：​`kops edit ig --name = useast1.dev.example.com master-us-east-1c`​

如果这是你第一次使用 kops，请花几分钟尝试一下！ 实例组是一组实例，将被注册为 kubernetes 节点。 在 AWS 上，这是通过 auto-scaling-groups 实现的。你可以有多个实例组。 例如，如果你想要的是混合实例和按需实例的节点，或者 GPU 和非 GPU 实例。

#### (5/5) 在 AWS 中创建集群

运行 "kops update cluster" 以在 AWS 中创建集群：

`kops update cluster useast1.dev.example.com --yes`

这需要几秒钟的时间才能运行，但实际上集群可能需要几分钟才能准备就绪。 每当更改集群配置时，都会使用 ​`kops update cluster`​ 工具。 它将对配置进行的更改应用于你的集群 - 根据需要重新配置 AWS 或者 kubernetes。

例如，在你运行 ​`kops edit ig nodes`​ 之后，然后运行 ​`kops update cluster --yes`​ 应用你的配置，有时你还必须运行 ​`kops rolling-update cluster`​ 立即回滚更新配置。

如果没有 ​`--yes` ​参数，​`kops update cluster`​ 操作将向你显示其操作的预览效果。这对于生产集群很方便！

清理
--

*   删除集群：​`kops delete cluster useast1.dev.example.com --yes`​

###  11.  Kubernetes 使用Kubespray安装Kubernetes
使用 Kubespray 安装 Kubernetes
--------------------------

此快速入门有助于使用 [Kubespray](https://github.com/kubernetes-sigs/kubespray) 安装在 GCE、Azure、OpenStack、AWS、vSphere、Packet（裸机）、Oracle Cloud Infrastructure（实验性）或 Baremetal 上托管的 Kubernetes 集群。

Kubespray 是一个由 [Ansible](https://docs.ansible.com/) playbooks、 [清单（inventory）](https://github.com/kubernetes-sigs/kubespray/blob/master/docs/ansible.md)、 制备工具和通用 OS/Kubernetes 集群配置管理任务的领域知识组成的。 Kubespray 提供：

*   高可用性集群
*   可组合属性
*   支持大多数流行的 Linux 发行版

*   Ubuntu 16.04、18.04、20.04
*   CentOS / RHEL / Oracle Linux 7、8
*   Debian Buster、Jessie、Stretch、Wheezy
*   Fedora 31、32
*   Fedora CoreOS
*   openSUSE Leap 15
*   Kinvolk 的 Flatcar Container Linux

*   持续集成测试

要选择最适合你的用例的工具，请阅读 ​`kubeadm` ​和 ​`kops` ​之间的 [这份比较](https://github.com/kubernetes-sigs/kubespray/blob/master/docs/comparisons.md)

创建集群
----

#### （1/5）满足下层设施要求

按以下[要求](https://github.com/kubernetes-sigs/kubespray target=)来配置服务器：

*   在将运行 Ansible 命令的计算机上安装 Ansible v2.9 和 python-netaddr
*   运行 Ansible Playbook 需要 Jinja 2.11（或更高版本）
*   目标服务器必须有权访问 Internet 才能拉取 Docker 镜像。否则， 需要其他配置（[请参见离线环境](https://github.com/kubernetes-sigs/kubespray/blob/master/docs/offline-environment.md)）
*   目标服务器配置为允许 IPv4 转发
*   你的 SSH 密钥必须复制到部署集群的所有服务器中
*   防火墙不是由 kubespray 管理的。你需要根据需求设置适当的规则策略。为了避免部署过程中出现问题，可以禁用防火墙。
*   如果从非 root 用户帐户运行 kubespray，则应在目标服务器中配置正确的特权升级方法 并指定 ​`ansible_become` ​标志或命令参数 ​`--become`​ 或 ​`-b`​

Kubespray 提供以下实用程序来帮助你设置环境：

*   为以下云驱动提供的 [Terraform](https://www.terraform.io/) 脚本：
*   [AWS](https://github.com/kubernetes-sigs/kubespray/tree/master/contrib/terraform/aws)
*   [OpenStack](http://sitebeskuethree/contrigetbernform/contribeskubernform/contribeskupernform/https/sitebesku/master/)
*   Packet

#### （2/5）编写清单文件

设置服务器后，请创建一个 [Ansible 的清单文件](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html)。 你可以手动执行此操作，也可以通过动态清单脚本执行此操作。有关更多信息，请参阅 “[建立你自己的清单](https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md target=)”。

#### （3/5）规划集群部署

Kubespray 能够自定义部署的许多方面：

*   选择部署模式： kubeadm 或非 kubeadm
*   CNI（网络）插件
*   DNS 配置
*   控制平面的选择：本机/可执行文件或容器化
*   组件版本
*   Calico 路由反射器
*   组件运行时选项

*   Docker
*   containerd
*   CRI-O

*   证书生成方式

可以修改[变量文件](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html) 以进行 Kubespray 定制。 如果你刚刚开始使用 Kubespray，请考虑使用 Kubespray 默认设置来部署你的集群 并探索 Kubernetes 。

#### （4/5）部署集群

接下来，部署你的集群：

使用 [ansible-playbook](https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md target=) 进行集群部署。

`ansible-playbook -i your/inventory/inventory.ini cluster.yml -b -v \   --private-key=~/.ssh/private_key`

大型部署（超过 100 个节点）可能需要 [特定的调整](https://github.com/kubernetes-sigs/kubespray/blob/master/docs/large-deployments.md)， 以获得最佳效果。

#### （5/5）验证部署

Kubespray 提供了一种使用 [Netchecker](https://github.com/kubernetes-sigs/kubespray/blob/master/docs/netcheck.md) 验证 Pod 间连接和 DNS 解析的方法。 Netchecker 确保 netchecker-agents Pods 可以解析 DNS 请求， 并在默认命名空间内对每个请求执行 ping 操作。 这些 Pod 模仿其他工作负载类似的行为，并用作集群运行状况指示器。

集群操作
----

Kubespray 提供了其他 Playbooks 来管理集群： scale 和 upgrade。

#### 扩展集群

你可以通过运行 scale playbook 向集群中添加工作节点。有关更多信息， 请参见 “[添加节点](https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md target=)”。 你可以通过运行 remove-node playbook 来从集群中删除工作节点。有关更多信息， 请参见 “[删除节点](https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md target=)”。

#### 升级集群

你可以通过运行 upgrade-cluster Playbook 来升级集群。有关更多信息，请参见 “[升级](https://github.com/kubernetes-sigs/kubespray/blob/master/docs/upgrades.md)”。

清理
--

你可以通过 [reset](https://github.com/kubernetes-sigs/kubespray/blob/master/reset.yml) Playbook 重置节点并清除所有与 Kubespray 一起安装的组件。

> Caution: 运行 reset playbook 时，请确保不要意外地将生产集群作为目标！  

反馈
--

*   Slack 频道：[#kubespray](https://kubernetes.slack.com/?redir=%2Fmessages%2Fkubespray%2F) （你可以在[此处](https://slack.k8s.io/)获得邀请）
*   [GitHub 问题](https://github.com/kubernetes-sigs/kubespray/issues)

##  12.  Kubernetes 对Windows的支持
Kubernetes 对 Windows 的支持
------------------------

在很多组织中，其服务和应用的很大比例是 Windows 应用。 [Windows 容器](https://docs.microsoft.com/zh-cn/virtualization/windowscontainers/)提供了一种对进程和包依赖关系 进行封装的现代方式，这使得用户更容易采用 DevOps 实践，令 Windows 应用同样遵从 云原生模式。 Kubernetes 已经成为事实上的标准容器编排器，Kubernetes 1.14 发行版本中包含了将 Windows 容器调度到 Kubernetes 集群中 Windows 节点上的生产级支持，从而使得巨大 的 Windows 应用生态圈能够充分利用 Kubernetes 的能力。 对于同时投入基于 Windows 应用和 Linux 应用的组织而言，他们不必寻找不同的编排系统 来管理其工作负载，其跨部署的运维效率得以大幅提升，而不必关心所用操作系统。

kubernetes 中的 Windows 容器 
-------------------------

若要在 Kubernetes 中启用对 Windows 容器的编排，可以在现有的 Linux 集群中 包含 Windows 节点。在 Kubernetes 上调度 Pods 中的 Windows 容器与调用基于 Linux 的容器类似。

为了运行 Windows 容器，你的 Kubernetes 集群必须包含多个操作系统，控制面 节点运行 Linux，工作节点则可以根据负载需要运行 Windows 或 Linux。 Windows Server 2019 是唯一被支持的 Windows 操作系统，在 Windows 上启用 [Kubernetes 节点](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/architecture.md target=) 支持（包括 kubelet, [容器运行时](https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/containerd)、 以及 kube-proxy）。关于 Windows 发行版渠道的详细讨论，可参见  [Microsoft 文档](https://docs.microsoft.com/en-us/windows-server/get-started/servicing-channels-comparison)。

> Note: Kubernetes 控制面，包括主控组件， 继续在 Linux 上运行。 目前没有支持完全是 Windows 节点的 Kubernetes 集群的计划。

> Note: 在本文中，当我们讨论 Windows 容器时，我们所指的是具有进程隔离能力的 Windows 容器。具有 [Hyper-V 隔离能力](https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container) 的 Windows 容器计划在将来发行版本中推出。

支持的功能与局限性 
----------

### 支持的功能 

#### Windows 操作系统版本支持 

参考下面的表格，了解 Kubernetes 中支持的 Windows 操作系统。 同一个异构的 Kubernetes 集群中可以同时包含 Windows 和 Linux 工作节点。 Windows 容器仅能调度到 Windows 节点，Linux 容器则只能调度到 Linux 节点。

Kubernetes 版本

Windows Server LTSC 版本

Windows Server SAC 版本

_Kubernetes v1.20_

Windows Server 2019

Windows Server ver 1909, Windows Server ver 2004

_Kubernetes v1.21_

Windows Server 2019

Windows Server ver 2004, Windows Server ver 20H2

_Kubernetes v1.22_

Windows Server 2019

Windows Server ver 2004, Windows Server ver 20H2

关于不同的 Windows Server 版本的服务渠道，包括其支持模式等相关信息可以在 [Windows Server servicing channels](https://docs.microsoft.com/en-us/windows-server/get-started/servicing-channels-comparison) 找到。

我们并不指望所有 Windows 客户都为其应用频繁地更新操作系统。 对应用的更新是向集群中引入新代码的根本原因。 对于想要更新运行于 Kubernetes 之上的容器中操作系统的客户，我们会在添加对新 操作系统版本的支持时提供指南和分步的操作指令。 该指南会包含与集群节点一起来升级用户应用的建议升级步骤。 Windows 节点遵从 Kubernetes 版本偏差策略（节点到控制面的 版本控制），与 Linux 节点的现行策略相同。

Windows Server 主机操作系统会受 [Windows Server](https://www.microsoft.com/en-us/windows-server/pricing) 授权策略控制。Windows 容器镜像则遵从 [Windows 容器的补充授权条款](https://docs.microsoft.com/en-us/virtualization/windowscontainers/images-eula) 约定。

带进程隔离的 Windows 容器受一些严格的兼容性规则约束， [其中宿主 OS 版本必须与容器基准镜像的 OS 版本相同](https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/version-compatibility?tabs=windows-server-2022%2Cwindows-11-21H2)。 一旦我们在 Kubernetes 中支持带 Hyper-V 隔离的 Windows 容器， 这一约束和兼容性规则也会发生改变。

#### Pause 镜像 

Kubernetes 维护着一个多体系结构镜像，其中包括对 Windows 的支持。 对于 Kubernetes v1.22，推荐的 pause 镜像是 ​`k8s.gcr.io/pause:3.5`​。 [源代码](https://github.com/kubernetes/kubernetes/tree/master/build/pause)可在 GitHub 上找到。

Microsoft 维护了一个支持 Linux 和 Windows amd64 的多体系结构镜像： ​`mcr.microsoft.com/oss/kubernetes/pause:3.5`​。 此镜像与 Kubernetes 维护的镜像是从同一来源构建，但所有 Windows 二进制文件 均由 Microsoft [签名](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/authenticode)。 当生产环境需要被签名的二进制文件时，建议使用 Microsoft 维护的镜像。

#### 计算 

从 API 和 kubectl 的角度，Windows 容器的表现在很大程度上与基于 Linux 的容器 是相同的。不过也有一些与关键功能相关的差别值得注意，这些差别列举于 局限性小节中。

关键性的 Kubernetes 元素在 Windows 下与其在 Linux 下工作方式相同。我们在本节中 讨论一些关键性的负载支撑组件及其在 Windows 中的映射。

*   Pods

Pod 是 Kubernetes 中最基本的构造模块，是 Kubernetes 对象模型中你可以创建或部署的 最小、最简单元。你不可以在同一 Pod 中部署 Windows 和 Linux 容器。 Pod 中的所有容器都会被调度到同一节点（Node），而每个节点代表的是一种特定的平台 和体系结构。Windows 容器支持 Pod 的以下能力、属性和事件：

*   在带进程隔离和卷共享支持的 Pod 中运行一个或多个容器
*   Pod 状态字段
*   就绪态（Readiness）和活跃性（Liveness）探针
*   postStart 和 preStop 容器生命周期事件
*   ConfigMap、Secrets：用作环境变量或卷
*   emptyDir 卷
*   从宿主系统挂载命名管道
*   资源限制

*   控制器（Controllers）

Kubernetes 控制器处理 Pod 的期望状态。Windows 容器支持以下负载控制器：

*   ReplicaSet
*   ReplicationController
*   Deployment
*   StatefulSet
*   DaemonSet
*   Job
*   CronJob

*   服务（Services）

Kubernetes Service 是一种抽象对象，用来定义 Pod 的一个逻辑集合及用来访问这些 Pod 的策略。Service 有时也称作微服务（Micro-service）。你可以使用服务来实现 跨操作系统的连接。在 Windows 系统中，服务可以使用下面的类型、属性和能力：

*   Service 环境变量
*   NodePort
*   ClusterIP
*   LoadBalancer
*   ExternalName
*   无头（Headless）服务

Pods、控制器和服务是在 Kubernetes 上管理 Windows 负载的关键元素。 不过，在一个动态的云原生环境中，这些元素本身还不足以用来正确管理 Windows 负载的生命周期。我们为此添加了如下功能特性：

*   Pod 和容器的度量（Metrics）
*   对水平 Pod 自动扩展的支持
*   对 kubectl exec 命令的支持
*   资源配额
*   调度器抢占

#### 容器运行时 

##### Docker EE

FEATURE STATE: Kubernetes v1.14 \[stable\]

Docker EE-basic 19.03+ 是建议所有 Windows Server 版本采用的容器运行时。 该容器运行时能够与 kubelet 中的 dockershim 代码协同工作。

##### CRI-ContainerD

FEATURE STATE: Kubernetes v1.20 \[stable\]

ContainerD 1.4.0+ 也可作为 Windows Kubernetes 节点上的容器运行时。

#### 持久性存储 

使用 Kubernetes 卷，对数据持久性和 Pod 卷 共享有需求的复杂应用也可以部署到 Kubernetes 上。 管理与特定存储后端或协议相关的持久卷时，相关的操作包括：对卷的配备（Provisioning）、 去配（De-provisioning）和调整大小，将卷挂接到 Kubernetes 节点或从节点上解除挂接， 将卷挂载到需要持久数据的 Pod 中的某容器或从容器上卸载。 负责实现为特定存储后端或协议实现卷管理动作的代码以 Kubernetes 卷 插件的形式发布。 Windows 支持以下大类的 Kubernetes 卷插件：

##### 树内卷插件 

与树内卷插件（In-Tree Volume Plugin）相关的代码都作为核心 Kubernetes 代码基 的一部分发布。树内卷插件的部署不需要安装额外的脚本，也不需要额外部署独立的 容器化插件组件。这些插件可以处理：对应存储后端上存储卷的配备、去配和尺寸更改， 将卷挂接到 Kubernetes 或从其上解挂，以及将卷挂载到 Pod 中各个容器上或从其上 卸载。以下树内插件支持 Windows 节点：

*   ​`awsElasticBlockStore` ​
*   ​`azureDisk` ​
*   ​`azureFile` ​
*   ​`gcePersistentDisk` ​
*   ​`vsphereVolume`​

##### FlexVolume 插件 

与 FlexVolume 插件相关的代码是作为 树外（Out-of-tree）脚本或可执行文件来发布的，因此需要在宿主系统上直接部署。 FlexVolume 插件处理将卷挂接到 Kubernetes 节点或从其上解挂、将卷挂载到 Pod 中 各个容器上或从其上卸载等操作。对于与 FlexVolume 插件相关联的持久卷的配备和 去配操作，可以通过外部的配置程序来处理。这类配置程序通常与 FlexVolume 插件 相分离。下面的 FlexVolume  [插件](https://github.com/Microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows) 可以以 PowerShell 脚本的形式部署到宿主系统上，支持 Windows 节点：

*   [SMB](https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~smb.cmd)
*   [iSCSI](https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~iscsi.cmd)

##### CSI 插件 

FEATURE STATE: Kubernetes v1.22 \[stable\]

与 CSI 插件相关联的代码作为 树外脚本和可执行文件来发布且通常发布为容器镜像形式，并使用 DaemonSet 和 StatefulSet 这类标准的 Kubernetes 构造体来部署。 CSI 插件处理 Kubernetes 中的很多卷管理操作：对卷的配备、去配和调整大小， 将卷挂接到 Kubernetes 节点或从节点上解除挂接，将卷挂载到需要持久数据的 Pod 中的某容器或从容器上卸载，使用快照和克隆来备份或恢复持久数据。

来支持；csi-proxy 是一个社区管理的、独立的可执行文件，需要预安装在每个 Windows 节点之上。请参考你要部署的 CSI 插件的部署指南以进一步了解其细节。

CSI 插件与执行本地存储操作的 CSI 节点插件通信。 在 Windows 节点上，CSI 节点插件通常调用处理本地存储操作的 csi-proxy 公开的 API, [csi-proxy](https://github.com/kubernetes-csi/csi-proxy) 由社区管理。

有关安装的更多详细信息，请参阅你要部署的 Windows CSI 插件的环境部署指南。 你也可以参考以下[安装步骤](https://github.com/kubernetes-csi/csi-proxy target=) 。

#### 联网 

Windows 容器的联网是通过 CNI 插件 来暴露出来的。Windows 容器的联网行为与虚拟机的联网行为类似。 每个容器有一块虚拟的网络适配器（vNIC）连接到 Hyper-V 的虚拟交换机（vSwitch）。 宿主的联网服务（Host Networking Service，HNS）和宿主计算服务（Host Compute Service，HCS）协同工作，创建容器并将容器的虚拟网卡连接到网络上。 HCS 负责管理容器，HNS 则负责管理网络资源，例如：

*   虚拟网络（包括创建 vSwitch）
*   端点（Endpoint）/ vNIC
*   名字空间（Namespace）
*   策略（报文封装、负载均衡规则、访问控制列表、网络地址转译规则等等）

支持的服务规约类型如下：

*   NodePort
*   ClusterIP
*   LoadBalancer
*   ExternalName

##### 网络模式 

Windows 支持五种不同的网络驱动/模式：二层桥接（L2bridge）、二层隧道（L2tunnel）、 覆盖网络（Overlay）、透明网络（Transparent）和网络地址转译（NAT）。 在一个包含 Windows 和 Linux 工作节点的异构集群中，你需要选择一种对 Windows 和 Linux 兼容的联网方案。下面是 Windows 上支持的一些树外插件及何时使用某种 CNI 插件的建议：

网络驱动

描述

容器报文更改

网络插件

网络插件特点

L2bridge

容器挂接到外部 vSwitch 上。容器挂接到下层网络之上，但由于容器的 MAC 地址在入站和出站时被重写，物理网络不需要这些地址。

MAC 地址被重写为宿主系统的 MAC 地址，IP 地址也可能依据 HNS OutboundNAT 策略重写为宿主的 IP 地址。

[win-bridge](https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-bridge)、 [Azure-CNI](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md)、 Flannel 宿主网关（host-gateway）使用 win-bridge

win-bridge 使用二层桥接（L2bridge）网络模式，将容器连接到下层宿主系统上， 从而提供最佳性能。需要用户定义的路由（User-Defined Routes，UDR）才能 实现节点间的连接。

L2Tunnel

这是二层桥接的一种特殊情形，但仅被用于 Azure 上。 所有报文都被发送到虚拟化环境中的宿主机上并根据 SDN 策略进行处理。

MAC 地址被改写，IP 地址在下层网络上可见。

[Azure-CNI](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md)

Azure-CNI 使得容器能够与 Azure vNET 集成，并允许容器利用 \[Azure 虚拟网络\](https://azure.microsoft.com/en-us/services/virtual-network/) 所提供的功能特性集合。例如，可以安全地连接到 Azure 服务上或者使用 Azure NSG。 你可以参考 \[azure-cni\](https://docs.microsoft.com/en-us/azure/aks/concepts-network#azure-cni-advanced-networking) 所提供的一些示例。

覆盖网络（Kubernetes 中为 Windows 提供的覆盖网络支持处于 \*alpha\* 阶段）

每个容器会获得一个连接到外部 vSwitch 的虚拟网卡（vNIC）。 每个覆盖网络都有自己的、通过定制 IP 前缀来定义的 IP 子网。 覆盖网络驱动使用 VxLAN 封装。

封装于外层包头内。

[Win-overlay](https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-overlay)、 Flannel VXLAN（使用 win-overlay）

当（比如出于安全原因）期望虚拟容器网络与下层宿主网络隔离时， 应该使用 win-overlay。如果你的数据中心可用 IP 地址受限， 覆盖网络允许你在不同的网络中复用 IP 地址（每个覆盖网络有不同的 VNID 标签）。 这一选项要求在 Windows Server 2009 上安装 \[KB4489899\](https://support.microsoft.com/help/4489899) 补丁。

透明网络（\[ovn-kubernetes\](https://github.com/openvswitch/ovn-kubernetes) 的特殊用例）

需要一个外部 vSwitch。容器挂接到某外部 vSwitch 上，该 vSwitch 通过逻辑网络（逻辑交换机和路由器）允许 Pod 间通信。

报文或者通过 \[GENEVE\](https://datatracker.ietf.org/doc/draft-gross-geneve/) 来封装， 或者通过 \[STT\](https://datatracker.ietf.org/doc/draft-davie-stt/) 隧道来封装， 以便能够到达不在同一宿主系统上的每个 Pod。  
报文通过 OVN 网络控制器所提供的隧道元数据信息来判定是转发还是丢弃。  
北-南向通信通过 NAT 网络地址转译来实现。

[ovn-kubernetes](https://github.com/openvswitch/ovn-kubernetes)

\[通过 Ansible 来部署\](https://github.com/openvswitch/ovn-kubernetes/tree/master/contrib)。 所发布的 ACL 可以通过 Kubernetes 策略来应用实施。支持 IPAM 。 负载均衡能力不依赖 kube-proxy。 网络地址转译（NAT）也不需要 iptables 或 netsh。

NAT（**未在 Kubernetes 中使用**）

容器获得一个连接到某内部 vSwitch 的 vNIC 接口。 DNS/DHCP 服务通过名为 \[WinNAT\](https://blogs.technet.microsoft.com/virtualization/2016/05/25/windows-nat-winnat-capabilities-and-limitations/) 的内部组件来提供。

MAC 地址和 IP 地址都被重写为宿主系统的 MAC 地址和 IP 地址。

[nat](https://github.com/Microsoft/windows-container-networking/tree/master/plugins/nat)

列在此表中仅出于完整性考虑

如前所述，[Flannel](https://github.com/flannel-io/flannel) CNI meta 插件 在 Windows 上也是 被支持 的，方法是通过 [VXLAN 网络后端](https://github.com/flannel-io/flannel/blob/master/Documentation/backends.md target=) （alpha 阶段 ：委托给 win-overlay）和 [主机-网关（host-gateway）网络后端](https://github.com/flannel-io/flannel/blob/master/Documentation/backends.md target=) （稳定版本；委托给 win-bridge 实现）。 此插件支持将操作委托给所引用的 CNI 插件（win-overlay、win-bridge）之一， 从而能够与 Windows 上的 Flannel 守护进程（Flanneld）一同工作，自动为节点 分配子网租期，创建 HNS 网络。 该插件读入其自身的配置文件（cni.conf），并将其与 FlannelD 所生成的 subnet.env 文件中的环境变量整合，之后将其操作委托给所引用的 CNI 插件之一以完成网络发现， 并将包含节点所被分配的子网信息的正确配置发送给 IPAM 插件（例如 host-local）。

对于节点、Pod 和服务对象，可针对 TCP/UDP 流量支持以下网络数据流：

*   Pod -> Pod （IP 寻址）
*   Pod -> Pod （名字寻址）
*   Pod -> 服务（集群 IP）
*   Pod -> 服务（部分限定域名，仅适用于名称中不包含“.”的情形）
*   Pod -> 服务（全限定域名）
*   Pod -> 集群外部（IP 寻址）
*   Pod -> 集群外部（DNS 寻址）
*   节点 -> Pod
*   Pod -> 节点

##### IP 地址管理（IPAM） 

Windows 上支持以下 IPAM 选项：

*   [host-local](https://github.com/containernetworking/plugins/tree/main/plugins/ipam/host-local)
*   HNS IPAM (Inbox 平台 IPAM，未指定 IPAM 时的默认设置）
*   [Azure-vnet-ipam](https://github.com/Azure/azure-container-networking/blob/master/docs/ipam.md)（仅适用于 azure-cni ）

##### 负载均衡与服务 

在 Windows 系统上，你可以使用以下配置来设定服务和负载均衡行为：

功能特性

描述

所支持的 Kubernetes 版本

所支持的 Windows OS 版本

如何启用

会话亲和性

确保来自特定客户的连接每次都被交给同一 Pod。

v1.20+

\[Windows Server vNext Insider Preview Build 19551\](https://blogs.windows.com/windowsexperience/2020/01/28/announcing-windows-server-vnext-insider-preview-build-19551/) 或更高版本

将 `service.spec.sessionAffinitys` 设置为 "ClientIP"

直接服务器返回（DSR）

这是一种负载均衡模式，IP 地址的修正和负载均衡地址转译（LBNAT） 直接在容器的 vSwitch 端口上处理；服务流量到达时，其源端 IP 地址 设置为来源 Pod 的 IP。

v1.20+

Windows Server 2019

为 kube-proxy 设置标志：\`--feature-gates="WinDSR=true" --enable-dsr=true\`

保留目标地址

对服务流量略过 DNAT 步骤，这样就可以在到达后端 Pod 的报文中保留目标服务的 虚拟 IP 地址。还要禁止节点之间的转发。

v1.20+

Windows Server 1903 或更高版本

在服务注解中设置 \`"preserve-destination": "true"\` 并启用 kube-proxy 中的 DSR 标志。

IPv4/IPv6 双栈网络

在集群内外同时支持原生的 IPv4-到-IPv4 和 IPv6-到-IPv6 通信。

v1.19+

Windows Server 2004 或更高版本

参见 \[IPv4/IPv6 双栈网络\](#ipv4ipv6-dual-stack)

保留客户端 IP

确保入站流量的源 IP 地址被保留。同样要禁止节点之间的转发。

v1.20+

Windows Server 2019 或更高版本

将 `service.spec.externalTrafficPolicy` 设置为 "Local"， 并在 kube-proxy 上启用 DSR。

#### IPv4/IPv6 双栈支持 

你可以通过使用 ​`IPv6DualStack` ​特性门控 来为 ​`l2bridge` ​网络启用 IPv4/IPv6 双栈联网支持。

对 Windows 而言，在 Kubernetes 中使用 IPv6 需要 Windows Server 2004 （内核版本 10.0.19041.610）或更高版本。

目前 Windows 上的覆盖网络（VXLAN）还不支持双协议栈联网。

### 局限性 

在 Kubernetes 架构和节点阵列中仅支持将 Windows 作为工作节点使用。 这意味着 Kubernetes 集群必须总是包含 Linux 主控节点，零个或者多个 Linux 工作节点以及零个或者多个 Windows 工作节点。

#### 资源处理

Linux 上使用 Linux 控制组（CGroups）作为 Pod 的边界，以实现资源控制。 容器都创建于这一边界之内，从而实现网络、进程和文件系统的隔离。 控制组 CGroups API 可用来收集 CPU、I/O 和内存的统计信息。 与此相比，Windows 为每个容器创建一个带有系统名字空间过滤设置的 Job 对象， 以容纳容器中的所有进程并提供其与宿主系统间的逻辑隔离。 没有现成的名字空间过滤设置是无法运行 Windows 容器的。 这也意味着，系统特权无法在宿主环境中评估，因而 Windows 上也就不存在特权容器。 归咎于独立存在的安全账号管理器（Security Account Manager，SAM），容器也不能 获得宿主系统上的任何身份标识。

#### 资源预留 

##### 内存预留 

Windows 不像 Linux 一样有一个内存耗尽（Out-of-memory）进程杀手（Process Killer）机制。Windows 总是将用户态的内存分配视为虚拟请求，页面文件（Pagefile） 是必需的。这一差异的直接结果是 Windows 不会像 Linux 那样出现内存耗尽的状况， 系统会将进程内存页面写入磁盘而不会因内存耗尽而终止进程。 当内存被过量使用且所有物理内存都被用光时，系统的换页行为会导致性能下降。

使用 kubelet 参数 ​`--kubelet-reserve`​ 与/或 ​`-system-reserve`​ 可以统计 节点上的内存用量（各容器之外），进而可能将内存用量限制在一个合理的范围，。 这样做会减少节点可分配内存。

在你部署工作负载时，对容器使用资源限制（必须仅设置 limits 或者让 limits 等于 requests 值）。这也会从 NodeAllocatable 中耗掉部分内存量，从而避免在节点 负荷已满时调度器继续向节点添加 Pods。

避免过量分配的最佳实践是为 kubelet 配置至少 2 GB 的系统预留内存，以供 Windows、Docker 和 Kubernetes 进程使用。

##### CPU 预留 

为了统计 Windows、Docker 和其他 Kubernetes 宿主进程的 CPU 用量，建议 预留一定比例的 CPU，以便对事件作出相应。此值需要根据 Windows 节点上 CPU 核的个数来调整，要确定此百分比值，用户需要为其所有节点确定 Pod 密度的上线，并监控系统服务的 CPU 用量，从而选择一个符合其负载需求的值。

使用 kubelet 参数 ​`--kubelet-reserve`​ 与/或 ​`-system-reserve`​ 可以统计 节点上的 CPU 用量（各容器之外），进而可能将 CPU 用量限制在一个合理的范围，。 这样做会减少节点可分配 CPU。

##### 功能特性限制 

*   终止宽限期（Termination Grace Period）：未实现
*   单文件映射：将用 CRI-ContainerD 来实现
*   终止消息（Termination message）：将用 CRI-ContainerD 来实现
*   特权容器：Windows 容器当前不支持
*   巨页（Huge Pages）：Windows 容器当前不支持
*   现有的节点问题探测器（Node Problem Detector）仅适用于 Linux，且要求使用特权容器。 一般而言，我们不设想此探测器能用于 Windows 节点，因为 Windows 不支持特权容器。
*   并非支持共享名字空间的所有功能特性（参见 API 节以了解详细信息）

#### 与 Linux 相比参数行为的差别

以下 kubelet 参数的行为在 Windows 节点上有些不同，描述如下：

*   ​`--kubelet-reserve`​、​`--system-reserve`​ 和 ​`--eviction-hard`​ 标志 会更新节点可分配资源量
*   未实现通过使用 ​`--enforce-node-allocable`​ 来完成的 Pod 驱逐
*   未实现通过使用 ​`--eviction-hard`​ 和 ​`--eviction-soft`​ 来完成的 Pod 驱逐
*   ​`MemoryPressure` ​状况未实现
*   ​`kubelet` ​不会采取措施来执行基于 OOM 的驱逐动作
*   Windows 节点上运行的 kubelet 没有内存约束。 ​`--kubelet-reserve`​ 和 ​`--system-reserve`​ 不会为 kubelet 或宿主系统上运行 的进程设限。这意味着 kubelet 或宿主系统上的进程可能导致内存资源紧张， 而这一情况既不受节点可分配量影响，也不会被调度器感知。
*   在 Windows 节点上存在一个额外的参数用来设置 kubelet 进程的优先级，称作 ​`--windows-priorityclass`​。此参数允许 kubelet 进程获得与 Windows 宿主上 其他进程相比更多的 CPU 时间片。 关于可用参数值及其含义的进一步信息可参考 [Windows Priority Classes](https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities target=)。 为了让 kubelet 总能够获得足够的 CPU 周期，建议将此参数设置为 ​`ABOVE_NORMAL_PRIORITY_CLASS` ​或更高。

#### 存储 

Windows 上包含一个分层的文件系统来挂载容器的分层，并会基于 NTFS 来创建一个 拷贝文件系统。容器中的所有文件路径都仅在该容器的上下文内完成解析。

*   Docker 卷挂载仅可针对容器中的目录进行，不可针对独立的文件。 这一限制不适用于 CRI-containerD。
*   卷挂载无法将文件或目录投射回宿主文件系统。
*   不支持只读文件系统，因为 Windows 注册表和 SAM 数据库总是需要写访问权限。 不过，Windows 支持只读的卷。
*   不支持卷的用户掩码和访问许可，因为宿主与容器之间并不共享 SAM，二者之间不存在 映射关系。所有访问许可都是在容器上下文中解析的。

因此，Windows 节点上不支持以下存储功能特性：

*   卷的子路径挂载；只能在 Windows 容器上挂载整个卷。
*   为 Secret 执行子路径挂载；
*   宿主挂载投射；
*   默认访问模式 defaultMode（因为该特性依赖 UID/GID）；
*   只读的根文件系统；映射的卷仍然支持 ​`readOnly`​；
*   块设备映射；
*   将内存作为存储介质；
*   类似 UUID/GUID、每用户不同的 Linux 文件系统访问许可等文件系统特性；
*   基于 NFS 的存储和卷支持；
*   扩充已挂载卷（resizefs）。

#### 联网 

Windows 容器联网与 Linux 联网有着非常重要的差别。 [Microsoft documentation for Windows Container Networking](https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/architecture) 中包含额外的细节和背景信息。

Windows 宿主联网服务和虚拟交换机实现了名字空间隔离，可以根据需要为 Pod 或容器 创建虚拟的网络接口（NICs）。不过，很多类似 DNS、路由、度量值之类的配置数据都 保存在 Windows 注册表数据库中而不是像 Linux 一样保存在 ​`/etc/...`​ 文件中。 Windows 为容器提供的注册表与宿主系统的注册表是分离的，因此类似于将 /etc/resolv.conf 文件从宿主系统映射到容器中的做法不会产生与 Linux 系统相同的效果。 这些信息必须在容器内部使用 Windows API 来配置。 因此，CNI 实现需要调用 HNS，而不是依赖文件映射来将网络细节传递到 Pod 或容器中。

Windows 节点不支持以下联网功能：

*   Windows Pod 不能使用宿主网络模式；
*   从节点本地访问 NodePort 会失败（但从其他节点或外部客户端可访问）
*   Windows Server 的未来版本中会支持从节点访问服务的 VIP；
*   每个服务最多支持 64 个后端 Pod 或独立的目标 IP 地址；
*   kube-proxy 的覆盖网络支持是 Beta 特性。此外，它要求在 Windows Server 2019 上安装 [KB4482887](https://support.microsoft.com/en-us/topic/march-1-2019-kb4482887-os-build-17763-348-f7a9f207-0627-1fb9-cca7-29bb7b26027f) 补丁；
*   非 DSR（保留目标地址）模式下的本地流量策略；
*   连接到覆盖网络的 Windows 容器不支持使用 IPv6 协议栈通信。 要使得这一网络驱动支持 IPv6 地址需要在 Windows 平台上开展大量的工作， 还需要在 Kubernetes 侧修改 kubelet、kube-proxy 以及 CNI 插件。
*   通过 win-overlay、win-bridge 和 Azure-CNI 插件使用 ICMP 协议向集群外通信。 尤其是，Windows 数据面 （[VFP](https://www.microsoft.com/en-us/research/project/azure-virtual-filtering-platform/)） 不支持转换 ICMP 报文。这意味着：

*   指向同一网络内目标地址的 ICMP 报文（例如 Pod 之间的 ping 通信）是可以工作的， 没有局限性；
*   TCP/UDP 报文可以正常工作，没有局限性；
*   指向远程网络的 ICMP 报文（例如，从 Pod 中 ping 外部互联网的通信）无法被转换， 因此也无法被路由回到其源点；
*   由于 TCP/UDP 包仍可被转换，用户可以将 ​`ping <目标>`​ 操作替换为 ​`curl <目标>`​ 以便能够调试与外部世界的网络连接。

Kubernetes v1.15 中添加了以下功能特性：

*   ​`kubectl port-forward` ​

##### CNI 插件 

*   Windows 参考网络插件 win-bridge 和 win-overlay 当前未实现 [CNI spec](https://github.com/containernetworking/cni/blob/master/SPEC.md) v0.4.0， 原因是缺少检查（CHECK）用的实现。
    
*   Windows 上的 Flannel VXLAN CNI 有以下局限性：

1.  其设计上不支持从节点到 Pod 的连接。 只有在 Flannel v0.12.0 或更高版本后才有可能访问本地 Pods。
2.  我们被限制只能使用 VNI 4096 和 UDP 端口 4789。 VNI 的限制正在被解决，会在将来的版本中消失（开源的 Flannel 更改）。 参见官方的 [Flannel VXLAN](https://github.com/flannel-io/flannel/blob/master/Documentation/backends.md target=) 后端文档以了解关于这些参数的详细信息。

##### DNS

*   不支持 DNS 的 ClusterFirstWithHostNet 配置。Windows 将所有包含 “.” 的名字 视为全限定域名（FQDN），因而不会对其执行部分限定域名（PQDN）解析。
*   在 Linux 上，你可以有一个 DNS 后缀列表供解析部分限定域名时使用。 在 Windows 上，我们只有一个 DNS 后缀，即与该 Pod 名字空间相关联的 DNS 后缀（例如 ​`mydns.svc.cluster.local`​）。 Windows 可以解析全限定域名、或者恰好可用该后缀来解析的服务名称。 例如，在 default 名字空间中生成的 Pod 会获得 DNS 后缀 ​`default.svc.cluster.local`​。在 Windows Pod 中，你可以解析 ​`kubernetes.default.svc.cluster.local`​ 和 ​`kubernetes`​，但无法解析二者 之间的形式，如 ​`kubernetes.default`​ 或 ​`kubernetes.default.svc`​。
*   在 Windows 上，可以使用的 DNS 解析程序有很多。由于这些解析程序彼此之间 会有轻微的行为差别，建议使用 ​`Resolve-DNSName`​ 工具来完成名字查询解析。

##### IPv6

Windows 上的 Kubernetes 不支持单协议栈的“只用 IPv6”联网选项。 不过，系统支持在 IPv4/IPv6 双协议栈的 Pod 和节点上运行单协议家族的服务。

##### 会话亲和性 

不支持使用 ​`service.spec.sessionAffinityConfig.clientIP.timeoutSeconds`​ 来为 Windows 服务设置最大会话粘滞时间。

##### 安全性 

Secret 以明文形式写入节点的卷中（而不是像 Linux 那样写入内存或 tmpfs 中）。 这意味着客户必须做以下两件事：

1.  使用文件访问控制列表来保护 Secret 文件所在的位置
2.  使用 [BitLocker](https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-how-to-deploy-on-windows-server) 来执行卷层面的加密

用户可以为 Windows Pods 或 Container 设置 ​`RunAsUserName` ​以便以非节点默认用户来执行容器中的进程。这大致等价于设置 ​`RunAsUser`​。

不支持特定于 Linux 的 Pod 安全上下文特权，例如 SELinux、AppArmor、Seccomp、 权能字（POSIX 权能字）等等。

此外，如前所述，Windows 不支持特权容器。

#### API

对 Windows 而言，大多数 Kubernetes API 的工作方式没有变化。 一些不易察觉的差别通常体现在 OS 和容器运行时上的不同。 在某些场合，负载 API （如 Pod 或 Container）的某些属性在设计时假定其 在 Linux 上实现，因此会无法在 Windows 上运行。

在较高层面，不同的 OS 概念有：

*   身份标识 - Linux 使用证书类型来表示用户 ID（UID）和组 ID（GID）。用户和组名 没有特定标准，它们是 ​`/etc/groups`​ 或 ​`/etc/passwd`​ 中的别名表项，会映射回 UID+GID。Windows 使用一个更大的二进制安全标识符（SID），保存在 Windows 安全访问管理器（Security Access Manager，SAM）数据库中。此数据库并不在宿主系统 与容器间，或者任意两个容器之间共享。
*   文件许可 - Windows 使用基于 SID 的访问控制列表，而不是基于 UID+GID 的访问权限位掩码。
*   文件路径 - Windows 上的习惯是使用 ​`\`​ 而非 ​`/`​。Go 语言的 IO 库同时接受这两种文件路径分隔符。不过，当你在指定要在容器内解析的路径或命令行时， 可能需要使用 ​`\`​。
*   信号（Signal） - Windows 交互式应用以不同方式来处理终止事件，并可实现以下方式之一或组合：

*   UI 线程处理包含 ​`WM_CLOSE` ​在内的良定的消息
*   控制台应用使用控制处理程序来处理 Ctrl-C 或 Ctrl-Break
*   服务会注册服务控制处理程序，接受 ​`SERVICE_CONTROL_STOP` ​控制代码

退出代码遵从相同的习惯，0 表示成功，非 0 值表示失败。 特定的错误代码在 Windows 和 Linux 上可能会不同。不过，从 Kubernetes 组件 （kubelet、kube-proxy）所返回的退出代码是没有变化的。

*   ​`v1.Container.ResourceRequirements.limits.cpu`​ 和 ​`v1.Container.ResourceRequirements.limits.memory`​ - Windows 不对 CPU 分配设置硬性的限制。与之相反，Windows 使用一个份额（share）系统。 基于毫核（millicores）的现有字段值会被缩放为相对的份额值，供 Windows 调度器使用。

*   Windows 容器运行时中没有实现巨页支持，因此相关特性不可用。 巨页支持需要判定用户的特权 而这一特性无法在容器级别配置。

*   ​`v1.Container.ResourceRequirements.requests.cpu`​ 和 ​`v1.Container.ResourceRequirements.requests.memory`​ - 请求 值会从节点可分配资源中扣除，从而可用来避免节点上的资源过量分配。 但是，它们无法用来在一个已经过量分配的节点上提供资源保障。 如果操作员希望彻底避免过量分配，作为最佳实践，他们就需要为所有容器设置资源请求值。
*   ​`v1.Container.SecurityContext.allowPrivilegeEscalation`​ - 在 Windows 上无法实现，对应的权能无一可在 Windows 上生效。
*   ​`v1.Container.SecurityContext.Capabilities`​ - Windows 上未实现 POSIX 权能机制
*   ​`v1.Container.SecurityContext.privileged`​ - Windows 不支持特权容器
*   ​`v1.Container.SecurityContext.procMount`​ - Windows 不包含 ​`/proc`​ 文件系统
*   ​`v1.Container.SecurityContext.readOnlyRootFilesystem`​ - 在 Windows 上无法实现， 要在容器内使用注册表或运行系统进程就必需写访问权限。
*   ​`v1.Container.SecurityContext.runAsGroup`​ - 在 Windows 上无法实现，没有 GID 支持
*   ​`v1.Container.SecurityContext.runAsNonRoot`​ - Windows 上没有 root 用户。 与之最接近的等价用户是 ContainerAdministrator，而该身份标识在节点上并不存在。
*   ​`v1.Container.SecurityContext.runAsUser`​ - 在 Windows 上无法实现， 因为没有作为整数支持的 GID。
*   ​`v1.Container.SecurityContext.seLinuxOptions`​ - 在 Windows 上无法实现， 因为没有 SELinux
*   ​`V1.Container.terminationMessagePath`​ - 因为 Windows 不支持单个文件的映射，这一功能 在 Windows 上也受限。默认值 ​`/dev/termination-log`​ 在 Windows 上也无法使用因为 对应路径在 Windows 上不存在。

##### V1.Pod

*   ​`v1.Pod.hostIPC`​、​`v1.Pod.hostPID`​ - Windows 不支持共享宿主系统的名字空间
*   ​`v1.Pod.hostNetwork`​ - Windows 操作系统不支持共享宿主网络
*   ​`v1.Pod.dnsPolicy`​ - 不支持 ​`ClusterFirstWithHostNet`​，因为 Windows 不支持宿主网络
*   ​`v1.Pod.podSecurityContext`​ - 参见下面的 ​`v1.PodSecurityContext`​
*   ​`v1.Pod.shareProcessNamespace`​ - 此为 Beta 特性且依赖于 Windows 上未实现 的 Linux 名字空间。 Windows 无法共享进程名字空间或者容器的根文件系统。只能共享网络。
*   ​`v1.Pod.terminationGracePeriodSeconds`​ - 这一特性未在 Windows 版本的 Docker 中完全实现。 参见[问题报告](https://github.com/moby/moby/issues/25982)。 目前实现的行为是向 ​`ENTRYPOINT` ​进程发送 ​`CTRL_SHUTDOWN_EVENT` ​事件，之后 Windows 默认 等待 5 秒钟，并最终使用正常的 Windows 关机行为关闭所有进程。 这里的 5 秒钟默认值实际上保存在  [容器内](https://github.com/moby/moby/issues/25982 target=) 的 Windows 注册表中，因此可以在构造容器时重载。
*   ​`v1.Pod.volumeDevices`​ - 此为 Beta 特性且未在 Windows 上实现。Windows 无法挂接 原生的块设备到 Pod 中。
*   ​`v1.Pod.volumes`​ - ​`emptyDir`​、​`secret`​、​`configMap` ​和 ​`hostPath` ​都可正常工作且在 TestGrid 中测试。

*   ​`v1.emptyDir.volumeSource`​ - Windows 上节点的默认介质是磁盘。 不支持将内存作为介质，因为 Windows 不支持内置的 RAM 磁盘。

*   ​`v1.VolumeMount.mountPropagation`​ - Windows 上不支持挂载传播。

##### V1.PodSecurityContext

PodSecurityContext 的所有选项在 Windows 上都无法工作。这些选项列在下面仅供参考。

*   ​`v1.PodSecurityContext.seLinuxOptions`​ - Windows 上无 SELinux
*   ​`v1.PodSecurityContext.runAsUser`​ - 提供 UID；Windows 不支持
*   ​`v1.PodSecurityContext.runAsGroup`​ - 提供 GID；Windows 不支持
*   ​`v1.PodSecurityContext.runAsNonRoot`​ - Windows 上没有 root 用户 最接近的等价账号是 ​`ContainerAdministrator`​，而该身份标识在节点上不存在
*   ​`v1.PodSecurityContext.supplementalGroups`​ - 提供 GID；Windows 不支持
*   ​`v1.PodSecurityContext.sysctls`​ - 这些是 Linux sysctl 接口的一部分；Windows 上 没有等价机制。

#### 操作系统版本限制 

Windows 有着严格的兼容性规则，宿主 OS 的版本必须与容器基准镜像 OS 的版本匹配。 目前仅支持容器操作系统为 Windows Server 2019 的 Windows 容器。 对于容器的 Hyper-V 隔离、允许一定程度上的 Windows 容器镜像版本向后兼容性等等， 都是将来版本计划的一部分。

获取帮助和故障排查 
----------

Kubernetes 中日志是故障排查的一个重要元素。确保你在尝试从其他贡献者那里获得 故障排查帮助时提供日志信息。你可以按照 SIG-Windows [贡献指南和收集日志](https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md target=) 所给的指令来操作。

*   我怎样知道 ​`start.ps1`​ 是否已成功完成？

你应该能看到节点上运行的 kubelet、kube-proxy 和（如果你选择 Flannel 作为联网方案）flanneld 宿主代理进程，它们的运行日志显示在不同的 PowerShell 窗口中。此外，你的 Windows 节点应该在你的 Kubernetes 集群 列举为 "Ready" 节点。

*   我可以将 Kubernetes 节点进程配置为服务运行在后台么？

kubelet 和 kube-proxy 都已经被配置为以本地 Windows 服务运行， 并且在出现失效事件（例如进程意外结束）时通过自动重启服务来提供一定的弹性。 你有两种办法将这些节点组件配置为服务。

*   以本地 Windows 服务的形式

Kubelet 和 kube-proxy 可以用 ​`sc.exe`​ 以本地 Windows 服务的形式运行：

`# 用两个单独的命令为 kubelet 和 kube-proxy 创建服务 sc.exe create <组件名称> binPath="<可执行文件路径> -service <其它参数>"  # 请注意如果参数中包含空格，必须使用转义 sc.exe create kubelet binPath= "C:\kubelet.exe --service --hostname-override 'minion' <其它参数>"  # 启动服务 Start-Service kubelet Start-Service kube-proxy  # 停止服务 Stop-Service kubelet (-Force) Stop-Service kube-proxy (-Force)  # 查询服务状态 Get-Service kubelet Get-Service kube-proxy`

*   使用 nssm.exe

你也总是可以使用替代的服务管理器，例如[nssm.exe](https://nssm.cc/)，来为你在后台运行 这些进程（​`flanneld`​、​`kubelet` ​和 ​`kube-proxy`​）。你可以使用这一 [示例脚本](https://github.com/microsoft/SDN/blob/master/Kubernetes/flannel/register-svc.ps1)， 利用 ​`nssm.exe`​ 将 ​`kubelet`​、​`kube-proxy`​ 和 ​`flanneld.exe`​ 注册为要在后台运行的 Windows 服务。

`register-svc.ps1 -NetworkMode <网络模式> -ManagementIP <Windows 节点 IP> -ClusterCIDR <集群子网> -KubeDnsServiceIP <kube-dns 服务 IP> -LogDir <日志目录>`

这里的参数解释如下：

*   ​`NetworkMode`​：网络模式 l2bridge（flannel host-gw，也是默认值）或 overlay（flannel vxlan）选做网络方案
*   ​`ManagementIP`​：分配给 Windows 节点的 IP 地址。你可以使用 ipconfig 得到此值
*   ​`ClusterCIDR`​：集群子网范围（默认值为 10.244.0.0/16）
*   ​`KubeDnsServiceIP`​：Kubernetes DNS 服务 IP（默认值为 10.96.0.10）
*   ​`LogDir`​：kubelet 和 kube-proxy 的日志会被重定向到这一目录中的对应输出文件， 默认值为 ​`C:\k`​。

若以上所引用的脚本不适合，你可以使用下面的例子手动配置 ​`nssm.exe`​。

注册 flanneld.exe：

`nssm install flanneld C:\flannel\flanneld.exe nssm set flanneld AppParameters --kubeconfig-file=c:\k\config --iface=<ManagementIP> --ip-masq=1 --kube-subnet-mgr=1 nssm set flanneld AppEnvironmentExtra NODE_NAME=<hostname> nssm set flanneld AppDirectory C:\flannel nssm start flanneld`

注册 kubelet.exe：

`nssm install kubelet C:\k\kubelet.exe nssm set kubelet AppParameters --hostname-override=<hostname> --v=6 --pod-infra-container-image=k8s.gcr.io/pause:3.5 --resolv-conf="" --allow-privileged=true --enable-debugging-handlers --cluster-dns=<DNS-service-IP> --cluster-domain=cluster.local --kubeconfig=c:\k\config --hairpin-mode=promiscuous-bridge --image-pull-progress-deadline=20m --cgroups-per-qos=false  --log-dir=<log directory> --logtostderr=false --enforce-node-allocatable="" --network-plugin=cni --cni-bin-dir=c:\k\cni --cni-conf-dir=c:\k\cni\config nssm set kubelet AppDirectory C:\k nssm start kubelet`

注册 kube-proxy.exe（二层网桥模式和主机网关模式）

`nssm install kube-proxy C:\k\kube-proxy.exe nssm set kube-proxy AppDirectory c:\k nssm set kube-proxy AppParameters --v=4 --proxy-mode=kernelspace --hostname-override=<hostname>--kubeconfig=c:\k\config --enable-dsr=false --log-dir=<log directory> --logtostderr=false nssm.exe set kube-proxy AppEnvironmentExtra KUBE_NETWORK=cbr0 nssm set kube-proxy DependOnService kubelet nssm start kube-proxy`

注册 kube-proxy.exe（覆盖网络模式或 VxLAN 模式）

`nssm install kube-proxy C:\k\kube-proxy.exe nssm set kube-proxy AppDirectory c:\k nssm set kube-proxy AppParameters --v=4 --proxy-mode=kernelspace --feature-gates="WinOverlay=true" --hostname-override=<hostname> --kubeconfig=c:\k\config --network-name=vxlan0 --source-vip=<source-vip> --enable-dsr=false --log-dir=<log directory> --logtostderr=false nssm set kube-proxy DependOnService kubelet nssm start kube-proxy`

作为初始的故障排查操作，你可以使用在 [nssm.exe](https://nssm.cc/) 中使用下面的标志 以便将标准输出和标准错误输出重定向到一个输出文件：

`nssm set <服务名称> AppStdout C:\k\mysvc.log nssm set <服务名称> AppStderr C:\k\mysvc.log`

要了解更多的细节，可参见官方的 [nssm 用法](https://nssm.cc/usage)文档。

*   我的 Windows Pods 无法连接网络

如果你在使用虚拟机，请确保 VM 网络适配器均已开启 MAC 侦听（Spoofing）。

*   我的 Windows Pods 无法 ping 外部资源

Windows Pods 目前没有为 ICMP 协议提供出站规则。不过 TCP/UDP 是支持的。 尝试与集群外资源连接时，可以将 ​`ping <IP>`​ 命令替换为对应的 ​`curl <IP>`​ 命令。

如果你还遇到问题，很可能你在 [cni.conf](https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf) 中的网络配置值得额外的注意。你总是可以编辑这一静态文件。 配置的更新会应用到所有新创建的 Kubernetes 资源上。

Kubernetes 网络的需求之一是集群内部无需网络地址转译（NAT）即可实现通信。 为了符合这一要求，对所有我们不希望出站时发生 NAT 的通信都存在一个 [ExceptionList](https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf target=)。 然而这也意味着你需要将你要查询的外部 IP 从 ExceptionList 中移除。 只有这时，从你的 Windows Pod 发起的网络请求才会被正确地通过 SNAT 转换以接收到 来自外部世界的响应。 就此而言，你在 ​`cni.conf`​ 中的 ​`ExceptionList` ​应该看起来像这样：

`"ExceptionList": [     "10.244.0.0/16",  # 集群子网     "10.96.0.0/12",   # 服务子网     "10.127.130.0/24" # 管理（主机）子网 ]`

*   我的 Windows 节点无法访问 NodePort 服务

从节点自身发起的本地 NodePort 请求会失败。这是一个已知的局限。 NodePort 服务的访问从其他节点或者外部客户端都可正常进行。

*   容器的 vNICs 和 HNS 端点被删除了

这一问题可能因为 ​`hostname-override`​ 参数未能传递给 kube-proxy 而导致。解决这一问题时，用户需要按如下方式将主机名传递给 kube-proxy：

`C:\k\kube-proxy.exe --hostname-override=$(hostname)`

*   使用 Flannel 时，我的节点在重新加入集群时遇到问题

无论何时，当一个之前被删除的节点被重新添加到集群时，flannelD 都会将为节点分配 一个新的 Pod 子网。 用户需要将将下面路径中的老的 Pod 子网配置文件删除：

`Remove-Item C:\k\SourceVip.json Remove-Item C:\k\SourceVipRequest.json`

*   在启动了 ​`start.ps1`​ 之后，flanneld 一直停滞在 "Waiting for the Network to be created" 状态

关于这一[问题](https://github.com/flannel-io/flannel/issues/1066)有很多的报告； 最可能的一种原因是关于何时设置 Flannel 网络的管理 IP 的时间问题。 一种解决办法是重新启动 ​`start.ps1`​ 或者按如下方式手动重启之：

`[Environment]::SetEnvironmentVariable("NODE_NAME", "<Windows 工作节点主机名>") C:\flannel\flanneld.exe --kubeconfig-file=c:\k\config --iface=<Windows 工作节点 IP> --ip-masq=1 --kube-subnet-mgr=1`

*   我的 Windows Pods 无法启动，因为缺少 ​`/run/flannel/subnet.env`​ 文件

这表明 Flannel 网络未能正确启动。你可以尝试重启 flanneld.exe 或者将文件手动地 从 Kubernetes 主控节点的 ​`/run/flannel/subnet.env`​ 路径复制到 Windows 工作 节点的 ​`C:\run\flannel\subnet.env`​ 路径，并将 ​`FLANNEL_SUBNET` ​行改为一个 不同的数值。例如，如果期望节点子网为 ​`10.244.4.1/24`​：

`FLANNEL_NETWORK=10.244.0.0/16 FLANNEL_SUBNET=10.244.4.1/24 FLANNEL_MTU=1500 FLANNEL_IPMASQ=true`

*   我的 Windows 节点无法使用服务 IP 访问我的服务

这是 Windows 上当前网络协议栈的一个已知的限制。 Windows Pods 能够访问服务 IP。

*   启动 kubelet 时找不到网络适配器

Windows 网络堆栈需要一个虚拟的适配器，这样 Kubernetes 网络才能工作。 如果下面的命令（在管理员 Shell 中）没有任何返回结果，证明虚拟网络创建 （kubelet 正常工作的必要前提之一）失败了：

`Get-HnsNetwork | ? Name -ieq "cbr0" Get-NetAdapter | ? Name -Like "vEthernet (Ethernet*"`

当宿主系统的网络适配器名称不是 "Ethernet" 时，通常值得更改 ​`start.ps1`​ 脚本中的 [InterfaceName](https://github.com/microsoft/SDN/blob/master/Kubernetes/flannel/start.ps1 target=) 参数来重试。否则可以查验 ​`start-kubelet.ps1`​ 的输出，看看是否在虚拟网络创建 过程中报告了其他错误。

*   我的 Pods 停滞在 "Container Creating" 状态或者反复重启

检查你的 pause 镜像是与你的 OS 版本兼容的。 如果你安装的是更新版本的 Windows，比如说 某个 Insider 构造版本，你需要相应地调整要使用的镜像。 请参照 Microsoft 的 [Docker 仓库](https://hub.docker.com/u/microsoft/) 了解镜像。不管怎样，pause 镜像的 Dockerfile 和示例服务都期望镜像的标签 为 ​`:latest`​。

*   ​`kubectl port-forward`​ 失败，错误信息为 "unable to do port forwarding: wincat not found"

此功能是在 Kubernetes v1.15 中实现的，pause 基础设施容器 ​`mcr.microsoft.com/oss/kubernetes/pause:3.4.1`​ 中包含了 wincat.exe。 请确保你使用的是这些版本或者更新版本。 如果你想要自行构造你自己的 pause 基础设施容器，要确保其中包含了 [wincat](https://github.com/kubernetes-sigs/sig-windows-tools/tree/master/cmd/wincat)

Windows 的端口转发支持需要在 pause 基础设施容器 中提供 wincat.exe。 确保你使用的是与你的 Windows 操作系统版本兼容的受支持镜像。 如果你想构建自己的 pause 基础架构容器，请确保包含 [wincat](https://github.com/kubernetes/kubernetes/tree/master/build/pause/windows/wincat)。

*   我的 Kubernetes 安装失败，因为我的 Windows Server 节点在防火墙后面

如果你处于防火墙之后，那么必须定义如下 PowerShell 环境变量：

`[Environment]::SetEnvironmentVariable("HTTP_PROXY", "http://proxy.example.com:80/", [EnvironmentVariableTarget]::Machine) [Environment]::SetEnvironmentVariable("HTTPS_PROXY", "http://proxy.example.com:443/", [EnvironmentVariableTarget]::Machine)`

*   ​`pause` ​容器是什么？

在一个 Kubernetes Pod 中，一个基础设施容器，或称 "pause" 容器，会被首先创建出来， 用以托管容器端点。属于同一 Pod 的容器，包括基础设施容器和工作容器，会共享相同的 网络名字空间和端点（相同的 IP 和端口空间）。我们需要 pause 容器来工作容器崩溃或 重启的状况，以确保不会丢失任何网络配置。

### 进一步探究 

如果以上步骤未能解决你遇到的问题，你可以通过以下方式获得在 Kubernetes 中的 Windows 节点上运行 Windows 容器的帮助：

*   StackOverflow [Windows Server Container](https://stackoverflow.com/questions/tagged/windows-server-container) 主题
*   Kubernetes 官方论坛 [discuss.kubernetes.io](https://discuss.kubernetes.io/)
*   Kubernetes Slack [#SIG-Windows 频道](https://kubernetes.slack.com/?redir=%2Fmessages%2Fsig-windows)

报告问题和功能需求 
----------

如果你遇到看起来像是软件缺陷的问题，或者你想要提起某种功能需求，请使用 [GitHub 问题跟踪系统](https://github.com/kubernetes/kubernetes/issues)。 你可以在 [GitHub](https://github.com/kubernetes/kubernetes/issues/new/choose) 上发起 Issue 并将其指派给 SIG-Windows。你应该首先搜索 Issue 列表，看看是否 该 Issue 以前曾经被报告过，以评论形式将你在该 Issue 上的体验追加进去，并附上 额外的日志信息。SIG-Windows Slack 频道也是一个获得初步支持的好渠道，可以在 生成新的 Ticket 之前对一些想法进行故障分析。

在登记软件缺陷时，请给出如何重现该问题的详细信息，例如：

*   Kubernetes 版本：kubectl 版本
*   环境细节：云平台、OS 版本、网络选型和配置情况以及 Docker 版本
*   重现该问题的详细步骤
*   [相关的日志](https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs)
*   通过为该 Issue 添加 ​`/sig windows`​ 评论为其添加 ​`sig/windows`​ 标签， 进而引起 SIG-Windows 成员的注意。

##  13.  Kubernetes Windows容器的调度指南
Kubernetes 中 Windows 容器的调度指南  

Windows 应用程序构成了许多组织中运行的服务和应用程序的很大一部分。 本指南将引导你完成在 Kubernetes 中配置和部署 Windows 容器的步骤。

目标
--

*   配置一个示例 deployment 以在 Windows 节点上运行 Windows 容器
*   （可选）使用组托管服务帐户（GMSA）为你的 Pod 配置 Active Directory 身份

在开始之前
-----

*   创建一个 Kubernetes 集群，其中包括一个控制平面和 运行 Windows 服务器的工作节点
*   重要的是要注意，对于 Linux 和 Windows 容器，在 Kubernetes 上创建和部署服务和工作负载的行为几乎相同。 与集群接口的 kubectl 命令相同。 提供以下部分中的示例只是为了快速启动 Windows 容器的使用体验。

入门：部署 Windows 容器
----------------

要在 Kubernetes 上部署 Windows 容器，你必须首先创建一个示例应用程序。 下面的示例 YAML 文件创建了一个简单的 Web 服务器应用程序。 创建一个名为 ​`win-webserver.yaml`​ 的服务规约，其内容如下：

`apiVersion: v1 kind: Service metadata:   name: win-webserver   labels:     app: win-webserver spec:   ports:     # the port that this service should serve on     - port: 80       targetPort: 80   selector:     app: win-webserver   type: NodePort --- apiVersion: apps/v1 kind: Deployment metadata:   labels:     app: win-webserver   name: win-webserver spec:   replicas: 2   selector:     matchLabels:       app: win-webserver   template:     metadata:       labels:         app: win-webserver       name: win-webserver     spec:      containers:       - name: windowswebserver         image: mcr.microsoft.com/windows/servercore:ltsc2019         command:         - powershell.exe         - -command         - "<#code used from https://gist.github.com/19WAS85/5424431#> ; $listener = New-Object System.Net.HttpListener ; $listener.Prefixes.Add('http://*:80/') ; $listener.Start() ; $callerCounts = @{} ; Write-Host('Listening at http://*:80/') ; while ($listener.IsListening) { ;$context = $listener.GetContext() ;$requestUrl = $context.Request.Url ;$clientIP = $context.Request.RemoteEndPoint.Address ;$response = $context.Response ;Write-Host '' ;Write-Host('> {0}' -f $requestUrl) ;  ;$count = 1 ;$k=$callerCounts.Get_Item($clientIP) ;if ($k -ne $null) { $count += $k } ;$callerCounts.Set_Item($clientIP, $count) ;$ip=(Get-NetAdapter | Get-NetIpAddress); $header='<html><body><H1>Windows Container Web Server</H1>' ;$callerCountsString='' ;$callerCounts.Keys | % { $callerCountsString+='<p>IP {0} callerCount {1} ' -f $ip[1].IPAddress,$callerCounts.Item($_) } ;$footer='</body></html>' ;$content='{0}{1}{2}' -f $header,$callerCountsString,$footer ;Write-Output $content ;$buffer = [System.Text.Encoding]::UTF8.GetBytes($content) ;$response.ContentLength64 = $buffer.Length ;$response.OutputStream.Write($buffer, 0, $buffer.Length) ;$response.Close() ;$responseStatus = $response.StatusCode ;Write-Host('< {0}' -f $responseStatus)  } ; "      nodeSelector:       kubernetes.io/os: windows`

> Note: 端口映射也是支持的，但为简单起见，在此示例中容器端口 80 直接暴露给服务。

1.  检查所有节点是否健康：

`kubectl get nodes`

3.  部署服务并观察 pod 更新：

`kubectl apply -f win-webserver.yaml kubectl get pods -o wide -w`

正确部署服务后，两个 Pod 都标记为 “Ready”。要退出 watch 命令，请按 Ctrl + C。

6.  检查部署是否成功。验证：

*   Windows 节点上每个 Pod 有两个容器，使用 ​`docker ps`​
*   Linux 控制平面节点列出两个 Pod，使用 ​`kubectl get pods`​
*   跨网络的节点到 Pod 通信，从 Linux 控制平面节点 ​`curl` ​你的 pod IPs 的端口 80，以检查 Web 服务器响应
*   Pod 到 Pod 的通信，使用 docker exec 或 kubectl exec 在 Pod 之间 （以及跨主机，如果你有多个 Windows 节点）进行 ping 操作
*   服务到 Pod 的通信，从 Linux 控制平面节点和各个 Pod 中 ​`curl` ​虚拟服务 IP （在 ​`kubectl get services`​ 下可见）
*   服务发现，使用 Kubernetes ​`curl` ​服务名称 默认 DNS 后缀
*   入站连接，从 Linux 控制平面节点或集群外部的计算机 ​`curl` ​NodePort
*   出站连接，使用 kubectl exec 从 Pod 内部 curl 外部 IP

> Note: 由于当前平台对 Windows 网络堆栈的限制，Windows 容器主机无法访问在其上调度的服务的 IP。只有 Windows pods 才能访问服务 IP。

可观测性 
-----

### 抓取来自工作负载的日志

日志是可观测性的重要一环；使用日志用户可以获得对负载运行状况的洞察， 因而日志是故障排查的一个重要手法。 因为 Windows 容器中的 Windows 容器和负载与 Linux 容器的行为不同， 用户很难收集日志，因此运行状态的可见性很受限。 例如，Windows 工作负载通常被配置为将日志输出到 Windows 事件跟踪 （Event Tracing for Windows，ETW），或者将日志条目推送到应用的事件日志中。  [LogMonitor](https://github.com/microsoft/windows-container-tools/tree/master/LogMonitor) 是 Microsoft 提供的一个开源工具，是监视 Windows 容器中所配置的日志源 的推荐方式。 LogMonitor 支持监视时间日志、ETW 提供者模块以及自定义的应用日志， 并使用管道的方式将其输出到标准输出（stdout），以便 ​`kubectl logs <pod>`​ 这类命令能够读取这些数据。

请遵照 LogMonitor GitHub 页面上的指令，将其可执行文件和配置文件复制到 你的所有容器中，并为其添加必要的入口点（Entrypoint），以便 LogMonitor 能够将你的日志输出推送到标准输出（stdout）。

使用可配置的容器用户名
-----------

从 Kubernetes v1.16 开始，可以为 Windows 容器配置与其镜像默认值不同的用户名 来运行其入口点和进程。 此能力的实现方式和 Linux 容器有些不同。

使用组托管服务帐户管理工作负载身份
-----------------

从 Kubernetes v1.14 开始，可以将 Windows 容器工作负载配置为使用组托管服务帐户（GMSA）。 组托管服务帐户是 Active Directory 帐户的一种特定类型，它提供自动密码管理， 简化的服务主体名称（SPN）管理以及将管理委派给跨多台服务器的其他管理员的功能。 配置了 GMSA 的容器可以访问外部 Active Directory 域资源，同时携带通过 GMSA 配置的身份。

污点和容忍度
------

目前，用户需要将 Linux 和 Windows 工作负载运行在各自特定的操作系统的节点上， 因而需要结合使用污点和节点选择算符。这可能仅给 Windows 用户造成不便。 推荐的方法概述如下，其主要目标之一是该方法不应破坏与现有 Linux 工作负载的兼容性。

如果 ​`IdentifyPodOS` ​特性门控是启用的， 你可以（并且应该）为 Pod 设置 ​`.spec.os.name`​ 以表明该 Pod 中的容器所针对的操作系统。对于运行 Linux 容器的 Pod，设置 ​`.spec.os.name`​ 为 ​`linux`​。对于运行 Windows 容器的 Pod，设置 ​`.spec.os.name`​ 为 ​`Windows`​。

> Note: 从 1.24 开始，​`IdentifyPodOS` ​功能处于 Beta 阶段，默认启用。

在将 Pod 分配给节点时，调度程序不使用 ​`.spec.os.name`​ 的值。你应该使用正常的 Kubernetes 机制将 Pod 分配给节点， 确保集群的控制平面将 Pod 放置到适合运行的操作系统。 ​`.spec.os.name`​ 值对 Windows Pod 的调度没有影响，因此仍然需要污点、容忍度以及节点选择器， 以确保 Windows Pod 调度至合适的 Windows 节点。

### 确保特定操作系统的工作负载落在适当的容器主机上

用户可以使用污点和容忍度确保 Windows 容器可以调度在适当的主机上。目前所有 Kubernetes 节点都具有以下默认标签：

*   kubernetes.io/os = \[windows|linux\]
*   kubernetes.io/arch = \[amd64|arm64|...\]

如果 Pod 规范未指定诸如 ​`"kubernetes.io/os": windows`​ 之类的 nodeSelector，则该 Pod 可能会被调度到任何主机（Windows 或 Linux）上。 这是有问题的，因为 Windows 容器只能在 Windows 上运行，而 Linux 容器只能在 Linux 上运行。 最佳实践是使用 nodeSelector。

但是，我们了解到，在许多情况下，用户都有既存的大量的 Linux 容器部署，以及一个现成的配置生态系统， 例如社区 Helm charts，以及程序化 Pod 生成案例，例如 Operators。 在这些情况下，你可能会不愿意更改配置添加 nodeSelector。替代方法是使用污点。 由于 kubelet 可以在注册期间设置污点，因此可以轻松修改它，使其仅在 Windows 上运行时自动添加污点。

例如：​`--register-with-taints='os=windows:NoSchedule'` ​

向所有 Windows 节点添加污点后，Kubernetes 将不会在它们上调度任何负载（包括现有的 Linux Pod）。 为了使某 Windows Pod 调度到 Windows 节点上，该 Pod 需要 nodeSelector 和合适的匹配的容忍度设置来选择 Windows。

`nodeSelector:     kubernetes.io/os: windows     node.kubernetes.io/windows-build: '10.0.17763' tolerations:     - key: "os"       operator: "Equal"       value: "windows"       effect: "NoSchedule"`

### 处理同一集群中的多个 Windows 版本

每个 Pod 使用的 Windows Server 版本必须与该节点的 Windows Server 版本相匹配。 如果要在同一集群中使用多个 Windows Server 版本，则应该设置其他节点标签和 nodeSelector。

Kubernetes 1.17 自动添加了一个新标签 ​`node.kubernetes.io/windows-build`​ 来简化此操作。 如果你运行的是旧版本，则建议手动将此标签添加到 Windows 节点。

此标签反映了需要兼容的 Windows 主要、次要和内部版本号。以下是当前每个 Windows Server 版本使用的值。

产品名称

内部编号

Windows Server 2019

10.0.17763

Windows Server version 1809

10.0.17763

Windows Server version 1903

10.0.18362

### 使用 RuntimeClass 简化

RuntimeClass 可用于 简化使用污点和容忍度的过程。 集群管理员可以创建 ​`RuntimeClass` ​对象，用于封装这些污点和容忍度。

1.  将此文件保存到 ​`runtimeClasses.yml`​ 文件。 它包括适用于 Windows 操作系统、体系结构和版本的 ​`nodeSelector`​。

`apiVersion: node.k8s.io/v1 kind: RuntimeClass metadata:   name: windows-2019 handler: 'docker' scheduling:   nodeSelector:     kubernetes.io/os: 'windows'     kubernetes.io/arch: 'amd64'     node.kubernetes.io/windows-build: '10.0.17763'   tolerations:   - effect: NoSchedule     key: os     operator: Equal     value: "windows"`

3.  集群管理员执行 ​`kubectl create -f runtimeClasses.yml`​ 操作
4.  根据需要向 Pod 规约中添加 ​`runtimeClassName: windows-2019`​，例如：

`apiVersion: apps/v1 kind: Deployment metadata:   name: iis-2019   labels:     app: iis-2019 spec:   replicas: 1   template:     metadata:       name: iis-2019       labels:         app: iis-2019     spec:       runtimeClassName: windows-2019       containers:       - name: iis         image: mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019         resources:           limits:             cpu: 1             memory: 800Mi           requests:             cpu: .1             memory: 300Mi         ports:           - containerPort: 80  selector:     matchLabels:       app: iis-2019 --- apiVersion: v1 kind: Service metadata:   name: iis spec:   type: LoadBalancer   ports:   - protocol: TCP     port: 80   selector:     app: iis-2019`

##  2.  Kubernetes 最佳实践

###  2.1.  Kubernetes 运行于多可用区环境
背景 
---

Kubernetes 从设计上允许同一个 Kubernetes 集群跨多个失效区来运行， 通常这些区位于某个称作 区域（region） 逻辑分组中。 主要的云提供商都将区域定义为一组失效区的集合（也称作 可用区（Availability Zones））， 能够提供一组一致的功能特性：每个区域内，各个可用区提供相同的 API 和服务。

典型的云体系结构都会尝试降低某个区中的失效影响到其他区中服务的概率。

控制面行为 
------

所有的控制面组件 都支持以一组可相互替换的资源池的形式来运行，每个组件都有多个副本。

当你部署集群控制面时，应将控制面组件的副本跨多个失效区来部署。 如果可用性是一个很重要的指标，应该选择至少三个失效区，并将每个 控制面组件（API 服务器、调度器、etcd、控制器管理器）复制多个副本， 跨至少三个失效区来部署。如果你在运行云控制器管理器，则也应该将 该组件跨所选的三个失效区来部署。

> Note:  
> Kubernetes 并不会为 API 服务器端点提供跨失效区的弹性。 你可以为集群 API 服务器使用多种技术来提升其可用性，包括使用 DNS 轮转、SRV 记录或者带健康检查的第三方负载均衡解决方案等等。

节点行为 
-----

Kubernetes 自动为负载资源（如Deployment 或 StatefulSet)） 跨集群中不同节点来部署其 Pods。 这种分布逻辑有助于降低失效带来的影响。

节点启动时，每个节点上的 kubelet 会向 Kubernetes API 中代表该 kubelet 的 Node 对象 添加 标签。 这些标签可能包含区信息。

如果你的集群跨了多个可用区或者地理区域，你可以使用节点标签，结合 Pod 拓扑分布约束 来控制如何在你的集群中多个失效域之间分布 Pods。这里的失效域可以是 地理区域、可用区甚至是特定节点。 这些提示信息使得调度器 能够更好地分布 Pods，以实现更好的可用性，降低因为某种失效给整个工作负载 带来的风险。

例如，你可以设置一种约束，确保某个 StatefulSet 中的三个副本都运行在 不同的可用区中，只要其他条件允许。你可以通过声明的方式来定义这种约束， 而不需要显式指定每个工作负载使用哪些可用区。

#### 跨多个区分布节点

Kubernetes 的核心逻辑并不会帮你创建节点，你需要自行完成此操作，或者使用 类似 [Cluster API](https://cluster-api.sigs.k8s.io/) 这类工具来替你管理节点。

使用类似 Cluster API 这类工具，你可以跨多个失效域来定义一组用做你的集群 工作节点的机器，以及当整个区的服务出现中断时如何自动治愈集群的策略。

为 Pods 手动指定区
------------

你可以应用节点选择算符约束 到你所创建的 Pods 上，或者为 Deployment、StatefulSet 或 Job 这类工作负载资源 中的 Pod 模板设置此类约束。

跨区的存储访问
-------

当创建持久卷时，​`PersistentVolumeLabel` ​准入控制器 会自动向那些链接到特定区的 PersistentVolume 添加区标签。 调度器通过其 ​`NoVolumeZoneConflict` ​断言确保申领给定 PersistentVolume 的 Pods 只会 被调度到该卷所在的可用区。

你可以为 PersistentVolumeClaim 指定StorageClass 以设置该类中的存储可以使用的失效域（区）。

网络 
---

Kubernetes 自身不提供与可用区相关的联网配置。 你可以使用网络插件 来配置集群的联网，该网络解决方案可能拥有一些与可用区相关的元素。 例如，如果你的云提供商支持 ​`type=LoadBalancer`​ 的 Service，则负载均衡器 可能仅会将请求流量发送到运行在负责处理给定连接的负载均衡器组件所在的区。 请查阅云提供商的文档了解详细信息。

对于自定义的或本地集群部署，也可以考虑这些因素 Service Ingress 的行为， 包括处理不同失效区的方法，在很大程度上取决于你的集群是如何搭建的。

失效恢复 
-----

在搭建集群时，你可能需要考虑当某区域中的所有失效区都同时掉线时，是否以及如何 恢复服务。例如，你是否要求在某个区中至少有一个节点能够运行 Pod？ 请确保任何对集群很关键的修复工作都不要指望集群中至少有一个健康节点。 例如：当所有节点都不健康时，你可能需要运行某个修复性的 Job， 该 Job 要设置特定的容忍度 以便修复操作能够至少将一个节点恢复为可用状态。

Kubernetes 对这类问题没有现成的解决方案；不过这也是要考虑的因素之一。

###  2.2.  Kubernetes 大规模集群的注意事项
大规模集群的注意事项
----------

集群是运行 Kubernetes 代理的、 由控制平面管理的一组 节点（物理机或虚拟机）。 Kubernetes v1.24 支持的最大节点数为 5000。 更具体地说，Kubernetes旨在适应满足以下所有标准的配置：

*   每个节点的 Pod 数量不超过 110
*   节点数不超过 5000
*   Pod 总数不超过 150000
*   容器总数不超过 300000

你可以通过添加或删除节点来扩展集群。集群扩缩的方式取决于集群的部署方式。

云供应商资源配额
--------

为避免遇到云供应商配额问题，在创建具有大规模节点的集群时，请考虑以下事项：

*   请求增加云资源的配额，例如：

*   计算实例
*   CPUs
*   存储卷
*   使用中的 IP 地址
*   数据包过滤规则集
*   负载均衡数量
*   网络子网
*   日志流

*   由于某些云供应商限制了创建新实例的速度，因此通过分批启动新节点来控制集群扩展操作，并在各批之间有一个暂停。

控制面组件
-----

对于大型集群，你需要一个具有足够计算能力和其他资源的控制平面。

通常，你将在每个故障区域运行一个或两个控制平面实例， 先垂直缩放这些实例，然后在到达下降点（垂直）后再水平缩放。

你应该在每个故障区域至少应运行一个实例，以提供容错能力。 Kubernetes 节点不会自动将流量引向相同故障区域中的控制平面端点。 但是，你的云供应商可能有自己的机制来执行此操作。

例如，使用托管的负载均衡器时，你可以配置负载均衡器发送源自故障区域 A 中的 kubelet 和 Pod 的流量， 并将该流量仅定向到也位于区域 A 中的控制平面主机。 如果单个控制平面主机或端点故障区域 A 脱机，则意味着区域 A 中的节点的所有控制平面流量现在都在区域之间发送。 在每个区域中运行多个控制平面主机能降低出现这种结果的可能性。

#### etcd 存储

为了提高大规模集群的性能，你可以将事件对象存储在单独的专用 etcd 实例中。

在创建集群时，你可以（使用自定义工具）：

*   启动并配置额外的 etcd 实例
*   配置 API 服务器，将它用于存储事件

#### 插件资源 

Kubernetes 资源限制 有助于最大程度地减少内存泄漏的影响以及 Pod 和容器可能对其他组件的其他方式的影响。 这些资源限制适用于插件资源， 就像它们适用于应用程序工作负载一样。

例如，你可以对日志组件设置 CPU 和内存限制

  `...   containers:   - name: fluentd-cloud-logging     image: fluent/fluentd-kubernetes-daemonset:v1     resources:       limits:         cpu: 100m         memory: 200Mi`

插件的默认限制通常基于从中小规模 Kubernetes 集群上运行每个插件的经验收集的数据。 插件在大规模集群上运行时，某些资源消耗常常比其默认限制更多。 如果在不调整这些值的情况下部署了大规模集群，则插件可能会不断被杀死，因为它们不断达到内存限制。 或者，插件可能会运行，但由于 CPU 时间片的限制而导致性能不佳。

为避免遇到集群插件资源问题，在创建大规模集群时，请考虑以下事项：

*   部分垂直扩展插件 —— 总有一个插件副本服务于整个集群或服务于整个故障区域。 对于这些附加组件，请在扩大集群时加大资源请求和资源限制。
*   许多水平扩展插件 —— 你可以通过运行更多的 Pod 来增加容量——但是在大规模集群下， 可能还需要稍微提高 CPU 或内存限制。 VerticalPodAutoscaler 可以在 recommender 模式下运行， 以提供有关请求和限制的建议数字。
*   一些插件在每个节点上运行一个副本，并由 DaemonSet 控制： 例如，节点级日志聚合器。与水平扩展插件的情况类似， 你可能还需要稍微提高 CPU 或内存限制。

###  2.3.  Kubernetes 校验节点设置
节点一致性测试 
--------

节点一致性测试 是一个容器化的测试框架，提供了针对节点的系统验证和功能测试。 测试验证节点是否满足 Kubernetes 的最低要求；通过测试的节点有资格加入 Kubernetes 集群。

该测试主要检测节点是否满足 Kubernetes 的最低要求，通过检测的节点有资格加入 Kubernetes 集群。

节点的前提条件 
--------

要运行节点一致性测试，节点必须满足与标准 Kubernetes 节点相同的前提条件。节点至少应安装以下守护程序：

*   容器运行时 (Docker)
*   Kubelet

运行节点一致性测试 
----------

要运行节点一致性测试，请执行以下步骤：

1.  得出 kubelet 的 ​`--kubeconfig`​ 的值；例如：​`--kubeconfig=/var/lib/kubelet/config.yaml`​。 由于测试框架启动了本地控制平面来测试 kubelet，因此使用 ​`http://localhost:8080`​ 作为API 服务器的 URL。 一些其他的 kubelet 命令行参数可能会被用到：

*   ​`--cloud-provider`​：如果使用 ​`--cloud-provider=gce`​，需要移除这个参数来运行测试。

3.  使用以下命令运行节点一致性测试：

`# $CONFIG_DIR 是你 Kubelet 的 pod manifest 路径。 # $LOG_DIR 是测试的输出路径。 sudo docker run -it --rm --privileged --net=host \   -v /:/rootfs -v $CONFIG_DIR:$CONFIG_DIR -v $LOG_DIR:/var/result \   k8s.gcr.io/node-test:0.2`

针对其他硬件体系结构运行节点一致性测试 
--------------------

Kubernetes 也为其他硬件体系结构的系统提供了节点一致性测试的 Docker 镜像：

架构

镜像

amd64

node-test-amd64

arm

node-test-arm

arm64

node-test-arm64

运行特定的测试 
--------

要运行特定测试，请使用你希望运行的测试的特定表达式覆盖环境变量 ​`FOCUS`​。

`sudo docker run -it --rm --privileged --net=host \   -v /:/rootfs:ro -v $CONFIG_DIR:$CONFIG_DIR -v $LOG_DIR:/var/result \   -e FOCUS=MirrorPod \ # Only run MirrorPod test   k8s.gcr.io/node-test:0.2`

要跳过特定的测试，请使用你希望跳过的测试的常规表达式覆盖环境变量 ​`SKIP`​。

`sudo docker run -it --rm --privileged --net=host \   -v /:/rootfs:ro -v $CONFIG_DIR:$CONFIG_DIR -v $LOG_DIR:/var/result \   -e SKIP=MirrorPod \ # 运行除 MirrorPod 测试外的所有一致性测试内容   k8s.gcr.io/node-test:0.2`

节点一致性测试是[节点端到端测试](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/e2e-node-tests.md)的容器化版本。

默认情况下，它会运行所有一致性测试。

理论上，只要合理地配置容器和挂载所需的卷，就可以运行任何的节点端到端测试用例。但是这里强烈建议只运行一致性测试，因为运行非一致性测试需要很多复杂的配置。

注意事项 
-----

*   测试会在节点上遗留一些 Docker 镜像，包括节点一致性测试本身的镜像和功能测试相关的镜像。
*   测试会在节点上遗留一些死的容器。这些容器是在功能测试的过程中创建的。

###  2.4.  Kubernetes PKI证书和要求
PKI 证书和要求
---------

Kubernetes 需要 PKI 证书才能进行基于 TLS 的身份验证。如果你是使用 kubeadm 安装的 Kubernetes， 则会自动生成集群所需的证书。你还可以生成自己的证书。 例如，不将私钥存储在 API 服务器上，可以让私钥更加安全。此页面说明了集群必需的证书。

集群是如何使用证书的 
-----------

Kubernetes 需要 PKI 才能执行以下操作：

*   Kubelet 的客户端证书，用于 API 服务器身份验证
*   Kubelet 服务端证书， 用于 API 服务器与 Kubelet 的会话
*   API 服务器端点的证书
*   集群管理员的客户端证书，用于 API 服务器身份认证
*   API 服务器的客户端证书，用于和 Kubelet 的会话
*   API 服务器的客户端证书，用于和 etcd 的会话
*   控制器管理器的客户端证书/kubeconfig，用于和 API 服务器的会话
*   调度器的客户端证书/kubeconfig，用于和 API 服务器的会话
*   前端代理 的客户端及服务端证书

> Note: 只有当你运行 kube-proxy 并要支持 扩展 API 服务器 时，才需要 ​`front-proxy`​ 证书  

etcd 还实现了双向 TLS 来对客户端和对其他对等节点进行身份验证。

证书存放的位置 
--------

假如通过 kubeadm 安装 Kubernetes，大多数证书都存储在 ​`/etc/kubernetes/pki`​。 本文档中的所有路径都是相对于该目录的，但用户账户证书除外，kubeadm 将其放在 ​`/etc/kubernetes`​ 中。

手动配置证书 
-------

如果你不想通过 kubeadm 生成这些必需的证书，你可以使用一个单一的根 CA 来创建这些证书或者直接提供所有证书。 

#### 单根 CA 

你可以创建一个单根 CA，由管理员控制器它。该根 CA 可以创建多个中间 CA，并将所有进一步的创建委托给 Kubernetes。

需要这些 CA：

路径

默认 CN

描述

ca.crt,key

kubernetes-ca

Kubernetes 通用 CA

etcd/ca.crt,key

etcd-ca

与 etcd 相关的所有功能

front-proxy-ca.crt,key

kubernetes-front-proxy-ca

用于 前端代理

上面的 CA 之外，还需要获取用于服务账户管理的密钥对，也就是 ​`sa.key`​ 和 ​`sa.pub`​。

下面的例子说明了上表中所示的 CA 密钥和证书文件。

`/etc/kubernetes/pki/ca.crt /etc/kubernetes/pki/ca.key /etc/kubernetes/pki/etcd/ca.crt /etc/kubernetes/pki/etcd/ca.key /etc/kubernetes/pki/front-proxy-ca.crt /etc/kubernetes/pki/front-proxy-ca.key`

#### 所有的证书 

如果你不想将 CA 的私钥拷贝至你的集群中，你也可以自己生成全部的证书。

需要这些证书：

默认 CN

父级 CA

O (位于 Subject 中)

类型

主机 (SAN)

kube-etcd

etcd-ca

server, client

`<hostname>`, `<Host_IP>`, `localhost`, `127.0.0.1`

kube-etcd-peer

etcd-ca

server, client

`<hostname>`, `<Host_IP>`, `localhost`, `127.0.0.1`

kube-etcd-healthcheck-client

etcd-ca

client

kube-apiserver-etcd-client

etcd-ca

system:masters

client

kube-apiserver

kubernetes-ca

server

`<hostname>`, `<Host_IP>`, `<advertise_IP>`, `[1]`

kube-apiserver-kubelet-client

kubernetes-ca

system:masters

client

front-proxy-client

kubernetes-front-proxy-ca

client

\[1\]: 用来连接到集群的不同 IP 或 DNS 名 （就像 kubeadm 为负载均衡所使用的固定 IP 或 DNS 名，​`kubernetes`​、​`kubernetes.default`​、​`kubernetes.default.svc`​、 ​`kubernetes.default.svc.cluster`​、​`kubernetes.default.svc.cluster.local`​）。

其中，​`kind` ​对应一种或多种类型的 [x509 密钥用途](https://pkg.go.dev/k8s.io/api/certificates/v1beta1 target=)：

kind

密钥用途

server

数字签名、密钥加密、服务端认证

client

数字签名、密钥加密、客户端认证

> Note:  
> 上面列出的 Hosts/SAN 是推荐的配置方式；如果需要特殊安装，则可以在所有服务器证书上添加其他 SAN。

> Note:  
> 对于 kubeadm 用户：  
> 
> *   不使用私钥，将证书复制到集群 CA 的方案，在 kubeadm 文档中将这种方案称为外部 CA。
> *   如果将以上列表与 kubeadm 生成的 PKI 进行比较，你会注意到，如果使用外部 etcd，则不会生成 ​`kube-etcd`​、​`kube-etcd-peer`​ 和 ​`kube-etcd-healthcheck-client`​ 证书。

#### 证书路径 

证书应放置在建议的路径中（以便 kubeadm 使用）。无论使用什么位置，都应使用给定的参数指定路径。

默认 CN

建议的密钥路径

建议的证书路径

命令

密钥参数

证书参数

etcd-ca

etcd/ca.key

etcd/ca.crt

kube-apiserver

\--etcd-cafile

kube-apiserver-etcd-client

apiserver-etcd-client.key

apiserver-etcd-client.crt

kube-apiserver

\--etcd-keyfile

\--etcd-certfile

kubernetes-ca

ca.key

ca.crt

kube-apiserver

\--client-ca-file

kubernetes-ca

ca.key

ca.crt

kube-controller-manager

\--cluster-signing-key-file

\--client-ca-file, --root-ca-file, --cluster-signing-cert-file

kube-apiserver

apiserver.key

apiserver.crt

kube-apiserver

\--tls-private-key-file

\--tls-cert-file

kube-apiserver-kubelet-client

apiserver-kubelet-client.key

apiserver-kubelet-client.crt

kube-apiserver

\--kubelet-client-key

\--kubelet-client-certificate

front-proxy-ca

front-proxy-ca.key

front-proxy-ca.crt

kube-apiserver

\--requestheader-client-ca-file

front-proxy-ca

front-proxy-ca.key

front-proxy-ca.crt

kube-controller-manager

\--requestheader-client-ca-file

front-proxy-client

front-proxy-client.key

front-proxy-client.crt

kube-apiserver

\--proxy-client-key-file

\--proxy-client-cert-file

etcd-ca

etcd/ca.key

etcd/ca.crt

etcd

\--trusted-ca-file, --peer-trusted-ca-file

kube-etcd

etcd/server.key

etcd/server.crt

etcd

\--key-file

\--cert-file

kube-etcd-peer

etcd/peer.key

etcd/peer.crt

etcd

\--peer-key-file

\--peer-cert-file

etcd-ca

etcd/ca.crt

etcdctl

\--cacert

kube-etcd-healthcheck-client

etcd/healthcheck-client.key

etcd/healthcheck-client.crt

etcdctl

\--key

\--cert

注意事项同样适用于服务帐户密钥对：

私钥路径

公钥路径

命令

参数

sa.key

kube-controller-manager

\--service-account-private-key-file

sa.pub

kube-apiserver

\--service-account-key-file

下面的例子展示了自行生成所有密钥和证书时所需要提供的文件路径。 这些路径基于前面的表格。

`/etc/kubernetes/pki/etcd/ca.key /etc/kubernetes/pki/etcd/ca.crt /etc/kubernetes/pki/apiserver-etcd-client.key /etc/kubernetes/pki/apiserver-etcd-client.crt /etc/kubernetes/pki/ca.key /etc/kubernetes/pki/ca.crt /etc/kubernetes/pki/apiserver.key /etc/kubernetes/pki/apiserver.crt /etc/kubernetes/pki/apiserver-kubelet-client.key /etc/kubernetes/pki/apiserver-kubelet-client.crt /etc/kubernetes/pki/front-proxy-ca.key /etc/kubernetes/pki/front-proxy-ca.crt /etc/kubernetes/pki/front-proxy-client.key /etc/kubernetes/pki/front-proxy-client.crt /etc/kubernetes/pki/etcd/server.key /etc/kubernetes/pki/etcd/server.crt /etc/kubernetes/pki/etcd/peer.key /etc/kubernetes/pki/etcd/peer.crt /etc/kubernetes/pki/etcd/healthcheck-client.key /etc/kubernetes/pki/etcd/healthcheck-client.crt /etc/kubernetes/pki/sa.key /etc/kubernetes/pki/sa.pub`

为用户帐户配置证书 
----------

你必须手动配置以下管理员帐户和服务帐户：

文件名

凭据名称

默认 CN

O (位于 Subject 中)

admin.conf

default-admin

kubernetes-admin

system:masters

kubelet.conf

default-auth

system:node:`<nodeName>` （参阅注释）

system:nodes

controller-manager.conf

default-controller-manager

system:kube-controller-manager

scheduler.conf

default-scheduler

system:kube-scheduler

> Note: ​`kubelet.conf`​ 中 ​`<nodeName>`​ 的值 必须 与 kubelet 向 apiserver 注册时提供的节点名称的值完全匹配。

1.  对于每个配置，请都使用给定的 CN 和 O 生成 x509 证书/密钥偶对。
2.  为每个配置运行下面的 ​`kubectl` ​命令：

`KUBECONFIG=<filename> kubectl config set-cluster default-cluster --server=https://<host ip>:6443 --certificate-authority <path-to-kubernetes-ca> --embed-certs KUBECONFIG=<filename> kubectl config set-credentials <credential-name> --client-key <path-to-key>.pem --client-certificate <path-to-cert>.pem --embed-certs KUBECONFIG=<filename> kubectl config set-context default-system --cluster default-cluster --user <credential-name> KUBECONFIG=<filename> kubectl config use-context default-system`

这些文件用途如下：

文件名

命令

说明

admin.conf

kubectl

配置集群的管理员

kubelet.conf

kubelet

集群中的每个节点都需要一份

controller-manager.conf

kube-controller-manager

必需添加到 `manifests/kube-controller-manager.yaml` 清单中

scheduler.conf

kube-scheduler

必需添加到 `manifests/kube-scheduler.yaml` 清单中

下面是前表中所列文件的完整路径。

`/etc/kubernetes/admin.conf /etc/kubernetes/kubelet.conf /etc/kubernetes/controller-manager.conf /etc/kubernetes/scheduler.conf`

###  2.5.  Kubernetes 强制实施Pod安全性标准
使用内置的 Pod 安全性准入控制器 
-------------------

FEATURE STATE: Kubernetes v1.23 \[beta\]

Pod 安全性准入控制器 尝试替换已被废弃的 PodSecurityPolicies。

#### 配置所有集群名字空间 

完全未经配置的名字空间应该被视为集群安全模型中的重大缺陷。 我们建议花一些时间来分析在每个名字空间中执行的负载的类型， 并通过引用 Pod 安全性标准来确定每个负载的合适级别。 未设置标签的名字空间应该视为尚未被评估。

针对所有名字空间中的所有负载都具有相同的安全性需求的场景， 我们提供了一个[示例](https://www.w3cschool.cn/kubernetes/kubernetes-pm913o6d.html) 用来展示如何批量应用 Pod 安全性标签。

#### 拥抱最小特权原则

在一个理想环境中，每个名字空间中的每个 Pod 都会满足 ​`restricted` ​策略的需求。 不过，这既不可能也不现实，某些负载会因为合理的原因而需要特权上的提升。

*   允许 ​`privileged` ​负载的名字空间需要建立并实施适当的访问控制机制。
*   对于运行在特权宽松的名字空间中的负载，需要维护其独特安全性需求的文档。 如果可能的话，要考虑如何进一步约束这些需求。

#### 采用多种模式的策略

Pod 安全性标准准入控制器的 ​`audit` ​和 ​`warn` ​模式（mode） 能够在不影响现有负载的前提下，让该控制器更方便地收集关于 Pod 的重要的安全信息。

针对所有名字空间启用这些模式是一种好的实践，将它们设置为你最终打算 ​`enforce` ​的 期望的 级别和版本。这一阶段中所生成的警告和审计注解信息可以帮助你到达这一状态。 如果你期望负载的作者能够作出变更以便适应期望的级别，可以启用 ​`warn` ​模式。 如果你希望使用审计日志了监控和驱动变更，以便负载能够适应期望的级别，可以启用 ​`audit` ​模式。

当你将 ​`enforce` ​模式设置为期望的取值时，这些模式在不同的场合下仍然是有用的：

*   通过将 ​`warn` ​设置为 ​`enforce` ​相同的级别，客户可以在尝试创建无法通过合法检查的 Pod （或者包含 Pod 模板的资源）时收到警告信息。这些信息会帮助于更新资源使其合规。
*   在将 ​`enforce` ​锁定到特定的非最新版本的名字空间中，将 ​`audit` ​和 ​`warn` ​模式设置为 ​`enforce` ​一样的级别而非 ​`latest` ​版本， 这样可以方便看到之前版本所允许但当前最佳实践中被禁止的设置。

第三方替代方案
-------

Kubernetes 生态系统中也有一些其他强制实施安全设置的替代方案处于开发状态中：

*   [Kubewarden](https://github.com/kubewarden)
*   [Kyverno](https://kyverno.io/policies/)
*   [OPA Gatekeeper](https://github.com/open-policy-agent/gatekeeper)

采用 内置的 方案（例如 PodSecurity 准入控制器）还是第三方工具， 这一决策完全取决于你自己的情况。在评估任何解决方案时，对供应链的信任都是至关重要的。 最终，使用前述方案中的 任何 一种都好过放任自流。

#  2.  Kubernetes 概述

##  1.  Kubernetes 简介
简介
--

Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。

Kubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。Kubernetes 建立在 [Google 在大规模运行生产工作负载方面拥有十几年的经验](https://research.google/pubs/pub43438/) 的基础上，结合了社区中最好的想法和实践。

时光回溯
----

让我们回顾一下为什么 Kubernetes 如此有用。

![](https://atts.w3cschool.cn/attachments/image/20220428/1651109065276234.jpg)  

### 传统部署时代：

早期，各个组织机构在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。

### 虚拟化部署时代：

作为解决方案，引入了虚拟化。虚拟化技术允许你在单个物理服务器的 CPU 上运行多个虚拟机（VM）。 虚拟化允许应用程序在 VM 之间隔离，并提供一定程度的安全，因为一个应用程序的信息 不能被另一应用程序随意访问。

虚拟化技术能够更好地利用物理服务器上的资源，并且因为可轻松地添加或更新应用程序 而可以实现更好的可伸缩性，降低硬件成本等等。

每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。

### 容器部署时代：

容器类似于 VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。

容器因具有许多优势而变得流行起来。下面列出的是容器的一些好处：

*   敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。
*   持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性），支持可靠且频繁的 容器镜像构建和部署。
*   关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像， 从而将应用程序与基础架构分离。
*   可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。
*   跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。
*   跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。
*   以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。
*   松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。
*   资源隔离：可预测的应用程序性能。
*   资源利用：高效率和高密度。

为什么需要 Kubernetes，它能做什么?
-----------------------

容器是打包和运行应用程序的好方式。在生产环境中，你需要管理运行应用程序的容器，并确保不会停机。 例如，如果一个容器发生故障，则需要启动另一个容器。如果系统处理此行为，会不会更容易？

这就是 Kubernetes 来解决这些问题的方法！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。

Kubernetes 为你提供：

*   服务发现和负载均衡
Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。

*   存储编排

Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。

*   自动部署和回滚
    

你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。

*   自动完成装箱计算
    

Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。

*   自我修复
    

Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。

*   密钥与配置管理
    

Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。

Kubernetes 不是什么
---------------

Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。 由于 Kubernetes 在容器级别而不是在硬件级别运行，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡、日志记录和监视。 但是，Kubernetes 不是单体系统，默认解决方案都是可选和可插拔的。 Kubernetes 提供了构建开发人员平台的基础，但是在重要的地方保留了用户的选择和灵活性。

Kubernetes：

*   不限制支持的应用程序类型。 Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。
*   不部署源代码，也不构建你的应用程序。 持续集成(CI)、交付和部署（CI/CD）工作流取决于组织的文化和偏好以及技术要求。
*   不提供应用程序级别的服务作为内置服务，例如中间件（例如，消息中间件）、 数据处理框架（例如，Spark）、数据库（例如，mysql）、缓存、集群存储系统 （例如，Ceph）。这样的组件可以在 Kubernetes 上运行，并且/或者可以由运行在 Kubernetes 上的应用程序通过可移植机制（例如， [开放服务代理](https://www.openservicebrokerapi.org/)）来访问。
*   不要求日志记录、监视或警报解决方案。 它提供了一些集成作为概念证明，并提供了收集和导出指标的机制。
*   不提供或不要求配置语言/系统（例如 jsonnet），它提供了声明性 API， 该声明性 API 可以由任意形式的声明性规范所构成。
*   不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。
*   此外，Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 相比之下，Kubernetes 包含一组独立的、可组合的控制过程， 这些过程连续地将当前状态驱动到所提供的所需状态。 如何从 A 到 C 的方式无关紧要，也不需要集中控制，这使得系统更易于使用 且功能更强大、系统更健壮、更为弹性和可扩展。

##  2.  Kubernetes 组件
组件
--

当你部署完 Kubernetes, 即拥有了一个完整的集群。

一个 Kubernetes 集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。

工作节点托管作为应用负载的组件的 Pod 。控制平面管理集群中的工作节点和 Pod 。 为集群提供故障转移和高可用性，这些控制平面一般跨多主机运行，集群跨多个节点运行。

本文档概述了交付正常运行的 Kubernetes 集群所需的各种组件。

![](https://atts.w3cschool.cn/attachments/image/20220428/1651110837317224.svg)  

控制平面组件（Control Plane Components）
--------------------------------

控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 ​`replicas` ​字段时，启动新的 pod）。

控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。 

### kube-apiserver

API 服务器是 Kubernetes 控制面的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。

Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。

### etcd

etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。

您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。

### kube-scheduler

控制平面组件，负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行。

调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。

### kube-controller-manager

运行控制器进程的控制平面组件。

从逻辑上讲，每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。

这些控制器包括:

*   节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应
*   任务控制器（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成
*   端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)
*   服务帐户和令牌控制器（Service Account & Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌

### cloud-controller-manager

云控制器管理器是指嵌入特定云的控制逻辑的 控制平面组件。 云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。

​`cloud-controller-manager`​ 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。

与 ​`kube-controller-manager`​ 类似，​`cloud-controller-manager`​ 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。

下面的控制器都包含对云平台驱动的依赖：

*   节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除
*   路由控制器（Route Controller）: 用于在底层云基础架构中设置路由
*   服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器

Node 组件 
--------

节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。

### kubelet

一个在集群中每个节点（node）上运行的代理。 它保证容器（containers）都 运行在 Pod 中。

kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。

### kube-proxy

kube-proxy 是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。

kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。

如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。

### 容器运行时（Container Runtime） 

容器运行环境是负责运行容器的软件。

Kubernetes 支持容器运行时，例如 Docker、 containerd、CRI-O 以及 [Kubernetes CRI (容器运行环境接口)](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md) 的其他任何实现。

插件（Addons） 
-----------

插件使用 Kubernetes 资源（DaemonSet、 Deployment等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 ​`kube-system`​ 命名空间。

下面描述众多插件中的几种。

### DNS 

尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该 有集群 DNS， 因为很多示例都需要 DNS 服务。

集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。

Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。

### Web 界面（仪表盘）

Dashboard 是 Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除。

### 容器资源监控

容器资源监控 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面。

### 集群层面日志

集群层面日志 机制负责将容器的日志数据 保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。

##  3.  Kubernetes API
API
---

Kubernetes 控制面 的核心是 API 服务器。 API 服务器负责提供 HTTP API，以供用户、集群中的不同部分和集群外部组件相互通信。

Kubernetes API 使你可以查询和操纵 Kubernetes API 中对象（例如：Pod、Namespace、ConfigMap 和 Event）的状态。

大部分操作都可以通过 kubectl 命令行接口或 类似 kubeadm 这类命令行工具来执行， 这些工具在背后也是调用 API。不过，你也可以使用 REST 调用来访问这些 API。

如果你正在编写程序来访问 Kubernetes API，可以考虑使用 客户端库之一。

OpenAPI 规范
----------

完整的 API 细节是用 [OpenAPI](https://www.openapis.org/) 来表述的。

### OpenAPI V2

Kubernetes API 服务器通过 ​`/openapi/v2`​ 端点提供聚合的 OpenAPI v2 规范。 你可以按照下表所给的请求头部，指定响应的格式：

头部

可选值

说明

`Accept-Encoding`

`gzip`

_不指定此头部也是可以的_

`Accept`

`application/com.github.proto-openapi.spec.v2@v1.0+protobuf`

_主要用于集群内部_

`application/json`

_默认值_

`*`

_提供_`application/json`

OpenAPI v2 查询请求的合法头部值

Kubernetes 为 API 实现了一种基于 Protobuf 的序列化格式，主要用于集群内部通信。 关于此格式的详细信息，可参考 [Kubernetes Protobuf 序列化](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md) 设计提案。每种模式对应的接口描述语言（IDL）位于定义 API 对象的 Go 包中。

### OpenAPI V3

FEATURE STATE: Kubernetes v1.23 \[alpha\]

Kubernetes v1.23 提供将其 API 以 OpenAPI v3 形式发布的初始支持；这一功能特性处于 Alpha 状态，默认被禁用。 你可以通过为 kube-apiserver 组件启用 ​`OpenAPIV3` ​特性门控来启用此 Alpha 特性。

特性被启用时，Kubernetes API 服务器会在端点 ​`/openapi/v3/apis/<group>/<version>`​ 提供按 Kubernetes 组版本聚合的 OpenAPI v3 规范。 请参阅下表了解可接受的请求头部。

头部

可选值

说明

`Accept-Encoding`

`gzip`

_不提供此头部也是可接受的_

`Accept`

`application/com.github.proto-openapi.spec.v3@v1.0+protobuf`

_主要用于集群内部使用_

`application/json`

_默认_

`*`

_以_ `application/json` 形式返回

发现端点 ​`/openapi/v3`​ 被提供用来查看可用的所有组、版本列表。 此列表仅返回 JSON。

API 变更 
-------

任何成功的系统都要随着新的使用案例的出现和现有案例的变化来成长和变化。 为此，Kubernetes 的功能特性设计考虑了让 Kubernetes API 能够持续变更和成长的因素。 Kubernetes 项目的目标是 不要 引发现有客户端的兼容性问题，并在一定的时期内 维持这种兼容性，以便其他项目有机会作出适应性变更。

一般而言，新的 API 资源和新的资源字段可以被频繁地添加进来。 删除资源或者字段则要遵从 API 废弃策略。

Kubernetes 对维护达到正式发布（GA）阶段的官方 API 的兼容性有着很强的承诺， 通常这一 API 版本为 v1。此外，Kubernetes 在可能的时候还会保持 Beta API 版本的兼容性：如果你采用了 Beta API，你可以继续在集群上使用该 API， 即使该功能特性已进入稳定期也是如此。

> Note:  
> 尽管 Kubernetes 也努力为 Alpha API 版本维护兼容性，在有些场合兼容性是无法做到的。 如果你使用了任何 Alpha API 版本，需要在升级集群时查看 Kubernetes 发布说明， 以防 API 的确发生变更。

API 扩展 
-------

有两种途径来扩展 Kubernetes API：

1.  你可以使用自定义资源 来以声明式方式定义 API 服务器如何提供你所选择的资源 API。
2.  你也可以选择实现自己的 聚合层 来扩展 Kubernetes API。

#  3.  Kubernetes 安装

##  1.  Kubernetes Linux安装
kubectl 版本和集群版本之间的差异必须在一个小版本号内。 例如：v1.23 版本的客户端能与 v1.22、 v1.23 和 v1.24 版本的控制面通信。 用最新兼容版的 kubectl 有助于避免不可预见的问题。

在 Linux 系统中安装 kubectl
---------------------

在 Linux 系统中安装 kubectl 有如下几种方法：

*   用 curl 在 Linux 系统中安装 kubectl
*   用原生包管理工具安装
*   用其他包管理工具安装

用 curl 在 Linux 系统中安装 kubectl 
-----------------------------

1、用以下命令下载最新发行版：  

`curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"`

> Note:  
> 如需下载某个指定的版本，请用指定版本号替换该命令的这一部分：​ `$(curl -L -s https://dl.k8s.io/release/stable.txt)。` ​  
> 例如，要在 Linux 中下载 v1.23.0 版本，请输入：  
> 
> `curl -LO https://dl.k8s.io/release/v1.23.0/bin/linux/amd64/kubectl`

2、验证该可执行文件（可选步骤）  

*   下载 kubectl 校验和文件：

`curl -LO "https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256"`

*   基于校验和文件，验证 kubectl 的可执行文件：

`echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check`

*   验证通过时，输出为：

`kubectl: OK`

*   验证失败时，sha256 将以非零值退出，并打印如下输出：

`kubectl: FAILED sha256sum: WARNING: 1 computed checksum did NOT match`

> 下载的 kubectl 与校验和文件版本必须相同。

3、安装 kubectl

`sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl`

> 即使你没有目标系统的 root 权限，仍然可以将 kubectl 安装到目录 ~/.local/bin 中：
> 
> `chmod +x kubectl mkdir -p ~/.local/bin mv ./kubectl ~/.local/bin/kubectl # 之后将 ~/.local/bin 附加（或前置）到 $PATH`

4、执行测试，以保障你安装的版本是最新的：

`kubectl version --client`

*   或者使用如下命令来查看版本的详细信息：

`kubectl version --client --output=yaml`

用原生包管理工具安装
----------

### Ubuntu、Debian 或 HypriotOS

1、更新 ​`apt` ​包索引，并安装使用 Kubernetes apt 仓库所需要的包：

`sudo apt-get update sudo apt-get install -y apt-transport-https ca-certificates curl`

2、下载 Google Cloud 公开签名秘钥：

`sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg`

3、添加 Kubernetes ​`apt` ​仓库：

`echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list`

4、更新 ​`apt` ​包索引，使之包含新的仓库并安装 kubectl：

`sudo apt-get update sudo apt-get install -y kubectl`

### 基于 Red Hat 的发行版

`cat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg EOF sudo yum install -y kubectl`

用其他包管理工具安装
----------

### Snap

如果你使用的 Ubuntu 或其他 Linux 发行版，内建支持 [snap](https://snapcraft.io/docs/installing-snapd) 包管理工具， 则可用 [snap](https://snapcraft.io/) 命令安装 kubectl。

`snap install kubectl --classic kubectl version --client`

### Homebrew

如果你使用 Linux 系统，并且装了 [Homebrew](https://docs.brew.sh/Homebrew-on-Linux) 包管理工具， 则可以使用这种方式安装 kubectl。

`brew install kubectl kubectl version --client`

验证 kubectl 配置 
--------------

为了让 kubectl 能发现并访问 Kubernetes 集群，你需要一个 kubeconfig 文件， 该文件在 [kube-up.sh](https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh) 创建集群时，或成功部署一个 Miniube 集群时，均会自动生成。 通常，kubectl 的配置信息存放于文件 ​`~/.kube/config`​ 中。

通过获取集群状态的方法，检查是否已恰当的配置了 kubectl：

`kubectl cluster-info`

如果返回一个 URL，则意味着 kubectl 成功的访问到了你的集群。

如果你看到如下所示的消息，则代表 kubectl 配置出了问题，或无法连接到 Kubernetes 集群。

`The connection to the server <server-name:port> was refused - did you specify the right host or port? （访问 <server-name:port> 被拒绝 - 你指定的主机和端口是否有误？）`

例如，如果你想在自己的笔记本上（本地）运行 Kubernetes 集群，你需要先安装一个 Minikube 这样的工具，然后再重新运行上面的命令。

如果命令 ​`kubectl cluster-info`​ 返回了 url，但你还不能访问集群，那可以用以下命令来检查配置是否妥当：

`kubectl cluster-info dump`

kubectl 的可选配置和插件
----------------

### 启用 shell 自动补全功能

kubectl 为 Bash、Zsh、Fish 和 PowerShell 提供自动补全功能，可以为你节省大量的输入。

下面是为 Bash、Fish 和 Zsh 设置自动补全功能的操作步骤。

### Bash

kubectl 的 Bash 补全脚本可以用命令 ​`kubectl completion bash`​ 生成。 在 shell 中导入（Sourcing）补全脚本，将启用 kubectl 自动补全功能。

然而，补全脚本依赖于工具 [bash-completion](https://github.com/scop/bash-completion)， 所以要先安装它（可以用命令 ​`type _init_completion`​ 检查 bash-completion 是否已安装）。

#### 安装 bash-completion

很多包管理工具均支持 bash-completion（参见[这里](https://github.com/scop/bash-completion target=)）。 可以通过 ​`apt-get install bash-completion`​ 或 ​`yum install bash-completion`​ 等命令来安装它。

上述命令将创建文件 ​`/usr/share/bash-completion/bash_completion`​，它是 bash-completion 的主脚本。 依据包管理工具的实际情况，你需要在 ​`~/.bashrc`​ 文件中手工导入此文件。

要查看结果，请重新加载你的 shell，并运行命令 ​`type _init_completion`​。 如果命令执行成功，则设置完成，否则将下面内容添加到文件 ​`~/.bashrc`​ 中：

`source /usr/share/bash-completion/bash_completion`

重新加载 shell，再输入命令 ​`type _init_completion`​ 来验证 bash-completion 的安装状态。

#### 启动 kubectl 自动补全功能 

你现在需要确保一点：kubectl 补全脚本已经导入（sourced）到 shell 会话中。 可以通过以下两种方法进行设置：

*   当前用户

`echo 'source <(kubectl completion bash)' >>~/.bashrc`

*   系统全局

`kubectl completion bash | sudo tee /etc/bash_completion.d/kubectl > /dev/null`

如果 kubectl 有关联的别名，你可以扩展 shell 补全来适配此别名：

`echo 'alias k=kubectl' >>~/.bashrc echo 'complete -F __start_kubectl k' >>~/.bashrc`

> bash-completion 负责导入 ​`/etc/bash_completion.d`​ 目录中的所有补全脚本。

两种方式的效果相同。重新加载 shell 后，kubectl 自动补全功能即可生效。

### Fish

kubectl 通过命令 ​`kubectl completion fish`​ 生成 Fish 自动补全脚本。 在 shell 中导入（Sourcing）该自动补全脚本，将启动 kubectl 自动补全功能。

为了在所有的 shell 会话中实现此功能，请将下面内容加入到文件 ​`~/.config/fish/config.fish`​ 中。

`kubectl completion fish | source`

重新加载 shell 后，kubectl 自动补全功能将立即生效。

### Zsh

kubectl 通过命令 ​`kubectl completion zsh`​ 生成 Zsh 自动补全脚本。 在 shell 中导入（Sourcing）该自动补全脚本，将启动 kubectl 自动补全功能。

为了在所有的 shell 会话中实现此功能，请将下面内容加入到文件 ​`~/.zshrc`​ 中。

`source <(kubectl completion zsh)`

如果你为 kubectl 定义了别名，kubectl 自动补全将自动使用它。

重新加载 shell 后，kubectl 自动补全功能将立即生效。

如果你收到 ​`2: command not found: compdef`​ 这样的错误提示，那请将下面内容添加到 ​`~/.zshrc`​ 文件的开头：

`autoload -Uz compinit compinit`

### 安装 kubectl convert 插件

一个 Kubernetes 命令行工具 ​`kubectl` ​的插件，允许你将清单在不同 API 版本间转换。 这对于将清单迁移到新的 Kubernetes 发行版上未被废弃的 API 版本时尤其有帮助。

1、用以下命令下载最新发行版：

`curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl-convert"`

2、验证该可执行文件（可选步骤）

*   下载 kubectl-convert 校验和文件：

`curl -LO "https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl-convert.sha256"`

*   基于校验和，验证 kubectl-convert 的可执行文件：

`echo "$(cat kubectl-convert.sha256) kubectl-convert" | sha256sum --check`

*   验证通过时，输出为：

`kubectl-convert: OK`

验证失败时，​`sha256` ​将以非零值退出，并打印输出类似于：

`kubectl-convert: FAILED sha256sum: WARNING: 1 computed checksum did NOT match`

> 下载相同版本的可执行文件和校验和。

3、安装 kubectl-convert

`sudo install -o root -g root -m 0755 kubectl-convert /usr/local/bin/kubectl-convert`

4、验证插件是否安装成功

`kubectl convert --help`

如果你没有看到任何错误就代表插件安装成功了。

##  2.  Kubernetes macOS安装
kubectl 版本和集群之间的差异必须在一个小版本号之内。 例如：v1.23 版本的客户端能与 v1.22、 v1.23 和 v1.24 版本的控制面通信。 用最新兼容版本的 kubectl 有助于避免不可预见的问题。

在 macOS 系统上安装 kubectl
---------------------

在 macOS 系统上安装 kubectl 有如下方法：

*   用 curl 在 macOS 系统上安装 kubectl
*   用 Homebrew 在 macOS 系统上安装
*   用 Macports 在 macOS 上安装
*   作为谷歌云 SDK 的一部分，在 macOS 上安装

用 curl 在 macOS 系统上安装 kubectl 
-----------------------------

1、下载最新的发行版：

*   Intel

   `curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/darwin/amd64/kubectl"`

*   Apple Silicon

   `curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/darwin/arm64/kubectl"`

> 如果需要下载某个指定的版本，用该指定版本号替换掉命令的这个部分：​`$(curl -L -s https://dl.k8s.io/release/stable.txt)`​。 例如：要为 Intel macOS 系统下载 v1.23.0 版本，则输入：
> 
> `curl -LO "https://dl.k8s.io/release/v1.23.0/bin/darwin/amd64/kubectl"`
> 
> 对于 Apple Silicon 版本的 macOS，输入：
> 
> `curl -LO "https://dl.k8s.io/release/v1.23.0/bin/darwin/arm64/kubectl"`

  

2、验证可执行文件（可选操作）

下载 kubectl 的校验和文件：

*   Intel

   `curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/darwin/amd64/kubectl.sha256"`

*   Apple Silicon

   `curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/darwin/arm64/kubectl.sha256"`

*   根据校验和文件，验证 kubectl：

`echo "$(cat kubectl.sha256)  kubectl" | shasum -a 256 --check`

*   验证通过时，输出如下：

`kubectl: OK`

*   验证失败时，​`shasum` ​将以非零值退出，并打印如下输出：

`kubectl: FAILED shasum: WARNING: 1 computed checksum did NOT match`

> 下载的 kubectl 与校验和文件版本要相同。

3、将 kubectl 置为可执行文件：

`chmod +x ./kubectl`

4、将可执行文件 kubectl 移动到系统可寻址路径 ​`PATH` ​内的一个位置：

`sudo mv ./kubectl /usr/local/bin/kubectl sudo chown root: /usr/local/bin/kubectl`

> 确保 ​`/usr/local/bin`​ 在你的 PATH 环境变量中。

5、测试一下，确保你安装的是最新的版本：

`kubectl version --client`

*   或者使用下面命令来查看版本的详细信息：

`kubectl version --client --output=yaml`

用 Homebrew 在 macOS 系统上安装
------------------------

如果你是 macOS 系统，且用的是 [Homebrew](https://brew.sh/) 包管理工具， 则可以用 Homebrew 安装 kubectl。

1、运行安装命令：

`brew install kubectl` 

*   或

`brew install kubernetes-cli`

2、测试一下，确保你安装的是最新的版本：

`kubectl version --client`

用 Macports 在 macOS 上安装
----------------------

如果你用的是 macOS，且用 [Macports](https://macports.org/) 包管理工具，则你可以用 Macports 安装kubectl。

1、运行安装命令：

`sudo port selfupdate sudo port install kubectl`

2、测试一下，确保你安装的是最新的版本：

`kubectl version --client`

验证 kubectl 配置
-------------

为了让 kubectl 能发现并访问 Kubernetes 集群，你需要一个 kubeconfig 文件， 该文件在 [kube-up.sh](https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh) 创建集群时，或成功部署一个 Miniube 集群时，均会自动生成。 通常，kubectl 的配置信息存放于文件 ​`~/.kube/config`​ 中。

通过获取集群状态的方法，检查是否已恰当的配置了 kubectl：

`kubectl cluster-info`

如果返回一个 URL，则意味着 kubectl 成功的访问到了你的集群。

如果你看到如下所示的消息，则代表 kubectl 配置出了问题，或无法连接到 Kubernetes 集群。

`The connection to the server <server-name:port> was refused - did you specify the right host or port? （访问 <server-name:port> 被拒绝 - 你指定的主机和端口是否有误？）`

例如，如果你想在自己的笔记本上（本地）运行 Kubernetes 集群，你需要先安装一个 Minikube 这样的工具，然后再重新运行上面的命令。

如果命令 ​`kubectl cluster-info`​ 返回了 url，但你还不能访问集群，那可以用以下命令来检查配置是否妥当：

`kubectl cluster-info dump`

可选的 kubectl 配置和插件
-----------------

### 启用 shell 自动补全功能

kubectl 为 Bash、Zsh、Fish 和 PowerShell 提供自动补全功能，可以为你节省大量的输入。

下面是为 Bash、Fish 和 Zsh 设置自动补全功能的操作步骤。

### Bash

kubectl 的 Bash 补全脚本可以通过 ​`kubectl completion bash`​ 命令生成。 在你的 shell 中导入（Sourcing）这个脚本即可启用补全功能。

此外，kubectl 补全脚本依赖于工具 [bash-completion](https://github.com/scop/bash-completion)， 所以你必须先安装它。

> **Warning**:  
> bash-completion 有两个版本：v1 和 v2。v1 对应 Bash3.2（也是 macOS 的默认安装版本），v2 对应 Bash 4.1+。 kubectl 的补全脚本**无法适配** bash-completion v1 和 Bash 3.2。 必须为它配备 **bash-completion v2** 和 **Bash 4.1+**。 有鉴于此，为了在 macOS 上使用 kubectl 补全功能，你必须要安装和使用 Bash 4.1+ ([说明](https://itnext.io/upgrading-bash-on-macos-7138bd1066ba?gi=9cba5d635a48))。 后续说明假定你用的是 Bash 4.1+（也就是 Bash 4.1 或更新的版本）

#### 升级 Bash

后续说明假定你已使用 Bash 4.1+。你可以运行以下命令检查 Bash 版本：

`echo $BASH_VERSION`

如果版本太旧，可以用 Homebrew 安装/升级：

`brew install bash`

重新加载 shell，并验证所需的版本已经生效：

`echo $BASH_VERSION $SHELL`

Homebrew 通常把它安装为 ​`/usr/local/bin/bash`​。

#### 安装 bash-completion 

> 如前所述，本说明假定你使用的 Bash 版本为 4.1+，这意味着你要安装 bash-completion v2 （不同于 Bash 3.2 和 bash-completion v1，kubectl 的补全功能在该场景下无法工作）。

你可以用命令 ​`type _init_completion`​ 测试 bash-completion v2 是否已经安装。 如未安装，用 Homebrew 来安装它：

`brew install bash-completion@2`

如命令的输出信息所显示的，将如下内容添加到文件 ​`~/.bash_profile`​ 中：

`export BASH_COMPLETION_COMPAT_DIR="/usr/local/etc/bash_completion.d" [[ -r "/usr/local/etc/profile.d/bash_completion.sh" ]] && . "/usr/local/etc/profile.d/bash_completion.sh"`

重新加载 shell，并用命令 ​`type _init_completion`​ 验证 bash-completion v2 已经恰当的安装。

#### 启用 kubectl 自动补全功能

你现在需要确保在所有的 shell 环境中均已导入（sourced） kubectl 的补全脚本， 有若干种方法可以实现这一点：

*   在文件 ​`~/.bash_profile`​ 中导入（Source）补全脚本：

`echo 'source <(kubectl completion bash)' >>~/.bash_profile`

*   将补全脚本添加到目录 ​`/usr/local/etc/bash_completion.d`​ 中：

`kubectl completion bash >/usr/local/etc/bash_completion.d/kubectl`

*   如果你为 kubectl 定义了别名，则可以扩展 shell 补全来兼容该别名：

`echo 'alias k=kubectl' >>~/.bash_profile echo 'complete -F __start_kubectl k' >>~/.bash_profile`

如果你是用 Homebrew 安装的 kubectl，则kubectl 补全脚本应该已经安装到目录 ​`/usr/local/etc/bash_completion.d/kubectl`​ 中了。这种情况下，你什么都不需要做。

> 用 Hommbrew 安装的 bash-completion v2 会初始化 目录 ​`BASH_COMPLETION_COMPAT_DIR`​ 中的所有文件，这就是后两种方法能正常工作的原因。

总之，重新加载 shell 之后，kubectl 补全功能将立即生效。

### Fish

kubectl 通过命令 ​`kubectl completion fish`​ 生成 Fish 自动补全脚本。 在 shell 中导入（Sourcing）该自动补全脚本，将启动 kubectl 自动补全功能。

为了在所有的 shell 会话中实现此功能，请将下面内容加入到文件 ​`~/.config/fish/config.fish`​ 中。

`kubectl completion fish | source`

重新加载 shell 后，kubectl 自动补全功能将立即生效。

### Zsh

kubectl 通过命令 ​`kubectl completion zsh`​ 生成 Zsh 自动补全脚本。 在 shell 中导入（Sourcing）该自动补全脚本，将启动 kubectl 自动补全功能。

为了在所有的 shell 会话中实现此功能，请将下面内容加入到文件 ​`~/.zshrc`​ 中。

`source <(kubectl completion zsh)`

如果你为 kubectl 定义了别名，kubectl 自动补全将自动使用它。

重新加载 shell 后，kubectl 自动补全功能将立即生效。

如果你收到 ​`2: command not found: compdef`​ 这样的错误提示，那请将下面内容添加到 ​`~/.zshrc`​ 文件的开头：

`autoload -Uz compinit compinit`

### 安装 kubectl convert 插件 

一个 Kubernetes 命令行工具 kubectl 的插件，允许你将清单在不同 API 版本间转换。 这对于将清单迁移到新的 Kubernetes 发行版上未被废弃的 API 版本时尤其有帮助。 更多信息请访问 迁移到非弃用 API

1、用以下命令下载最新发行版：

*   Intel

   `curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/darwin/amd64/kubectl-convert"`

*   Apple Silicon

   `curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/darwin/arm64/kubectl-convert"`

2、验证该可执行文件（可选步骤）

下载 kubectl-convert 校验和文件：

*   Intel

   `curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/darwin/amd64/kubectl-convert.sha256"`

*   Apple Silicon

   `curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/darwin/arm64/kubectl-convert.sha256"`

基于校验和，验证 kubectl-convert 的可执行文件：

`echo "$(cat kubectl-convert.sha256)  kubectl-convert" | shasum -a 256 --check`

验证通过时，输出为：

`kubectl-convert: OK`

验证失败时，​`sha256` ​将以非零值退出，并打印输出类似于：

`kubectl-convert: FAILED shasum: WARNING: 1 computed checksum did NOT match`

> 下载相同版本的可执行文件和校验和。

3、使 kubectl-convert 二进制文件可执行

`chmod +x ./kubectl-convert`

4、将 kubectl-convert 可执行文件移动到系统 PATH 环境变量中的一个位置。

`sudo mv ./kubectl-convert /usr/local/bin/kubectl-convert sudo chown root: /usr/local/bin/kubectl-convert`

> 确保你的 PATH 环境变量中存在 ​`/usr/local/bin`​

5、验证插件是否安装成功

`kubectl convert --help`

如果你没有看到任何错误就代表插件安装成功了。

##  3.  Kubernetes Windows安装
kubectl 版本和集群版本之间的差异必须在一个小版本号内。 例如：v1.23 版本的客户端能与 v1.22、 v1.23 和 v1.24 版本的控制面通信。 用最新兼容版的 kubectl 有助于避免不可预见的问题。

在 Windows 上安装 kubectl 
----------------------

在 Windows 系统中安装 kubectl 有如下几种方法：

*   用 curl 在 Windows 上安装 kubectl
*   在 Windows 上用 Chocolatey 或 Scoop 安装

用 curl 在 Windows 上安装 kubectl
----------------------------

1、下载 [最新发行版 v1.23.0](https://storage.googleapis.com/kubernetes-release/release/v1.23.0/bin/windows/amd64/kubectl.exe)。

如果你已安装了 ​`curl`​,也可以使用此命令：

`curl -LO "https://dl.k8s.io/release/v1.23.0/bin/windows/amd64/kubectl.exe"`

2、验证该可执行文件（可选步骤）

下载 ​`kubectl` ​校验和文件：

`curl -LO "https://dl.k8s.io/v1.23.0/bin/windows/amd64/kubectl.exe.sha256"`

基于校验和文件，验证 kubectl 的可执行文件：

*   在命令行环境中，手工对比 CertUtil 命令的输出与校验和文件：

`CertUtil -hashfile kubectl.exe SHA256 type kubectl.exe.sha256`

用 PowerShell 自动验证，用运算符 ​`-eq`​ 来直接取得 ​`True` ​或 ​`False` ​的结果：

`$($(CertUtil -hashfile .\kubectl.exe SHA256)[1] -replace " ", "") -eq $(type .\kubectl.exe.sha256)`

3、将 ​`kubectl` ​二进制文件夹追加或插入到你的 ​`PATH` ​环境变量中。

4、测试一下，确保此 ​`kubectl` ​的版本和期望版本一致：

`kubectl version --client`

或者使用下面命令来查看版本的详细信息：

`kubectl version --client --output=yaml`

> [Windows 版的 Docker Desktop](https://docs.docker.com/desktop/windows/) 将其自带版本的 ​`kubectl` ​添加到 ​`PATH`​。 如果你之前安装过 Docker Desktop，可能需要把此 ​`PATH` ​条目置于 Docker Desktop 安装的条目之前， 或者直接删掉 Docker Desktop 的 ​`kubectl`​。

在 Windows 上用 Chocolatey 或 Scoop 安装
----------------------------------

1、要在 Windows 上安装 kubectl，你可以使用包管理器 [Chocolatey](https://chocolatey.org/) 或是命令行安装器 [Scoop](https://scoop.sh/)。

*   choco

`choco install kubernetes-cli`

*   scoop

`scoop install kubectl`

2、测试一下，确保安装的是最新版本：

`kubectl version --client`

3、导航到你的 home 目录：

`# 当你用 cmd.exe 时，则运行： cd %USERPROFILE% cd ~`

4、创建目录 ​`.kube`​：

`mkdir .kube`

5、切换到新创建的目录 ​`.kube` ​

`cd .kube`

6、配置 kubectl，以接入远程的 Kubernetes 集群：

`New-Item config -type file`

> 编辑配置文件，你需要先选择一个文本编辑器，比如 Notepad。

验证 kubectl 配置
-------------

为了让 kubectl 能发现并访问 Kubernetes 集群，你需要一个 kubeconfig 文件， 该文件在 [kube-up.sh](https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh) 创建集群时，或成功部署一个 Miniube 集群时，均会自动生成。 通常，kubectl 的配置信息存放于文件 ​`~/.kube/config`​ 中。

通过获取集群状态的方法，检查是否已恰当的配置了 kubectl：

`kubectl cluster-info`

如果返回一个 URL，则意味着 kubectl 成功的访问到了你的集群。

如果你看到如下所示的消息，则代表 kubectl 配置出了问题，或无法连接到 Kubernetes 集群。

`The connection to the server <server-name:port> was refused - did you specify the right host or port? （访问 <server-name:port> 被拒绝 - 你指定的主机和端口是否有误？）`

例如，如果你想在自己的笔记本上（本地）运行 Kubernetes 集群，你需要先安装一个 Minikube 这样的工具，然后再重新运行上面的命令。

如果命令 ​`kubectl cluster-info`​ 返回了 url，但你还不能访问集群，那可以用以下命令来检查配置是否妥当：

`kubectl cluster-info dump`

kubectl 可选配置和插件
---------------

### 启用 shell 自动补全功能

kubectl 为 Bash、Zsh、Fish 和 PowerShell 提供自动补全功能，可以为你节省大量的输入。

下面是设置 PowerShell 自动补全功能的操作步骤。

使用命令 ​`kubectl completion powershell`​ 生成 PowerShell 的 kubectl 自动补全脚本。

如果需要自动补全在所有 shell 会话中生效，请将以下命令添加到 ​`$PROFILE`​ 文件中：

`kubectl completion powershell | Out-String | Invoke-Expression`

此命令将在每次 PowerShell 启动时重新生成自动补全脚本。你还可以将生成的自动补全脚本添加到 ​`$PROFILE`​ 文件中。

如果需要将自动补全脚本直接添加到 ​`$PROFILE`​ 文件中，请在 PowerShell 终端运行以下命令：

`kubectl completion powershell >> $PROFILE`

完成上述操作后重启 shell，kubectl的自动补全就可以工作了。

### 安装 kubectl convert 插件

一个 Kubernetes 命令行工具 ​`kubectl` ​的插件，允许你将清单在不同 API 版本间转换。 这对于将清单迁移到新的 Kubernetes 发行版上未被废弃的 API 版本时尤其有帮助。

1、用以下命令下载最新发行版：

`curl -LO "https://dl.k8s.io/release/v1.23.0/bin/windows/amd64/kubectl-convert.exe"`

2、验证该可执行文件（可选步骤）

下载 ​`kubectl-convert`​ 校验和文件：

`curl -LO "https://dl.k8s.io/v1.23.0/bin/windows/amd64/kubectl-convert.exe.sha256"`

基于校验和，验证 ​`kubectl-convert`​ 的可执行文件：

*   用提示的命令对 ​`CertUtil` ​的输出和下载的校验和文件进行手动比较。

`CertUtil -hashfile kubectl-convert.exe SHA256 type kubectl-convert.exe.sha256`

*   使用 PowerShell ​`-eq`​ 操作使验证自动化，获得 ​`True` ​或者 ​`False` ​的结果：

`$($(CertUtil -hashfile .\kubectl-convert.exe SHA256)[1] -replace " ", "") -eq $(type .\kubectl-convert.exe.sha256)`

3、将 kubectl-convert 二进制文件夹附加或添加到你的 PATH 环境变量中。

4、验证插件是否安装成功

`kubectl convert --help`

如果你没有看到任何错误就代表插件安装成功了。

#  4.  Kubernetes 对象

##  1.  Kubernetes 对象简介
本页说明了 Kubernetes 对象在 Kubernetes API 中是如何表示的，以及如何在 ​`.yaml`​ 格式的文件中表示。

理解 Kubernetes 对象
----------------

在 Kubernetes 系统中，Kubernetes 对象 是持久化的实体。 Kubernetes 使用这些实体去表示整个集群的状态。特别地，它们描述了如下信息：

*   哪些容器化应用在运行（以及在哪些节点上）
*   可以被应用使用的资源
*   关于应用运行时表现的策略，比如重启策略、升级策略，以及容错策略

Kubernetes 对象是 “目标性记录” —— 一旦创建对象，Kubernetes 系统将持续工作以确保对象存在。 通过创建对象，本质上是在告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的， 这就是 Kubernetes 集群的 期望状态（Desired State）。

操作 Kubernetes 对象 —— 无论是创建、修改，或者删除 —— 需要使用 Kubernetes API。 比如，当使用 kubectl 命令行接口时，CLI 会执行必要的 Kubernetes API 调用， 也可以在程序中使用 客户端库直接调用 Kubernetes API。

对象规约（Spec）与状态（Status） 
----------------------

几乎每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置： 对象 ​`spec`​（规约） 和 对象 ​`status`​（状态） 。 对于具有 ​`spec` ​的对象，你必须在创建对象时设置其内容，描述你希望对象所具有的特征： 期望状态（Desired State） 。

​`status` ​描述了对象的 当前状态（Current State），它是由 Kubernetes 系统和组件 设置并更新的。在任何时刻，Kubernetes 控制平面 都一直积极地管理着对象的实际状态，以使之与期望状态相匹配。

例如，Kubernetes 中的 Deployment 对象能够表示运行在集群中的应用。 当创建 Deployment 时，可能需要设置 Deployment 的 ​`spec`​，以指定该应用需要有 3 个副本运行。 Kubernetes 系统读取 Deployment 规约，并启动我们所期望的应用的 3 个实例 —— 更新状态以与规约相匹配。 如果这些实例中有的失败了（一种状态变更），Kubernetes 系统通过执行修正操作 来响应规约和状态间的不一致 —— 在这里意味着它会启动一个新的实例来替换。

关于对象 spec、status 和 metadata 的更多信息，可参阅 [Kubernetes API 约定](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md)。

描述 Kubernetes 对象
----------------

创建 Kubernetes 对象时，必须提供对象的规约，用来描述该对象的期望状态， 以及关于对象的一些基本信息（例如名称）。 当使用 Kubernetes API 创建对象时（或者直接创建，或者基于​`kubectl`​）， API 请求必须在请求体中包含 JSON 格式的信息。 大多数情况下，需要在 ​`.yaml`​ 文件中为 ​`kubectl` ​提供这些信息。 ​`kubectl` ​在发起 API 请求时，将这些信息转换成 JSON 格式。

这里有一个 ​`.yaml`​ 示例文件，展示了 Kubernetes Deployment 的必需字段和对象规约：

`apiVersion: apps/v1 kind: Deployment metadata:   name: nginx-deployment spec:   selector:     matchLabels:       app: nginx   replicas: 2 # tells deployment to run 2 pods matching the template   template:     metadata:       labels:         app: nginx     spec:       containers:       - name: nginx         image: nginx:1.14.2         ports:         - containerPort: 80`

使用类似于上面的 ​`.yaml`​ 文件来创建 Deployment的一种方式是使用 ​`kubectl` ​命令行接口（CLI）中的 [kubectl apply](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=) 命令， 将 ​`.yaml`​ 文件作为参数。下面是一个示例：

`kubectl apply -f https://k8s.io/examples/application/deployment.yaml`

输出类似如下这样：

`deployment.apps/nginx-deployment created`

必需字段 
-----

在想要创建的 Kubernetes 对象对应的 ​`.yaml`​ 文件中，需要配置如下的字段：

*   ​`apiVersion` ​- 创建该对象所使用的 Kubernetes API 的版本
*   ​`kind` ​- 想要创建的对象的类别
*   ​`metadata` ​- 帮助唯一性标识对象的一些数据，包括一个 name 字符串、UID 和可选的 namespace
*   ​`spec` ​- 你所期望的该对象的状态

对象 ​`spec` ​的精确格式对每个 Kubernetes 对象来说是不同的，包含了特定于该对象的嵌套字段。

例如，参阅 Pod API 参考文档中 ​`spec`​ 字段。 对于每个 Pod，其 ​`.spec`​ 字段设置了 Pod 及其期望状态（例如 Pod 中每个容器的容器镜像名称）。 另一个对象规约的例子是 StatefulSet API 中的 ​`spec` ​字段。 对于 StatefulSet 而言，其 ​`.spec`​ 字段设置了 StatefulSet 及其期望状态。 在 StatefulSet 的 ​`.spec`​ 内，有一个为 Pod 对象提供的模板。该模板描述了 StatefulSet 控制器为了满足 StatefulSet 规约而要创建的 Pod。 不同类型的对象可以由不同的 ​`.status`​ 信息。API 参考页面给出了 ​`.status`​ 字段的详细结构， 以及针对不同类型 API 对象的具体内容。

##  2.  Kubernetes 对象管理
对象管理
----

​`kubectl` ​命令行工具支持多种不同的方式来创建和管理 Kubernetes 对象。 本文档概述了不同的方法。 阅读 [Kubectl book](https://kubectl.docs.kubernetes.io/) 来了解 kubectl 管理对象的详细信息。

管理技巧
----

> 应该只使用一种技术来管理 Kubernetes 对象。混合和匹配技术作用在同一对象上将导致未定义行为。

管理技术

作用于

建议的环境

支持的写者

学习难度

指令式命令

活跃对象

开发项目

1+

最低

指令式对象配置

单个文件

生产项目

1

中等

声明式对象配置

文件目录

生产项目

1+

最高

指令式命令
-----

使用指令式命令时，用户可以在集群中的活动对象上进行操作。用户将操作传给 ​`kubectl` ​命令作为参数或标志。

这是开始或者在集群中运行一次性任务的推荐方法。因为这个技术直接在活跃对象 上操作，所以它不提供以前配置的历史记录。

### 例子

通过创建 Deployment 对象来运行 nginx 容器的实例：

`kubectl create deployment nginx --image nginx`

### 权衡 

与对象配置相比的优点：

*   命令简单，易学且易于记忆。
*   命令仅需一步即可对集群进行更改。

与对象配置相比的缺点：

*   命令不与变更审查流程集成。
*   命令不提供与更改关联的审核跟踪。
*   除了实时内容外，命令不提供记录源。
*   命令不提供用于创建新对象的模板。

指令式对象配置
-------

在指令式对象配置中，kubectl 命令指定操作（创建，替换等），可选标志和 至少一个文件名。指定的文件必须包含 YAML 或 JSON 格式的对象的完整定义。

有关对象定义的详细信息，请查看 [API 参考](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/)。

> **Warning**:
> 
> ​`replace` ​指令式命令将现有规范替换为新提供的规范，并放弃对配置文件中 缺少的对象的所有更改。此方法不应与对象规约被独立于配置文件进行更新的 资源类型一起使用。比如类型为 ​`LoadBalancer` ​的服务，它的 ​`externalIPs` ​字段就是独立于集群配置进行更新。

### 例子

创建配置文件中定义的对象：

`kubectl create -f nginx.yaml`

删除两个配置文件中定义的对象：

`kubectl delete -f nginx.yaml -f redis.yaml`

通过覆盖活动配置来更新配置文件中定义的对象：

`kubectl replace -f nginx.yaml`

### 权衡

与指令式命令相比的优点：

*   对象配置可以存储在源控制系统中，比如 Git。
*   对象配置可以与流程集成，例如在推送和审计之前检查更新。
*   对象配置提供了用于创建新对象的模板。

与指令式命令相比的缺点：

*   对象配置需要对对象架构有基本的了解。
*   对象配置需要额外的步骤来编写 YAML 文件。

与声明式对象配置相比的优点：

*   指令式对象配置行为更加简单易懂。
*   从 Kubernetes 1.5 版本开始，指令对象配置更加成熟。

与声明式对象配置相比的缺点：

*   指令式对象配置更适合文件，而非目录。
*   对活动对象的更新必须反映在配置文件中，否则会在下一次替换时丢失。

声明式对象配置 
--------

使用声明式对象配置时，用户对本地存储的对象配置文件进行操作，但是用户 未定义要对该文件执行的操作。 ​`kubectl` ​会自动检测每个文件的创建、更新和删除操作。 这使得配置可以在目录上工作，根据目录中配置文件对不同的对象执行不同的操作。

> 声明式对象配置保留其他编写者所做的修改，即使这些更改并未合并到对象配置文件中。 可以通过使用 ​`patch` ​API 操作仅写入观察到的差异，而不是使用 ​`replace` ​API 操作来替换整个对象配置来实现。

### 例子

处理 ​`configs` ​目录中的所有对象配置文件，创建并更新活跃对象。 可以首先使用 ​`diff` ​子命令查看将要进行的更改，然后在进行应用：

`kubectl diff -f configs/ kubectl apply -f configs/`

递归处理目录：

`kubectl diff -R -f configs/ kubectl apply -R -f configs/`

### 权衡

与指令式对象配置相比的优点：

*   对活动对象所做的更改即使未合并到配置文件中，也会被保留下来。
*   声明性对象配置更好地支持对目录进行操作并自动检测每个文件的操作类型（创建，修补，删除）。

与指令式对象配置相比的缺点：

*   声明式对象配置难于调试并且出现异常时结果难以理解。
*   使用 diff 产生的部分更新会创建复杂的合并和补丁操作。

##  3.  Kubernetes 对象名称和IDs
对象名称和 IDs
---------

集群中的每一个对象都有一个名称 来标识在同类资源中的唯一性。

每个 Kubernetes 对象也有一个UID 来标识在整个集群中的唯一性。

比如，在同一个名字空间 中有一个名为 ​`myapp-1234`​ 的 Pod, 但是可以命名一个 Pod 和一个 Deployment 同为 ​`myapp-1234`​.

对于用户提供的非唯一性的属性，Kubernetes 提供了 标签（Labels）和 注解（Annotation）机制。

名称 
---

客户端提供的字符串，引用资源 url 中的对象，如​`/api/v1/pods/some name`​。

某一时刻，只能有一个给定类型的对象具有给定的名称。但是，如果删除该对象，则可以创建同名的新对象。

> 当对象所代表的是一个物理实体（例如代表一台物理主机的 Node）时， 如果在 Node 对象未被删除并重建的条件下，重新创建了同名的物理主机， 则 Kubernetes 会将新的主机看作是老的主机，这可能会带来某种不一致性。

以下是比较常见的四种资源命名约束。

### DNS 子域名 

很多资源类型需要可以用作 DNS 子域名的名称。 DNS 子域名的定义可参见 [RFC 1123](https://datatracker.ietf.org/doc/html/rfc1123)。 这一要求意味着名称必须满足如下规则：

*   不能超过253个字符
*   只能包含小写字母、数字，以及'-' 和 '.'
*   须以字母数字开头
*   须以字母数字结尾

### RFC 1123 标签名 

某些资源类型需要其名称遵循 [RFC 1123](https://datatracker.ietf.org/doc/html/rfc1123) 所定义的 DNS 标签标准。也就是命名必须满足如下规则：

*   最多 63 个字符
*   只能包含小写字母、数字，以及 '-'
*   须以字母数字开头
*   须以字母数字结尾

### RFC 1035 标签名 

某些资源类型需要其名称遵循 [RFC 1035](https://tools.ietf.org/html/rfc1035) 所定义的 DNS 标签标准。也就是命名必须满足如下规则：

*   最多 63 个字符
*   只能包含小写字母、数字，以及 '-'
*   须以字母开头
*   须以字母数字结尾

### 路径分段名称 

某些资源类型要求名称能被安全地用作路径中的片段。 换句话说，其名称不能是 ​`.`​、​`..`​，也不可以包含 ​`/`​ 或 ​`%`​ 这些字符。

下面是一个名为​`nginx-demo`​的 Pod 的配置清单：

`apiVersion: v1 kind: Pod metadata:   name: nginx-demo spec:   containers:   - name: nginx     image: nginx:1.14.2     ports:     - containerPort: 80`

> 某些资源类型可能具有额外的命名约束。

UIDs
----

Kubernetes 系统生成的字符串，唯一标识对象。

在 Kubernetes 集群的整个生命周期中创建的每个对象都有一个不同的 uid，它旨在区分类似实体的历史事件。

Kubernetes UIDs 是全局唯一标识符（也叫 UUIDs）。 UUIDs 是标准化的，见 ISO/IEC 9834-8 和 ITU-T X.667.

##  4.  Kubernetes 名字空间
名字空间
----

在 Kubernetes 中，“名字空间（Namespace）”提供一种机制，将同一集群中的资源划分为相互隔离的组。 同一名字空间内的资源名称要唯一，但跨名字空间时没有这个要求。 名字空间作用域仅针对带有名字空间的对象，例如 Deployment、Service 等， 这种作用域对集群访问的对象不适用，例如 StorageClass、Node、PersistentVolume 等。

何时使用多个名字空间
----------

名字空间适用于存在很多跨多个团队或项目的用户的场景。对于只有几到几十个用户的集群，根本不需要创建或考虑名字空间。当需要名称空间提供的功能时，请开始使用它们。

名字空间为名称提供了一个范围。资源的名称需要在名字空间内是唯一的，但不能跨名字空间。 名字空间不能相互嵌套，每个 Kubernetes 资源只能在一个名字空间中。

名字空间是在多个用户之间划分集群资源的一种方法（通过资源配额）。

不必使用多个名字空间来分隔仅仅轻微不同的资源，例如同一软件的不同版本： 应该使用标签 来区分同一名字空间中的不同资源。

使用名字空间
------

### 创建名字空间

> 避免使用前缀 ​`kube-`​ 创建名字空间，因为它是为 Kubernetes 系统名字空间保留的。

新建一个名为 my-namespace.yaml 的 YAML 文件，并写入下列内容：

`apiVersion: v1 kind: Namespace metadata:   name: <insert-namespace-name-here>`

然后运行：

`kubectl create -f ./my-namespace.yaml`

2、或者，你可以使用下面的命令创建名字空间：

`kubectl create namespace <insert-namespace-name-here>`

请注意，名字空间的名称必须是一个合法的 DNS 标签。

可选字段 finalizers 允许观察者们在名字空间被删除时清除资源。记住如果指定了一个不存在的终结器，名字空间仍会被创建，但如果用户试图删除它，它将陷入 Terminating 状态。

更多有关 finalizers 的信息请查阅 [设计文档](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/namespaces.md target=) 中名字空间部分。

### 删除名字空间 

删除名字空间使用命令：

`kubectl delete namespaces <insert-some-namespace-name>`

> **Warning**: 这会删除名字空间下的 所有内容 ！

删除是异步的，所以有一段时间你会看到名字空间处于 ​`Terminating` ​状态。

查看名字空间  

你可以使用以下命令列出集群中现存的名字空间：

`kubectl get namespace`

Kubernetes 会创建四个初始名字空间：

*   ​`default` ​没有指明使用其它名字空间的对象所使用的默认名字空间
*   ​`kube-system`​ Kubernetes 系统创建对象所使用的名字空间
*   ​`kube-public`​ 这个名字空间是自动创建的，所有用户（包括未经过身份验证的用户）都可以读取它。 这个名字空间主要用于集群使用，以防某些资源在整个集群中应该是可见和可读的。 这个名字空间的公共方面只是一种约定，而不是要求。
*   ​`kube-node-lease`​ 此名字空间用于与各个节点相关的 租约（Lease）对象。 节点租期允许 kubelet 发送心跳，由此控制面能够检测到节点故障。

### 为请求设置名字空间 

要为当前请求设置名字空间，请使用 ​`--namespace`​ 参数。

例如：

`kubectl run nginx --image=nginx --namespace=<名字空间名称> kubectl get pods --namespace=<名字空间名称>`

### 设置名字空间偏好 

你可以永久保存名字空间，以用于对应上下文中所有后续 kubectl 命令。

`kubectl config set-context --current --namespace=<名字空间名称> # 验证之 kubectl config view | grep namespace:`

名字空间和 DNS 
----------

当你创建一个服务 时， Kubernetes 会创建一个相应的 DNS 条目。

该条目的形式是 ​`<服务名称>.<名字空间名称>.svc.cluster.local`​，这意味着如果容器只使用 ​`<服务名称>`​，它将被解析到本地名字空间的服务。这对于跨多个名字空间（如开发、分级和生产） 使用相同的配置非常有用。如果你希望跨名字空间访问，则需要使用完全限定域名（FQDN）。

因此，所有的名字空间名称都必须是合法的 RFC 1123 DNS 标签。

> **Warning**:  
> 通过创建与[公共顶级域名](https://data.iana.org/TLD/tlds-alpha-by-domain.txt) 同名的名字空间，这些名字空间中的服务可以拥有与公共 DNS 记录重叠的、较短的 DNS 名称。 所有名字空间中的负载在执行 DNS 查找时，如果查找的名称没有 [尾部句点](https://datatracker.ietf.org/doc/html/rfc1034 target=)， 就会被重定向到这些服务上，因此呈现出比公共 DNS 更高的优先序。  
> 为了缓解这类问题，需要将创建名字空间的权限授予可信的用户。 如果需要，你可以额外部署第三方的安全控制机制，例如以 准入 Webhook 的形式，阻止用户创建与公共 [TLD](https://data.iana.org/TLD/tlds-alpha-by-domain.txt) 同名的名字空间。

并非所有对象都在名字空间中
-------------

大多数 kubernetes 资源（例如 Pod、Service、副本控制器等）都位于某些名字空间中。 但是名字空间资源本身并不在名字空间中。而且底层资源，例如 节点 和持久化卷不属于任何名字空间。

查看哪些 Kubernetes 资源在名字空间中，哪些不在名字空间中：

`# 位于名字空间中的资源 kubectl api-resources --namespaced=true  # 不在名字空间中的资源 kubectl api-resources --namespaced=false`

自动打标签 
------

FEATURE STATE: Kubernetes 1.21 \[beta\]

Kubernetes 控制面会为所有名字空间设置一个不可变更的 标签 ​`kubernetes.io/metadata.name`​，只要 ​`NamespaceDefaultLabelName`​ 这一 特性门控 被启用。标签的值是名字空间的名称。

##  5.  Kubernetes 标签和选择算符
标签和选择算符
-------

标签（Labels） 是附加到 Kubernetes 对象（比如 Pods）上的键值对。 标签旨在用于指定对用户有意义且相关的对象的标识属性，但不直接对核心系统有语义含义。 标签可以用于组织和选择对象的子集。标签可以在创建时附加到对象，随后可以随时添加和修改。 每个对象都可以定义一组键/值标签。每个键对于给定对象必须是唯一的。

`"metadata": {   "labels": {     "key1" : "value1",     "key2" : "value2"   } }`

标签能够支持高效的查询和监听操作，对于用户界面和命令行是很理想的。 应使用注解 记录非识别信息。

动机
--

标签使用户能够以松散耦合的方式将他们自己的组织结构映射到系统对象，而无需客户端存储这些映射。

服务部署和批处理流水线通常是多维实体（例如，多个分区或部署、多个发行序列、多个层，每层多个微服务）。 管理通常需要交叉操作，这打破了严格的层次表示的封装，特别是由基础设施而不是用户确定的严格的层次结构。

示例标签：

*   ​`"release" : "stable"`​, ​`"release" : "canary"` ​
*   ​`"environment" : "dev"`​, ​`"environment" : "qa"`​, ​`"environment" : "production"` ​
*   ​`"tier" : "frontend"`​, ​`"tier" : "backend"`​, ​`"tier" : "cache"` ​
*   ​`"partition" : "customerA"`​, ​`"partition" : "customerB"` ​
*   ​`"track" : "daily"`​, ​`"track" : "weekly"`​

有一些常用标签的例子; 你可以任意制定自己的约定。 请记住，标签的 Key 对于给定对象必须是唯一的。

语法和字符集 
-------

标签 是键值对。有效的标签键有两个段：可选的前缀和名称，用斜杠（​`/`​）分隔。 名称段是必需的，必须小于等于 63 个字符，以字母数字字符（​`[a-z0-9A-Z]`​）开头和结尾， 带有破折号（​`-`​），下划线（​`_`​），点（ ​`.`​）和之间的字母数字。 前缀是可选的。如果指定，前缀必须是 DNS 子域：由点（​`.`​）分隔的一系列 DNS 标签，总共不超过 253 个字符， 后跟斜杠（​`/`​）。

如果省略前缀，则假定标签键对用户是私有的。 向最终用户对象添加标签的自动系统组件（例如 ​`kube-scheduler`​、​`kube-controller-manager`​、 ​`kube-apiserver`​、​`kubectl`​ 或其他第三方自动化工具）必须指定前缀。

​`kubernetes.io/`​ 和 ​`k8s.io/`​ 前缀是为 Kubernetes 核心组件保留的。

有效标签值：

*   必须为 63 个字符或更少（可以为空）
*   除非标签值为空，必须以字母数字字符（​`[a-z0-9A-Z]`​）开头和结尾
*   包含破折号（​`-`​）、下划线（​`_`​）、点（​`.`​）和字母或数字。

标签选择算符 
-------

与名称和 UID 不同， 标签不支持唯一性。通常，我们希望许多对象携带相同的标签。

通过 标签选择算符，客户端/用户可以识别一组对象。标签选择算符是 Kubernetes 中的核心分组原语。

API 目前支持两种类型的选择算符：基于等值的 和 基于集合的。 标签选择算符可以由逗号分隔的多个 需求 组成。 在多个需求的情况下，必须满足所有要求，因此逗号分隔符充当逻辑 与（​`&&`​）运算符。

空标签选择算符或者未指定的选择算符的语义取决于上下文， 支持使用选择算符的 API 类别应该将算符的合法性和含义用文档记录下来。

> 对于某些 API 类别（例如 ReplicaSet）而言，两个实例的标签选择算符不得在命名空间内重叠， 否则它们的控制器将互相冲突，无法确定应该存在的副本个数。

> 对于基于等值的和基于集合的条件而言，不存在逻辑或（||）操作符。 你要确保你的过滤语句按合适的方式组织。

### 基于等值的需求

基于等值 或 基于不等值 的需求允许按标签键和值进行过滤。 匹配对象必须满足所有指定的标签约束，尽管它们也可能具有其他标签。 可接受的运算符有​`=`​、​`==`​ 和 ​`!=`​ 三种。 前两个表示 相等（并且只是同义词），而后者表示 不相等。例如：

`environment = production tier != frontend`

前者选择所有资源，其键名等于 ​`environment`​，值等于 ​`production`​。 后者选择所有资源，其键名等于 ​`tier`​，值不同于 ​`frontend`​，所有资源都没有带有 ​`tier` ​键的标签。 可以使用逗号运算符来过滤 ​`production` ​环境中的非 ​`frontend` ​层资源：​`environment=production,tier!=frontend`​。

基于等值的标签要求的一种使用场景是 Pod 要指定节点选择标准。 例如，下面的示例 Pod 选择带有标签 "​`accelerator=nvidia-tesla-p100`​"。

`apiVersion: v1 kind: Pod metadata:   name: cuda-test spec:   containers:     - name: cuda-test       image: "k8s.gcr.io/cuda-vector-add:v0.1"       resources:         limits:           nvidia.com/gpu: 1   nodeSelector:     accelerator: nvidia-tesla-p100`

### 基于集合的需求

基于集合 的标签需求允许你通过一组值来过滤键。 支持三种操作符：​`in`​、​`notin` ​和 ​`exists` ​(只可以用在键标识符上)。例如：

`environment in (production, qa) tier notin (frontend, backend) partition !partition`

*   第一个示例选择了所有键等于 ​`environment` ​并且值等于 ​`production` ​或者 ​`qa` ​的资源。
*   第二个示例选择了所有键等于 ​`tier` ​并且值不等于 ​`frontend` ​或者 ​`backend` ​的资源，以及所有没有 ​`tier` ​键标签的资源。
*   第三个示例选择了所有包含了有 ​`partition` ​标签的资源；没有校验它的值。
*   第四个示例选择了所有没有 ​`partition` ​标签的资源；没有校验它的值。

类似地，逗号分隔符充当 与 运算符。因此，使用 ​`partition` ​键（无论为何值）和 ​`environment` ​不同于 ​`qa`​ 来过滤资源可以使用 ​`partition, environment notin（qa)`​ 来实现。

基于集合 的标签选择算符是相等标签选择算符的一般形式，因为 ​`environment=production`​ 等同于 ​`environment in（production）`​；​`!=`​ 和 ​`notin` ​也是类似的。

基于集合 的要求可以与基于 相等 的要求混合使用。例如：​`partition in (customerA, customerB),environment!=qa`​。

API
---

### LIST 和 WATCH 过滤

LIST 和 WATCH 操作可以使用查询参数指定标签选择算符过滤一组对象。 两种需求都是允许的。（这里显示的是它们出现在 URL 查询字符串中）

*   基于等值 的需求: ​`?labelSelector=environment%3Dproduction,tier%3Dfrontend` ​
*   基于集合 的需求: ​`?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29`​

两种标签选择算符都可以通过 REST 客户端用于 list 或者 watch 资源。 例如，使用 ​`kubectl` ​定位 ​`apiserver`​，可以使用 基于等值 的标签选择算符可以这么写：

`kubectl get pods -l environment=production,tier=frontend`

或者使用 基于集合的 需求：

`kubectl get pods -l 'environment in (production),tier in (frontend)'`

正如刚才提到的，基于集合 的需求更具有表达力。例如，它们可以实现值的 或 操作：

`kubectl get pods -l 'environment in (production, qa)'`

或者通过 exists 运算符限制不匹配：

`kubectl get pods -l 'environment,environment notin (frontend)'`

### 在 API 对象中设置引用

一些 Kubernetes 对象，例如 ​`services` ​和 ​`replicationcontrollers` ​， 也使用了标签选择算符去指定了其他资源的集合，例如 pods。

#### Service 和 ReplicationController

一个 ​`Service` ​指向的一组 Pods 是由标签选择算符定义的。同样，一个 ​`ReplicationController` ​应该管理的 pods 的数量也是由标签选择算符定义的。

两个对象的标签选择算符都是在 ​`json` ​或者 ​`yaml` ​文件中使用映射定义的，并且只支持 基于等值 需求的选择算符：

`"selector": {     "component" : "redis", }`

或者

`selector:     component: redis`

这个选择算符(分别在 ​`json` ​或者 ​`yaml` ​格式中) 等价于 ​`component=redis`​ 或 ​`component in (redis)`​ 。

#### 支持基于集合需求的资源

比较新的资源，例如 ​`Job`​、 ​`Deployment`​、 ​`Replica Set`​ 和 ​`DaemonSet` ​， 也支持 基于集合的 需求。

`selector:   matchLabels:     component: redis   matchExpressions:     - {key: tier, operator: In, values: [cache]}     - {key: environment, operator: NotIn, values: [dev]}`

​`matchLabels`​ 是由 ​`{key,value}`​ 对组成的映射。 ​`matchLabels`​ 映射中的单个 ​`{key,value }`​ 等同于 ​`matchExpressions` ​的元素， 其 ​`key` ​字段为 "key"，​`operator` ​为 "In"，而 ​`values` ​数组仅包含 "value"。 ​`matchExpressions` ​是 Pod 选择算符需求的列表。 有效的运算符包括 ​`In`​、​`NotIn`​、​`Exists` ​和 ​`DoesNotExist`​。 在 ​`In` ​和 ​`NotIn` ​的情况下，设置的值必须是非空的。 来自 ​`matchLabels` ​和 ​`matchExpressions` ​的所有要求都按逻辑与的关系组合到一起 -- 它们必须都满足才能匹配。

#### 选择节点集 

通过标签进行选择的一个用例是确定节点集，方便 Pod 调度。

##  6.  Kubernetes 注解
注解
--

你可以使用 Kubernetes 注解为对象附加任意的非标识的元数据。客户端程序（例如工具和库）能够获取这些元数据信息。

为对象附加元数据
--------

你可以使用标签或注解将元数据附加到 Kubernetes 对象。 标签可以用来选择对象和查找满足某些条件的对象集合。 相反，注解不用于标识和选择对象。 注解中的元数据，可以很小，也可以很大，可以是结构化的，也可以是非结构化的，能够包含标签不允许的字符。

注解和标签一样，是键/值对:

`"metadata": {   "annotations": {     "key1" : "value1",     "key2" : "value2"   } }`

> Map 中的键和值必须是字符串。 换句话说，你不能使用数字、布尔值、列表或其他类型的键或值。

以下是一些例子，用来说明哪些信息可以使用注解来记录:

*   由声明性配置所管理的字段。 将这些字段附加为注解，能够将它们与客户端或服务端设置的默认值、 自动生成的字段以及通过自动调整大小或自动伸缩系统设置的字段区分开来。
*   构建、发布或镜像信息（如时间戳、发布 ID、Git 分支、PR 数量、镜像哈希、仓库地址）。
*   指向日志记录、监控、分析或审计仓库的指针。
*   可用于调试目的的客户端库或工具信息：例如，名称、版本和构建信息。
*   用户或者工具/系统的来源信息，例如来自其他生态系统组件的相关对象的 URL。
*   轻量级上线工具的元数据信息：例如，配置或检查点。
*   负责人员的电话或呼机号码，或指定在何处可以找到该信息的目录条目，如团队网站。
*   从用户到最终运行的指令，以修改行为或使用非标准功能。

你可以将这类信息存储在外部数据库或目录中而不使用注解， 但这样做就使得开发人员很难生成用于部署、管理、自检的客户端共享库和工具。

语法和字符集
------

注解（Annotations） 存储的形式是键/值对。有效的注解键分为两部分： 可选的前缀和名称，以斜杠（​`/`​）分隔。 名称段是必需项，并且必须在63个字符以内，以字母数字字符（​`[a-z0-9A-Z]`​）开头和结尾， 并允许使用破折号（​`-`​），下划线（​`_`​），点（​`.`​）和字母数字。 前缀是可选的。如果指定，则前缀必须是DNS子域：一系列由点（​`.`​）分隔的DNS标签， 总计不超过253个字符，后跟斜杠（​`/`​）。 如果省略前缀，则假定注解键对用户是私有的。 由系统组件添加的注解 （例如，​`kube-scheduler`​，​`kube-controller-manager`​，​`kube-apiserver`​，​`kubectl`​ 或其他第三方组件），必须为终端用户添加注解前缀。

​`kubernetes.io/`​ 和 ​`k8s.io/`​ 前缀是为Kubernetes核心组件保留的。

例如，下面是一个 Pod 的配置文件，其注解中包含 ​`imageregistry: https://hub.docker.com/`​：

`apiVersion: v1 kind: Pod metadata:   name: annotations-demo   annotations:     imageregistry: "https://hub.docker.com/" spec:   containers:   - name: nginx     image: nginx:1.7.9     ports:     - containerPort: 80`

##  7.  Kubernetes Finalizers
Finalizers
----------

Finalizer 是带有命名空间的键，告诉 Kubernetes 等到特定的条件被满足后， 再完全删除被标记为删除的资源。 Finalizer 提醒控制器清理被删除的对象拥有的资源。

当你告诉 Kubernetes 删除一个指定了 Finalizer 的对象时， Kubernetes API 通过填充 ​`.metadata.deletionTimestamp`​ 来标记要删除的对象， 并返回​`202`​状态码 (HTTP "已接受") 使其进入只读状态。 此时控制平面或其他组件会采取 Finalizer 所定义的行动， 而目标对象仍然处于终止中（Terminating）的状态。 这些行动完成后，控制器会删除目标对象相关的 Finalizer。 当 ​`metadata.finalizers`​ 字段为空时，Kubernetes 认为删除已完成。

你可以使用 Finalizer 控制资源的垃圾收集。 例如，你可以定义一个 Finalizer，在删除目标资源前清理相关资源或基础设施。

你可以通过使用 Finalizers 提醒控制器 在删除目标资源前执行特定的清理任务， 来控制资源的垃圾收集。

Finalizers 通常不指定要执行的代码。 相反，它们通常是特定资源上的键的列表，类似于注解。 Kubernetes 自动指定了一些 Finalizers，但你也可以指定你自己的。

Finalizers 如何工作 
----------------

当你使用清单文件创建资源时，你可以在 ​`metadata.finalizers`​ 字段指定 Finalizers。 当你试图删除该资源时，处理删除请求的 API 服务器会注意到 ​`finalizers`​ 字段中的值， 并进行以下操作：

*   修改对象，将你开始执行删除的时间添加到 ​`metadata.deletionTimestamp`​ 字段。
*   禁止对象被删除，直到其 ​`metadata.finalizers`​ 字段为空。
*   返回 ​`202`​ 状态码（HTTP "Accepted"）。

管理 finalizer 的控制器注意到对象上发生的更新操作，对象的 ​`metadata.deletionTimestamp`​ 被设置，意味着已经请求删除该对象。然后，控制器会试图满足资源的 Finalizers 的条件。 每当一个 Finalizer 的条件被满足时，控制器就会从资源的 ​`finalizers` ​字段中删除该键。 当 ​`finalizers` ​字段为空时，​`deletionTimestamp` ​字段被设置的对象会被自动删除。 你也可以使用 Finalizers 来阻止删除未被管理的资源。

一个常见的 Finalizer 的例子是 ​`kubernetes.io/pv-protection`​， 它用来防止意外删除 ​`PersistentVolume` ​对象。 当一个 ​`PersistentVolume` ​对象被 Pod 使用时， Kubernetes 会添加 ​`pv-protection`​ Finalizer。 如果你试图删除 ​`PersistentVolume`​，它将进入 ​`Terminating` ​状态， 但是控制器因为该 Finalizer 存在而无法删除该资源。 当 Pod 停止使用 ​`PersistentVolume` ​时， Kubernetes 清除 ​`pv-protection`​ Finalizer，控制器就会删除该卷。

属主引用、标签和 Finalizers
-------------------

与标签类似， 属主引用 描述了 Kubernetes 中对象之间的关系，但它们作用不同。 当一个控制器 管理类似于 Pod 的对象时，它使用标签来跟踪相关对象组的变化。 例如，当 Job 创建一个或多个 Pod 时， Job 控制器会给这些 Pod 应用上标签，并跟踪集群中的具有相同标签的 Pod 的变化。

Job 控制器还为这些 Pod 添加了属主引用，指向创建 Pod 的 Job。 如果你在这些 Pod 运行的时候删除了 Job， Kubernetes 会使用属主引用（而不是标签）来确定集群中哪些 Pod 需要清理。

当 Kubernetes 识别到要删除的资源上的属主引用时，它也会处理 Finalizers。

在某些情况下，Finalizers 会阻止依赖对象的删除， 这可能导致目标属主对象被保留的时间比预期的长，而没有被完全删除。 在这些情况下，你应该检查目标属主和附属对象上的 Finalizers 和属主引用，来排查原因。

> 在对象卡在删除状态的情况下，要避免手动移除 Finalizers，以允许继续删除操作。 Finalizers 通常因为特殊原因被添加到资源上，所以强行删除它们会导致集群出现问题。 只有了解 finalizer 的用途时才能这样做，并且应该通过一些其他方式来完成 （例如，手动清除其余的依赖对象）。

##  8.  Kubernetes 字段选择器
字段选择器
-----

“字段选择器（Field selectors）”允许你根据一个或多个资源字段的值 筛选 Kubernetes 资源。 下面是一些使用字段选择器查询的例子：

*   ​`metadata.name=my-service` ​
*   ​`metadata.namespace!=default` ​
*   ​`status.phase=Pending` ​

下面这个 ​`kubectl` ​命令将筛选出 ​`status.phase`​ 字段值为 ​`Running` ​的所有 Pod：

`kubectl get pods --field-selector status.phase=Running`

> 字段选择器本质上是资源过滤器（Filters）。默认情况下，字段选择器/过滤器是未被应用的， 这意味着指定类型的所有资源都会被筛选出来。 这使得以下的两个 ​kubectl ​查询是等价的：
> 
> `kubectl get pods kubectl get pods --field-selector ""`

支持的字段 
------

不同的 Kubernetes 资源类型支持不同的字段选择器。 所有资源类型都支持 ​`metadata.name`​ 和 ​`metadata.namespace`​ 字段。 使用不被支持的字段选择器会产生错误。例如：

`kubectl get ingress --field-selector foo.bar=baz`

`Error from server (BadRequest): Unable to find "ingresses" that match label selector "", field selector "foo.bar=baz": "foo.bar" is not a known field selector: only "metadata.name", "metadata.namespace"`

支持的操作符 
-------

你可在字段选择器中使用 ​`=`​、​`==`​和 ​`!=`​ （​`=`​ 和 ​`==`​ 的意义是相同的）操作符。 例如，下面这个 ​`kubectl`​ 命令将筛选所有不属于 ​`default` ​命名空间的 Kubernetes 服务：

`kubectl get services  --all-namespaces --field-selector metadata.namespace!=default`

链式选择器 
------

同标签和其他选择器一样， 字段选择器可以通过使用逗号分隔的列表组成一个选择链。 下面这个 ​`kubectl` ​命令将筛选 ​`status.phase`​ 字段不等于 ​`Running` ​同时 ​`spec.restartPolicy`​ 字段等于 ​`Always` ​的所有 Pod：

`kubectl get pods --field-selector=status.phase!=Running,spec.restartPolicy=Always`

多种资源类型 
-------

你能够跨多种资源类型来使用字段选择器。 下面这个 ​`kubectl` ​命令将筛选出所有不在 ​`default` ​命名空间中的 StatefulSet 和 Service：

`kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!=default`

##  9.  Kubernetes 属主与附属
属主与附属
-----

在 Kubernetes 中，一些对象是其他对象的属主（Owner）。 例如，ReplicaSet 是一组 Pod 的属主。 具有属主的对象是属主的附属（Dependent） 。

属主关系不同于一些资源使用的标签和选择算符机制。 例如，有一个创建 ​`EndpointSlice` ​对象的 Service， 该 Service 使用标签来让控制平面确定，哪些 ​`EndpointSlice` ​对象属于该 Service。 除开标签，每个代表 Service 所管理的 ​`EndpointSlice` ​都有一个属主引用。 属主引用避免 Kubernetes 的不同部分干扰到不受它们控制的对象。

对象规约中的属主引用 
-----------

附属对象有一个 ​`metadata.ownerReferences`​ 字段，用于引用其属主对象。 一个有效的属主引用，包含与附属对象同在一个命名空间下的对象名称和一个 UID。 Kubernetes 自动为一些对象的附属资源设置属主引用的值， 这些对象包含 ReplicaSet、DaemonSet、Deployment、Job、CronJob、ReplicationController 等。 你也可以通过改变这个字段的值，来手动配置这些关系。 然而，你通常不需要这么做，你可以让 Kubernetes 自动管理附属关系。

附属对象还有一个 ​`ownerReferences.blockOwnerDeletion`​ 字段，该字段使用布尔值， 用于控制特定的附属对象是否可以阻止垃圾收集删除其属主对象。 如果控制器（例如 Deployment 控制器） 设置了 ​`metadata.ownerReferences`​ 字段的值，Kubernetes 会自动设置 ​`blockOwnerDeletion` ​的值为 ​`true`​。 你也可以手动设置 ​`blockOwnerDeletion` ​字段的值，以控制哪些附属对象会阻止垃圾收集。

> 根据设计，kubernetes 不允许跨名字空间指定属主。 名字空间范围的附属可以指定集群范围的或者名字空间范围的属主。 名字空间范围的属主必须和该附属处于相同的名字空间。 如果名字空间范围的属主和附属不在相同的名字空间，那么该属主引用就会被认为是缺失的， 并且当附属的所有属主引用都被确认不再存在之后，该附属就会被删除。  
>   
> 集群范围的附属只能指定集群范围的属主。 在 v1.20+ 版本，如果一个集群范围的附属指定了一个名字空间范围类型的属主， 那么该附属就会被认为是拥有一个不可解析的属主引用，并且它不能够被垃圾回收。  
>   
> 在 v1.20+ 版本，如果垃圾收集器检测到无效的跨名字空间的属主引用， 或者一个集群范围的附属指定了一个名字空间范围类型的属主， 那么它就会报告一个警告事件。该事件的原因是 ​`OwnerRefInvalidNamespace`​， ​`involvedObject` ​属性中包含无效的附属。 你可以运行 ​`kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace`​ 来获取该类型的事件。

属主关系与 Finalizer 
----------------

当你告诉 Kubernetes 删除一个资源，API 服务器允许管理控制器处理该资源的任何 Finalizer 规则。 Finalizer 防止意外删除你的集群所依赖的、用于正常运作的资源。 例如，如果你试图删除一个仍被 Pod 使用的 ​`PersistentVolume`​，该资源不会被立即删除， 因为 ​`PersistentVolume` ​有 ​`kubernetes.io/pv-protection`​ Finalizer。 相反，它将进入 ​`Terminating` ​状态，直到 Kubernetes 清除这个 Finalizer， 而这种情况只会发生在 ​`PersistentVolume` ​不再被挂载到 Pod 上时。

当你使用前台或孤立级联删除时， Kubernetes 也会向属主资源添加 Finalizer。 在前台删除中，会添加 ​`foreground` ​Finalizer，这样控制器必须在删除了拥有 ​`ownerReferences.blockOwnerDeletion=true`​ 的附属资源后，才能删除属主对象。 如果你指定了孤立删除策略，Kubernetes 会添加 ​`orphan` ​Finalizer， 这样控制器在删除属主对象后，会忽略附属资源。

##  10.  Kubernetes 推荐使用的标签
推荐使用的标签
-------

除了 kubectl 和 dashboard 之外，您可以使用其他工具来可视化和管理 Kubernetes 对象。一组通用的标签可以让多个工具之间相互操作，用所有工具都能理解的通用方式描述对象。

除了支持工具外，推荐的标签还以一种可以查询的方式描述了应用程序。

元数据围绕 应用（application） 的概念进行组织。Kubernetes 不是 平台即服务（PaaS），没有或强制执行正式的应用程序概念。 相反，应用程序是非正式的，并使用元数据进行描述。应用程序包含的定义是松散的。

> 这些是推荐的标签。它们使管理应用程序变得更容易但不是任何核心工具所必需的。

共享标签和注解都使用同一个前缀：​`app.kubernetes.io`​。没有前缀的标签是用户私有的。共享前缀可以确保共享标签不会干扰用户自定义的标签。

标签
--

为了充分利用这些标签，应该在每个资源对象上都使用它们。

键

描述

示例

类型

`app.kubernetes.io/name`

应用程序的名称

`mysql`

字符串

`app.kubernetes.io/instance`

用于唯一确定应用实例的名称

`mysql-abcxzy`

字符串

`app.kubernetes.io/version`

应用程序的当前版本（例如，语义版本，修订版哈希等）

`5.7.21`

字符串

`app.kubernetes.io/component`

架构中的组件

`database`

字符串

`app.kubernetes.io/part-of`

此级别的更高级别应用程序的名称

`wordpress`

字符串

`app.kubernetes.io/managed-by`

用于管理应用程序的工具

`helm`

字符串

`app.kubernetes.io/created-by`

创建该资源的控制器或者用户

`controller-manager`

字符串

为说明这些标签的实际使用情况，请看下面的 StatefulSet 对象：

`# 这是一段节选 apiVersion: apps/v1 kind: StatefulSet metadata:   labels:     app.kubernetes.io/name: mysql     app.kubernetes.io/instance: mysql-abcxzy     app.kubernetes.io/version: "5.7.21"     app.kubernetes.io/component: database     app.kubernetes.io/part-of: wordpress     app.kubernetes.io/managed-by: helm     app.kubernetes.io/created-by: controller-manager`

应用和应用实例
-------

应用可以在 Kubernetes 集群中安装一次或多次。在某些情况下，可以安装在同一命名空间中。例如，可以不止一次地为不同的站点安装不同的 WordPress。

应用的名称和实例的名称是分别记录的。例如，WordPress 应用的 ​`app.kubernetes.io/name`​ 为 ​`wordpress`​，而其实例名称 ​`app.kubernetes.io/instance`​ 为 ​`wordpress-abcxzy`​。 这使得应用和应用的实例均可被识别，应用的每个实例都必须具有唯一的名称。

示例
--

为了说明使用这些标签的不同方式，以下示例具有不同的复杂性。

### 一个简单的无状态服务

考虑使用 ​`Deployment` ​和 ​`Service` ​对象部署的简单无状态服务的情况。以下两个代码段表示如何以最简单的形式使用标签。

下面的 ​`Deployment` ​用于监督运行应用本身的 pods。

`apiVersion: apps/v1 kind: Deployment metadata:   labels:     app.kubernetes.io/name: myservice     app.kubernetes.io/instance: myservice-abcxzy ...`

下面的 ​`Service` ​用于暴露应用。

`apiVersion: v1 kind: Service metadata:   labels:     app.kubernetes.io/name: myservice     app.kubernetes.io/instance: myservice-abcxzy ...`

### 带有一个数据库的 Web 应用程序

考虑一个稍微复杂的应用：一个使用 Helm 安装的 Web 应用（WordPress），其中 使用了数据库（MySQL）。以下代码片段说明用于部署此应用程序的对象的开始。

以下 ​`Deployment` ​的开头用于 WordPress：

`apiVersion: apps/v1 kind: Deployment metadata:   labels:     app.kubernetes.io/name: wordpress     app.kubernetes.io/instance: wordpress-abcxzy     app.kubernetes.io/version: "4.9.4"     app.kubernetes.io/managed-by: helm     app.kubernetes.io/component: server     app.kubernetes.io/part-of: wordpress ...`

这个 ​`Service` ​用于暴露 WordPress：

`apiVersion: v1 kind: Service metadata:   labels:     app.kubernetes.io/name: wordpress     app.kubernetes.io/instance: wordpress-abcxzy     app.kubernetes.io/version: "4.9.4"     app.kubernetes.io/managed-by: helm     app.kubernetes.io/component: server     app.kubernetes.io/part-of: wordpress ...`

MySQL 作为一个 ​`StatefulSet` ​暴露，包含它和它所属的较大应用程序的元数据：

`apiVersion: apps/v1 kind: StatefulSet metadata:   labels:     app.kubernetes.io/name: mysql     app.kubernetes.io/instance: mysql-abcxzy     app.kubernetes.io/version: "5.7.21"     app.kubernetes.io/managed-by: helm     app.kubernetes.io/component: database     app.kubernetes.io/part-of: wordpress ...`

​`Service` ​用于将 MySQL 作为 WordPress 的一部分暴露：

`apiVersion: v1 kind: Service metadata:   labels:     app.kubernetes.io/name: mysql     app.kubernetes.io/instance: mysql-abcxzy     app.kubernetes.io/version: "5.7.21"     app.kubernetes.io/managed-by: helm     app.kubernetes.io/component: database     app.kubernetes.io/part-of: wordpress ...`

使用 MySQL ​`StatefulSet` ​和 ​`Service`​，您会注意到有关 MySQL 和 Wordpress 的信息，包括更广泛的应用程序。

#  5.  Kubernetes 架构

##  1.  Kubernetes 节点
节点
--

Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的工作负载。 节点可以是一个虚拟机或者物理机器，取决于所在的集群配置。 每个节点包含运行 Pods 所需的服务； 这些节点由 控制面 负责管理。

通常集群中会有若干个节点；而在一个学习用或者资源受限的环境中，你的集群中也可能 只有一个节点。

节点上的组件包括 kubelet、 容器运行时以及 kube-proxy。

管理 
---

向 API 服务器添加节点的方式主要有两种：

1.  节点上的 ​`kubelet` ​向控制面执行自注册；
2.  你，或者别的什么人，手动添加一个 Node 对象。

在你创建了 Node 对象或者节点上的 ​`kubelet` ​执行了自注册操作之后，控制面会检查新的 Node 对象是否合法。 例如，如果你尝试使用下面的 JSON 对象来创建 Node 对象：

`{   "kind": "Node",   "apiVersion": "v1",   "metadata": {     "name": "10.240.79.157",     "labels": {       "name": "my-first-k8s-node"     }   } }`

Kubernetes 会在内部创建一个 Node 对象作为节点的表示。Kubernetes 检查 ​`kubelet` ​向 API 服务器注册节点时使用的 ​`metadata.name`​ 字段是否匹配。 如果节点是健康的（即所有必要的服务都在运行中），则该节点可以用来运行 Pod。 否则，直到该节点变为健康之前，所有的集群活动都会忽略该节点。

> Kubernetes 会一直保存着非法节点对应的对象，并持续检查该节点是否已经变得健康。 你，或者某个控制器必须显式地删除该 Node 对象以停止健康检查操作。

Node 对象的名称必须是合法的 DNS 子域名。

### 节点名称唯一性 

节点的名称用来标识 Node 对象。 没有两个 Node 可以同时使用相同的名称。 Kubernetes 还假定名字相同的资源是同一个对象。 就 Node 而言，隐式假定使用相同名称的实例会具有相同的状态（例如网络配置、根磁盘内容） 和类似节点标签这类属性。这可能在节点被更改但其名称未变时导致系统状态不一致。 如果某个 Node 需要被替换或者大量变更，需要从 API 服务器移除现有的 Node 对象， 之后再在更新之后重新将其加入。

### 节点自注册

当 kubelet 标志 ​`--register-node`​ 为 true（默认）时，它会尝试向 API 服务注册自己。 这是首选模式，被绝大多数发行版选用。

对于自注册模式，kubelet 使用下列参数启动：

*   ​`--kubeconfig`​ - 用于向 API 服务器执行身份认证所用的凭据的路径。
*   ​`--cloud-provider`​ - 与某云驱动 进行通信以读取与自身相关的元数据的方式。
*   ​`--register-node`​ - 自动向 API 服务注册。
*   ​`--register-with-taints`​ - 使用所给的污点列表 （逗号分隔的 ​`<key>=<value>:<effect>`​）注册节点。当 ​`register-node`​ 为 false 时无效。
*   ​`--node-ip`​ - 节点 IP 地址。
*   ​`--node-labels`​ - 在集群中注册节点时要添加的标签。
*   ​`--node-status-update-frequency`​ - 指定 kubelet 向控制面发送状态的频率。

启用Node 鉴权模式和 NodeRestriction 准入插件时， 仅授权 ​`kubelet` ​创建或修改其自己的节点资源。

> 正如节点名称唯一性一节所述，当 Node 的配置需要被更新时， 一种好的做法是重新向 API 服务器注册该节点。例如，如果 kubelet 重启时其 ​`--node-labels`​ 是新的值集，但同一个 Node 名称已经被使用，则所作变更不会起作用， 因为节点标签是在 Node 注册时完成的。  
>   
> 如果在 kubelet 重启期间 Node 配置发生了变化，已经被调度到某 Node 上的 Pod 可能会出现行为不正常或者出现其他问题，例如，已经运行的 Pod 可能通过污点机制设置了与 Node 上新设置的标签相排斥的规则，也有一些其他 Pod， 本来与此 Pod 之间存在不兼容的问题，也会因为新的标签设置而被调到到同一节点。 节点重新注册操作可以确保节点上所有 Pod 都被排空并被正确地重新调度。

### 手动节点管理 

你可以使用 kubectl 来创建和修改 Node 对象。

如果你希望手动创建节点对象时，请设置 kubelet 标志 ​`--register-node=false`​。

你可以修改 Node 对象（忽略 ​`--register-node`​ 设置）。 例如，修改节点上的标签或标记其为不可调度。

你可以结合使用 Node 上的标签和 Pod 上的选择算符来控制调度。 例如，你可以限制某 Pod 只能在符合要求的节点子集上运行。

如果标记节点为不可调度（unschedulable），将阻止新 Pod 调度到该 Node 之上， 但不会影响任何已经在其上的 Pod。 这是重启节点或者执行其他维护操作之前的一个有用的准备步骤。

要标记一个 Node 为不可调度，执行以下命令：

`kubectl cordon $NODENAME`

被 DaemonSet 控制器创建的 Pod 能够容忍节点的不可调度属性。 DaemonSet 通常提供节点本地的服务，即使节点上的负载应用已经被腾空， 这些服务也仍需运行在节点之上。

节点状态 
-----

一个节点的状态包含以下信息:

*   地址（Addresses）
*   状况（Condition）
*   容量与可分配（Capacity）
*   信息（Info）

你可以使用 ​`kubectl` ​来查看节点状态和其他细节信息：

`kubectl describe node <节点名称>`

下面对每个部分进行详细描述。

### 地址 

这些字段的用法取决于你的云服务商或者物理机配置。

*   HostName：由节点的内核报告。可以通过 kubelet 的 ​`--hostname-override`​ 参数覆盖。
*   ExternalIP：通常是节点的可外部路由（从集群外可访问）的 IP 地址。
*   InternalIP：通常是节点的仅可在集群内部路由的 IP 地址。

### 状况

​`conditions` ​字段描述了所有 ​`Running` ​节点的状况。状况的示例包括：

节点状况

描述

`Ready`

如节点是健康的并已经准备好接收 Pod 则为 `True`；`False` 表示节点不健康而且不能接收 Pod；`Unknown` 表示节点控制器在最近 `node-monitor-grace-period` 期间（默认 40 秒）没有收到节点的消息

`DiskPressure`

`True` 表示节点存在磁盘空间压力，即磁盘可用量低, 否则为 `False`

`MemoryPressure`

`True` 表示节点存在内存压力，即节点内存可用量低，否则为 `False`

`PIDPressure`

`True` 表示节点存在进程压力，即节点上进程过多；否则为 `False`

`NetworkUnavailable`

`True` 表示节点网络配置不正确；否则为 `False`

> 如果使用命令行工具来打印已保护（Cordoned）节点的细节，其中的 Condition 字段可能包括 ​`SchedulingDisabled`​。​`SchedulingDisabled` ​不是 Kubernetes API 中定义的 Condition，被保护起来的节点在其规约中被标记为不可调度（Unschedulable）。

在 Kubernetes API 中，节点的状况表示节点资源中​`.status`​ 的一部分。 例如，以下 JSON 结构描述了一个健康节点：

`"conditions": [   {     "type": "Ready",     "status": "True",     "reason": "KubeletReady",     "message": "kubelet is posting ready status",     "lastHeartbeatTime": "2019-06-05T18:38:35Z",     "lastTransitionTime": "2019-06-05T11:41:27Z"   } ]`

如果 Ready 状况的 ​`status` ​处于 ​`Unknown` ​或者 ​`False` ​状态的时间超过了 ​`pod-eviction-timeout`​ 值（一个传递给 kube-controller-manager 的参数），节点控制器会对节点上的所有 Pod 触发 API-发起的驱逐。 默认的逐出超时时长为 5 分钟。

某些情况下，当节点不可达时，API 服务器不能和其上的 kubelet 通信。 删除 Pod 的决定不能传达给 kubelet，直到它重新建立和 API 服务器的连接为止。 与此同时，被计划删除的 Pod 可能会继续在游离的节点上运行。

节点控制器在确认 Pod 在集群中已经停止运行前，不会强制删除它们。 你可以看到可能在这些无法访问的节点上运行的 Pod 处于 ​`Terminating` ​或者 ​`Unknown` ​状态。 如果 kubernetes 不能基于下层基础设施推断出某节点是否已经永久离开了集群， 集群管理员可能需要手动删除该节点对象。 从 Kubernetes 删除节点对象将导致 API 服务器删除节点上所有运行的 Pod 对象并释放它们的名字。

当节点上出现问题时，Kubernetes 控制面会自动创建与影响节点的状况对应的 污点。 调度器在将 Pod 指派到某 Node 时会考虑 Node 上的污点设置。 Pod 也可以设置容忍度， 以便能够在设置了特定污点的 Node 上运行。

### 容量（Capacity）与可分配（Allocatable） 

这两个值描述节点上的可用资源：CPU、内存和可以调度到节点上的 Pod 的个数上限。

​`capacity` ​块中的字段标示节点拥有的资源总量。 ​`allocatable` ​块指示节点上可供普通 Pod 消耗的资源量。

### 信息（Info）

Info 指的是节点的一般信息，如内核版本、Kubernetes 版本（​`kubelet` ​和 ​`kube-proxy`​ 版本）、 容器运行时详细信息，以及节点使用的操作系统。 ​`kubelet` ​从节点收集这些信息并将其发布到 Kubernetes API。

心跳 
---

Kubernetes 节点发送的心跳帮助你的集群确定每个节点的可用性，并在检测到故障时采取行动。

对于节点，有两种形式的心跳:

*   更新节点的 ​`.status` ​
*   ​`kube-node-lease`​ 名字空间中的 Lease（租约）对象。 每个节点都有一个关联的 Lease 对象。

与 Node 的 ​`.status`​ 更新相比，Lease 是一种轻量级资源。 使用 Lease 来表达心跳在大型集群中可以减少这些更新对性能的影响。

kubelet 负责创建和更新节点的 ​`.status`​，以及更新它们对应的 Lease。

*   当节点状态发生变化时，或者在配置的时间间隔内没有更新事件时，kubelet 会更新 ​`.status`​。 ​`.status`​ 更新的默认间隔为 5 分钟（比节点不可达事件的 40 秒默认超时时间长很多）。
*   ​`kubelet` ​会创建并每 10 秒（默认更新间隔时间）更新 Lease 对象。 Lease 的更新独立于 Node 的 ​`.status`​ 更新而发生。 如果 Lease 的更新操作失败，kubelet 会采用指数回退机制，从 200 毫秒开始重试， 最长重试间隔为 7 秒钟。

节点控制器 
------

节点控制器是 Kubernetes 控制面组件， 管理节点的方方面面。

节点控制器在节点的生命周期中扮演多个角色。 第一个是当节点注册时为它分配一个 CIDR 区段（如果启用了 CIDR 分配）。

第二个是保持节点控制器内的节点列表与云服务商所提供的可用机器列表同步。 如果在云环境下运行，只要某节点不健康，节点控制器就会询问云服务是否节点的虚拟机仍可用。 如果不可用，节点控制器会将该节点从它的节点列表删除。

第三个是监控节点的健康状况。节点控制器负责：

*   在节点不可达的情况下，在 Node 的 ​`.status`​ 中更新 ​`Ready` ​状况。 在这种情况下，节点控制器将 NodeReady 状况更新为 ​`Unknown` ​。
*   如果节点仍然无法访问：对于不可达节点上的所有 Pod 触发 API 发起的逐出操作。 默认情况下，节点控制器在将节点标记为 ​`Unknown` ​后等待 5 分钟提交第一个驱逐请求。

默认情况下，节点控制器每 5 秒检查一次节点状态，可以使用 ​`kube-controller-manager`​ 组件上的 ​`--node-monitor-period`​ 参数来配置周期。

### 逐出速率限制 

大部分情况下，节点控制器把逐出速率限制在每秒 ​`--node-eviction-rate`​ 个（默认为 0.1）。 这表示它每 10 秒钟内至多从一个节点驱逐 Pod。

当一个可用区域（Availability Zone）中的节点变为不健康时，节点的驱逐行为将发生改变。 节点控制器会同时检查可用区域中不健康（​`Ready` ​状况为 ​`Unknown` ​或 ​`False`​） 的节点的百分比：

*   如果不健康节点的比例超过 ​`--unhealthy-zone-threshold`​ （默认为 0.55）， 驱逐速率将会降低。
*   如果集群较小（意即小于等于 ​`--large-cluster-size-threshold`​ 个节点 - 默认为 50）， 驱逐操作将会停止。
*   否则驱逐速率将降为每秒 ​`--secondary-node-eviction-rate`​ 个（默认为 0.01）。

在逐个可用区域中实施这些策略的原因是， 当一个可用区域可能从控制面脱离时其它可用区域可能仍然保持连接。 如果你的集群没有跨越云服务商的多个可用区域，那（整个集群）就只有一个可用区域。

跨多个可用区域部署你的节点的一个关键原因是当某个可用区域整体出现故障时， 工作负载可以转移到健康的可用区域。 因此，如果一个可用区域中的所有节点都不健康时，节点控制器会以正常的速率 ​`--node-eviction-rate`​ 进行驱逐操作。 在所有的可用区域都不健康（也即集群中没有健康节点）的极端情况下， 节点控制器将假设控制面与节点间的连接出了某些问题，它将停止所有驱逐动作 （如果故障后部分节点重新连接，节点控制器会从剩下不健康或者不可达节点中驱逐 Pod）。

节点控制器还负责驱逐运行在拥有 ​`NoExecute` ​污点的节点上的 Pod， 除非这些 Pod 能够容忍此污点。 节点控制器还负责根据节点故障（例如节点不可访问或没有就绪） 为其添加污点。 这意味着调度器不会将 Pod 调度到不健康的节点上。

### 资源容量跟踪 

Node 对象会跟踪节点上资源的容量（例如可用内存和 CPU 数量）。 通过自注册机制生成的 Node 对象会在注册期间报告自身容量。 如果你手动添加了 Node， 你就需要在添加节点时手动设置节点容量。

Kubernetes 调度器 保证节点上有足够的资源供其上的所有 Pod 使用。 它会检查节点上所有容器的请求的总和不会超过节点的容量。 总的请求包括由 kubelet 启动的所有容器，但不包括由容器运行时直接启动的容器， 也不包括不受 ​`kubelet` ​控制的其他进程。

节点拓扑 
-----

FEATURE STATE: Kubernetes v1.18 \[beta\]

如果启用了 ​`TopologyManager` ​特性门控， ​`kubelet` ​可以在作出资源分配决策时使用拓扑提示。

节点体面关闭
------

FEATURE STATE: Kubernetes v1.21 \[beta\]

kubelet 会尝试检测节点系统关闭事件并终止在节点上运行的 Pods。

在节点终止期间，kubelet 保证 Pod 遵从常规的 Pod 终止流程。

体面节点关闭特性依赖于 systemd，因为它要利用 systemd 抑制器锁机制， 在给定的期限内延迟节点关闭。

体面节点关闭特性受 ​`GracefulNodeShutdown` ​特性门控控制， 在 1.21 版本中是默认启用的。

注意，默认情况下，下面描述的两个配置选项，shutdownGracePeriod 和 shutdownGracePeriodCriticalPods 都是被设置为 0 的，因此不会激活体面节点关闭功能。 要激活此功能特性，这两个 kubelet 配置选项要适当配置，并设置为非零值。

在体面关闭节点过程中，kubelet 分两个阶段来终止 Pod：

1.  终止在节点上运行的常规 Pod。
2.  终止在节点上运行的关键 Pod。

节点体面关闭的特性对应两个 ​`KubeletConfiguration` ​选项：

*   ​`shutdownGracePeriod`​：

*   指定节点应延迟关闭的总持续时间。此时间是 Pod 体面终止的时间总和，不区分常规 Pod 还是关键 Pod。

*   ​`shutdownGracePeriodCriticalPods`​：

*   在节点关闭期间指定用于终止关键 Pod 的持续时间。该值应小于 ​`shutdownGracePeriod`​。

例如，如果设置了 ​`shutdownGracePeriod=30s`​ 和 ​`shutdownGracePeriodCriticalPods=10s`​， 则 kubelet 将延迟 30 秒关闭节点。 在关闭期间，将保留前 20（30 - 10）秒用于体面终止常规 Pod， 而保留最后 10 秒用于终止关键 Pod。

> 当 Pod 在正常节点关闭期间被驱逐时，它们会被标记为已经失败（Failed）。 运行 ​`kubectl get pods`​ 时，被驱逐的 Pod 的状态显示为 ​`Shutdown`​。 并且 ​`kubectl describe pod`​ 表示 Pod 因节点关闭而被驱逐：
> 
> `Reason:         Terminated Message:        Pod was terminated in response to imminent node shutdown.`
> 
>         

### 基于 Pod 优先级的体面节点关闭 

FEATURE STATE: Kubernetes v1.23 \[alpha\]

为了在体面节点关闭期间提供更多的灵活性，尤其是处理关闭期间的 Pod 排序问题， 体面节点关闭机制能够关注 Pod 的 PriorityClass 设置，前提是你已经在集群中启用了此功能特性。 此功能特性允许集群管理员基于 Pod 的优先级类（Priority Class） 显式地定义体面节点关闭期间 Pod 的处理顺序。

前文所述的体面节点关闭特性能够分两个阶段关闭 Pod， 首先关闭的是非关键的 Pod，之后再处理关键 Pod。 如果需要显式地以更细粒度定义关闭期间 Pod 的处理顺序，需要一定的灵活度， 这时可以使用基于 Pod 优先级的体面关闭机制。

当体面节点关闭能够处理 Pod 优先级时，体面节点关闭的处理可以分为多个阶段， 每个阶段关闭特定优先级类的 Pod。kubelet 可以被配置为按确切的阶段处理 Pod， 且每个阶段可以独立设置关闭时间。

假设集群中存在以下自定义的 Pod 优先级类。

Pod 优先级类名称

Pod 优先级类数值

`custom-class-a`

100000

`custom-class-b`

10000

`custom-class-c`

1000

`regular/unset`

0

在 kubelet 配置中， ​`shutdownGracePeriodByPodPriority` ​可能看起来是这样：

Pod 优先级类数值

关闭期限

100000

10 秒

10000

180 秒

1000

120 秒

0

60 秒

对应的 kubelet 配置 YAML 将会是：

`shutdownGracePeriodByPodPriority:   - priority: 100000     shutdownGracePeriodSeconds: 10   - priority: 10000     shutdownGracePeriodSeconds: 180   - priority: 1000     shutdownGracePeriodSeconds: 120   - priority: 0     shutdownGracePeriodSeconds: 60`

上面的表格表明，所有 ​`priority` ​值大于等于 100000 的 Pod 会得到 10 秒钟期限停止， 所有 ​`priority` ​值介于 10000 和 100000 之间的 Pod 会得到 180 秒钟期限停止， 所有 ​`priority` ​值介于 1000 和 10000 之间的 Pod 会得到 120 秒钟期限停止， 所有其他 Pod 将获得 60 秒的时间停止。

用户不需要为所有的优先级类都设置数值。例如，你也可以使用下面这种配置：

Pod 优先级类数值

关闭期限

100000

300 秒

1000

120 秒

0

60 秒

在上面这个场景中，优先级类为 ​`custom-class-b`​ 的 Pod 会与优先级类为 ​`custom-class-c`​ 的 Pod 在关闭时按相同期限处理。

如果在特定的范围内不存在 Pod，则 kubelet 不会等待对应优先级范围的 Pod。 kubelet 会直接跳到下一个优先级数值范围进行处理。

如果此功能特性被启用，但没有提供配置数据，则不会出现排序操作。

使用此功能特性需要启用 ​`GracefulNodeShutdownBasedOnPodPriority` ​特性门控， 并将 kubelet 配置中的 ​`shutdownGracePeriodByPodPriority` ​设置为期望的配置， 其中包含 Pod 的优先级类数值以及对应的关闭期限。

kubelet 子系统中会生成 ​`graceful_shutdown_start_time_seconds` ​和 ​`graceful_shutdown_end_time_seconds` ​度量指标以便监视节点关闭行为。

交换内存管理
------

FEATURE STATE: Kubernetes v1.22 \[alpha\]

在 Kubernetes 1.22 之前，节点不支持使用交换内存，并且默认情况下， 如果在节点上检测到交换内存配置，kubelet 将无法启动。 在 1.22 以后，可以逐个节点地启用交换内存支持。

要在节点上启用交换内存，必须启用kubelet 的 ​`NodeSwap` ​特性门控， 同时使用 ​`--fail-swap-on`​ 命令行参数或者将 ​`failSwapOn` ​配置设置为 false。

用户还可以选择配置 ​`memorySwap.swapBehavior`​ 以指定节点使用交换内存的方式。例如:

`memorySwap:   swapBehavior: LimitedSwap`

可用的 ​`swapBehavior` ​的配置选项有：

*   ​`LimitedSwap`​：Kubernetes 工作负载的交换内存会受限制。 不受 Kubernetes 管理的节点上的工作负载仍然可以交换。
*   ​`UnlimitedSwap`​：Kubernetes 工作负载可以使用尽可能多的交换内存请求， 一直到达到系统限制为止。

如果启用了特性门控但是未指定 ​`memorySwap` ​的配置，默认情况下 kubelet 将使用 ​`LimitedSwap` ​设置。

​`LimitedSwap` ​这种设置的行为取决于节点运行的是 v1 还是 v2 的控制组（也就是 ​`cgroups`​）：

*   cgroupsv1: Kubernetes 工作负载可以使用内存和交换，上限为 Pod 的内存限制值（如果设置了的话）。
*   cgroupsv2: Kubernetes 工作负载不能使用交换内存。

##  2.  Kubernetes 控制面到节点通信
控制面到节点通信
--------

本文列举控制面节点（确切说是 API 服务器）和 Kubernetes 集群之间的通信路径。 目的是为了让用户能够自定义他们的安装，以实现对网络配置的加固，使得集群能够在不可信的网络上 （或者在一个云服务商完全公开的 IP 上）运行。

节点到控制面
------

Kubernetes 采用的是中心辐射型（Hub-and-Spoke）API 模式。 所有从集群（或所运行的 Pods）发出的 API 调用都终止于 API 服务器。 其它控制面组件都没有被设计为可暴露远程服务。 API 服务器被配置为在一个安全的 HTTPS 端口（通常为 443）上监听远程连接请求， 并启用一种或多种形式的客户端身份认证机制。 一种或多种客户端鉴权机制应该被启用， 特别是在允许使用匿名请求 或服务账号令牌的时候。

应该使用集群的公共根证书开通节点，这样它们就能够基于有效的客户端凭据安全地连接 API 服务器。 一种好的方法是以客户端证书的形式将客户端凭据提供给 kubelet。 请查看 kubelet TLS 启动引导 以了解如何自动提供 kubelet 客户端证书。

想要连接到 API 服务器的 Pod 可以使用服务账号安全地进行连接。 当 Pod 被实例化时，Kubernetes 自动把公共根证书和一个有效的持有者令牌注入到 Pod 里。 ​`kubernetes` ​服务（位于 ​`default` ​名字空间中）配置了一个虚拟 IP 地址，用于（通过 kube-proxy）转发 请求到 API 服务器的 HTTPS 末端。

控制面组件也通过安全端口与集群的 API 服务器通信。

这样，从集群节点和节点上运行的 Pod 到控制面的连接的缺省操作模式即是安全的， 能够在不可信的网络或公网上运行。

控制面到节点
------

从控制面（API 服务器）到节点有两种主要的通信路径。 第一种是从 API 服务器到集群中每个节点上运行的 kubelet 进程。 第二种是从 API 服务器通过它的代理功能连接到任何节点、Pod 或者服务。

### API 服务器到 kubelet

从 API 服务器到 kubelet 的连接用于：

*   获取 Pod 日志
*   挂接（通过 kubectl）到运行中的 Pod
*   提供 kubelet 的端口转发功能。

这些连接终止于 kubelet 的 HTTPS 末端。 默认情况下，API 服务器不检查 kubelet 的服务证书。这使得此类连接容易受到中间人攻击， 在非受信网络或公开网络上运行也是 不安全的。

为了对这个连接进行认证，使用 ​`--kubelet-certificate-authority`​ 标志给 API 服务器提供一个根证书包，用于 kubelet 的服务证书。

如果无法实现这点，又要求避免在非受信网络或公共网络上进行连接，可在 API 服务器和 kubelet 之间使用 SSH 隧道。

最后，应该启用 kubelet 用户认证和/或鉴权 来保护 kubelet API。

### API 服务器到节点、Pod 和服务

从 API 服务器到节点、Pod 或服务的连接默认为纯 HTTP 方式，因此既没有认证，也没有加密。 这些连接可通过给 API URL 中的节点、Pod 或服务名称添加前缀 ​`https:`​ 来运行在安全的 HTTPS 连接上。 不过这些连接既不会验证 HTTPS 末端提供的证书，也不会提供客户端证书。 因此，虽然连接是加密的，仍无法提供任何完整性保证。 这些连接 目前还不能安全地 在非受信网络或公共网络上运行。

### SSH 隧道 

Kubernetes 支持使用 SSH 隧道来保护从控制面到节点的通信路径。在这种配置下，API 服务器建立一个到集群中各节点的 SSH 隧道（连接到在 22 端口监听的 SSH 服务） 并通过这个隧道传输所有到 kubelet、节点、Pod 或服务的请求。 这一隧道保证通信不会被暴露到集群节点所运行的网络之外。

SSH 隧道目前已被废弃。除非你了解个中细节，否则不应使用。 Konnectivity 服务是对此通信通道的替代品。

### Konnectivity 服务 

FEATURE STATE: Kubernetes v1.18 \[beta\]

作为 SSH 隧道的替代方案，Konnectivity 服务提供 TCP 层的代理，以便支持从控制面到集群的通信。 Konnectivity 服务包含两个部分：Konnectivity 服务器和 Konnectivity 代理，分别运行在 控制面网络和节点网络中。Konnectivity 代理建立并维持到 Konnectivity 服务器的网络连接。 启用 Konnectivity 服务之后，所有控制面到节点的通信都通过这些连接传输。

##  3.  Kubernetes 控制器
控制器
---

在机器人技术和自动化领域，控制回路（Control Loop）是一个非终止回路，用于调节系统状态。

这是一个控制环的例子：房间里的温度自动调节器。

当你设置了温度，告诉了温度自动调节器你的期望状态（Desired State）。 房间的实际温度是当前状态（Current State）。 通过对设备的开关控制，温度自动调节器让其当前状态接近期望状态。

在 Kubernetes 中，控制器通过监控集群 的公共状态，并致力于将当前状态转变为期望的状态。

控制器模式
-----

一个控制器至少追踪一种类型的 Kubernetes 资源。这些 对象 有一个代表期望状态的 ​`spec` ​字段。 该资源的控制器负责确保其当前状态接近期望状态。

控制器可能会自行执行操作；在 Kubernetes 中更常见的是一个控制器会发送信息给 API 服务器，这会有副作用。 具体可参看后文的例子。

### 通过 API 服务器来控制

Job 控制器是一个 Kubernetes 内置控制器的例子。 内置控制器通过和集群 API 服务器交互来管理状态。

Job 是一种 Kubernetes 资源，它运行一个或者多个 Pod， 来执行一个任务然后停止。 （一旦被调度了，对 kubelet 来说 Pod 对象就会变成了期望状态的一部分）。

在集群中，当 Job 控制器拿到新任务时，它会保证一组 Node 节点上的 ​`kubelet` ​可以运行正确数量的 Pod 来完成工作。 Job 控制器不会自己运行任何的 Pod 或者容器。Job 控制器是通知 API 服务器来创建或者移除 Pod。 控制面中的其它组件 根据新的消息作出反应（调度并运行新 Pod）并且最终完成工作。

创建新 Job 后，所期望的状态就是完成这个 Job。Job 控制器会让 Job 的当前状态不断接近期望状态：创建为 Job 要完成工作所需要的 Pod，使 Job 的状态接近完成。

控制器也会更新配置对象。例如：一旦 Job 的工作完成了，Job 控制器会更新 Job 对象的状态为 ​`Finished`​。

（这有点像温度自动调节器关闭了一个灯，以此来告诉你房间的温度现在到你设定的值了）。

### 直接控制

相比 Job 控制器，有些控制器需要对集群外的一些东西进行修改。

例如，如果你使用一个控制回路来保证集群中有足够的 节点，那么控制器就需要当前集群外的 一些服务在需要时创建新节点。

和外部状态交互的控制器从 API 服务器获取到它想要的状态，然后直接和外部系统进行通信 并使当前状态更接近期望状态。

（实际上有一个控制器 可以水平地扩展集群中的节点。）

这里，很重要的一点是，控制器做出了一些变更以使得事物更接近你的期望状态， 之后将当前状态报告给集群的 API 服务器。 其他控制回路可以观测到所汇报的数据的这种变化并采取其各自的行动。

在温度计的例子中，如果房间很冷，那么某个控制器可能还会启动一个防冻加热器。 就 Kubernetes 集群而言，控制面间接地与 IP 地址管理工具、存储服务、云驱动 APIs 以及其他服务协作，通过扩展 Kubernetes 来实现这点。

期望状态与当前状态
---------

Kubernetes 采用了系统的云原生视图，并且可以处理持续的变化。

在任务执行时，集群随时都可能被修改，并且控制回路会自动修复故障。 这意味着很可能集群永远不会达到稳定状态。

只要集群中的控制器在运行并且进行有效的修改，整体状态的稳定与否是无关紧要的。

设计 
---

作为设计原则之一，Kubernetes 使用了很多控制器，每个控制器管理集群状态的一个特定方面。 最常见的一个特定的控制器使用一种类型的资源作为它的期望状态， 控制器管理控制另外一种类型的资源向它的期望状态演化。

使用简单的控制器而不是一组相互连接的单体控制回路是很有用的。 控制器会失败，所以 Kubernetes 的设计正是考虑到了这一点。

> 可以有多个控制器来创建或者更新相同类型的对象。 在后台，Kubernetes 控制器确保它们只关心与其控制资源相关联的资源。  
> 例如，你可以创建 Deployment 和 Job；它们都可以创建 Pod。 Job 控制器不会删除 Deployment 所创建的 Pod，因为有信息 （标签）让控制器可以区分这些 Pod。

运行控制器的方式
--------

Kubernetes 内置一组控制器，运行在 kube-controller-manager 内。 这些内置的控制器提供了重要的核心功能。

Deployment 控制器和 Job 控制器是 Kubernetes 内置控制器的典型例子。 Kubernetes 允许你运行一个稳定的控制平面，这样即使某些内置控制器失败了， 控制平面的其他部分会接替它们的工作。

你会遇到某些控制器运行在控制面之外，用以扩展 Kubernetes。 或者，如果你愿意，你也可以自己编写新控制器。 你可以以一组 Pod 来运行你的控制器，或者运行在 Kubernetes 之外。 最合适的方案取决于控制器所要执行的功能是什么。

##  4.  Kubernetes 云控制器管理器
云控制器管理器
-------

FEATURE STATE: Kubernetes v1.11 \[beta\]

使用云基础设施技术，你可以在公有云、私有云或者混合云环境中运行 Kubernetes。 Kubernetes 的信条是基于自动化的、API 驱动的基础设施，同时避免组件间紧密耦合。

组件 cloud-controller-manager 是指云控制器管理器， 云控制器管理器是指嵌入特定云的控制逻辑的 控制平面组件。 云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。

通过分离 Kubernetes 和底层云基础设置之间的互操作性逻辑， 云控制器管理器组件使云提供商能够以不同于 Kubernetes 主项目的 步调发布新特征。

​`cloud-controller-manager`​ 组件是基于一种插件机制来构造的， 这种机制使得不同的云厂商都能将其平台与 Kubernetes 集成。

设计
--

![](https://atts.w3cschool.cn/attachments/image/20220429/1651198280484132.svg)  

云控制器管理器以一组多副本的进程集合的形式运行在控制面中，通常表现为 Pod 中的容器。每个 cloud-controller-manager 在同一进程中实现多个 控制器。

> 你也可以用 Kubernetes 插件 的形式而不是控制面中的一部分来运行云控制器管理器。

云控制器管理器的功能
----------

云控制器管理器中的控制器包括：

### 节点控制器 

节点控制器负责在云基础设施中创建了新服务器时为之 更新 节点（Node）对象。 节点控制器从云提供商获取当前租户中主机的信息。节点控制器执行以下功能：

1.  使用从云平台 API 获取的对应服务器的唯一标识符更新 Node 对象；
2.  利用特定云平台的信息为 Node 对象添加注解和标签，例如节点所在的 区域（Region）和所具有的资源（CPU、内存等等）；
3.  获取节点的网络地址和主机名；
4.  检查节点的健康状况。如果节点无响应，控制器通过云平台 API 查看该节点是否 已从云中禁用、删除或终止。如果节点已从云中删除，则控制器从 Kubernetes 集群 中删除 Node 对象。

某些云驱动实现中，这些任务被划分到一个节点控制器和一个节点生命周期控制器中。

### 路由控制器 

Route 控制器负责适当地配置云平台中的路由，以便 Kubernetes 集群中不同节点上的 容器之间可以相互通信。

取决于云驱动本身，路由控制器可能也会为 Pod 网络分配 IP 地址块。

### 服务控制器 

服务（Service）与受控的负载均衡器、 IP 地址、网络包过滤、目标健康检查等云基础设施组件集成。 服务控制器与云驱动的 API 交互，以配置负载均衡器和其他基础设施组件。 你所创建的 Service 资源会需要这些组件服务。

鉴权 
---

本节分别讲述云控制器管理器为了完成自身工作而产生的对各类 API 对象的访问需求。

### 节点控制器 

节点控制器只操作 Node 对象。它需要读取和修改 Node 对象的完全访问权限。

​`v1/Node`​:

*   Get
*   List
*   Create
*   Update
*   Patch
*   Watch
*   Delete

### 路由控制器

路由控制器会监听 Node 对象的创建事件，并据此配置路由设施。 它需要读取 Node 对象的 Get 权限。

​`v1/Node`​:

*   Get

### 服务控制器 

服务控制器监测 Service 对象的 Create、Update 和 Delete 事件，并配置 对应服务的 Endpoints 对象。 为了访问 Service 对象，它需要 List、Watch 访问权限；为了更新 Service 对象 它需要 Patch 和 Update 访问权限。 为了能够配置 Service 对应的 Endpoints 资源，它需要 Create、List、Get、Watch 和 Update 等访问权限。

​`v1/Service`​:

*   List
*   Get
*   Watch
*   Patch
*   Update

### 其他 

云控制器管理器的实现中，其核心部分需要创建 Event 对象的访问权限以及 创建 ServiceAccount 资源以保证操作安全性的权限。

​`v1/Event`​:

*   Create
*   Patch
*   Update

​`v1/ServiceAccount`​:

*   Create

用于云控制器管理器 RBAC 的 ClusterRole 如下例所示：

`apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata:   name: cloud-controller-manager rules: - apiGroups:   - ""   resources:   - events   verbs:   - create   - patch   - update - apiGroups:   - ""   resources:   - nodes   verbs:   - '*' - apiGroups:   - ""   resources:   - nodes/status   verbs:   - patch - apiGroups:   - ""   resources:   - services   verbs:   - list   - patch   - update   - watch - apiGroups:   - ""   resources:   - serviceaccounts   verbs:   - create - apiGroups:   - ""   resources:   - persistentvolumes   verbs:   - get   - list   - update   - watch - apiGroups:   - ""   resources:   - endpoints   verbs:   - create   - get   - list   - watch   - update`

##  5.  Kubernetes 垃圾收集
垃圾收集
----

垃圾收集是 Kubernetes 用于清理集群资源的各种机制的统称。 垃圾收集允许系统清理如下资源：

*   失败的 Pod
*   已完成的 Job
*   不再存在属主引用的对象
*   未使用的容器和容器镜像
*   动态制备的、StorageClass 回收策略为 Delete 的 PV 卷
*   阻滞或者过期的 CertificateSigningRequest (CSRs)
*   在以下情形中删除了的节点对象：

*   当集群使用云控制器管理器运行于云端时；
*   当集群使用类似于云控制器管理器的插件运行在本地环境中时。

*   节点租约对象

属主与依赖 
------

Kubernetes 中很多对象通过属主引用 链接到彼此。属主引用（Owner Reference）可以告诉控制面哪些对象依赖于其他对象。 Kubernetes 使用属主引用来为控制面以及其他 API 客户端在删除某对象时提供一个 清理关联资源的机会。在大多数场合，Kubernetes 都是自动管理属主引用的。

属主关系与某些资源所使用的的标签和选择算符 不同。例如，考虑一个创建 ​`EndpointSlice` ​对象的 Service 对象。Service 对象使用标签来允许控制面确定哪些 ​`EndpointSlice` ​对象被该 Service 使用。除了标签，每个被 Service 托管的 ​`EndpointSlice` ​对象还有一个属主引用属性。 属主引用可以帮助 Kubernetes 中的不同组件避免干预并非由它们控制的对象。

> 根据设计，系统不允许出现跨名字空间的属主引用。名字空间作用域的依赖对象可以指定集群作用域或者名字空间作用域的属主。 名字空间作用域的属主必须存在于依赖对象所在的同一名字空间。 如果属主位于不同名字空间，则属主引用被视为不存在，而当检查发现所有属主都已不存在时， 依赖对象会被删除。  
>   
> 集群作用域的依赖对象只能指定集群作用域的属主。 在 1.20 及更高版本中，如果一个集群作用域的依赖对象指定了某个名字空间作用域的类别作为其属主， 则该对象被视为拥有一个无法解析的属主引用，因而无法被垃圾收集处理。  
>   
> 在 1.20 及更高版本中，如果垃圾收集器检测到非法的跨名字空间 ​`ownerReference`​， 或者某集群作用域的依赖对象的 ​`ownerReference` ​引用某名字空间作用域的类别， 系统会生成一个警告事件，其原因为 ​`OwnerRefInvalidNamespace`​，​`involvedObject` ​设置为非法的依赖对象。你可以通过运行 ​`kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace`​ 来检查是否存在这类事件。

级联删除 
-----

Kubernetes 会检查并删除那些不再拥有属主引用的对象，例如在你删除了 ReplicaSet 之后留下来的 Pod。当你删除某个对象时，你可以控制 Kubernetes 是否要通过一个称作 级联删除（Cascading Deletion）的过程自动删除该对象的依赖对象。 级联删除有两种类型，分别如下：

*   前台级联删除
*   后台级联删除

你也可以使用 Kubernetes Finalizers 来控制垃圾收集机制如何以及何时删除包含属主引用的资源。

### 前台级联删除

在前台级联删除中，正在被你删除的对象首先进入 deletion in progress 状态。 在这种状态下，针对属主对象会发生以下事情：

*   Kubernetes API 服务器将对象的 ​`metadata.deletionTimestamp`​ 字段设置为对象被标记为要删除的时间点。
*   Kubernetes API 服务器也会将 ​`metadata.finalizers`​ 字段设置为 ​`foregroundDeletion`​。
*   在删除过程完成之前，通过 Kubernetes API 仍然可以看到该对象。

当属主对象进入删除过程中状态后，控制器删除其依赖对象。控制器在删除完所有依赖对象之后， 删除属主对象。这时，通过 Kubernetes API 就无法再看到该对象。

在前台级联删除过程中，唯一的可能阻止属主对象被删除的依赖对象是那些带有 ​`ownerReference.blockOwnerDeletion=true`​ 字段的对象。

### 后台级联删除

在后台级联删除过程中，Kubernetes 服务器立即删除属主对象，控制器在后台清理所有依赖对象。 默认情况下，Kubernetes 使用后台级联删除方案，除非你手动设置了要使用前台删除， 或者选择遗弃依赖对象。

### 被遗弃的依赖对象 

当 Kubernetes 删除某个属主对象时，被留下来的依赖对象被称作被遗弃的（Orphaned）对象。 默认情况下，Kubernetes 会删除依赖对象。

未使用容器和镜像的垃圾收集 
--------------

kubelet 会每五分钟对未使用的镜像执行一次垃圾收集， 每分钟对未使用的容器执行一次垃圾收集。 你应该避免使用外部的垃圾收集工具，因为外部工具可能会破坏 kubelet 的行为，移除应该保留的容器。

要配置对未使用容器和镜像的垃圾收集选项，可以使用一个 配置文件，基于 KubeletConfiguration 资源类型来调整与垃圾搜集相关的 kubelet 行为。

### 容器镜像生命期 

Kubernetes 通过其镜像管理器（Image Manager）来管理所有镜像的生命周期， 该管理器是 kubelet 的一部分，工作时与 cadvisor 协同。 kubelet 在作出垃圾收集决定时会考虑如下磁盘用量约束：

*   ​`HighThresholdPercent` ​
*   ​`LowThresholdPercent` ​

磁盘用量超出所配置的 ​`HighThresholdPercent` ​值时会触发垃圾收集， 垃圾收集器会基于镜像上次被使用的时间来按顺序删除它们，首先删除的是最老的镜像。 kubelet 会持续删除镜像，直到磁盘用量到达 ​`LowThresholdPercent` ​值为止。

### 容器垃圾收集 

kubelet 会基于如下变量对所有未使用的容器执行垃圾收集操作，这些变量都是你可以定义的：

*   ​`MinAge`​：kubelet 可以垃圾回收某个容器时该容器的最小年龄。设置为 ​`0`​ 表示禁止使用此规则。
*   ​`MaxPerPodContainer`​：每个 Pod 可以包含的已死亡的容器个数上限。设置为小于 ​`0`​ 的值表示禁止使用此规则。
*   ​`MaxContainers`​：集群中可以存在的已死亡的容器个数上限。设置为小于 ​`0`​ 的值意味着禁止应用此规则。

除以上变量之外，kubelet 还会垃圾收集除无标识的以及已删除的容器，通常从最老的容器开始。

当保持每个 Pod 的最大数量的容器（​`MaxPerPodContainer`​）会使得全局的已死亡容器个数超出上限 （​`MaxContainers`​）时，​`MaxPerPodContainer` ​和 ​`MaxContainers` ​之间可能会出现冲突。 在这种情况下，kubelet 会调整 ​`MaxPerPodContainer` ​来解决这一冲突。 最坏的情形是将 ​`MaxPerPodContainer` ​降格为 ​`1`​，并驱逐最老的容器。 此外，当隶属于某已被删除的 Pod 的容器的年龄超过 ​`MinAge` ​时，它们也会被删除。

> kubelet 仅会回收由它所管理的容器。

配置垃圾收集 
-------

你可以通过配置特定于管理资源的控制器来调整资源的垃圾收集行为。

##  6.  Kubernetes 容器运行时接口（CRI）
容器运行时接口（CRI）
------------

CRI 是一个插件接口，它使 kubelet 能够使用各种容器运行时，无需重新编译集群组件。

你需要在集群中的每个节点上都有一个可以正常工作的 容器运行时， 这样 kubelet 能启动 Pod 及其容器。

容器运行时接口（CRI）是 kubelet 和容器运行时之间通信的主要协议。

Kubernetes 容器运行时接口（CRI）定义了主要 gRPC 协议， 用于集群组件 kubelet 和 容器运行时。

API
---

FEATURE STATE: Kubernetes v1.23 \[stable\]

当通过 gRPC 连接到容器运行时时，kubelet 充当客户端。 运行时和镜像服务端点必须在容器运行时中可用，可以使用 命令行标志的 ​`--image-service-endpoint`​ 和 ​`--container-runtime-endpoint`​ 在 kubelet 中单独配置。

对 Kubernetes v1.23，kubelet 偏向于使用 CRI ​`v1`​ 版本。 如果容器运行时不支持 CRI 的 ​`v1`​ 版本，那么 kubelet 会尝试协商任何旧的其他支持版本。 如果 kubelet 无法协商支持的 CRI 版本，则 kubelet 放弃并且不会注册为节点。

升级 
---

升级 Kubernetes 时，kubelet 会尝试在组件重启时自动选择最新的 CRI 版本。 如果失败，则将如上所述进行回退。如果由于容器运行时已升级而需要 gRPC 重拨， 则容器运行时还必须支持最初选择的版本，否则重拨预计会失败。 这需要重新启动 kubelet。

#  6.  Kubernetes 容器

##  1.  Kubernetes 镜像
镜像
--

容器镜像（Image）所承载的是封装了应用程序及其所有软件依赖的二进制数据。 容器镜像是可执行的软件包，可以单独运行；该软件包对所处的运行时环境具有 良定（Well Defined）的假定。

你通常会创建应用的容器镜像并将其推送到某仓库（Registry），然后在 Pod 中引用它。

本页概要介绍容器镜像的概念。

镜像名称 
-----

容器镜像通常会被赋予 ​`pause`​、​`example/mycontainer`​ 或者 ​`kube-apiserver`​ 这类的名称。 镜像名称也可以包含所在仓库的主机名。例如：​`fictional.registry.example/imagename`​。 还可以包含仓库的端口号，例如：​`fictional.registry.example:10443/imagename`​。

如果你不指定仓库的主机名，Kubernetes 认为你在使用 Docker 公共仓库。

在镜像名称之后，你可以添加一个标签（Tag）（与使用 ​`docker` ​或 ​`podman` ​等命令时的方式相同）。 使用标签能让你辨识同一镜像序列中的不同版本。

镜像标签可以包含小写字母、大写字母、数字、下划线（​`_`​）、句点（​`.`​）和连字符（​`-`​）。 关于在镜像标签中何处可以使用分隔字符（​`_`​、​`-`​ 和 ​`.`​）还有一些额外的规则。 如果你不指定标签，Kubernetes 认为你想使用标签 ​`latest`​。

更新镜像 
-----

当你最初创建一个 Deployment、 StatefulSet、Pod 或者其他包含 Pod 模板的对象时，如果没有显式设定的话，Pod 中所有容器的默认镜像 拉取策略是 ​`IfNotPresent`​。这一策略会使得 kubelet 在镜像已经存在的情况下直接略过拉取镜像的操作。

### 镜像拉取策略 

容器的 ​`imagePullPolicy` ​和镜像的标签会影响 kubelet 尝试拉取（下载）指定的镜像。

以下列表包含了 ​`imagePullPolicy` ​可以设置的值，以及这些值的效果：

*   IfNotPresent
只有当镜像在本地不存在时才会拉取。*   Always
每当 kubelet 启动一个容器时，kubelet 会查询容器的镜像仓库， 将名称解析为一个镜像摘要。 如果 kubelet 有一个容器镜像，并且对应的摘要已在本地缓存，kubelet 就会使用其缓存的镜像； 否则，kubelet 就会使用解析后的摘要拉取镜像，并使用该镜像来启动容器。*   Never
Kubelet 不会尝试获取镜像。如果镜像已经以某种方式存在本地， kubelet 会尝试启动容器；否则，会启动失败。 

只要能够可靠地访问镜像仓库，底层镜像提供者的缓存语义甚至可以使 imagePullPolicy: Always 高效。 你的容器运行时可以注意到节点上已经存在的镜像层，这样就不需要再次下载。

> 在生产环境中部署容器时，你应该避免使用 ​`:latest`​ 标签，因为这使得正在运行的镜像的版本难以追踪，并且难以正确地回滚。  
>   
> 相反，应指定一个有意义的标签，如 ​`v1.42.0`​。

为了确保 Pod 总是使用相同版本的容器镜像，你可以指定镜像的摘要； 将 ​`<image-name>:<tag>`​ 替换为 ​`<image-name>@<digest>`​，例如 ​`image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2`​。

当使用镜像标签时，如果镜像仓库修改了代码所对应的镜像标签，可能会出现新旧代码混杂在 Pod 中运行的情况。 镜像摘要唯一标识了镜像的特定版本，因此 Kubernetes 每次启动具有指定镜像名称和摘要的容器时，都会运行相同的代码。 通过摘要指定镜像可固定你运行的代码，这样镜像仓库的变化就不会导致版本的混杂。

有一些第三方的准入控制器 在创建 Pod（和 Pod 模板）时产生变更，这样运行的工作负载就是根据镜像摘要，而不是标签来定义的。 无论镜像仓库上的标签发生什么变化，你都想确保你所有的工作负载都运行相同的代码，那么指定镜像摘要会很有用。

### 默认镜像拉取策略 

当你（或控制器）向 API 服务器提交一个新的 Pod 时，你的集群会在满足特定条件时设置 ​`imagePullPolicy` ​字段：

*   如果你省略了 ​`imagePullPolicy` ​字段，并且容器镜像的标签是 ​`:latest`​， ​`imagePullPolicy` ​会自动设置为 ​`Always`​。
*   如果你省略了 ​`imagePullPolicy` ​字段，并且没有指定容器镜像的标签， ​`imagePullPolicy` ​会自动设置为 ​`Always`​。
*   如果你省略了 ​`imagePullPolicy` ​字段，并且为容器镜像指定了非 ​`:latest`​ 的标签， ​`imagePullPolicy` ​就会自动设置为 ​`IfNotPresent`​。

> 容器的 ​`imagePullPolicy` ​的值总是在对象初次 创建 时设置的，如果后来镜像的标签发生变化，则不会更新。  
>   
> 例如，如果你用一个 非 ​`:latest`​ 的镜像标签创建一个 Deployment， 并在随后更新该 Deployment 的镜像标签为 ​`:latest`​，则 ​`imagePullPolicy` ​字段 不会 变成 ​`Always`​。 你必须手动更改已经创建的资源的拉取策略。

### 必要的镜像拉取 

如果你想总是强制执行拉取，你可以使用下述的一中方式：

*   设置容器的 ​`imagePullPolicy` ​为 ​`Always`​。
*   省略 ​`imagePullPolicy`​，并使用 ​`:latest`​ 作为镜像标签； 当你提交 Pod 时，Kubernetes 会将策略设置为 ​`Always`​。
*   省略 ​`imagePullPolicy` ​和镜像的标签； 当你提交 Pod 时，Kubernetes 会将策略设置为 ​`Always`​。
*   启用准入控制器 AlwaysPullImages。

### ImagePullBackOff

当 kubelet 使用容器运行时创建 Pod 时，容器可能因为 ​`ImagePullBackOff` ​导致状态为 Waiting。

​`ImagePullBackOff` ​状态意味着容器无法启动， 因为 Kubernetes 无法拉取容器镜像（原因包括无效的镜像名称，或从私有仓库拉取而没有 ​`imagePullSecret`​）。 ​`BackOff` ​部分表示 Kubernetes 将继续尝试拉取镜像，并增加回退延迟。

Kubernetes 会增加每次尝试之间的延迟，直到达到编译限制，即 300 秒（5 分钟）。

带镜像索引的多架构镜像 
------------

除了提供二进制的镜像之外，容器仓库也可以提供 容器镜像索引。 镜像索引可以根据特定于体系结构版本的容器指向镜像的多个 镜像清单。 这背后的理念是让你可以为镜像命名（例如：​`pause`​、​`example/mycontainer`​、​`kube-apiserver`​） 的同时，允许不同的系统基于它们所使用的机器体系结构取回正确的二进制镜像。

Kubernetes 自身通常在命名容器镜像时添加后缀 ​`-$(ARCH)`​。 为了向前兼容，请在生成较老的镜像时也提供后缀。 这里的理念是为某镜像（如 ​`pause`​）生成针对所有平台都适用的清单时， 生成 ​`pause-amd64`​ 这类镜像，以便较老的配置文件或者将镜像后缀影编码到其中的 YAML 文件也能兼容。

使用私有仓库 
-------

从私有仓库读取镜像时可能需要密钥。 凭证可以用以下方式提供:

*   配置节点向私有仓库进行身份验证

*   所有 Pod 均可读取任何已配置的私有仓库
*   需要集群管理员配置节点

*   预拉镜像

*   所有 Pod 都可以使用节点上缓存的所有镜像
*   需要所有节点的 root 访问权限才能进行设置

*   在 Pod 中设置 ImagePullSecrets

*   只有提供自己密钥的 Pod 才能访问私有仓库

*   特定于厂商的扩展或者本地扩展

*   如果你在使用定制的节点配置，你（或者云平台提供商）可以实现让节点 向容器仓库认证的机制

### 配置 Node 对私有仓库认证

设置凭据的具体说明取决于你选择使用的容器运行时和仓库。

> Kubernetes 默认仅支持 Docker 配置中的 ​`auths` ​和 ​`HttpHeaders` ​部分， 不支持 Docker 凭据辅助程序（​`credHelpers` ​或 ​`credsStore`​）。

### config.json 说明

对于 ​`config.json`​ 的解释在原始 Docker 实现和 Kubernetes 的解释之间有所不同。 在 Docker 中，​`auths` ​键只能指定根 URL ，而 Kubernetes 允许 glob URLs 以及 前缀匹配的路径。这意味着，像这样的 ​`config.json`​ 是有效的：

`{     "auths": {         "*my-registry.io/images": {             "auth": "…"         }     } }`

    

使用以下语法匹配根 URL （​`*my-registry.io`​）：

`pattern:     { term }  term:     '*'         匹配任何无分隔符字符序列     '?'         匹配任意单个非分隔符     '[' [ '^' ] 字符范围                   字符集（必须非空）     c           匹配字符 c （c 不为 '*','?','\\','['）     '\\' c      匹配字符 c  字符范围:      c           匹配字符 c （c 不为 '\\','?','-',']'）     '\\' c      匹配字符 c     lo '-' hi   匹配字符范围在 lo 到 hi 之间字符`

现在镜像拉取操作会将每种有效模式的凭据都传递给 CRI 容器运行时。例如下面的容器镜像名称会匹配成功：

*   ​`my-registry.io/images` ​
*   ​`my-registry.io/images/my-image` ​
*   ​`my-registry.io/images/another-image` ​
*   ​`sub.my-registry.io/images/my-image` ​
*   ​`a.sub.my-registry.io/images/my-image`​

kubelet 为每个找到的凭证的镜像按顺序拉取。 这意味着在 ​`config.json`​ 中可能有多项：

`{     "auths": {         "my-registry.io/images": {             "auth": "…"         },         "my-registry.io/images/subpath": {             "auth": "…"         }     } }`

如果一个容器指定了要拉取的镜像 ​`my-registry.io/images/subpath/my-image`​， 并且其中一个失败，kubelet 将尝试从另一个身份验证源下载镜像。

### 提前拉取镜像 

> 该方法适用于你能够控制节点配置的场合。 如果你的云供应商负责管理节点并自动置换节点，这一方案无法可靠地工作。

默认情况下，​`kubelet` ​会尝试从指定的仓库拉取每个镜像。 但是，如果容器属性 ​`imagePullPolicy` ​设置为 ​`IfNotPresent` ​或者 ​`Never`​， 则会优先使用（对应 ​`IfNotPresent`​）或者一定使用（对应 ​`Never`​）本地镜像。

如果你希望使用提前拉取镜像的方法代替仓库认证，就必须保证集群中所有节点提前拉取的镜像是相同的。

这一方案可以用来提前载入指定的镜像以提高速度，或者作为向私有仓库执行身份认证的一种替代方案。

所有的 Pod 都可以使用节点上提前拉取的镜像。

### 在 Pod 上指定 ImagePullSecrets 

> 运行使用私有仓库中镜像的容器时，建议使用这种方法。

Kubernetes 支持在 Pod 中设置容器镜像仓库的密钥。

### 使用 Docker Config 创建 Secret 

你需要知道用于向仓库进行身份验证的用户名、密码和客户端电子邮件地址，以及它的主机名。 运行以下命令，注意替换适当的大写值：

`kubectl create secret docker-registry <name> --docker-server=DOCKER_REGISTRY_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL`

如果你已经有 Docker 凭据文件，则可以将凭据文件导入为 Kubernetes Secret， 而不是执行上面的命令。

如果你在使用多个私有容器仓库，这种技术将特别有用。 原因是 ​`kubectl create secret docker-registry`​ 创建的是仅适用于某个私有仓库的 Secret。

> Pod 只能引用位于自身所在名字空间中的 Secret，因此需要针对每个名字空间 重复执行上述过程。

### 在 Pod 中引用 ImagePullSecrets

现在，在创建 Pod 时，可以在 Pod 定义中增加 ​`imagePullSecrets` ​部分来引用该 Secret。

例如：

`cat <<EOF > pod.yaml apiVersion: v1 kind: Pod metadata:   name: foo   namespace: awesomeapps spec:   containers:     - name: foo       image: janedoe/awesomeapp:v1   imagePullSecrets:     - name: myregistrykey EOF  cat <<EOF >> ./kustomization.yaml resources: - pod.yaml EOF`

你需要对使用私有仓库的每个 Pod 执行以上操作。 不过，设置该字段的过程也可以通过为 服务账号 资源设置 ​`imagePullSecrets` ​来自动完成。

你也可以将此方法与节点级别的 ​`.docker/config.json`​ 配置结合使用。 来自不同来源的凭据会被合并。

使用案例 
-----

配置私有仓库有多种方案，以下是一些常用场景和建议的解决方案。

1.  集群运行非专有镜像（例如，开源镜像）。镜像不需要隐藏。

*   使用 Docker hub 上的公开镜像

*   无需配置
*   某些云厂商会自动为公开镜像提供高速缓存，以便提升可用性并缩短拉取镜像所需时间

7.  集群运行一些专有镜像，这些镜像需要对公司外部隐藏，对所有集群用户可见

*   使用托管的私有 Docker 仓库。

*   可以托管在 Docker Hub 或者其他地方
*   按照上面的描述，在每个节点上手动配置 .docker/config.json 文件

*   或者，在防火墙内运行一个组织内部的私有仓库，并开放读取权限

*   不需要配置 Kubenretes

*   使用控制镜像访问的托管容器镜像仓库服务

*   与手动配置节点相比，这种方案能更好地处理集群自动扩缩容

*   或者，在不方便更改节点配置的集群中，使用 imagePullSecrets

13.  集群使用专有镜像，且有些镜像需要更严格的访问控制

*   确保 AlwaysPullImages 准入控制器被启用。否则，所有 Pod 都可以使用所有镜像。
*   确保将敏感数据存储在 Secret 资源中，而不是将其打包在镜像里

19.  集群是多租户的并且每个租户需要自己的私有仓库

*   确保 AlwaysPullImages 准入控制器。否则，所有租户的所有的 Pod 都可以使用所有镜像。
*   为私有仓库启用鉴权
*   为每个租户生成访问仓库的凭据，放置在 Secret 中，并将 Secrert 发布到各租户的命名空间下。
*   租户将 Secret 添加到每个名字空间中的 imagePullSecrets

如果你需要访问多个仓库，可以为每个仓库创建一个 Secret。 ​`kubelet` ​将所有 ​`imagePullSecrets` ​合并为一个虚拟的 ​`.docker/config.json`​ 文件。

##  2.  Kubernetes 容器环境
容器环境 
-----

Kubernetes 的容器环境给容器提供了几个重要的资源：

*   文件系统，其中包含一个镜像 和一个或多个的卷
*   容器自身的信息
*   集群中其他对象的信息

### 容器信息

容器的 hostname 是它所运行在的 pod 的名称。它可以通过 ​`hostname` ​命令或者调用 libc 中的 gethostname 函数来获取。

Pod 名称和命名空间可以通过 下行 API 转换为环境变量。

Pod 定义中的用户所定义的环境变量也可在容器中使用，就像在 container 镜像中静态指定的任何环境变量一样。

### 集群信息

创建容器时正在运行的所有服务都可用作该容器的环境变量。 这里的服务仅限于新容器的 Pod 所在的名字空间中的服务，以及 Kubernetes 控制面的服务。

对于名为 foo 的服务，当映射到名为 bar 的容器时，以下变量是被定义了的：

`FOO_SERVICE_HOST=<the host the service is running on> FOO_SERVICE_PORT=<the port the service is running on>`

服务具有专用的 IP 地址。如果启用了 DNS 插件， 可以在容器中通过 DNS 来访问服务。

##  3.  Kubernetes 容器运行时类（Runtime Class）
容器运行时类（Runtime Class）
---------------------

FEATURE STATE: Kubernetes v1.20 \[stable\]

本页面描述了 RuntimeClass 资源和运行时的选择机制。

RuntimeClass 是一个用于选择容器运行时配置的特性，容器运行时配置用于运行 Pod 中的容器。

动机 
---

你可以在不同的 Pod 设置不同的 RuntimeClass，以提供性能与安全性之间的平衡。 例如，如果你的部分工作负载需要高级别的信息安全保证，你可以决定在调度这些 Pod 时尽量使它们在使用硬件虚拟化的容器运行时中运行。 这样，你将从这些不同运行时所提供的额外隔离中获益，代价是一些额外的开销。

你还可以使用 RuntimeClass 运行具有相同容器运行时但具有不同设置的 Pod。

设置 
---

1.  在节点上配置 CRI 的实现（取决于所选用的运行时）
2.  创建相应的 RuntimeClass 资源

### 1. 在节点上配置 CRI 实现

RuntimeClass 的配置依赖于 运行时接口（CRI）的实现。 根据你使用的 CRI 实现，查阅相关的文档（下方）来了解如何配置。

> RuntimeClass 假设集群中的节点配置是同构的（换言之，所有的节点在容器运行时方面的配置是相同的）。 如果需要支持异构节点，配置方法请参阅下面的 调度。

所有这些配置都具有相应的 ​`handler` ​名，并被 RuntimeClass 引用。 handler 必须是有效的 DNS 标签名。

### 2. 创建相应的 RuntimeClass 资源

在上面步骤 1 中，每个配置都需要有一个用于标识配置的 ​`handler`​。 针对每个 handler 需要创建一个 RuntimeClass 对象。

RuntimeClass 资源当前只有两个重要的字段：RuntimeClass 名 (​`metadata.name`​) 和 handler (​`handler`​)。 对象定义如下所示：

`apiVersion: node.k8s.io/v1  # RuntimeClass 定义于 node.k8s.io API 组 kind: RuntimeClass metadata:   name: myclass  # 用来引用 RuntimeClass 的名字   # RuntimeClass 是一个集群层面的资源 handler: myconfiguration  # 对应的 CRI 配置的名称`

> 建议将 RuntimeClass 写操作（create、update、patch 和 delete）限定于集群管理员使用。 通常这是默认配置。

使用说明 
-----

一旦完成集群中 RuntimeClasses 的配置，使用起来非常方便。 在 Pod spec 中指定 ​`runtimeClassName` ​即可。例如:

`apiVersion: v1 kind: Pod metadata:   name: mypod spec:   runtimeClassName: myclass   # ...`

这一设置会告诉 kubelet 使用所指的 RuntimeClass 来运行该 pod。 如果所指的 RuntimeClass 不存在或者 CRI 无法运行相应的 handler， 那么 pod 将会进入 ​`Failed` ​终止阶段。 你可以查看相应的事件， 获取执行过程中的错误信息。

如果未指定 ​`runtimeClassName` ​，则将使用默认的 RuntimeHandler，相当于禁用 RuntimeClass 功能特性。

### CRI 配置

#### dockershim

Dockershim 自 Kubernetes v1.20 起已弃用，并将在 v1.24 中删除。

为 dockershim 设置 RuntimeClass 时，必须将运行时处理程序设置为 ​`docker`​。 Dockershim 不支持自定义的可配置的运行时处理程序。

#### containerd

通过 containerd 的 ​`/etc/containerd/config.toml`​ 配置文件来配置运行时 handler。 handler 需要配置在 runtimes 块中：

`[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.${HANDLER_NAME}]`

更详细信息，请查阅 containerd [CRI 插件配置指南](https://github.com/containerd/cri/blob/master/docs/config.md)

#### cri-o

通过 cri-o 的 ​`/etc/crio/crio.conf`​ 配置文件来配置运行时 handler。 handler 需要配置在 [crio.runtime](https://github.com/cri-o/cri-o/blob/main/docs/crio.conf.5.md target=) 表 下面：

`[crio.runtime.runtimes.${HANDLER_NAME}]   runtime_path = "${PATH_TO_BINARY}"`

更详细信息，请查阅 CRI-O [配置文档](https://github.com/cri-o/cri-o/blob/main/docs/crio.conf.5.md)。

调度 
---

FEATURE STATE: Kubernetes v1.16 \[beta\]

通过为 RuntimeClass 指定 ​`scheduling` ​字段， 你可以通过设置约束，确保运行该 RuntimeClass 的 Pod 被调度到支持该 RuntimeClass 的节点上。 如果未设置 ​`scheduling`​，则假定所有节点均支持此 RuntimeClass 。

为了确保 pod 会被调度到支持指定运行时的 node 上，每个 node 需要设置一个通用的 label 用于被 ​`runtimeclass.scheduling.nodeSelector`​ 挑选。在 admission 阶段，RuntimeClass 的 nodeSelector 将会与 pod 的 nodeSelector 合并，取二者的交集。如果有冲突，pod 将会被拒绝。

如果 node 需要阻止某些需要特定 RuntimeClass 的 pod，可以在 ​`tolerations` ​中指定。 与 ​`nodeSelector` ​一样，tolerations 也在 admission 阶段与 pod 的 tolerations 合并，取二者的并集。

### Pod 开销 

FEATURE STATE: Kubernetes v1.18 \[beta\]

你可以指定与运行 Pod 相关的 开销 资源。声明开销即允许集群（包括调度器）在决策 Pod 和资源时将其考虑在内。 若要使用 Pod 开销特性，你必须确保 PodOverhead 特性门控 处于启用状态（默认为启用状态）。

Pod 开销通过 RuntimeClass 的 ​`overhead` ​字段定义。 通过使用这些字段，你可以指定使用该 RuntimeClass 运行 Pod 时的开销并确保 Kubernetes 将这些开销计算在内。

##  4.  Kubernetes 容器生命周期回调
概述
--

类似于许多具有生命周期回调组件的编程语言框架，例如 Angular、Kubernetes 为容器提供了生命周期回调。 回调使容器能够了解其管理生命周期中的事件，并在执行相应的生命周期回调时运行在处理程序中实现的代码。

容器回调
----

有两个回调暴露给容器：

​`PostStart` ​

这个回调在容器被创建之后立即被执行。 但是，不能保证回调会在容器入口点（ENTRYPOINT）之前执行。 没有参数传递给处理程序。

​`PreStop` ​

在容器因 API 请求或者管理事件（诸如存活态探针、启动探针失败、资源抢占、资源竞争等） 而被终止之前，此回调会被调用。 如果容器已经处于已终止或者已完成状态，则对 preStop 回调的调用将失败。 在用来停止容器的 TERM 信号被发出之前，回调必须执行结束。 Pod 的终止宽限周期在 ​`PreStop` ​回调被执行之前即开始计数，所以无论 回调函数的执行结果如何，容器最终都会在 Pod 的终止宽限期内被终止。 没有参数会被传递给处理程序。

### 回调处理程序的实现 

容器可以通过实现和注册该回调的处理程序来访问该回调。 针对容器，有两种类型的回调处理程序可供实现：

*   Exec - 在容器的 cgroups 和名称空间中执行特定的命令（例如 ​`pre-stop.sh`​）。 命令所消耗的资源计入容器的资源消耗。
*   HTTP - 对容器上的特定端点执行 HTTP 请求。

### 回调处理程序执行

当调用容器生命周期管理回调时，Kubernetes 管理系统根据回调动作执行其处理程序， ​`httpGet` ​和 ​`tcpSocket` ​在kubelet 进程执行，而 ​`exec` ​则由容器内执行 。

回调处理程序调用在包含容器的 Pod 上下文中是同步的。 这意味着对于 ​`PostStart` ​回调，容器入口点和回调异步触发。 但是，如果回调运行或挂起的时间太长，则容器无法达到 ​`running` ​状态。

​`PreStop` ​回调并不会与停止容器的信号处理程序异步执行；回调必须在 可以发送信号之前完成执行。 如果 ​`PreStop` ​回调在执行期间停滞不前，Pod 的阶段会变成 ​`Terminating` ​并且一直处于该状态，直到其 ​`terminationGracePeriodSeconds` ​耗尽为止， 这时 Pod 会被杀死。 这一宽限期是针对 ​`PreStop` ​回调的执行时间及容器正常停止时间的总和而言的。 例如，如果 ​`terminationGracePeriodSeconds` ​是 60，回调函数花了 55 秒钟 完成执行，而容器在收到信号之后花了 10 秒钟来正常结束，那么容器会在其 能够正常结束之前即被杀死，因为 ​`terminationGracePeriodSeconds` ​的值 小于后面两件事情所花费的总时间（55+10）。

如果 ​`PostStart` ​或 ​`PreStop` ​回调失败，它会杀死容器。

用户应该使他们的回调处理程序尽可能的轻量级。 但也需要考虑长时间运行的命令也很有用的情况，比如在停止容器之前保存状态。

### 回调递送保证

回调的递送应该是 至少一次，这意味着对于任何给定的事件， 例如 ​`PostStart` ​或 ​`PreStop`​，回调可以被调用多次。 如何正确处理被多次调用的情况，是回调实现所要考虑的问题。

通常情况下，只会进行单次递送。 例如，如果 HTTP 回调接收器宕机，无法接收流量，则不会尝试重新发送。 然而，偶尔也会发生重复递送的可能。 例如，如果 kubelet 在发送回调的过程中重新启动，回调可能会在 kubelet 恢复后重新发送。

### 调试回调处理程序

回调处理程序的日志不会在 Pod 事件中公开。 如果处理程序由于某种原因失败，它将播放一个事件。 对于 ​`PostStart`​，这是 ​`FailedPostStartHook` ​事件，对于 ​`PreStop`​，这是 ​`FailedPreStopHook` ​事件。 要自己生成失败的 ​`FailedPreStopHook` ​事件，请修改 [lifecycle-events.yaml](https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/lifecycle-events.yaml) 文件将 postStart 命令更改为 ”badcommand“ 并应用它。 以下是通过运行 ​`kubectl describe pod lifecycle-demo`​ 后你看到的一些结果事件的示例输出：

`Events:   Type     Reason               Age              From               Message   ----     ------               ----             ----               -------   Normal   Scheduled            7s               default-scheduler  Successfully assigned default/lifecycle-demo to ip-XXX-XXX-XX-XX.us-east-2...   Normal   Pulled               6s               kubelet            Successfully pulled image "nginx" in 229.604315ms   Normal   Pulling              4s (x2 over 6s)  kubelet            Pulling image "nginx"   Normal   Created              4s (x2 over 5s)  kubelet            Created container lifecycle-demo-container   Normal   Started              4s (x2 over 5s)  kubelet            Started container lifecycle-demo-container   Warning  FailedPostStartHook  4s (x2 over 5s)  kubelet            Exec lifecycle hook ([badcommand]) for Container "lifecycle-demo-container" in Pod "lifecycle-demo_default(30229739-9651-4e5a-9a32-a8f1688862db)" failed - error: command 'badcommand' exited with 126: , message: "OCI runtime exec failed: exec failed: container_linux.go:380: starting container process caused: exec: \"badcommand\": executable file not found in $PATH: unknown\r\n"   Normal   Killing              4s (x2 over 5s)  kubelet            FailedPostStartHook   Normal   Pulled               4s               kubelet            Successfully pulled image "nginx" in 215.66395ms   Warning  BackOff              2s (x2 over 3s)  kubelet            Back-off restarting failed container`

#  7.  Kubernetes Pods

##  1.  Kubernetes Pod的生命周期
Pod 的生命周期
---------

本页面讲述 Pod 的生命周期。 Pod 遵循一个预定义的生命周期，起始于 ​`Pending` ​阶段，如果至少 其中有一个主要容器正常启动，则进入 ​`Running`​，之后取决于 Pod 中是否有容器以 失败状态结束而进入 Succeeded 或者 Failed 阶段。

在 Pod 运行期间，​`kubelet` ​能够重启容器以处理一些失效场景。 在 Pod 内部，Kubernetes 跟踪不同容器的状态 并确定使 Pod 重新变得健康所需要采取的动作。

在 Kubernetes API 中，Pod 包含规约部分和实际状态部分。 Pod 对象的状态包含了一组 Pod 状况（Conditions）。 如果应用需要的话，你也可以向其中注入自定义的就绪性信息。

Pod 在其生命周期中只会被调度一次。 一旦 Pod 被调度（分派）到某个节点，Pod 会一直在该节点运行，直到 Pod 停止或者 被终止。

Pod 生命期 
--------

和一个个独立的应用容器一样，Pod 也被认为是相对临时性（而不是长期存在）的实体。 Pod 会被创建、赋予一个唯一的 ID（UID）， 并被调度到节点，并在终止（根据重启策略）或删除之前一直运行在该节点。

如果一个节点死掉了，调度到该节点 的 Pod 也被计划在给定超时期限结束后删除。

Pod 自身不具有自愈能力。如果 Pod 被调度到某节点 而该节点之后失效，Pod 会被删除；类似地，Pod 无法在因节点资源 耗尽或者节点维护而被驱逐期间继续存活。Kubernetes 使用一种高级抽象 来管理这些相对而言可随时丢弃的 Pod 实例，称作 控制器。

任何给定的 Pod （由 UID 定义）从不会被“重新调度（rescheduled）”到不同的节点； 相反，这一 Pod 可以被一个新的、几乎完全相同的 Pod 替换掉。 如果需要，新 Pod 的名字可以不变，但是其 UID 会不同。

如果某物声称其生命期与某 Pod 相同，例如存储卷， 这就意味着该对象在此 Pod （UID 亦相同）存在期间也一直存在。 如果 Pod 因为任何原因被删除，甚至某完全相同的替代 Pod 被创建时， 这个相关的对象（例如这里的卷）也会被删除并重建。

![](https://atts.w3cschool.cn/attachments/image/20220429/1651202755538007.svg)  

*   Pod 结构图例
一个包含多个容器的 Pod 中包含一个用来拉取文件的程序和一个 Web 服务器， 均使用持久卷作为容器间共享的存储。

Pod 阶段 
-------

Pod 的 ​`status` ​字段是一个 [PodStatus](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/ target=) 对象，其中包含一个 ​`phase` ​字段。

Pod 的阶段（Phase）是 Pod 在其生命周期中所处位置的简单宏观概述。 该阶段并不是对容器或 Pod 状态的综合汇总，也不是为了成为完整的状态机。

Pod 阶段的数量和含义是严格定义的。 除了本文档中列举的内容外，不应该再假定 Pod 有其他的 ​`phase` ​值。

下面是 ​`phase` ​可能的值：

取值

描述

`Pending`（悬决）

Pod 已被 Kubernetes 系统接受，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间。

`Running`（运行中）

Pod 已经绑定到了某个节点，Pod 中所有的容器都已被创建。至少有一个容器仍在运行，或者正处于启动或重启状态。

`Succeeded`（成功）

Pod 中的所有容器都已成功终止，并且不会再重启。

`Failed`（失败）

Pod 中的所有容器都已终止，并且至少有一个容器是因为失败终止。也就是说，容器以非 0 状态退出或者被系统终止。

`Unknown`（未知）

因为某些原因无法取得 Pod 的状态。这种情况通常是因为与 Pod 所在主机通信失败。

如果某节点死掉或者与集群中其他节点失联，Kubernetes 会实施一种策略，将失去的节点上运行的所有 Pod 的 ​`phase` ​设置为 ​`Failed`​。

容器状态 
-----

Kubernetes 会跟踪 Pod 中每个容器的状态，就像它跟踪 Pod 总体上的阶段一样。 你可以使用容器生命周期回调 来在容器生命周期中的特定时间点触发事件。

一旦调度器将 Pod 分派给某个节点，kubelet 就通过 容器运行时 开始为 Pod 创建容器。 容器的状态有三种：​`Waiting`​（等待）、​`Running`​（运行中）和 ​`Terminated`​（已终止）。

要检查 Pod 中容器的状态，你可以使用 ​`kubectl describe pod <pod 名称>`​。 其输出中包含 Pod 中每个容器的状态。

每种状态都有特定的含义：

### Waiting （等待） 

如果容器并不处在 ​`Running` ​或 ​`Terminated` ​状态之一，它就处在 ​`Waiting` ​状态。 处于 ​`Waiting` ​状态的容器仍在运行它完成启动所需要的操作：例如，从某个容器镜像 仓库拉取容器镜像，或者向容器应用 Secret 数据等等。 当你使用 ​`kubectl` ​来查询包含 ​`Waiting` ​状态的容器的 Pod 时，你也会看到一个 Reason 字段，其中给出了容器处于等待状态的原因。

### Running（运行中） 

​`Running` ​状态表明容器正在执行状态并且没有问题发生。 如果配置了 ​`postStart` ​回调，那么该回调已经执行且已完成。 如果你使用 ​`kubectl` ​来查询包含 ​`Running` ​状态的容器的 Pod 时，你也会看到 关于容器进入 ​`Running` ​状态的信息。

### Terminated（已终止） 

处于 ​`Terminated` ​状态的容器已经开始执行并且或者正常结束或者因为某些原因失败。 如果你使用 ​`kubectl` ​来查询包含 ​`Terminated` ​状态的容器的 Pod 时，你会看到 容器进入此状态的原因、退出代码以及容器执行期间的起止时间。

如果容器配置了 ​`preStop` ​回调，则该回调会在容器进入 ​`Terminated` ​状态之前执行。

容器重启策略
------

Pod 的 ​`spec` ​中包含一个 ​`restartPolicy` ​字段，其可能取值包括 Always、OnFailure 和 Never。默认值是 Always。

​`restartPolicy` ​适用于 Pod 中的所有容器。​`restartPolicy` ​仅针对同一节点上 ​`kubelet` ​的容器重启动作。当 Pod 中的容器退出时，​`kubelet` ​会按指数回退 方式计算重启的延迟（10s、20s、40s、...），其最长延迟为 5 分钟。 一旦某容器执行了 10 分钟并且没有出现问题，​`kubelet` ​对该容器的重启回退计时器执行 重置操作。

Pod 状况 
-------

Pod 有一个 PodStatus 对象，其中包含一个 [PodConditions](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/ target=) 数组。Pod 可能通过也可能未通过其中的一些状况测试。

*   ​`PodScheduled`​：Pod 已经被调度到某节点；
*   ​`ContainersReady`​：Pod 中所有容器都已就绪；
*   ​`Initialized`​：所有的 Init 容器 都已成功完成；
*   ​`Ready`​：Pod 可以为请求提供服务，并且应该被添加到对应服务的负载均衡池中。

字段名称

描述

`type`

Pod 状况的名称

`status`

表明该状况是否适用，可能的取值有 "`True`", "`False`" 或 "`Unknown`"

`lastProbeTime`

上次探测 Pod 状况时的时间戳

`lastTransitionTime`

Pod 上次从一种状态转换到另一种状态时的时间戳

`reason`

机器可读的、驼峰编码（UpperCamelCase）的文字，表述上次状况变化的原因

`message`

人类可读的消息，给出上次状态转换的详细信息

### Pod 就绪态 

FEATURE STATE: Kubernetes v1.14 \[stable\]

你的应用可以向 PodStatus 中注入额外的反馈或者信号：Pod Readiness（Pod 就绪态）。 要使用这一特性，可以设置 Pod 规约中的 ​`readinessGates` ​列表，为 kubelet 提供一组额外的状况供其评估 Pod 就绪态时使用。

就绪态门控基于 Pod 的 ​`status.conditions`​ 字段的当前值来做决定。 如果 Kubernetes 无法在 ​`status.conditions`​ 字段中找到某状况，则该状况的 状态值默认为 "​`False`​"。

这里是一个例子：

`kind: Pod ... spec:   readinessGates:     - conditionType: "www.example.com/feature-1" status:   conditions:     - type: Ready                              # 内置的 Pod 状况       status: "False"       lastProbeTime: null       lastTransitionTime: 2018-01-01T00:00:00Z     - type: "www.example.com/feature-1"        # 额外的 Pod 状况       status: "False"       lastProbeTime: null       lastTransitionTime: 2018-01-01T00:00:00Z   containerStatuses:     - containerID: docker://abcd...       ready: true ...`

你所添加的 Pod 状况名称必须满足 Kubernetes 标签键名格式。

### Pod 就绪态的状态

命令 ​`kubectl patch`​ 不支持修改对象的状态。 如果需要设置 Pod 的 ​`status.conditions`​，应用或者 Operators 需要使用 ​`PATCH` ​操作。 你可以使用 Kubernetes 客户端库 之一来编写代码，针对 Pod 就绪态设置定制的 Pod 状况。

对于使用定制状况的 Pod 而言，只有当下面的陈述都适用时，该 Pod 才会被评估为就绪：

*   Pod 中所有容器都已就绪；
*   readinessGates 中的所有状况都为 True 值。

当 Pod 的容器都已就绪，但至少一个定制状况没有取值或者取值为 ​`False`​， ​`kubelet` ​将 Pod 的状况设置为 ​`ContainersReady`​。

容器探针 
-----

probe 是由 kubelet 对容器执行的定期诊断。 要执行诊断，kubelet 既可以在容器内执行代码，也可以发出一个网络请求。

### 检查机制 

使用探针来检查容器有四种不同的方法。 每个探针都必须准确定义为这四种机制中的一种：

*   exec
在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。*   grpc
使用 gRPC 执行一个远程过程调用。 目标应该实现 gRPC健康检查。 如果响应的状态是 "SERVING"，则认为诊断成功。 gRPC 探针是一个 alpha 特性，只有在你启用了 "GRPCContainerProbe" 特性门控时才能使用。*   httpGet
对容器的 IP 地址上指定端口和路径执行 HTTP GET 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。*   tcpSocket
对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。 如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的。

### 探测结果 

每次探测都将获得以下三种结果之一：

*   Success（成功）
容器通过了诊断。*   Failure（失败）
容器未通过诊断。*   Unknown（未知）
诊断失败，因此不会采取任何行动。

### 探测类型 

针对运行中的容器，​`kubelet` ​可以选择是否执行以下三种探针，以及如何针对探测结果作出反应：

*   livenessProbe
指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器， 并且容器将根据其重启策略决定未来。如果容器不提供存活探针， 则默认状态为 Success。*   readinessProbe
指示容器是否准备好为请求提供服务。如果就绪态探测失败， 端点控制器将从与 Pod 匹配的所有服务的端点列表中删除该 Pod 的 IP 地址。 初始延迟之前的就绪态的状态值默认为 Failure。 如果容器不提供就绪态探针，则默认状态为 Success。*   startupProbe
指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被 禁用，直到此探针成功为止。如果启动探测失败，kubelet 将杀死容器，而容器依其 重启策略进行重启。 如果容器没有提供启动探测，则默认状态为 Success。

### 何时该使用存活态探针? 

FEATURE STATE: Kubernetes v1.0 \[stable\]

如果容器中的进程能够在遇到问题或不健康的情况下自行崩溃，则不一定需要存活态探针; ​`kubelet` ​将根据 Pod 的​`restartPolicy` ​自动执行修复操作。

如果你希望容器在探测失败时被杀死并重新启动，那么请指定一个存活态探针， 并指定​`restartPolicy` ​为 "​`Always`​" 或 "​`OnFailure`​"。

### 何时该使用就绪态探针? 

FEATURE STATE: Kubernetes v1.0 \[stable\]

如果要仅在探测成功时才开始向 Pod 发送请求流量，请指定就绪态探针。 在这种情况下，就绪态探针可能与存活态探针相同，但是规约中的就绪态探针的存在意味着 Pod 将在启动阶段不接收任何数据，并且只有在探针探测成功后才开始接收数据。

如果你希望容器能够自行进入维护状态，也可以指定一个就绪态探针，检查某个特定于 就绪态的因此不同于存活态探测的端点。

如果你的应用程序对后端服务有严格的依赖性，你可以同时实现存活态和就绪态探针。 当应用程序本身是健康的，存活态探针检测通过后，就绪态探针会额外检查每个所需的后端服务是否可用。 这可以帮助你避免将流量导向只能返回错误信息的 Pod。

如果你的容器需要在启动期间加载大型数据、配置文件或执行迁移，你可以使用 启动探针。 然而，如果你想区分已经失败的应用和仍在处理其启动数据的应用，你可能更倾向于使用就绪探针。

> 请注意，如果你只是想在 Pod 被删除时能够排空请求，则不一定需要使用就绪态探针； 在删除 Pod 时，Pod 会自动将自身置于未就绪状态，无论就绪态探针是否存在。 等待 Pod 中的容器停止期间，Pod 会一直处于未就绪状态。

### 何时该使用启动探针？ 

FEATURE STATE: Kubernetes v1.18 \[beta\]

对于所包含的容器需要较长时间才能启动就绪的 Pod 而言，启动探针是有用的。 你不再需要配置一个较长的存活态探测时间间隔，只需要设置另一个独立的配置选定， 对启动期间的容器执行探测，从而允许使用远远超出存活态时间间隔所允许的时长。

如果你的容器启动时间通常超出 ​`initialDelaySeconds + failureThreshold × periodSeconds`​ 总值，你应该设置一个启动探测，对存活态探针所使用的同一端点执行检查。 ​`periodSeconds` ​的默认值是 10 秒。你应该将其 ​`failureThreshold`​ 设置得足够高， 以便容器有充足的时间完成启动，并且避免更改存活态探针所使用的默认值。 这一设置有助于减少死锁状况的发生。

Pod 的终止 
--------

由于 Pod 所代表的是在集群中节点上运行的进程，当不再需要这些进程时允许其体面地 终止是很重要的。一般不应武断地使用 ​`KILL` ​信号终止它们，导致这些进程没有机会 完成清理操作。

设计的目标是令你能够请求删除进程，并且知道进程何时被终止，同时也能够确保删除 操作终将完成。当你请求删除某个 Pod 时，集群会记录并跟踪 Pod 的体面终止周期， 而不是直接强制地杀死 Pod。在存在强制关闭设施的前提下， kubelet 会尝试体面地终止 Pod。

通常情况下，容器运行时会发送一个 TERM 信号到每个容器中的主进程。 很多容器运行时都能够注意到容器镜像中 ​`STOPSIGNAL` ​的值，并发送该信号而不是 TERM。 一旦超出了体面终止限期，容器运行时会向所有剩余进程发送 KILL 信号，之后 Pod 就会被从 API 服务器 上移除。如果 ​`kubelet` ​或者容器运行时的管理服务在等待进程终止期间被重启， 集群会从头开始重试，赋予 Pod 完整的体面终止限期。

下面是一个例子：

1.  你使用 ​`kubectl` ​工具手动删除某个特定的 Pod，而该 Pod 的体面终止限期是默认值（30 秒）。
2.  API 服务器中的 Pod 对象被更新，记录涵盖体面终止限期在内 Pod 的最终死期，超出所计算时间点则认为 Pod 已死（dead）。 如果你使用 ​`kubectl describe`​ 来查验你正在删除的 Pod，该 Pod 会显示为 "Terminating" （正在终止）。 在 Pod 运行所在的节点上：​`kubelet` ​一旦看到 Pod 被标记为正在终止（已经设置了体面终止限期），​`kubelet` ​即开始本地的 Pod 关闭过程。

1.  如果 Pod 中的容器之一定义了 ​`preStop` ​回调， ​`kubelet` ​开始在容器内运行该回调逻辑。如果超出体面终止限期时，​`preStop` ​回调逻辑 仍在运行，​`kubelet` ​会请求给予该 Pod 的宽限期一次性增加 2 秒钟。

> 如果 ​`preStop` ​回调所需要的时间长于默认的体面终止限期，你必须修改 ​`terminationGracePeriodSeconds` ​属性值来使其正常工作。

3.  ​`kubelet` ​接下来触发容器运行时发送 TERM 信号给每个容器中的进程 1。

> Pod 中的容器会在不同时刻收到 TERM 信号，接收顺序也是不确定的。 如果关闭的顺序很重要，可以考虑使用 ​preStop ​回调逻辑来协调。

4.  与此同时，​`kubelet` ​启动体面关闭逻辑，控制面会将 Pod 从对应的端点列表（以及端点切片列表， 如果启用了的话）中移除，过滤条件是 Pod 被对应的 服务以某 选择算符选定。 ReplicaSets和其他工作负载资源 不再将关闭进程中的 Pod 视为合法的、能够提供服务的副本。关闭动作很慢的 Pod 也无法继续处理请求数据，因为负载均衡器（例如服务代理）已经在终止宽限期开始的时候 将其从端点列表中移除。
5.  超出终止宽限期限时，​`kubelet` ​会触发强制关闭过程。容器运行时会向 Pod 中所有容器内 仍在运行的进程发送 ​`SIGKILL` ​信号。 ​`kubelet` ​也会清理隐藏的 ​`pause` ​容器，如果容器运行时使用了这种容器的话。
6.  ​`kubelet` ​触发强制从 API 服务器上删除 Pod 对象的逻辑，并将体面终止限期设置为 0 （这意味着马上删除）。
7.  API 服务器删除 Pod 的 API 对象，从任何客户端都无法再看到该对象。

### 强制终止 Pod

> 对于某些工作负载及其 Pod 而言，强制删除很可能会带来某种破坏。

默认情况下，所有的删除操作都会附有 30 秒钟的宽限期限。 ​`kubectl delete`​ 命令支持 ​`--grace-period=<seconds>`​ 选项，允许你重载默认值， 设定自己希望的期限值。

将宽限期限强制设置为 ​`0`​ 意味着立即从 API 服务器删除 Pod。 如果 Pod 仍然运行于某节点上，强制删除操作会触发 ​`kubelet` ​立即执行清理操作。

> 你必须在设置 ​`--grace-period=0`​ 的同时额外设置 ​`--force`​ 参数才能发起强制删除请求。

执行强制删除操作时，API 服务器不再等待来自 ​`kubelet` ​的、关于 Pod 已经在原来运行的节点上终止执行的确认消息。 API 服务器直接删除 Pod 对象，这样新的与之同名的 Pod 即可以被创建。 在节点侧，被设置为立即终止的 Pod 仍然会在被强行杀死之前获得一点点的宽限时间。

### 失效 Pod 的垃圾收集 

对于已失败的 Pod 而言，对应的 API 对象仍然会保留在集群的 API 服务器上，直到 用户或者控制器进程显式地 将其删除。

控制面组件会在 Pod 个数超出所配置的阈值 （根据 ​`kube-controller-manager`​ 的 ​`terminated-pod-gc-threshold`​ 设置）时 删除已终止的 Pod（阶段值为 ​`Succeeded` ​或 ​`Failed`​）。 这一行为会避免随着时间演进不断创建和终止 Pod 而引起的资源泄露问题。

##  2.  Kubernetes Init容器
Init 容器
-------

本页提供了 Init 容器的概览。Init 容器是一种特殊容器，在 Pod 内的应用容器启动之前运行。Init 容器可以包括一些应用镜像中不存在的实用工具和安装脚本。

你可以在 Pod 的规约中与用来描述应用容器的 ​`containers` ​数组平行的位置指定 Init 容器。

理解 Init 容器
----------

每个 Pod 中可以包含多个容器， 应用运行在这些容器里面，同时 Pod 也可以有一个或多个先于应用容器启动的 Init 容器。

Init 容器与普通的容器非常像，除了如下两点：

*   它们总是运行到完成。
*   每个都必须在下一个启动之前成功完成。

如果 Pod 的 Init 容器失败，kubelet 会不断地重启该 Init 容器直到该容器成功为止。 然而，如果 Pod 对应的 ​`restartPolicy` ​值为 "Never"，并且 Pod 的 Init 容器失败， 则 Kubernetes 会将整个 Pod 状态设置为失败。

为 Pod 设置 Init 容器需要在 Pod 规约 中添加 ​`initContainers` ​字段， 该字段以 Container 类型对象数组的形式组织，和应用的 ​`containers` ​数组同级相邻。 参阅 API 参考的容器章节了解详情。

Init 容器的状态在 ​`status.initContainerStatuses`​ 字段中以容器状态数组的格式返回 （类似 ​`status.containerStatuses`​ 字段）。

### 与普通容器的不同之处 

Init 容器支持应用容器的全部字段和特性，包括资源限制、数据卷和安全设置。 然而，Init 容器对资源请求和限制的处理稍有不同，在下面资源节有说明。

同时 Init 容器不支持 ​`lifecycle`​、​`livenessProbe`​、​`readinessProbe` ​和 ​`startupProbe`​， 因为它们必须在 Pod 就绪之前运行完成。

如果为一个 Pod 指定了多个 Init 容器，这些容器会按顺序逐个运行。 每个 Init 容器必须运行成功，下一个才能够运行。当所有的 Init 容器运行完成时， Kubernetes 才会为 Pod 初始化应用容器并像平常一样运行。

使用 Init 容器
----------

因为 Init 容器具有与应用容器分离的单独镜像，其启动相关代码具有如下优势：

*   Init 容器可以包含一些安装过程中应用容器中不存在的实用工具或个性化代码。 例如，没有必要仅为了在安装过程中使用类似 ​`sed`​、​`awk`​、​`python` ​或 ​`dig` ​这样的工具而去 ​`FROM` ​一个镜像来生成一个新的镜像。
*   Init 容器可以安全地运行这些工具，避免这些工具导致应用镜像的安全性降低。
*   应用镜像的创建者和部署者可以各自独立工作，而没有必要联合构建一个单独的应用镜像。
*   Init 容器能以不同于 Pod 内应用容器的文件系统视图运行。因此，Init 容器可以访问 应用容器不能访问的 Secret 的权限。
*   由于 Init 容器必须在应用容器启动之前运行完成，因此 Init 容器 提供了一种机制来阻塞或延迟应用容器的启动，直到满足了一组先决条件。 一旦前置条件满足，Pod 内的所有的应用容器会并行启动。

### 示例 

下面是一些如何使用 Init 容器的想法：

*   等待一个 Service 完成创建，通过类似如下 shell 命令：

`for i in {1..100}; do sleep 1; if dig myservice; then exit 0; fi; done; exit 1`

*   注册这个 Pod 到远程服务器，通过在命令中调用 API，类似如下： 

`curl -X POST http://$MANAGEMENT_SERVICE_HOST:$MANAGEMENT_SERVICE_PORT/register \   -d 'instance=$(<POD_NAME>)&ip=$(<POD_IP>)'`

*   在启动应用容器之前等一段时间，使用类似命令：

`sleep 60`

*   克隆 Git 仓库到卷中。
*   将配置值放到配置文件中，运行模板工具为主应用容器动态地生成配置文件。 例如，在配置文件中存放 POD\_IP 值，并使用 Jinja 生成主应用配置文件。

### 使用 Init 容器的情况

下面的例子定义了一个具有 2 个 Init 容器的简单 Pod。 第一个等待 ​`myservice` ​启动， 第二个等待 ​`mydb` ​启动。 一旦这两个 Init容器 都启动完成，Pod 将启动 ​`spec` ​节中的应用容器。

`apiVersion: v1 kind: Pod metadata:   name: myapp-pod   labels:     app: myapp spec:   containers:   - name: myapp-container     image: busybox:1.28     command: ['sh', '-c', 'echo The app is running! && sleep 3600']   initContainers:   - name: init-myservice     image: busybox:1.28     command: ['sh', '-c', "until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done"]   - name: init-mydb     image: busybox:1.28     command: ['sh', '-c', "until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done"]`

你通过运行下面的命令启动 Pod：

`kubectl apply -f myapp.yaml`

输出类似于：

`pod/myapp-pod created`

使用下面的命令检查其状态：

`kubectl get -f myapp.yaml`

输出类似于：

`NAME        READY     STATUS     RESTARTS   AGE myapp-pod   0/1       Init:0/2   0          6m`

或者查看更多详细信息：

`kubectl describe -f myapp.yaml`

输出类似于：

`Name:          myapp-pod Namespace:     default [...] Labels:        app=myapp Status:        Pending [...] Init Containers:   init-myservice: [...]     State:         Running [...]   init-mydb: [...]     State:         Waiting       Reason:      PodInitializing     Ready:         False [...] Containers:   myapp-container: [...]     State:         Waiting       Reason:      PodInitializing     Ready:         False [...] Events:   FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message   ---------    --------    -----    ----                      -------------                           --------      ------        -------   16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201   16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image "busybox"   13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image "busybox"   13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container with docker id 5ced34a04634; Security:[seccomp=unconfined]   13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container with docker id 5ced34a04634`

如需查看 Pod 内 Init 容器的日志，请执行：

`kubectl logs myapp-pod -c init-myservice # 查看第一个 Init 容器 kubectl logs myapp-pod -c init-mydb      # 查看第二个 Init 容器`

在这一刻，Init 容器将会等待至发现名称为 ​`mydb` ​和 ​`myservice` ​的 Service。

如下为创建这些 Service 的配置文件：

`--- apiVersion: v1 kind: Service metadata:   name: myservice spec:   ports:   - protocol: TCP     port: 80     targetPort: 9376 --- apiVersion: v1 kind: Service metadata:   name: mydb spec:   ports:   - protocol: TCP     port: 80     targetPort: 9377`

创建 ​`mydb` ​和 ​`myservice` ​服务的命令：

`kubectl create -f services.yaml`

输出类似于：

`service "myservice" created service "mydb" created`

这样你将能看到这些 Init 容器执行完毕，随后 ​`my-app`​ 的 Pod 进入 ​`Running` ​状态：

`kubectl get -f myapp.yaml`

输出类似于：

`NAME        READY     STATUS    RESTARTS   AGE myapp-pod   1/1       Running   0          9m`

具体行为
----

在 Pod 启动过程中，每个 Init 容器会在网络和数据卷初始化之后按顺序启动。 kubelet 运行依据 Init 容器在 Pod 规约中的出现顺序依次运行之。

每个 Init 容器成功退出后才会启动下一个 Init 容器。 如果某容器因为容器运行时的原因无法启动，或以错误状态退出，kubelet 会根据 Pod 的 ​`restartPolicy` ​策略进行重试。 然而，如果 Pod 的 ​`restartPolicy` ​设置为 "Always"，Init 容器失败时会使用 ​`restartPolicy` ​的 "OnFailure" 策略。

在所有的 Init 容器没有成功之前，Pod 将不会变成 ​`Ready` ​状态。 Init 容器的端口将不会在 Service 中进行聚集。正在初始化中的 Pod 处于 ​`Pending` ​状态， 但会将状况 ​`Initializing` ​设置为 false。

如果 Pod 重启，所有 Init 容器必须重新执行。

对 Init 容器规约的修改仅限于容器的 ​`image` ​字段。 更改 Init 容器的 ​`image` ​字段，等同于重启该 Pod。

因为 Init 容器可能会被重启、重试或者重新执行，所以 Init 容器的代码应该是幂等的。 特别地，基于 ​`emptyDirs` ​写文件的代码，应该对输出文件可能已经存在做好准备。

Init 容器具有应用容器的所有字段。然而 Kubernetes 禁止使用 ​`readinessProbe`​， 因为 Init 容器不能定义不同于完成态（Completion）的就绪态（Readiness）。 Kubernetes 会在校验时强制执行此检查。

在 Pod 上使用 ​`activeDeadlineSeconds` ​和在容器上使用 ​`livenessProbe` ​可以避免 Init 容器一直重复失败。 ​`activeDeadlineSeconds` ​时间包含了 Init 容器启动的时间。 但建议仅在团队将其应用程序部署为 Job 时才使用 ​`activeDeadlineSeconds`​， 因为 ​`activeDeadlineSeconds` ​在 Init 容器结束后仍有效果。 如果你设置了 ​`activeDeadlineSeconds`​，已经在正常运行的 Pod 会被杀死。

在 Pod 中的每个应用容器和 Init 容器的名称必须唯一； 与任何其它容器共享同一个名称，会在校验时抛出错误。

### 资源

在给定的 Init 容器执行顺序下，资源使用适用于如下规则：

*   所有 Init 容器上定义的任何特定资源的 limit 或 request 的最大值，作为 Pod 有效初始 request/limit。 如果任何资源没有指定资源限制，这被视为最高限制。
*   Pod 对资源的 有效 limit/request 是如下两者的较大者：

*   所有应用容器对某个资源的 limit/request 之和
*   对某个资源的有效初始 limit/request

*   基于有效 limit/request 完成调度，这意味着 Init 容器能够为初始化过程预留资源， 这些资源在 Pod 生命周期过程中并没有被使用。
*   Pod 的 有效 QoS 层 ，与 Init 容器和应用容器的一样。

配额和限制适用于有效 Pod 的请求和限制值。 Pod 级别的 cgroups 是基于有效 Pod 的请求和限制值，和调度器相同。

### Pod 重启的原因 

Pod 重启会导致 Init 容器重新执行，主要有如下几个原因：

*   Pod 的基础设施容器 (译者注：如 ​`pause` ​容器) 被重启。这种情况不多见， 必须由具备 root 权限访问节点的人员来完成。
*   当 ​`restartPolicy` ​设置为 "​`Always`​"，Pod 中所有容器会终止而强制重启。 由于垃圾收集机制的原因，Init 容器的完成记录将会丢失。

当 Init 容器的镜像发生改变或者 Init 容器的完成记录因为垃圾收集等原因被丢失时， Pod 不会被重启。这一行为适用于 Kubernetes v1.20 及更新版本。如果你在使用较早 版本的 Kubernetes，可查阅你所使用的版本对应的文档。

##  3.  Kubernetes Pod拓扑分布约束
Pod 拓扑分布约束
----------

FEATURE STATE: Kubernetes v1.19 \[stable\]

你可以使用 拓扑分布约束（Topology Spread Constraints） 来控制 Pods 在集群内故障域 之间的分布，例如区域（Region）、可用区（Zone）、节点和其他用户自定义拓扑域。 这样做有助于实现高可用并提升资源利用率。

先决条件 
-----

### 节点标签 

拓扑分布约束依赖于节点标签来标识每个节点所在的拓扑域。 例如，某节点可能具有标签：​`node=node1,zone=us-east-1a,region=us-east-1` ​

假设你拥有具有以下标签的一个 4 节点集群：

`NAME    STATUS   ROLES    AGE     VERSION   LABELS node1   Ready    <none>   4m26s   v1.16.0   node=node1,zone=zoneA node2   Ready    <none>   3m58s   v1.16.0   node=node2,zone=zoneA node3   Ready    <none>   3m17s   v1.16.0   node=node3,zone=zoneB node4   Ready    <none>   2m43s   v1.16.0   node=node4,zone=zoneB`

那么，从逻辑上看集群如下：

  ![](https://atts.w3cschool.cn/attachments/image/20220429/1651214186740469.png)  

你可以复用在大多数集群上自动创建和填充的常用标签， 而不是手动添加标签。

Pod 的分布约束 
----------

### API

​`pod.spec.topologySpreadConstraints`​ 字段定义如下所示：

`apiVersion: v1 kind: Pod metadata:   name: mypod spec:   topologySpreadConstraints:     - maxSkew: <integer>       topologyKey: <string>       whenUnsatisfiable: <string>       labelSelector: <object>`

你可以定义一个或多个 ​`topologySpreadConstraint`​ 来指示 kube-scheduler 如何根据与现有的 Pod 的关联关系将每个传入的 Pod 部署到集群中。字段包括：

*   maxSkew 描述 Pod 分布不均的程度。这是给定拓扑类型中任意两个拓扑域中 匹配的 pod 之间的最大允许差值。它必须大于零。取决于 ​`whenUnsatisfiable` ​的 取值，其语义会有不同。

*   当 ​`whenUnsatisfiable` ​等于 "DoNotSchedule" 时，​`maxSkew` ​是目标拓扑域 中匹配的 Pod 数与全局最小值之间可存在的差异。
*   当 ​`whenUnsatisfiable` ​等于 "ScheduleAnyway" 时，调度器会更为偏向能够降低 偏差值的拓扑域。

*   topologyKey 是节点标签的键。如果两个节点使用此键标记并且具有相同的标签值， 则调度器会将这两个节点视为处于同一拓扑域中。调度器试图在每个拓扑域中放置数量 均衡的 Pod。
*   whenUnsatisfiable 指示如果 Pod 不满足分布约束时如何处理：

*   ​`DoNotSchedule`​（默认）告诉调度器不要调度。
*   ​`ScheduleAnyway` ​告诉调度器仍然继续调度，只是根据如何能将偏差最小化来对 节点进行排序。

*   labelSelector 用于查找匹配的 pod。匹配此标签的 Pod 将被统计，以确定相应 拓扑域中 Pod 的数量。

当 Pod 定义了不止一个 ​`topologySpreadConstraint`​，这些约束之间是逻辑与的关系。 kube-scheduler 会为新的 Pod 寻找一个能够满足所有约束的节点。

你可以执行 ​`kubectl explain Pod.spec.topologySpreadConstraints`​ 命令以 了解关于 topologySpreadConstraints 的更多信息。

### 例子：单个 TopologySpreadConstraint

假设你拥有一个 4 节点集群，其中标记为 ​`foo:bar`​ 的 3 个 Pod 分别位于 node1、node2 和 node3 中：

![](https://atts.w3cschool.cn/attachments/image/20220429/1651214227197110.png)  

如果希望新来的 Pod 均匀分布在现有的可用区域，则可以按如下设置其规约：

`kind: Pod apiVersion: v1 metadata:   name: mypod   labels:     foo: bar spec:   topologySpreadConstraints:   - maxSkew: 1     topologyKey: zone     whenUnsatisfiable: DoNotSchedule     labelSelector:       matchLabels:         foo: bar   containers:   - name: pause     image: k8s.gcr.io/pause:3.1`

​`topologyKey: zone`​ 意味着均匀分布将只应用于存在标签键值对为 "zone:<any value>" 的节点。 ​`whenUnsatisfiable: DoNotSchedule`​ 告诉调度器如果新的 Pod 不满足约束， 则让它保持悬决状态。

如果调度器将新的 Pod 放入 "zoneA"，Pods 分布将变为 \[3, 1\]，因此实际的偏差 为 2（3 - 1）。这违反了 ​`maxSkew: 1`​ 的约定。此示例中，新 Pod 只能放置在 "zoneB" 上：

![](https://atts.w3cschool.cn/attachments/image/20220429/1651214242600816.png)  

或者

![](https://atts.w3cschool.cn/attachments/image/20220429/1651214261240538.png)

你可以调整 Pod 规约以满足各种要求：

*   将 ​`maxSkew` ​更改为更大的值，比如 "2"，这样新的 Pod 也可以放在 "zoneA" 上。
*   将 ​`topologyKey` ​更改为 "node"，以便将 Pod 均匀分布在节点上而不是区域中。 在上面的例子中，如果 ​`maxSkew` ​保持为 "1"，那么传入的 Pod 只能放在 "node4" 上。
*   将 ​`whenUnsatisfiable: DoNotSchedule`​ 更改为 ​`whenUnsatisfiable: ScheduleAnyway`​， 以确保新的 Pod 始终可以被调度（假设满足其他的调度 API）。 但是，最好将其放置在匹配 Pod 数量较少的拓扑域中。 （请注意，这一优先判定会与其他内部调度优先级（如资源使用率等）排序准则一起进行标准化。）

### 例子：多个 TopologySpreadConstraints

下面的例子建立在前面例子的基础上。假设你拥有一个 4 节点集群，其中 3 个标记为 ​`foo:bar`​ 的 Pod 分别位于 node1、node2 和 node3 上：

![](https://atts.w3cschool.cn/attachments/image/20220429/1651214728456296.png)  

可以使用 2 个 TopologySpreadConstraint 来控制 Pod 在 区域和节点两个维度上的分布：

`kind: Pod apiVersion: v1 metadata:   name: mypod   labels:     foo: bar spec:   topologySpreadConstraints:   - maxSkew: 1     topologyKey: zone     whenUnsatisfiable: DoNotSchedule     labelSelector:       matchLabels:         foo: bar   - maxSkew: 1     topologyKey: node     whenUnsatisfiable: DoNotSchedule     labelSelector:       matchLabels:         foo: bar   containers:   - name: pause     image: k8s.gcr.io/pause:3.1`

在这种情况下，为了匹配第一个约束，新的 Pod 只能放置在 "zoneB" 中；而在第二个约束中， 新的 Pod 只能放置在 "node4" 上。最后两个约束的结果加在一起，唯一可行的选择是放置 在 "node4" 上。

多个约束之间可能存在冲突。假设有一个跨越 2 个区域的 3 节点集群：

![](https://atts.w3cschool.cn/attachments/image/20220429/1651214747235932.png)  

如果对集群应用 "two-constraints.yaml"，会发现 "mypod" 处于 ​`Pending` ​状态。 这是因为：为了满足第一个约束，"mypod" 只能放在 "zoneB" 中，而第二个约束要求 "mypod" 只能放在 "node2" 上。Pod 调度无法满足两种约束。

为了克服这种情况，你可以增加 ​`maxSkew` ​或修改其中一个约束，让其使用 ​`whenUnsatisfiable: ScheduleAnyway`​。

### 节点亲和性与节点选择器的相互作用 

如果 Pod 定义了 ​`spec.nodeSelector`​ 或 ​`spec.affinity.nodeAffinity`​， 调度器将在偏差计算中跳过不匹配的节点。

### 示例：TopologySpreadConstraints 与 NodeAffinity

假设你有一个跨越 zoneA 到 zoneC 的 5 节点集群：

![](https://atts.w3cschool.cn/attachments/image/20220429/1651214762408272.png)  

![](https://atts.w3cschool.cn/attachments/image/20220429/1651214786255141.png)  

而且你知道 "zoneC" 必须被排除在外。在这种情况下，可以按如下方式编写 YAML， 以便将 "mypod" 放置在 "zoneB" 上，而不是 "zoneC" 上。同样，​`spec.nodeSelector`​ 也要一样处理。

`kind: Pod apiVersion: v1 metadata:   name: mypod   labels:     foo: bar spec:   topologySpreadConstraints:   - maxSkew: 1     topologyKey: zone     whenUnsatisfiable: DoNotSchedule     labelSelector:       matchLabels:         foo: bar   affinity:     nodeAffinity:       requiredDuringSchedulingIgnoredDuringExecution:         nodeSelectorTerms:         - matchExpressions:           - key: zone             operator: NotIn             values:             - zoneC   containers:   - name: pause     image: k8s.gcr.io/pause:3.1`

调度器不会预先知道集群拥有的所有区域和其他拓扑域。拓扑域由集群中存在的节点确定。 在自动伸缩的集群中，如果一个节点池（或节点组）的节点数量为零， 而用户正期望其扩容时，可能会导致调度出现问题。 因为在这种情况下，调度器不会考虑这些拓扑域信息，因为它们是空的，没有节点。

### 其他值得注意的语义 

这里有一些值得注意的隐式约定：

*   只有与新的 Pod 具有相同命名空间的 Pod 才能作为匹配候选者。
*   调度器会忽略没有 topologySpreadConstraints\[\*\].topologyKey 的节点。这意味着：

1.  位于这些节点上的 Pod 不影响 maxSkew 的计算。 在上面的例子中，假设 "node1" 没有标签 "zone"，那么 2 个 Pod 将被忽略， 因此传入的 Pod 将被调度到 "zoneA" 中。
2.  新的 Pod 没有机会被调度到这类节点上。 在上面的例子中，假设一个带有标签 {zone-typo: zoneC} 的 "node5" 加入到集群， 它将由于没有标签键 "zone" 而被忽略。

*   注意，如果新 Pod 的 topologySpreadConstraints\[\*\].labelSelector 与自身的 标签不匹配，将会发生什么。 在上面的例子中，如果移除新 Pod 上的标签，Pod 仍然可以调度到 "zoneB"，因为约束仍然满足。 然而，在调度之后，集群的不平衡程度保持不变。zoneA 仍然有 2 个带有 {foo:bar} 标签的 Pod， zoneB 有 1 个带有 {foo:bar} 标签的 Pod。 因此，如果这不是你所期望的，建议工作负载的 topologySpreadConstraints\[\*\].labelSelector 与其自身的标签匹配。

### 集群级别的默认约束 

为集群设置默认的拓扑分布约束也是可能的。默认拓扑分布约束在且仅在以下条件满足 时才会应用到 Pod 上：

*   Pod 没有在其 ​`.spec.topologySpreadConstraints`​ 设置任何约束；
*   Pod 隶属于某个服务、副本控制器、ReplicaSet 或 StatefulSet。

你可以在 调度方案（Scheduling Profile） 中将默认约束作为 ​`PodTopologySpread` ​插件参数的一部分来设置。 约束的设置采用如前所述的 API，只是 ​`labelSelector` ​必须为空。 选择算符是根据 Pod 所属的服务、副本控制器、ReplicaSet 或 StatefulSet 来设置的。

配置的示例可能看起来像下面这个样子：

`apiVersion: kubescheduler.config.k8s.io/v1beta3 kind: KubeSchedulerConfiguration  profiles:   - schedulerName: default-scheduler     pluginConfig:       - name: PodTopologySpread         args:           defaultConstraints:             - maxSkew: 1               topologyKey: topology.kubernetes.io/zone               whenUnsatisfiable: ScheduleAnyway           defaultingType: List`

> 默认调度约束所生成的评分可能与 SelectorSpread 插件 所生成的评分有冲突。 建议你在为 ​`PodTopologySpread` ​设置默认约束是禁用调度方案中的该插件。

### 内部默认约束 

FEATURE STATE: Kubernetes v1.20 \[beta\]

当你使用了默认启用的 ​`DefaultPodTopologySpread`​ 特性门控时，原来的 ​`SelectorSpread` ​插件会被禁用。 kube-scheduler 会使用下面的默认拓扑约束作为 ​`PodTopologySpread` ​插件的 配置：

`defaultConstraints:   - maxSkew: 3     topologyKey: "kubernetes.io/hostname"     whenUnsatisfiable: ScheduleAnyway   - maxSkew: 5     topologyKey: "topology.kubernetes.io/zone"     whenUnsatisfiable: ScheduleAnyway`

此外，原来用于提供等同行为的 ​`SelectorSpread` ​插件也会被禁用。

> 对于分布约束中所指定的拓扑键而言，​`PodTopologySpread` ​插件不会为不包含这些主键的节点评分。 这可能导致在使用默认拓扑约束时，其行为与原来的 ​`SelectorSpread` ​插件的默认行为不同，  
>   
> 如果你的节点不会 同时 设置 ​`kubernetes.io/hostname`​ 和 ​`topology.kubernetes.io/zone`​ 标签，你应该定义自己的约束而不是使用 Kubernetes 的默认约束。

如果你不想为集群使用默认的 Pod 分布约束，你可以通过设置 ​`defaultingType` ​参数为 ​`List` ​并将 ​`PodTopologySpread` ​插件配置中的 ​`defaultConstraints` ​参数置空来禁用默认 Pod 分布约束。

`apiVersion: kubescheduler.config.k8s.io/v1beta3 kind: KubeSchedulerConfiguration  profiles:   - schedulerName: default-scheduler     pluginConfig:       - name: PodTopologySpread         args:           defaultConstraints: []           defaultingType: List`

    

与 PodAffinity/PodAntiAffinity 相比较
---------------------------------

在 Kubernetes 中，与“亲和性”相关的指令控制 Pod 的调度方式（更密集或更分散）。

*   对于 ​`PodAffinity`​，你可以尝试将任意数量的 Pod 集中到符合条件的拓扑域中。
*   对于 ​`PodAntiAffinity`​，只能将一个 Pod 调度到某个拓扑域中。

要实现更细粒度的控制，你可以设置拓扑分布约束来将 Pod 分布到不同的拓扑域下， 从而实现高可用性或节省成本。这也有助于工作负载的滚动更新和平稳地扩展副本规模。

已知局限性
-----

*   当 Pod 被移除时，无法保证约束仍被满足。例如，缩减某 Deployment 的规模时， Pod 的分布可能不再均衡。 你可以使用 Descheduler 来重新实现 Pod 分布的均衡。
*   具有污点的节点上匹配的 Pods 也会被统计。 参考 [Issue 80921](https://github.com/kubernetes/kubernetes/issues/80921)。

##  4.  Kubernetes 干扰（Disruptions）
干扰（Disruptions）
---------------

本指南针对的是希望构建高可用性应用程序的应用所有者，他们有必要了解可能发生在 Pod 上的干扰类型。

文档同样适用于想要执行自动化集群操作（例如升级和自动扩展集群）的集群管理员。

自愿干扰和非自愿干扰 
-----------

Pod 不会消失，除非有人（用户或控制器）将其销毁，或者出现了不可避免的硬件或软件系统错误。

我们把这些不可避免的情况称为应用的非自愿干扰（Involuntary Disruptions）。例如：

*   节点下层物理机的硬件故障
*   集群管理员错误地删除虚拟机（实例）
*   云提供商或虚拟机管理程序中的故障导致的虚拟机消失
*   内核错误
*   节点由于集群网络隔离从集群中消失
*   由于节点资源不足导致 pod 被驱逐。

除了资源不足的情况，大多数用户应该都熟悉这些情况；它们不是特定于 Kubernetes 的。

我们称其他情况为自愿干扰（Voluntary Disruptions）。 包括由应用程序所有者发起的操作和由集群管理员发起的操作。典型的应用程序所有者的操 作包括：

*   删除 Deployment 或其他管理 Pod 的控制器
*   更新了 Deployment 的 Pod 模板导致 Pod 重启
*   直接删除 Pod（例如，因为误操作）

集群管理员操作包括：

*   排空（drain）节点进行修复或升级。
*   从集群中排空节点以缩小集群（了解集群自动扩缩）。
*   从节点中移除一个 Pod，以允许其他 Pod 使用该节点。

这些操作可能由集群管理员直接执行，也可能由集群管理员所使用的自动化工具执行，或者由集群托管提供商自动执行。

咨询集群管理员或联系云提供商，或者查询发布文档，以确定是否为集群启用了任何资源干扰源。 如果没有启用，可以不用创建 Pod Disruption Budgets（Pod 干扰预算）

> 并非所有的自愿干扰都会受到 Pod 干扰预算的限制。 例如，删除 Deployment 或 Pod 的删除操作就会跳过 Pod 干扰预算检查。

处理干扰
----

以下是减轻非自愿干扰的一些方法：

*   确保 Pod 在请求中给出所需资源。
*   如果需要更高的可用性，请复制应用程序。
*   为了在运行复制应用程序时获得更高的可用性，请跨机架（使用 反亲和性 或跨区域（如果使用多区域集群）扩展应用程序。

自愿干扰的频率各不相同。在一个基本的 Kubernetes 集群中，没有自愿干扰（只有用户触发的干扰）。 然而，集群管理员或托管提供商可能运行一些可能导致自愿干扰的额外服务。例如，节点软 更新可能导致自愿干扰。另外，集群（节点）自动缩放的某些 实现可能导致碎片整理和紧缩节点的自愿干扰。集群 管理员或托管提供商应该已经记录了各级别的自愿干扰（如果有的话）。 有些配置选项，例如在 pod spec 中 使用 PriorityClasses 也会产生自愿（和非自愿）的干扰。

Kubernetes 提供特性来满足在出现频繁自愿干扰的同时运行高可用的应用程序。我们称这些特性为 干扰预算（Disruption Budget）。

干扰预算 
-----

FEATURE STATE: Kubernetes v1.21 \[stable\]

即使你会经常引入自愿性干扰，Kubernetes 也能够支持你运行高度可用的应用。

应用程序所有者可以为每个应用程序创建 ​`PodDisruptionBudget` ​对象（PDB）。 PDB 将限制在同一时间因自愿干扰导致的复制应用程序中宕机的 pod 数量。 例如，基于票选机制的应用程序希望确保运行的副本数永远不会低于仲裁所需的数量。 Web 前端可能希望确保提供负载的副本数量永远不会低于总数的某个百分比。

集群管理员和托管提供商应该使用遵循 PodDisruptionBudgets 的接口 （通过调用Eviction API）， 而不是直接删除 Pod 或 Deployment。

例如，​`kubectl drain`​ 命令可以用来标记某个节点即将停止服务。 运行 ​`kubectl drain`​ 命令时，工具会尝试驱逐机器上的所有 Pod。 ​`kubectl` ​所提交的驱逐请求可能会暂时被拒绝，所以该工具会定时重试失败的请求， 直到所有的 Pod 都被终止，或者达到配置的超时时间。

PDB 指定应用程序可以容忍的副本数量（相当于应该有多少副本）。 例如，具有 ​`.spec.replicas: 5`​ 的 Deployment 在任何时间都应该有 5 个 Pod。 如果 PDB 允许其在某一时刻有 4 个副本，那么驱逐 API 将允许同一时刻仅有一个而不是两个 Pod 自愿干扰。

使用标签选择器来指定构成应用程序的一组 Pod，这与应用程序的控制器（Deployment，StatefulSet 等） 选择 Pod 的逻辑一样。

Pod 控制器的 ​`.spec.replicas`​ 计算“预期的” Pod 数量。 根据 Pod 对象的 ​`.metadata.ownerReferences`​ 字段来发现控制器。

PDB 无法防止非自愿干扰； 但它们确实计入预算。

由于应用程序的滚动升级而被删除或不可用的 Pod 确实会计入干扰预算， 但是控制器（如 Deployment 和 StatefulSet）在进行滚动升级时不受 PDB 的限制。应用程序更新期间的故障处理方式是在对应的工作负载资源的 ​`spec` ​中配置的。

当使用驱逐 API 驱逐 Pod 时，Pod 会被体面地 终止，期间会 参考 [PodSpec](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/ target=) 中的 ​`terminationGracePeriodSeconds` ​配置值。

PDB 例子 
-------

假设集群有 3 个节点，​`node-1`​ 到 ​`node-3`​。集群上运行了一些应用。 其中一个应用有 3 个副本，分别是 ​`pod-a`​，​`pod-b`​ 和 ​`pod-c`​。 另外，还有一个不带 PDB 的无关 pod ​`pod-x`​ 也同样显示出来。 最初，所有的 Pod 分布如下：

node-1

node-2

node-3

pod-a _available_

pod-b _available_

pod-c _available_

pod-x _available_

3 个 Pod 都是 deployment 的一部分，并且共同拥有同一个 PDB，要求 3 个 Pod 中至少有 2 个 Pod 始终处于可用状态。

例如，假设集群管理员想要重启系统，升级内核版本来修复内核中的权限。 集群管理员首先使用 ​`kubectl drain`​ 命令尝试排空 ​`node-1`​ 节点。 命令尝试驱逐 ​`pod-a`​ 和 ​`pod-x`​。操作立即就成功了。 两个 Pod 同时进入 ​`terminating` ​状态。这时的集群处于下面的状态：

node-1 _draining_

node-2

node-3

pod-a _terminating_

pod-b _available_

pod-c _available_

pod-x _terminating_

Deployment 控制器观察到其中一个 Pod 正在终止，因此它创建了一个替代 Pod ​`pod-d`​。 由于 ​`node-1`​ 被封锁（cordon），​`pod-d`​ 落在另一个节点上。 同样其他控制器也创建了 ​`pod-y`​ 作为 ​`pod-x`​ 的替代品。

（注意：对于 StatefulSet 来说，​`pod-a`​（也称为 ​`pod-0`​）需要在替换 Pod 创建之前完全终止， 替代它的也称为 ​`pod-0`​，但是具有不同的 UID。除此之外，此示例也适用于 StatefulSet。）

当前集群的状态如下：

node-1 _draining_

node-2

node-3

pod-a _terminating_

pod-b _available_

pod-c _available_

pod-x _terminating_

pod-d _starting_

pod-y

在某一时刻，Pod 被终止，集群如下所示：

node-1 _drained_

node-2

node-3

pod-b _available_

pod-c _available_

pod-d _starting_

pod-y

此时，如果一个急躁的集群管理员试图排空（drain）​`node-2`​ 或 ​`node-3`​，drain 命令将被阻塞， 因为对于 Deployment 来说只有 2 个可用的 Pod，并且它的 PDB 至少需要 2 个。 经过一段时间，​`pod-d`​ 变得可用。

集群状态如下所示：

node-1 _drained_

node-2

node-3

pod-b _available_

pod-c _available_

pod-d _available_

pod-y

现在，集群管理员试图排空（drain）​`node-2`​。 drain 命令将尝试按照某种顺序驱逐两个 Pod，假设先是 ​`pod-b`​，然后是 ​`pod-d`​。 命令成功驱逐 ​`pod-b`​，但是当它尝试驱逐 ​`pod-d`​时将被拒绝，因为对于 Deployment 来说只剩一个可用的 Pod 了。

Deployment 创建 ​`pod-b`​ 的替代 Pod ​`pod-e`​。 因为集群中没有足够的资源来调度 ​`pod-e`​，drain 命令再次阻塞。集群最终将是下面这种状态：

node-1 _drained_

node-2

node-3

_no node_

pod-b _terminating_

pod-c _available_

pod-e _pending_

pod-d _available_

pod-y

此时，集群管理员需要增加一个节点到集群中以继续升级操作。

可以看到 Kubernetes 如何改变干扰发生的速率，根据：

*   应用程序需要多少个副本
*   优雅关闭应用实例需要多长时间
*   启动应用新实例需要多长时间
*   控制器的类型
*   集群的资源能力

分离集群所有者和应用所有者角色
---------------

通常，将集群管理者和应用所有者视为彼此了解有限的独立角色是很有用的。这种责任分离在下面这些场景下是有意义的：

*   当有许多应用程序团队共用一个 Kubernetes 集群，并且有自然的专业角色
*   当第三方工具或服务用于集群自动化管理

Pod 干扰预算通过在角色之间提供接口来支持这种分离。

如果你的组织中没有这样的责任分离，则可能不需要使用 Pod 干扰预算。

如何在集群上执行干扰性操作
-------------

如果你是集群管理员，并且需要对集群中的所有节点执行干扰操作，例如节点或系统软件升级，则可以使用以下选项

*   接受升级期间的停机时间。
*   故障转移到另一个完整的副本集群。

*   没有停机时间，但是对于重复的节点和人工协调成本可能是昂贵的。

*   编写可容忍干扰的应用程序和使用 PDB。

*   不停机。
*   最小的资源重复。
*   允许更多的集群管理自动化。
*   编写可容忍干扰的应用程序是棘手的，但对于支持容忍自愿干扰所做的工作，和支持自动扩缩和容忍非 自愿干扰所做工作相比，有大量的重叠

##  5.  Kubernetes 临时容器
临时容器
----

FEATURE STATE: Kubernetes v1.23 \[beta\]

本页面概述了临时容器：一种特殊的容器，该容器在现有 Pod 中临时运行，以便完成用户发起的操作，例如故障排查。 你会使用临时容器来检查服务，而不是用它来构建应用程序。

了解临时容器 
-------

Pod 是 Kubernetes 应用程序的基本构建块。 由于 Pod 是一次性且可替换的，因此一旦 Pod 创建，就无法将容器加入到 Pod 中。 取而代之的是，通常使用 Deployment 以受控的方式来删除并替换 Pod。

有时有必要检查现有 Pod 的状态。例如，对于难以复现的故障进行排查。 在这些场景中，可以在现有 Pod 中运行临时容器来检查其状态并运行任意命令。

### 什么是临时容器？ 

临时容器与其他容器的不同之处在于，它们缺少对资源或执行的保证，并且永远不会自动重启， 因此不适用于构建应用程序。 临时容器使用与常规容器相同的 ​`ContainerSpec` ​节来描述，但许多字段是不兼容和不允许的。

*   临时容器没有端口配置，因此像 ​`ports`​，​`livenessProbe`​，​`readinessProbe` ​这样的字段是不允许的。
*   Pod 资源分配是不可变的，因此 ​`resources` ​配置是不允许的。
*   有关允许字段的完整列表，请参见 [EphemeralContainer 参考文档](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/ target=)。

临时容器是使用 API 中的一种特殊的 ​`ephemeralcontainers`​ 处理器进行创建的， 而不是直接添加到 ​`pod.spec`​ 段，因此无法使用 ​`kubectl edit`​ 来添加一个临时容器。

与常规容器一样，将临时容器添加到 Pod 后，将不能更改或删除临时容器。

临时容器的用途 
--------

当由于容器崩溃或容器镜像不包含调试工具而导致 ​`kubectl exec`​ 无用时， 临时容器对于交互式故障排查很有用。

尤其是，[Distroless 镜像](https://github.com/GoogleContainerTools/distroless) 允许用户部署最小的容器镜像，从而减少攻击面并减少故障和漏洞的暴露。 由于 distroless 镜像不包含 Shell 或任何的调试工具，因此很难单独使用 ​`kubectl exec`​ 命令进行故障排查。

使用临时容器时，启用 进程名字空间共享 很有帮助，可以查看其他容器中的进程。

#  8.  Kubernetes 工作负载资源

##  1.  Kubernetes Deployments
Deployments
-----------

一个 Deployment 为 Pod 和 ReplicaSet 提供声明式的更新能力。

你负责描述 Deployment 中的 目标状态，而 Deployment 控制器（Controller） 以受控速率更改实际状态， 使其变为期望状态。你可以定义 Deployment 以创建新的 ReplicaSet，或删除现有 Deployment， 并通过新的 Deployment 收养其资源。

> 不要管理 Deployment 所拥有的 ReplicaSet 。 如果存在下面未覆盖的使用场景，请考虑在 Kubernetes 仓库中提出 Issue。

用例
--

以下是 Deployments 的典型用例：

*   创建 Deployment 以将 ReplicaSet 上线。 ReplicaSet 在后台创建 Pods。 检查 ReplicaSet 的上线状态，查看其是否成功。
*   通过更新 Deployment 的 PodTemplateSpec，声明 Pod 的新状态 。 新的 ReplicaSet 会被创建，Deployment 以受控速率将 Pod 从旧 ReplicaSet 迁移到新 ReplicaSet。 每个新的 ReplicaSet 都会更新 Deployment 的修订版本。
*   如果 Deployment 的当前状态不稳定，回滚到较早的 Deployment 版本。 每次回滚都会更新 Deployment 的修订版本。
*   扩大 Deployment 规模以承担更多负载。
*   暂停 Deployment 以应用对 PodTemplateSpec 所作的多项修改， 然后恢复其执行以启动新的上线版本。
*   使用 Deployment 状态 来判定上线过程是否出现停滞。
*   清理较旧的不再需要的 ReplicaSet 。

创建 Deployment 
--------------

下面是一个 Deployment 示例。其中创建了一个 ReplicaSet，负责启动三个 ​`nginx`​ Pods：

`apiVersion: apps/v1 kind: Deployment metadata:   name: nginx-deployment   labels:     app: nginx spec:   replicas: 3   selector:     matchLabels:       app: nginx   template:     metadata:       labels:         app: nginx     spec:       containers:       - name: nginx         image: nginx:1.14.2         ports:         - containerPort: 80`

在该例中：

*   创建名为 ​`nginx-deployment`​（由 ​`.metadata.name`​ 字段标明）的 Deployment。
*   该 Deployment 创建三个（由 ​`replicas` ​字段标明）Pod 副本。
*   ​`selector` ​字段定义 Deployment 如何查找要管理的 Pods。 在这里，你选择在 Pod 模板中定义的标签（​`app: nginx`​）。 不过，更复杂的选择规则是也可能的，只要 Pod 模板本身满足所给规则即可。

> ​`spec.selector.matchLabels`​ 字段是 ​`{key,value}`​ 键值对映射。 在 ​`matchLabels` ​映射中的每个 ​`{key,value}`​ 映射等效于 ​`matchExpressions` ​中的一个元素， 即其 ​`key` ​字段是 “key”，​`operator` ​为 “In”，​`values` ​数组仅包含 “value”。 在 ​`matchLabels` ​和 ​`matchExpressions` ​中给出的所有条件都必须满足才能匹配。

*   ​`template` ​字段包含以下子字段：

*   Pod 被使用 ​`.metadata.labels`​ 字段打上 ​`app: nginx`​ 标签。
*   Pod 模板规约（即 ​`.template.spec`​ 字段）指示 Pods 运行一个 ​`nginx` ​容器， 该容器运行版本为 1.14.2 的 ​`nginx` [​Docker Hub](https://hub.docker.com/)镜像。
*   创建一个容器并使用 ​`.spec.template.spec.containers[0].name`​ 字段将其命名为 ​`nginx`​。

开始之前，请确保的 Kubernetes 集群已启动并运行。 按照以下步骤创建上述 Deployment ：

1.  通过运行以下命令创建 Deployment ：

`kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml`

3.  运行 ​`kubectl get deployments`​ 检查 Deployment 是否已创建。 如果仍在创建 Deployment，则输出类似于：

`NAME               READY   UP-TO-DATE   AVAILABLE   AGE nginx-deployment   0/3     0            0           1s`

在检查集群中的 Deployment 时，所显示的字段有：

*   ​`NAME` ​列出了集群中 Deployment 的名称。
*   ​`READY` ​显示应用程序的可用的“副本”数。显示的模式是“就绪个数/期望个数”。
*   ​`UP-TO-DATE`​ 显示为了达到期望状态已经更新的副本数。
*   ​`AVAILABLE` ​显示应用可供用户使用的副本数。
*   ​`AGE` ​显示应用程序运行的时间。

请注意期望副本数是根据 ​`.spec.replicas`​ 字段设置 3。

8.  要查看 Deployment 上线状态，运行 kubectl rollout status deployment/nginx-deployment。

输出类似于：

`Waiting for rollout to finish: 2 out of 3 new replicas have been updated... deployment "nginx-deployment" successfully rolled out`

11.  几秒钟后再次运行 ​`kubectl get deployments`​。输出类似于：

`NAME               READY   UP-TO-DATE   AVAILABLE   AGE nginx-deployment   3/3     3            3           18s`

注意 Deployment 已创建全部三个副本，并且所有副本都是最新的（它们包含最新的 Pod 模板） 并且可用。

14.  要查看 Deployment 创建的 ReplicaSet（​`rs`​），运行 ​`kubectl get rs`​。 输出类似于：

`NAME                          DESIRED   CURRENT   READY   AGE nginx-deployment-75675f5897   3         3         3       18s`

ReplicaSet 输出中包含以下字段：

*   ​`NAME` ​列出名字空间中 ReplicaSet 的名称；
*   ​`DESIRED` ​显示应用的期望副本个数，即在创建 Deployment 时所定义的值。 此为期望状态；
*   ​`CURRENT` ​显示当前运行状态中的副本个数；
*   ​`READY` ​显示应用中有多少副本可以为用户提供服务；
*   ​`AGE` ​显示应用已经运行的时间长度。

注意 ReplicaSet 的名称始终被格式化为​`[Deployment名称]-[随机字符串]`​。 其中的随机字符串是使用 ​`pod-template-hash`​ 作为种子随机生成的。

19.  要查看每个 Pod 自动生成的标签，运行 ​`kubectl get pods --show-labels`​。返回以下输出：

`NAME                                READY     STATUS    RESTARTS   AGE       LABELS nginx-deployment-75675f5897-7ci7o   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453 nginx-deployment-75675f5897-kzszj   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453 nginx-deployment-75675f5897-qqcnn   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453`

所创建的 ReplicaSet 确保总是存在三个 ​`nginx` ​Pod。

> 你必须在 Deployment 中指定适当的选择算符和 Pod 模板标签（在本例中为 ​`app: nginx`​）。 标签或者选择算符不要与其他控制器（包括其他 Deployment 和 StatefulSet）重叠。 Kubernetes 不会阻止你这样做，但是如果多个控制器具有重叠的选择算符， 它们可能会发生冲突执行难以预料的操作。

### Pod-template-hash 标签 

> 不要更改此标签。

Deployment 控制器将 ​`pod-template-hash`​ 标签添加到 Deployment 所创建或收留的每个 ReplicaSet 。

此标签可确保 Deployment 的子 ReplicaSets 不重叠。 标签是通过对 ReplicaSet 的 ​`PodTemplate` ​进行哈希处理。 所生成的哈希值被添加到 ReplicaSet 选择算符、Pod 模板标签，并存在于在 ReplicaSet 可能拥有的任何现有 Pod 中。

更新 Deployment 
--------------

> 仅当 Deployment Pod 模板（即 ​`.spec.template`​）发生改变时，例如模板的标签或容器镜像被更新， 才会触发 Deployment 上线。其他更新（如对 Deployment 执行扩缩容的操作）不会触发上线动作。

按照以下步骤更新 Deployment：

1.  先来更新 nginx Pod 以使用 ​`nginx:1.16.1`​ 镜像，而不是 ​`nginx:1.14.2`​ 镜像。

`kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1`

或者使用下面的命令：

`kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1`

输出类似于：

`deployment/nginx-deployment image updated`

或者，可以对 Deployment 执行 ​`edit` ​操作并将 ​`.spec.template.spec.containers[0].image`​ 从 ​`nginx:1.14.2`​ 更改至 ​`nginx:1.16.1`​。

`kubectl edit deployment/nginx-deployment`

输出类似于：

`deployment/nginx-deployment edited`

11.  要查看上线状态，运行：

`kubectl rollout status deployment/nginx-deployment`

输出类似于：

`Waiting for rollout to finish: 2 out of 3 new replicas have been updated...`

或者

`deployment "nginx-deployment" successfully rolled out`

获取关于已更新的 Deployment 的更多信息：

*   在上线成功后，可以通过运行 ​`kubectl get deployments`​ 来查看 Deployment： 输出类似于：

`NAME               READY   UP-TO-DATE   AVAILABLE   AGE nginx-deployment   3/3     3            3           36s`

*   运行 ​`kubectl get rs`​ 以查看 Deployment 通过创建新的 ReplicaSet 并将其扩容到 3 个副本并将旧 ReplicaSet 缩容到 0 个副本完成了 Pod 的更新操作：

`kubectl get rs`

输出类似于：

`NAME                          DESIRED   CURRENT   READY   AGE nginx-deployment-1564180365   3         3         3       6s nginx-deployment-2035384211   0         0         0       36s`

*   现在运行 ​`get pods`​ 应仅显示新的 Pods:

`kubectl get pods`

输出类似于：

`NAME                                READY     STATUS    RESTARTS   AGE nginx-deployment-1564180365-khku8   1/1       Running   0          14s nginx-deployment-1564180365-nacti   1/1       Running   0          14s nginx-deployment-1564180365-z9gth   1/1       Running   0          14s`

下次要更新这些 Pods 时，只需再次更新 Deployment Pod 模板即可。

Deployment 可确保在更新时仅关闭一定数量的 Pod。默认情况下，它确保至少所需 Pods 75% 处于运行状态（最大不可用比例为 25%）。

Deployment 还确保仅所创建 Pod 数量只可能比期望 Pods 数高一点点。 默认情况下，它可确保启动的 Pod 个数比期望个数最多多出 25%（最大峰值 25%）。

例如，如果仔细查看上述 Deployment ，将看到它首先创建了一个新的 Pod，然后删除了一些旧的 Pods， 并创建了新的 Pods。它不会杀死老 Pods，直到有足够的数量新的 Pods 已经出现。 在足够数量的旧 Pods 被杀死前并没有创建新 Pods。它确保至少 2 个 Pod 可用， 同时最多总共 4 个 Pod 可用。 当 Deployment 设置为 4 个副本时，Pod 的个数会介于 3 和 5 之间。

*   获取 Deployment 的更多信息

`kubectl describe deployments`

输出类似于：

`Name:                   nginx-deployment Namespace:              default CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000 Labels:                 app=nginx Annotations:            deployment.kubernetes.io/revision=2 Selector:               app=nginx Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable StrategyType:           RollingUpdate MinReadySeconds:        0 RollingUpdateStrategy:  25% max unavailable, 25% max surge Pod Template:   Labels:  app=nginx    Containers:     nginx:       Image:        nginx:1.16.1       Port:         80/TCP       Environment:  <none>       Mounts:       <none>     Volumes:        <none>   Conditions:     Type           Status  Reason     ----           ------  ------     Available      True    MinimumReplicasAvailable     Progressing    True    NewReplicaSetAvailable   OldReplicaSets:  <none>   NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)   Events:     Type    Reason             Age   From                   Message     ----    ------             ----  ----                   -------     Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica set nginx-deployment-2035384211 to 3     Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 1     Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 2     Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 2     Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 1     Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 3     Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 0`

可以看到，当第一次创建 Deployment 时，它创建了一个 ReplicaSet（​`nginx-deployment-2035384211`​） 并将其直接扩容至 3 个副本。更新 Deployment 时，它创建了一个新的 ReplicaSet （nginx-deployment-1564180365），并将其扩容为 1，等待其就绪；然后将旧 ReplicaSet 缩容到 2， 将新的 ReplicaSet 扩容到 2 以便至少有 3 个 Pod 可用且最多创建 4 个 Pod。 然后，它使用相同的滚动更新策略继续对新的 ReplicaSet 扩容并对旧的 ReplicaSet 缩容。 最后，你将有 3 个可用的副本在新的 ReplicaSet 中，旧 ReplicaSet 将缩容到 0。

> Kubernetes 在计算 ​`availableReplicas` ​数值时不考虑终止过程中的 Pod， ​`availableReplicas` ​的值一定介于 ​`replicas - maxUnavailable`​ 和 ​`replicas + maxSurge`​ 之间。 因此，你可能在上线期间看到 Pod 个数比预期的多，Deployment 所消耗的总的资源也大于 ​`replicas + maxSurge`​ 个 Pod 所用的资源，直到被终止的 Pod 所设置的 ​`terminationGracePeriodSeconds` ​到期为止。

### 翻转（多 Deployment 动态更新）

Deployment 控制器每次注意到新的 Deployment 时，都会创建一个 ReplicaSet 以启动所需的 Pods。 如果更新了 Deployment，则控制标签匹配 ​`.spec.selector`​ 但模板不匹配 ​`.spec.template`​ 的 Pods 的现有 ReplicaSet 被缩容。最终，新的 ReplicaSet 缩放为 ​`.spec.replicas`​ 个副本， 所有旧 ReplicaSets 缩放为 0 个副本。

当 Deployment 正在上线时被更新，Deployment 会针对更新创建一个新的 ReplicaSet 并开始对其扩容，之前正在被扩容的 ReplicaSet 会被翻转，添加到旧 ReplicaSets 列表 并开始缩容。

例如，假定你在创建一个 Deployment 以生成 ​`nginx:1.14.2`​ 的 5 个副本，但接下来 更新 Deployment 以创建 5 个 ​`nginx:1.16.1`​ 的副本，而此时只有 3 个​`nginx:1.14.2`​ 副本已创建。在这种情况下，Deployment 会立即开始杀死 3 个 ​`nginx:1.14.2`​ Pods， 并开始创建 ​`nginx:1.16.1`​ Pods。它不会等待 ​`nginx:1.14.2`​ 的 5 个副本都创建完成后才开始执行变更动作。

### 更改标签选择算符 

通常不鼓励更新标签选择算符。建议你提前规划选择算符。 在任何情况下，如果需要更新标签选择算符，请格外小心， 并确保自己了解这背后可能发生的所有事情。

> 在 API 版本 ​`apps/v1`​ 中，Deployment 标签选择算符在创建后是不可变的。

*   添加选择算符时要求使用新标签更新 Deployment 规约中的 Pod 模板标签，否则将返回验证错误。 此更改是非重叠的，也就是说新的选择算符不会选择使用旧选择算符所创建的 ReplicaSet 和 Pod， 这会导致创建新的 ReplicaSet 时所有旧 ReplicaSet 都会被孤立。
*   选择算符的更新如果更改了某个算符的键名，这会导致与添加算符时相同的行为。
*   删除选择算符的操作会删除从 Deployment 选择算符中删除现有算符。 此操作不需要更改 Pod 模板标签。现有 ReplicaSet 不会被孤立，也不会因此创建新的 ReplicaSet， 但请注意已删除的标签仍然存在于现有的 Pod 和 ReplicaSet 中。

回滚 Deployment
-------------

有时，你可能想要回滚 Deployment；例如，当 Deployment 不稳定时（例如进入反复崩溃状态）。 默认情况下，Deployment 的所有上线记录都保留在系统中，以便可以随时回滚 （你可以通过修改修订历史记录限制来更改这一约束）。

> Deployment 被触发上线时，系统就会创建 Deployment 的新的修订版本。 这意味着仅当 Deployment 的 Pod 模板（​`.spec.template`​）发生更改时，才会创建新修订版本 -- 例如，模板的标签或容器镜像发生变化。 其他更新，如 Deployment 的扩缩容操作不会创建 Deployment 修订版本。 这是为了方便同时执行手动缩放或自动缩放。 换言之，当你回滚到较早的修订版本时，只有 Deployment 的 Pod 模板部分会被回滚。

*   假设你在更新 Deployment 时犯了一个拼写错误，将镜像名称命名设置为 ​`nginx:1.161`​ 而不是 ​`nginx:1.16.1`​：

`kubectl set image deployment/nginx-deployment nginx=nginx:1.161 --record=true`

输出类似于：

`deployment/nginx-deployment image updated`

*   此上线进程会出现停滞。你可以通过检查上线状态来验证：

`kubectl rollout status deployment/nginx-deployment`

输出类似于：

`Waiting for rollout to finish: 1 out of 3 new replicas have been updated...`

*   按 Ctrl-C 停止上述上线状态观测。
*   你可以看到旧的副本有两个（​`nginx-deployment-1564180365`​ 和 ​`nginx-deployment-2035384211`​）， 新的副本有 1 个（​`nginx-deployment-3066724191`​）：

`kubectl get rs`

输出类似于：

`NAME                          DESIRED   CURRENT   READY   AGE nginx-deployment-1564180365   3         3         3       25s nginx-deployment-2035384211   0         0         0       36s nginx-deployment-3066724191   1         1         0       6s`

*   查看所创建的 Pod，你会注意到新 ReplicaSet 所创建的 1 个 Pod 卡顿在镜像拉取循环中。

`kubectl get pods`

输出类似于：

`NAME                                READY     STATUS             RESTARTS   AGE nginx-deployment-1564180365-70iae   1/1       Running            0          25s nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s nginx-deployment-1564180365-hysrc   1/1       Running            0          25s nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s`

> Deployment 控制器自动停止有问题的上线过程，并停止对新的 ReplicaSet 扩容。 这行为取决于所指定的 rollingUpdate 参数（具体为 ​`maxUnavailable`​）。 默认情况下，Kubernetes 将此值设置为 25%。

*   获取 Deployment 描述信息：

`kubectl describe deployment`

输出类似于：

`Name:           nginx-deployment Namespace:      default CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700 Labels:         app=nginx Selector:       app=nginx Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable StrategyType:       RollingUpdate MinReadySeconds:    0 RollingUpdateStrategy:  25% max unavailable, 25% max surge Pod Template:   Labels:  app=nginx   Containers:    nginx:     Image:        nginx:1.91     Port:         80/TCP     Host Port:    0/TCP     Environment:  <none>     Mounts:       <none>   Volumes:        <none> Conditions:   Type           Status  Reason   ----           ------  ------   Available      True    MinimumReplicasAvailable   Progressing    True    ReplicaSetUpdated OldReplicaSets:     nginx-deployment-1564180365 (3/3 replicas created) NewReplicaSet:      nginx-deployment-3066724191 (1/1 replicas created) Events:   FirstSeen LastSeen    Count   From                    SubobjectPath   Type        Reason              Message   --------- --------    -----   ----                    -------------   --------    ------              -------   1m        1m          1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3   22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1   22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2   22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2   21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 1   21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3   13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0   13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1`

要解决此问题，需要回滚到以前稳定的 Deployment 版本。

### 检查 Deployment 上线历史 

按照如下步骤检查回滚历史：

1.  首先，检查 Deployment 修订历史：

`kubectl rollout history deployment/nginx-deployment`

输出类似于：

`deployments "nginx-deployment" REVISION    CHANGE-CAUSE 1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml 2           kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1 3           kubectl set image deployment/nginx-deployment nginx=nginx:1.161`

​`CHANGE-CAUSE`​ 的内容是从 Deployment 的 ​`kubernetes.io/change-cause`​ 注解复制过来的。 复制动作发生在修订版本创建时。你可以通过以下方式设置 ​`CHANGE-CAUSE`​ 消息：

*   使用 ​`kubectl annotate deployment/nginx-deployment kubernetes.io/change-cause="image updated to 1.16.1"`​ 为 Deployment 添加注解。
*   手动编辑资源的清单。

7.  要查看修订历史的详细信息，运行：

`kubectl rollout history deployment/nginx-deployment --revision=2`

输出类似于：

`deployments "nginx-deployment" revision 2   Labels:       app=nginx           pod-template-hash=1159050644   Annotations:  kubernetes.io/change-cause=kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1   Containers:    nginx:     Image:      nginx:1.16.1     Port:       80/TCP      QoS Tier:         cpu:      BestEffort         memory:   BestEffort     Environment Variables:      <none>   No volumes.`

### 回滚到之前的修订版本 

按照下面给出的步骤将 Deployment 从当前版本回滚到以前的版本（即版本 2）。

1.  假定现在你已决定撤消当前上线并回滚到以前的修订版本：

`kubectl rollout undo deployment/nginx-deployment`

输出类似于：

`deployment.apps/nginx-deployment`

或者，你也可以通过使用 --to-revision 来回滚到特定修订版本：

`kubectl rollout undo deployment/nginx-deployment --to-revision=2`

输出类似于：

`deployment.apps/nginx-deployment`

与回滚相关的指令的更详细信息，请参考 [kubectl rollout](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=)。

现在，Deployment 正在回滚到以前的稳定版本。正如你所看到的，Deployment 控制器生成了回滚到修订版本 2 的 ​`DeploymentRollback` ​事件。

11.  检查回滚是否成功以及 Deployment 是否正在运行，运行：

`kubectl get deployment nginx-deployment`

输出类似于：

`NAME               READY   UP-TO-DATE   AVAILABLE   AGE nginx-deployment   3/3     3            3           30m`

15.  获取 Deployment 描述信息：

`kubectl describe deployment nginx-deployment`

输出类似于：

`Name:                   nginx-deployment Namespace:              default CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500 Labels:                 app=nginx Annotations:            deployment.kubernetes.io/revision=4                         kubernetes.io/change-cause=kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1 Selector:               app=nginx Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable StrategyType:           RollingUpdate MinReadySeconds:        0 RollingUpdateStrategy:  25% max unavailable, 25% max surge Pod Template:   Labels:  app=nginx   Containers:    nginx:     Image:        nginx:1.16.1     Port:         80/TCP     Host Port:    0/TCP     Environment:  <none>     Mounts:       <none>   Volumes:        <none> Conditions:   Type           Status  Reason   ----           ------  ------   Available      True    MinimumReplicasAvailable   Progressing    True    NewReplicaSetAvailable OldReplicaSets:  <none> NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created) Events:   Type    Reason              Age   From                   Message   ----    ------              ----  ----                   -------   Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica set nginx-deployment-75675f5897 to 3   Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 1   Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 2   Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 2   Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 1   Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 3   Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 0   Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-595696685f to 1   Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment "nginx-deployment" to revision 2   Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica set nginx-deployment-595696685f to 0`

缩放 Deployment 
--------------

你可以使用如下指令缩放 Deployment：

`kubectl scale deployment/nginx-deployment --replicas=10`

输出类似于：

`deployment.apps/nginx-deployment scaled`

假设集群启用了Pod 的水平自动缩放， 你可以为 Deployment 设置自动缩放器，并基于现有 Pod 的 CPU 利用率选择要运行的 Pod 个数下限和上限。

`kubectl autoscale deployment/nginx-deployment --min=10 --max=15 --cpu-percent=80`

输出类似于：

`deployment.apps/nginx-deployment scaled`

### 比例缩放 

RollingUpdate 的 Deployment 支持同时运行应用程序的多个版本。 当自动缩放器缩放处于上线进程（仍在进行中或暂停）中的 RollingUpdate Deployment 时， Deployment 控制器会平衡现有的活跃状态的 ReplicaSets（含 Pods 的 ReplicaSets）中的额外副本， 以降低风险。这称为 比例缩放（Proportional Scaling）。

例如，你正在运行一个 10 个副本的 Deployment，其 maxSurge=3，maxUnavailable=2。

*   确保 Deployment 的这 10 个副本都在运行。

`kubectl get deploy`

输出类似于：

`NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE nginx-deployment     10        10        10           10          50s`

*   更新 Deployment 使用新镜像，碰巧该镜像无法从集群内部解析。

`kubectl set image deployment/nginx-deployment nginx=nginx:sometag`

输出类似于：

`deployment.apps/nginx-deployment image updated`

*   镜像更新使用 ReplicaSet ​`nginx-deployment-1989198191`​ 启动新的上线过程， 但由于上面提到的 ​`maxUnavailable` ​要求，该进程被阻塞了。检查上线状态：

`kubectl get rs`

输出类似于：

`NAME                          DESIRED   CURRENT   READY     AGE nginx-deployment-1989198191   5         5         0         9s nginx-deployment-618515232    8         8         8         1m`

*   然后，出现了新的 Deployment 扩缩请求。自动缩放器将 Deployment 副本增加到 15。 Deployment 控制器需要决定在何处添加 5 个新副本。如果未使用比例缩放，所有 5 个副本 都将添加到新的 ReplicaSet 中。使用比例缩放时，可以将额外的副本分布到所有 ReplicaSet。 较大比例的副本会被添加到拥有最多副本的 ReplicaSet，而较低比例的副本会进入到 副本较少的 ReplicaSet。所有剩下的副本都会添加到副本最多的 ReplicaSet。 具有零副本的 ReplicaSets 不会被扩容。

在上面的示例中，3 个副本被添加到旧 ReplicaSet 中，2 个副本被添加到新 ReplicaSet。 假定新的副本都很健康，上线过程最终应将所有副本迁移到新的 ReplicaSet 中。 要确认这一点，请运行：

`kubectl get deploy`

输出类似于：

`NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE nginx-deployment     15        18        7            8           7m`

上线状态确认了副本是如何被添加到每个 ReplicaSet 的。

`kubectl get rs`

输出类似于：

`NAME                          DESIRED   CURRENT   READY     AGE nginx-deployment-1989198191   7         7         0         7m nginx-deployment-618515232    11        11        11        7m`

暂停、恢复 Deployment 的上线过程 
-----------------------

在你更新一个 Deployment 的时候，或者计划更新它的时候， 你可以在触发一个或多个更新之前暂停 Deployment 的上线过程。 当你准备行应用这些变更时，你可以重新恢复 Deployment 上线过程。 这样做使得你能够在暂停和恢复执行之间应用多个修补程序，而不会触发不必要的上线操作。

*   例如，对于一个刚刚创建的 Deployment：

获取该 Deployment 信息：

`kubectl get deploy`

输出类似于：

`NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE nginx     3         3         3            3           1m`

获取上线状态：

`kubectl get rs`

输出类似于：

`NAME               DESIRED   CURRENT   READY     AGE nginx-2142116321   3         3         3         1m`

*   使用如下指令暂停上线：

`kubectl rollout pause deployment/nginx-deployment`

输出类似于：

`deployment.apps/nginx-deployment paused`

*   接下来更新 Deployment 镜像：

`kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1`

输出类似于：

`deployment.apps/nginx-deployment image updated`

*   注意没有新的上线被触发：

`kubectl rollout history deployment/nginx-deployment`

输出类似于：

`deployments "nginx" REVISION  CHANGE-CAUSE 1   <none>`

*   获取上线状态验证现有的 ReplicaSet 没有被更改：

`kubectl get rs`

输出类似于：

`NAME               DESIRED   CURRENT   READY     AGE nginx-2142116321   3         3         3         2m`

*   你可以根据需要执行很多更新操作，例如，可以要使用的资源：

`kubectl set resources deployment/nginx-deployment -c=nginx --limits=cpu=200m,memory=512Mi`

输出类似于：

`deployment.apps/nginx-deployment resource requirements updated`

暂停 Deployment 上线之前的初始状态将继续发挥作用，但新的更新在 Deployment 上线被暂停期间不会产生任何效果。

*   最终，恢复 Deployment 上线并观察新的 ReplicaSet 的创建过程，其中包含了所应用的所有更新：

`kubectl rollout resume deployment/nginx-deployment`

输出类似于这样：

`deployment.apps/nginx-deployment resumed`

*   观察上线的状态，直到完成。

`kubectl get rs -w`

输出类似于：

`NAME               DESIRED   CURRENT   READY     AGE nginx-2142116321   2         2         2         2m nginx-3926361531   2         2         0         6s nginx-3926361531   2         2         1         18s nginx-2142116321   1         2         2         2m nginx-2142116321   1         2         2         2m nginx-3926361531   3         2         1         18s nginx-3926361531   3         2         1         18s nginx-2142116321   1         1         1         2m nginx-3926361531   3         3         1         18s nginx-3926361531   3         3         2         19s nginx-2142116321   0         1         1         2m nginx-2142116321   0         1         1         2m nginx-2142116321   0         0         0         2m nginx-3926361531   3         3         3         20s`

*   获取最近上线的状态：

`kubectl get rs`

输出类似于：

`NAME               DESIRED   CURRENT   READY     AGE nginx-2142116321   0         0         0         2m nginx-3926361531   3         3         3         28s`

> 你不可以回滚处于暂停状态的 Deployment，除非先恢复其执行状态。

Deployment 状态
-------------

Deployment 的生命周期中会有许多状态。上线新的 ReplicaSet 期间可能处于 Progressing（进行中），可能是 Complete（已完成），也可能是 Failed（失败）以至于无法继续进行。

### 进行中的 Deployment 

执行下面的任务期间，Kubernetes 标记 Deployment 为 进行中（Progressing）：

*   Deployment 创建新的 ReplicaSet
*   Deployment 正在为其最新的 ReplicaSet 扩容
*   Deployment 正在为其旧有的 ReplicaSet(s) 缩容
*   新的 Pods 已经就绪或者可用（就绪至少持续了 MinReadySeconds 秒）。

当上线过程进入“Progressing”状态时，Deployment 控制器会向 Deployment 的​ `.status.conditions`​ 中添加包含下面属性的状况条目：

*   ​`type: Progressing` ​
*   ​`status: "True"` ​
*   ​`reason: NewReplicaSetCreated`​ | ​`reason: FoundNewReplicaSet`​ | ​`reason: ReplicaSetUpdated`​

你可以使用 ​`kubectl rollout status`​ 监视 Deployment 的进度。

### 完成的 Deployment 

当 Deployment 具有以下特征时，Kubernetes 将其标记为 完成（Complete）：

*   与 Deployment 关联的所有副本都已更新到指定的最新版本，这意味着之前请求的所有更新都已完成。
*   与 Deployment 关联的所有副本都可用。
*   未运行 Deployment 的旧副本。

当上线过程进入“Complete”状态时，Deployment 控制器会向 Deployment 的 ​`.status.conditions`​ 中添加包含下面属性的状况条目：

*   ​`type: Progressing` ​
*   ​`status: "True"` ​
*   ​`reason: NewReplicaSetAvailable`​

这一 ​`Progressing` ​状况的状态值会持续为 ​`"True"`​，直至新的上线动作被触发。 即使副本的可用状态发生变化（进而影响 ​`Available` ​状况），​`Progressing` ​状况的值也不会变化。

你可以使用 ​`kubectl rollout status`​ 检查 Deployment 是否已完成。 如果上线成功完成，​`kubectl rollout status`​ 返回退出代码 0。

`kubectl rollout status deployment/nginx-deployment`

输出类似于：

`Waiting for rollout to finish: 2 of 3 updated replicas are available... deployment "nginx-deployment" successfully rolled out`

从 ​`kubectl rollout`​ 命令获得的返回状态为 0（成功）：

`$ echo $?`

`0`

### 失败的 Deployment 

你的 Deployment 可能会在尝试部署其最新的 ReplicaSet 受挫，一直处于未完成状态。 造成此情况一些可能因素如下：

*   配额（Quota）不足
*   就绪探测（Readiness Probe）失败
*   镜像拉取错误
*   权限不足
*   限制范围（Limit Ranges）问题
*   应用程序运行时的配置错误

检测此状况的一种方法是在 Deployment 规约中指定截止时间参数： （\[​`.spec.progressDeadlineSeconds`​\]（#progress-deadline-seconds））。 ​`.spec.progressDeadlineSeconds`​ 给出的是一个秒数值，Deployment 控制器在（通过 Deployment 状态） 标示 Deployment 进展停滞之前，需要等待所给的时长。

以下 ​`kubectl` ​命令设置规约中的 ​`progressDeadlineSeconds`​，从而告知控制器 在 10 分钟后报告 Deployment 没有进展：

`kubectl patch deployment/nginx-deployment -p '{"spec":{"progressDeadlineSeconds":600}}'`

输出类似于：

`deployment.apps/nginx-deployment patched`

超过截止时间后，Deployment 控制器将添加具有以下属性的 Deployment 状况到 Deployment 的 ​`.status.conditions`​ 中：

*   Type=Progressing
*   Status=False
*   Reason=ProgressDeadlineExceeded

这一状况也可能会比较早地失败，因而其状态值被设置为 ​`"False"`​， 其原因为 ​`ReplicaSetCreateError`​。 一旦 Deployment 上线完成，就不再考虑其期限。

参考 [Kubernetes API Conventions](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md target=) 获取更多状态状况相关的信息。

> 除了报告 ​`Reason=ProgressDeadlineExceeded`​ 状态之外，Kubernetes 对已停止的 Deployment 不执行任何操作。更高级别的编排器可以利用这一设计并相应地采取行动。 例如，将 Deployment 回滚到其以前的版本。

> 如果你暂停了某个 Deployment 上线，Kubernetes 不再根据指定的截止时间检查 Deployment 进展。 你可以在上线过程中间安全地暂停 Deployment 再恢复其执行，这样做不会导致超出最后时限的问题。

Deployment 可能会出现瞬时性的错误，可能因为设置的超时时间过短， 也可能因为其他可认为是临时性的问题。例如，假定所遇到的问题是配额不足。 如果描述 Deployment，你将会注意到以下部分：

`kubectl describe deployment nginx-deployment`

输出类似于：

`<...> Conditions:   Type            Status  Reason   ----            ------  ------   Available       True    MinimumReplicasAvailable   Progressing     True    ReplicaSetUpdated   ReplicaFailure  True    FailedCreate <...>`

如果运行 ​`kubectl get deployment nginx-deployment -o yaml`​，Deployment 状态输出 将类似于这样：

`status:   availableReplicas: 2   conditions:   - lastTransitionTime: 2016-10-04T12:25:39Z     lastUpdateTime: 2016-10-04T12:25:39Z     message: Replica set "nginx-deployment-4262182780" is progressing.     reason: ReplicaSetUpdated     status: "True"     type: Progressing   - lastTransitionTime: 2016-10-04T12:25:42Z     lastUpdateTime: 2016-10-04T12:25:42Z     message: Deployment has minimum availability.     reason: MinimumReplicasAvailable     status: "True"     type: Available   - lastTransitionTime: 2016-10-04T12:25:39Z     lastUpdateTime: 2016-10-04T12:25:39Z     message: 'Error creating: pods "nginx-deployment-4262182780-" is forbidden: exceeded quota:       object-counts, requested: pods=1, used: pods=3, limited: pods=2'     reason: FailedCreate     status: "True"     type: ReplicaFailure   observedGeneration: 3   replicas: 2   unavailableReplicas: 2`

最终，一旦超过 Deployment 进度限期，Kubernetes 将更新状态和进度状况的原因：

`Conditions:   Type            Status  Reason   ----            ------  ------   Available       True    MinimumReplicasAvailable   Progressing     False   ProgressDeadlineExceeded   ReplicaFailure  True    FailedCreate`

可以通过缩容 Deployment 或者缩容其他运行状态的控制器，或者直接在命名空间中增加配额 来解决配额不足的问题。如果配额条件满足，Deployment 控制器完成了 Deployment 上线操作， Deployment 状态会更新为成功状况（​`Status=True`​ and ​`Reason=NewReplicaSetAvailable`​）。

`Conditions:   Type          Status  Reason   ----          ------  ------   Available     True    MinimumReplicasAvailable   Progressing   True    NewReplicaSetAvailable`

    

​`type: Available`​ 加上 ​`status: True`​ 意味着 Deployment 具有最低可用性。 最低可用性由 Deployment 策略中的参数指定。 ​`type: Progressing`​ 加上 ​`status: True`​ 表示 Deployment 处于上线过程中，并且正在运行， 或者已成功完成进度，最小所需新副本处于可用。 请参阅对应状况的 Reason 了解相关细节。 在我们的案例中 ​`reason: NewReplicaSetAvailable`​ 表示 Deployment 已完成。

你可以使用 ​`kubectl rollout status`​ 检查 Deployment 是否未能取得进展。 如果 Deployment 已超过进度限期，​`kubectl rollout status`​ 返回非零退出代码。

`kubectl rollout status deployment/nginx-deployment`

输出类似于：

`Waiting for rollout to finish: 2 out of 3 new replicas have been updated... error: deployment "nginx" exceeded its progress deadline`

​`kubectl rollout`​ 命令的退出状态为 1（表明发生了错误）：

`$ echo $?`

`1`

### 对失败 Deployment 的操作 

可应用于已完成的 Deployment 的所有操作也适用于失败的 Deployment。 你可以对其执行扩缩容、回滚到以前的修订版本等操作，或者在需要对 Deployment 的 Pod 模板应用多项调整时，将 Deployment 暂停。

清理策略
----

你可以在 Deployment 中设置 ​`.spec.revisionHistoryLimit`​ 字段以指定保留此 Deployment 的多少个旧有 ReplicaSet。其余的 ReplicaSet 将在后台被垃圾回收。 默认情况下，此值为 10。

> 显式将此字段设置为 0 将导致 Deployment 的所有历史记录被清空，因此 Deployment 将无法回滚。

金丝雀部署 
------

如果要使用 Deployment 向用户子集或服务器子集上线版本， 则可以遵循资源管理 所描述的金丝雀模式，创建多个 Deployment，每个版本一个。

编写 Deployment 规约 
-----------------

同其他 Kubernetes 配置一样， Deployment 需要 ​`apiVersion`​，​`kind` ​和 ​`metadata` ​字段。

Deployment 对象的名称必须是合法的 DNS 子域名。 Deployment 还需要 ​

##  2.  Kubernetes ReplicaSet
ReplicaSet
----------

ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。

ReplicaSet 的工作原理
----------------

ReplicaSet 是通过一组字段来定义的，包括一个用来识别可获得的 Pod 的集合的选择算符、一个用来标明应该维护的副本个数的数值、一个用来指定应该创建新 Pod 以满足副本个数条件时要使用的 Pod 模板等等。 每个 ReplicaSet 都通过根据需要创建和 删除 Pod 以使得副本个数达到期望值， 进而实现其存在价值。当 ReplicaSet 需要创建新的 Pod 时，会使用所提供的 Pod 模板。

ReplicaSet 通过 Pod 上的 metadata.ownerReferences 字段连接到附属 Pod，该字段给出当前对象的属主资源。 ReplicaSet 所获得的 Pod 都在其 ownerReferences 字段中包含了属主 ReplicaSet 的标识信息。正是通过这一连接，ReplicaSet 知道它所维护的 Pod 集合的状态， 并据此计划其操作行为。

ReplicaSet 使用其选择算符来辨识要获得的 Pod 集合。如果某个 Pod 没有 OwnerReference 或者其 OwnerReference 不是一个 控制器，且其匹配到 某 ReplicaSet 的选择算符，则该 Pod 立即被此 ReplicaSet 获得。

何时使用 ReplicaSet
---------------

ReplicaSet 确保任何时间都有指定数量的 Pod 副本在运行。 然而，Deployment 是一个更高级的概念，它管理 ReplicaSet，并向 Pod 提供声明式的更新以及许多其他有用的功能。 因此，我们建议使用 Deployment 而不是直接使用 ReplicaSet，除非 你需要自定义更新业务流程或根本不需要更新。

这实际上意味着，你可能永远不需要操作 ReplicaSet 对象：而是使用 Deployment，并在 spec 部分定义你的应用。

示例
--

`apiVersion: apps/v1 kind: ReplicaSet metadata:   name: frontend   labels:     app: guestbook     tier: frontend spec:   # modify replicas according to your case   replicas: 3   selector:     matchLabels:       tier: frontend   template:     metadata:       labels:         tier: frontend     spec:       containers:       - name: php-redis         image: gcr.io/google_samples/gb-frontend:v3`

将此清单保存到 ​`frontend.yaml`​ 中，并将其提交到 Kubernetes 集群， 应该就能创建 yaml 文件所定义的 ReplicaSet 及其管理的 Pod。

`kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml`

你可以看到当前被部署的 ReplicaSet：

`kubectl get rs`

并看到你所创建的前端：

`NAME       DESIRED   CURRENT   READY   AGE frontend   3         3         3       6s`

你也可以查看 ReplicaSet 的状态：

`kubectl describe rs/frontend`

你会看到类似如下的输出：

`Name:		frontend Namespace:	default Selector:	tier=frontend Labels:		app=guestbook 		tier=frontend Annotations:  kubectl.kubernetes.io/last-applied-configuration:                 {"apiVersion":"apps/v1","kind":"ReplicaSet","metadata":{"annotations":{},"labels":{"app":"guestbook","tier":"frontend"},"name":"frontend",... Replicas:	3 current / 3 desired Pods Status:	3 Running / 0 Waiting / 0 Succeeded / 0 Failed Pod Template:   Labels:       tier=frontend   Containers:    php-redis:     Image:      gcr.io/google_samples/gb-frontend:v3     Port:         <none>     Host Port:    <none>     Environment:  <none>     Mounts:             <none>   Volumes:              <none> Events:   Type    Reason            Age   From                   Message   ----    ------            ----  ----                   -------   Normal  SuccessfulCreate  117s  replicaset-controller  Created pod: frontend-wtsmm   Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-b2zdv   Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-vcmts`

最后可以查看启动了的 Pods：

`kubectl get pods`

你会看到类似如下的 Pod 信息：

`NAME             READY   STATUS    RESTARTS   AGE frontend-b2zdv   1/1     Running   0          6m36s frontend-vcmts   1/1     Running   0          6m36s frontend-wtsmm   1/1     Running   0          6m36s`

你也可以查看 Pods 的属主引用被设置为前端的 ReplicaSet。 要实现这点，可取回运行中的 Pods 之一的 YAML：

`kubectl get pods frontend-b2zdv -o yaml`

输出将类似这样，frontend ReplicaSet 的信息被设置在 metadata 的 ​`ownerReferences` ​字段中：

`apiVersion: v1 kind: Pod metadata:   creationTimestamp: "2020-02-12T07:06:16Z"   generateName: frontend-   labels:     tier: frontend   name: frontend-b2zdv   namespace: default   ownerReferences:   - apiVersion: apps/v1     blockOwnerDeletion: true     controller: true     kind: ReplicaSet     name: frontend     uid: f391f6db-bb9b-4c09-ae74-6a1f77f3d5cf ...`

非模板 Pod 的获得 
------------

尽管你完全可以直接创建裸的 Pods，强烈建议你确保这些裸的 Pods 并不包含可能与你 的某个 ReplicaSet 的选择算符相匹配的标签。原因在于 ReplicaSet 并不仅限于拥有 在其模板中设置的 Pods，它还可以像前面小节中所描述的那样获得其他 Pods。

`apiVersion: v1 kind: Pod metadata:   name: pod1   labels:     tier: frontend spec:   containers:   - name: hello1     image: gcr.io/google-samples/hello-app:2.0  ---  apiVersion: v1 kind: Pod metadata:   name: pod2   labels:     tier: frontend spec:   containers:   - name: hello2     image: gcr.io/google-samples/hello-app:1.0`

由于这些 Pod 没有控制器（Controller，或其他对象）作为其属主引用，并且 其标签与 frontend ReplicaSet 的选择算符匹配，它们会立即被该 ReplicaSet 获取。

假定你在 frontend ReplicaSet 已经被部署之后创建 Pods，并且你已经在 ReplicaSet 中设置了其初始的 Pod 副本数以满足其副本计数需要：

`kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml`

新的 Pods 会被该 ReplicaSet 获取，并立即被 ReplicaSet 终止，因为 它们的存在会使得 ReplicaSet 中 Pod 个数超出其期望值。

取回 Pods：

`kubectl get pods`

输出显示新的 Pods 或者已经被终止，或者处于终止过程中：

`NAME             READY   STATUS        RESTARTS   AGE frontend-b2zdv   1/1     Running       0          10m frontend-vcmts   1/1     Running       0          10m frontend-wtsmm   1/1     Running       0          10m pod1             0/1     Terminating   0          1s pod2             0/1     Terminating   0          1s`

如果你先行创建 Pods：

`kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml`

之后再创建 ReplicaSet：

`kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml`

你会看到 ReplicaSet 已经获得了该 Pods，并仅根据其规约创建新的 Pods，直到 新的 Pods 和原来的 Pods 的总数达到其预期个数。 这时取回 Pods：

`kubectl get pods`

将会生成下面的输出：

`NAME             READY   STATUS    RESTARTS   AGE frontend-hmmj2   1/1     Running   0          9s pod1             1/1     Running   0          36s pod2             1/1     Running   0          36s`

采用这种方式，一个 ReplicaSet 中可以包含异质的 Pods 集合。

编写 ReplicaSet 的 spec
--------------------

与所有其他 Kubernetes API 对象一样，ReplicaSet 也需要 ​`apiVersion`​、​`kind`​、和 ​`metadata` ​字段。 对于 ReplicaSets 而言，其 ​`kind` ​始终是 ReplicaSet。

ReplicaSet 对象的名称必须是合法的 DNS 子域名。

ReplicaSet 也需要 ​`.spec`​ 部分。

### Pod 模版

​`.spec.template`​ 是一个Pod 模版， 要求设置标签。在 ​`frontend.yaml`​ 示例中，我们指定了标签 ​`tier: frontend`​。 注意不要将标签与其他控制器的选择算符重叠，否则那些控制器会尝试收养此 Pod。

对于模板的重启策略 字段，​`.spec.template.spec.restartPolicy`​，唯一允许的取值是 ​`Always`​，这也是默认值.

### Pod 选择算符 

​`.spec.selector`​ 字段是一个标签选择算符。 如前文中所讨论的，这些是用来标识要被获取的 Pods 的标签。在签名的 ​`frontend.yaml`​ 示例中，选择算符为：

`matchLabels:   tier: frontend`

在 ReplicaSet 中，​`.spec.template.metadata.labels`​ 的值必须与 ​`spec.selector`​ 值 相匹配，否则该配置会被 API 拒绝。

> 对于设置了相同的 ​`.spec.selector`​，但 ​`.spec.template.metadata.labels`​ 和 ​`.spec.template.spec`​ 字段不同的 两个 ReplicaSet 而言，每个 ReplicaSet 都会忽略被另一个 ReplicaSet 所 创建的 Pods。

### Replicas

你可以通过设置 ​`.spec.replicas`​ 来指定要同时运行的 Pod 个数。 ReplicaSet 创建、删除 Pods 以与此值匹配。

如果你没有指定 ​`.spec.replicas`​, 那么默认值为 1。

使用 ReplicaSets
--------------

### 删除 ReplicaSet 和它的 Pod

要删除 ReplicaSet 和它的所有 Pod，使用 [kubectl delete](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=) 命令。 默认情况下，垃圾收集器 自动删除所有依赖的 Pod。

当使用 REST API 或 ​`client-go`​ 库时，你必须在删除选项中将 ​`propagationPolicy` ​设置为 ​`Background` ​或 ​`Foreground`​。例如：

`kubectl proxy --port=8080 curl -X DELETE  'localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend' \    -d '{"kind":"DeleteOptions","apiVersion":"v1","propagationPolicy":"Foreground"}' \    -H "Content-Type: application/json"`

### 只删除 ReplicaSet

你可以只删除 ReplicaSet 而不影响它的 Pods，方法是使用 [kubectl delete](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=) 命令并设置 ​`--cascade=orphan`​ 选项。

当使用 REST API 或 ​`client-go`​ 库时，你必须将 ​`propagationPolicy` ​设置为 ​`Orphan`​。 例如：

`kubectl proxy --port=8080 curl -X DELETE  'localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend' \   -d '{"kind":"DeleteOptions","apiVersion":"v1","propagationPolicy":"Orphan"}' \   -H "Content-Type: application/json"`

一旦删除了原来的 ReplicaSet，就可以创建一个新的来替换它。 由于新旧 ReplicaSet 的 ​`.spec.selector`​ 是相同的，新的 ReplicaSet 将接管老的 Pod。 但是，它不会努力使现有的 Pod 与新的、不同的 Pod 模板匹配。 若想要以可控的方式更新 Pod 的规约，可以使用 Deployment 资源，因为 ReplicaSet 并不直接支持滚动更新。

### 将 Pod 从 ReplicaSet 中隔离

可以通过改变标签来从 ReplicaSet 的目标集中移除 Pod。 这种技术可以用来从服务中去除 Pod，以便进行排错、数据恢复等。 以这种方式移除的 Pod 将被自动替换（假设副本的数量没有改变）。

### 缩放 RepliaSet 

通过更新 ​`.spec.replicas`​ 字段，ReplicaSet 可以被轻松的进行缩放。ReplicaSet 控制器能确保匹配标签选择器的数量的 Pod 是可用的和可操作的。

在降低集合规模时，ReplicaSet 控制器通过对可用的 Pods 进行排序来优先选择 要被删除的 Pods。其一般性算法如下：

1.  首先选择剔除悬决（Pending，且不可调度）的 Pods
2.  如果设置了 ​`controller.kubernetes.io/pod-deletion-cost`​ 注解，则注解值 较小的优先被裁减掉
3.  所处节点上副本个数较多的 Pod 优先于所处节点上副本较少者
4.  如果 Pod 的创建时间不同，最近创建的 Pod 优先于早前创建的 Pod 被裁减。 （当 ​`LogarithmicScaleDown` ​这一 特性门控 被启用时，创建时间是按整数幂级来分组的）。

如果以上比较结果都相同，则随机选择。

### Pod 删除开销 

FEATURE STATE: Kubernetes v1.22 \[beta\]

通过使用 ​`controller.kubernetes.io/pod-deletion-cost`​ 注解，用户可以对 ReplicaSet 缩容时要先删除哪些 Pods 设置偏好。

此注解要设置到 Pod 上，取值范围为 \[-2147483647, 2147483647\]。 所代表的的是删除同一 ReplicaSet 中其他 Pod 相比较而言的开销。 删除开销较小的 Pods 比删除开销较高的 Pods 更容易被删除。

Pods 如果未设置此注解，则隐含的设置值为 0。负值也是可接受的。 如果注解值非法，API 服务器会拒绝对应的 Pod。

此功能特性处于 Beta 阶段，默认被禁用。你可以通过为 kube-apiserver 和 kube-controller-manager 设置 特性门控 ​`PodDeletionCost` ​来启用此功能。

> 此机制实施时仅是尽力而为，并不能对 Pod 的删除顺序作出任何保证；  
> 用户应避免频繁更新注解值，例如根据某观测度量值来更新此注解值是应该避免的。 这样做会在 API 服务器上产生大量的 Pod 更新操作。

### 使用场景示例

同一应用的不同 Pods 可能其利用率是不同的。在对应用执行缩容操作时，可能 希望移除利用率较低的 Pods。为了避免频繁更新 Pods，应用应该在执行缩容 操作之前更新一次 ​`controller.kubernetes.io/pod-deletion-cost`​ 注解值 （将注解值设置为一个与其 Pod 利用率对应的值）。 如果应用自身控制器缩容操作时（例如 Spark 部署的驱动 Pod），这种机制 是可以起作用的。

### ReplicaSet 作为水平的 Pod 自动缩放器目标

ReplicaSet 也可以作为 水平的 Pod 缩放器 (HPA) 的目标。也就是说，ReplicaSet 可以被 HPA 自动缩放。 以下是 HPA 以我们在前一个示例中创建的副本集为目标的示例。

`apiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata:   name: frontend-scaler spec:   scaleTargetRef:     kind: ReplicaSet     name: frontend   minReplicas: 3   maxReplicas: 10   targetCPUUtilizationPercentage: 50`

将这个列表保存到 ​`hpa-rs.yaml`​ 并提交到 Kubernetes 集群，就能创建它所定义的 HPA，进而就能根据复制的 Pod 的 CPU 利用率对目标 ReplicaSet进行自动缩放。

`kubectl apply -f https://k8s.io/examples/controllers/hpa-rs.yaml`

或者，可以使用 ​`kubectl autoscale`​ 命令完成相同的操作。 (而且它更简单！)

`kubectl autoscale rs frontend --max=10 --min=3 --cpu-percent=50`

ReplicaSet 的替代方案
----------------

### Deployment （推荐）

Deployment 是一个 可以拥有 ReplicaSet 并使用声明式方式在服务器端完成对 Pods 滚动更新的对象。 尽管 ReplicaSet 可以独立使用，目前它们的主要用途是提供给 Deployment 作为 编排 Pod 创建、删除和更新的一种机制。当使用 Deployment 时，你不必关心 如何管理它所创建的 ReplicaSet，Deployment 拥有并管理其 ReplicaSet。 因此，建议你在需要 ReplicaSet 时使用 Deployment。

### 裸 Pod

与用户直接创建 Pod 的情况不同，ReplicaSet 会替换那些由于某些原因被删除或被终止的 Pod，例如在节点故障或破坏性的节点维护（如内核升级）的情况下。 因为这个原因，我们建议你使用 ReplicaSet，即使应用程序只需要一个 Pod。 想像一下，ReplicaSet 类似于进程监视器，只不过它在多个节点上监视多个 Pod， 而不是在单个节点上监视单个进程。 ReplicaSet 将本地容器重启的任务委托给了节点上的某个代理（例如，Kubelet 或 Docker）去完成。

### Job

使用Job 代替ReplicaSet， 可以用于那些期望自行终止的 Pod。

### DaemonSet

对于管理那些提供主机级别功能（如主机监控和主机日志）的容器， 就要用 ​`DaemonSet` ​而不用 ReplicaSet。 这些 Pod 的寿命与主机寿命有关：这些 Pod 需要先于主机上的其他 Pod 运行， 并且在机器准备重新启动/关闭时安全地终止。

### ReplicationController

ReplicaSet 是 ReplicationController 的后继者。二者目的相同且行为类似，只是 ReplicationController 不支持 标签用户指南 中讨论的基于集合的选择算符需求。 因此，相比于 ReplicationController，应优先考虑 ReplicaSet。

##  3.  Kubernetes StatefulSets
StatefulSets
------------

StatefulSet 是用来管理有状态应用的工作负载 API 对象。

StatefulSet 用来管理某 Pod 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。

和 Deployment 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。

如果希望使用存储卷为工作负载提供持久存储，可以使用 StatefulSet 作为解决方案的一部分。 尽管 StatefulSet 中的单个 Pod 仍可能出现故障， 但持久的 Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。

使用 StatefulSets
---------------

StatefulSets 对于需要满足以下一个或多个需求的应用程序很有价值：

*   稳定的、唯一的网络标识符。
*   稳定的、持久的存储。
*   有序的、优雅的部署和缩放。
*   有序的、自动的滚动更新。

在上面描述中，“稳定的”意味着 Pod 调度或重调度的整个过程是有持久性的。 如果应用程序不需要任何稳定的标识符或有序的部署、删除或伸缩，则应该使用 由一组无状态的副本控制器提供的工作负载来部署应用程序，比如 Deployment 或者 ReplicaSet 可能更适用于你的无状态应用部署需要。

限制 
---

*   给定 Pod 的存储必须由 PersistentVolume 驱动 基于所请求的 ​`storage class`​ 来提供，或者由管理员预先提供。
*   删除或者收缩 StatefulSet 并不会删除它关联的存储卷。 这样做是为了保证数据安全，它通常比自动清除 StatefulSet 所有相关的资源更有价值。
*   StatefulSet 当前需要无头服务 来负责 Pod 的网络标识。你需要负责创建此服务。
*   当删除 StatefulSets 时，StatefulSet 不提供任何终止 Pod 的保证。 为了实现 StatefulSet 中的 Pod 可以有序地且体面地终止，可以在删除之前将 StatefulSet 缩放为 0。
*   在默认 Pod 管理策略(​`OrderedReady`​) 时使用 滚动更新，可能进入需要人工干预 才能修复的损坏状态。

组件
--

下面的示例演示了 StatefulSet 的组件。

`apiVersion: v1 kind: Service metadata:   name: nginx   labels:     app: nginx spec:   ports:   - port: 80     name: web   clusterIP: None   selector:     app: nginx --- apiVersion: apps/v1 kind: StatefulSet metadata:   name: web spec:   selector:     matchLabels:       app: nginx # has to match .spec.template.metadata.labels   serviceName: "nginx"   replicas: 3 # by default is 1   template:     metadata:       labels:         app: nginx # has to match .spec.selector.matchLabels     spec:       terminationGracePeriodSeconds: 10       containers:       - name: nginx         image: k8s.gcr.io/nginx-slim:0.8         ports:         - containerPort: 80           name: web         volumeMounts:         - name: www           mountPath: /usr/share/nginx/html   volumeClaimTemplates:   - metadata:       name: www     spec:       accessModes: [ "ReadWriteOnce" ]       storageClassName: "my-storage-class"       resources:         requests:           storage: 1Gi`

上述例子中：

*   名为 ​`nginx` ​的 Headless Service 用来控制网络域名。
*   名为 ​`web` ​的 StatefulSet 有一个 Spec，它表明将在独立的 3 个 Pod 副本中启动 nginx 容器。
*   ​`volumeClaimTemplates` ​将通过 PersistentVolumes 驱动提供的 PersistentVolumes 来提供稳定的存储。

StatefulSet 的命名需要遵循DNS 子域名规范。

Pod选择算符
-------

你必须设置 StatefulSet 的 ​`.spec.selector`​ 字段，使之匹配其在 ​`.spec.template.metadata.labels`​ 中设置的标签。在 Kubernetes 1.8 版本之前， 被忽略 ​`.spec.selector`​ 字段会获得默认设置值。 在 1.8 和以后的版本中，未指定匹配的 Pod 选择器将在创建 StatefulSet 期间导致验证错误。

Pod 标识 
-------

StatefulSet Pod 具有唯一的标识，该标识包括顺序标识、稳定的网络标识和稳定的存储。 该标识和 Pod 是绑定的，不管它被调度在哪个节点上。

### 有序索引 

对于具有 N 个副本的 StatefulSet，StatefulSet 中的每个 Pod 将被分配一个整数序号， 从 0 到 N-1，该序号在 StatefulSet 上是唯一的。

### 稳定的网络 ID 

StatefulSet 中的每个 Pod 根据 StatefulSet 的名称和 Pod 的序号派生出它的主机名。 组合主机名的格式为​`$(StatefulSet 名称)-$(序号)`​。 上例将会创建三个名称分别为 ​`web-0、web-1、web-2`​ 的 Pod。 StatefulSet 可以使用 无头服务 控制它的 Pod 的网络域。管理域的这个服务的格式为： ​`$(服务名称).$(命名空间).svc.cluster.local`​，其中 ​`cluster.local`​ 是集群域。 一旦每个 Pod 创建成功，就会得到一个匹配的 DNS 子域，格式为： ​`$(pod 名称).$(所属服务的 DNS 域名)`​，其中所属服务由 StatefulSet 的 ​`serviceName` ​域来设定。

取决于集群域内部 DNS 的配置，有可能无法查询一个刚刚启动的 Pod 的 DNS 命名。 当集群内其他客户端在 Pod 创建完成前发出 Pod 主机名查询时，就会发生这种情况。 负缓存 (在 DNS 中较为常见) 意味着之前失败的查询结果会被记录和重用至少若干秒钟， 即使 Pod 已经正常运行了也是如此。

如果需要在 Pod 被创建之后及时发现它们，有以下选项：

*   直接查询 Kubernetes API（比如，利用 watch 机制）而不是依赖于 DNS 查询
*   缩短 Kubernetes DNS 驱动的缓存时长（通常这意味着修改 CoreDNS 的 ConfigMap，目前缓存时长为 30 秒）

正如限制中所述，你需要负责创建无头服务 以便为 Pod 提供网络标识。

下面给出一些选择集群域、服务名、StatefulSet 名、及其怎样影响 StatefulSet 的 Pod 上的 DNS 名称的示例：

集群域名

服务（名字空间/名字）

StatefulSet（名字空间/名字）

StatefulSet 域名

Pod DNS

Pod 主机名

cluster.local

default/nginx

default/web

nginx.default.svc.cluster.local

web-{0..N-1}.nginx.default.svc.cluster.local

web-{0..N-1}

cluster.local

foo/nginx

foo/web

nginx.foo.svc.cluster.local

web-{0..N-1}.nginx.foo.svc.cluster.local

web-{0..N-1}

kube.local

foo/nginx

foo/web

nginx.foo.svc.kube.local

web-{0..N-1}.nginx.foo.svc.kube.local

web-{0..N-1}

> 集群域会被设置为 ​`cluster.local`​，除非有其他配置。

### 稳定的存储

对于 StatefulSet 中定义的每个 VolumeClaimTemplate，每个 Pod 接收到一个 PersistentVolumeClaim。在上面的 nginx 示例中，每个 Pod 将会得到基于 StorageClass ​`my-storage-class`​ 提供的 1 Gib 的 PersistentVolume。 如果没有声明 StorageClass，就会使用默认的 StorageClass。 当一个 Pod 被调度（重新调度）到节点上时，它的 ​`volumeMounts` ​会挂载与其 PersistentVolumeClaims 相关联的 PersistentVolume。 请注意，当 Pod 或者 StatefulSet 被删除时，与 PersistentVolumeClaims 相关联的 PersistentVolume 并不会被删除。要删除它必须通过手动方式来完成。

### Pod 名称标签 

当 StatefulSet 控制器（Controller） 创建 Pod 时， 它会添加一个标签 ​`statefulset.kubernetes.io/pod-name`​，该标签值设置为 Pod 名称。 这个标签允许你给 StatefulSet 中的特定 Pod 绑定一个 Service。

部署和扩缩保证 
--------

*   对于包含 N 个 副本的 StatefulSet，当部署 Pod 时，它们是依次创建的，顺序为 ​`0..N-1`​。
*   当删除 Pod 时，它们是逆序终止的，顺序为 ​`N-1..0`​。
*   在将缩放操作应用到 Pod 之前，它前面的所有 Pod 必须是 Running 和 Ready 状态。
*   在 Pod 终止之前，所有的继任者必须完全关闭。

StatefulSet 不应将 ​`pod.Spec.TerminationGracePeriodSeconds`​ 设置为 0。 这种做法是不安全的，要强烈阻止。

在上面的 nginx 示例被创建后，会按照 web-0、web-1、web-2 的顺序部署三个 Pod。 在 web-0 进入 Running 和 Ready 状态前不会部署 web-1。在 web-1 进入 Running 和 Ready 状态前不会部署 web-2。 如果 web-1 已经处于 Running 和 Ready 状态，而 web-2 尚未部署，在此期间发生了 web-0 运行失败，那么 web-2 将不会被部署，要等到 web-0 部署完成并进入 Running 和 Ready 状态后，才会部署 web-2。

如果用户想将示例中的 StatefulSet 收缩为 ​`replicas=1`​，首先被终止的是 web-2。 在 web-2 没有被完全停止和删除前，web-1 不会被终止。 当 web-2 已被终止和删除、web-1 尚未被终止，如果在此期间发生 web-0 运行失败， 那么就不会终止 web-1，必须等到 web-0 进入 Running 和 Ready 状态后才会终止 web-1。

### Pod 管理策略

在 Kubernetes 1.7 及以后的版本中，StatefulSet 允许你放宽其排序保证， 同时通过它的 ​`.spec.podManagementPolicy`​ 域保持其唯一性和身份保证。

#### OrderedReady Pod 管理

​`OrderedReady` ​Pod 管理是 StatefulSet 的默认设置。它实现了 上面描述的功能。

#### 并行 Pod 管理 

​`Parallel` ​Pod 管理让 StatefulSet 控制器并行的启动或终止所有的 Pod， 启动或者终止其他 Pod 前，无需等待 Pod 进入 Running 和 ready 或者完全停止状态。 这个选项只会影响伸缩操作的行为，更新则不会被影响。

更新策略 
-----

StatefulSet 的 ​`.spec.updateStrategy`​ 字段让 你可以配置和禁用掉自动滚动更新 Pod 的容器、标签、资源请求或限制、以及注解。 有两个允许的值：

*   OnDelete

*   当 StatefulSet 的 ​`.spec.updateStrategy.type`​ 设置为 ​`OnDelete` ​时， 它的控制器将不会自动更新 StatefulSet 中的 Pod。 用户必须手动删除 Pod 以便让控制器创建新的 Pod，以此来对 StatefulSet 的 ​`.spec.template`​ 的变动作出反应。

*   RollingUpdate

*   ​`RollingUpdate` ​更新策略对 StatefulSet 中的 Pod 执行自动的滚动更新。这是默认的更新策略。

滚动更新
----

当 StatefulSet 的 ​`.spec.updateStrategy.type`​ 被设置为 ​`RollingUpdate` ​时， StatefulSet 控制器会删除和重建 StatefulSet 中的每个 Pod。 它将按照与 Pod 终止相同的顺序（从最大序号到最小序号）进行，每次更新一个 Pod。

Kubernetes 控制面会等到被更新的 Pod 进入 Running 和 Ready 状态，然后再更新其前身。 如果你设置了 ​`.spec.minReadySeconds`​（查看最短就绪秒数），控制面在 Pod 就绪后会额外等待一定的时间再执行下一步。

### 分区滚动更新 

通过声明 ​`.spec.updateStrategy.rollingUpdate.partition`​ 的方式，​`RollingUpdate` ​更新策略可以实现分区。 如果声明了一个分区，当 StatefulSet 的 ​`.spec.template`​ 被更新时， 所有序号大于等于该分区序号的 Pod 都会被更新。 所有序号小于该分区序号的 Pod 都不会被更新，并且，即使他们被删除也会依据之前的版本进行重建。 如果 StatefulSet 的 ​`.spec.updateStrategy.rollingUpdate.partition`​ 大于它的 ​`.spec.replicas`​，对它的 ​`.spec.template`​ 的更新将不会传递到它的 Pod。 在大多数情况下，你不需要使用分区，但如果你希望进行阶段更新、执行金丝雀或执行 分阶段上线，则这些分区会非常有用。

### 强制回滚

在默认 Pod 管理策略(​`OrderedReady`​) 下使用 滚动更新 ，可能进入需要人工干预才能修复的损坏状态。

如果更新后 Pod 模板配置进入无法运行或就绪的状态（例如，由于错误的二进制文件 或应用程序级配置错误），StatefulSet 将停止回滚并等待。

在这种状态下，仅将 Pod 模板还原为正确的配置是不够的。由于 已知问题，StatefulSet 将继续等待损坏状态的 Pod 准备就绪（永远不会发生），然后再尝试将其恢复为正常工作配置。

恢复模板后，还必须删除 StatefulSet 尝试使用错误的配置来运行的 Pod。这样， StatefulSet 才会开始使用被还原的模板来重新创建 Pod。

### 最短就绪秒数 

FEATURE STATE: Kubernetes v1.22 \[alpha\]

​`.spec.minReadySeconds`​ 是一个可选字段，用于指定新创建的 Pod 就绪（没有任何容器崩溃）后被认为可用的最小秒数。 默认值是 0（Pod 就绪时就被认为可用）。

请注意只有当你启用 ​`StatefulSetMinReadySeconds` ​特性门控时，该字段才会生效。

##  4.  Kubernetes DaemonSet
DaemonSet
---------

DaemonSet 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。

DaemonSet 的一些典型用法：

*   在每个节点上运行集群守护进程
*   在每个节点上运行日志收集守护进程
*   在每个节点上运行监控守护进程

一种简单的用法是为每种类型的守护进程在所有的节点上都启动一个 DaemonSet。 一个稍微复杂的用法是为同一种守护进程部署多个 DaemonSet；每个具有不同的标志， 并且对不同硬件类型具有不同的内存、CPU 要求。

编写 DaemonSet Spec 
------------------

### 创建 DaemonSet 

你可以在 YAML 文件中描述 DaemonSet。 例如，下面的 daemonset.yaml 文件描述了一个运行 fluentd-elasticsearch Docker 镜像的 DaemonSet：

`apiVersion: apps/v1 kind: DaemonSet metadata:   name: fluentd-elasticsearch   namespace: kube-system   labels:     k8s-app: fluentd-logging spec:   selector:     matchLabels:       name: fluentd-elasticsearch   template:     metadata:       labels:         name: fluentd-elasticsearch     spec:       tolerations:       # 这些容忍度设置是为了让守护进程在控制平面节点上运行       # 如果你不希望控制平面节点运行 Pod，可以删除它们       - key: node-role.kubernetes.io/control-plane         operator: Exists         effect: NoSchedule       - key: node-role.kubernetes.io/master         operator: Exists         effect: NoSchedule       containers:       - name: fluentd-elasticsearch         image: quay.io/fluentd_elasticsearch/fluentd:v2.5.2         resources:           limits:             memory: 200Mi           requests:             cpu: 100m             memory: 200Mi         volumeMounts:         - name: varlog           mountPath: /var/log         - name: varlibdockercontainers           mountPath: /var/lib/docker/containers           readOnly: true       terminationGracePeriodSeconds: 30       volumes:       - name: varlog         hostPath:           path: /var/log       - name: varlibdockercontainers         hostPath:           path: /var/lib/docker/containers`

基于 YAML 文件创建 DaemonSet：

`kubectl apply -f https://k8s.io/examples/controllers/daemonset.yaml`

### 必需字段 

和所有其他 Kubernetes 配置一样，DaemonSet 需要 ​`apiVersion`​、​`kind` ​和 ​`metadata` ​字段。 有关配置文件的基本信息，参见 部署应用、 配置容器和 使用 kubectl 进行对象管理 文档。

DaemonSet 对象的名称必须是一个合法的 DNS 子域名。

DaemonSet 也需要一个 ​`[.spec](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md target=)`​ 配置段。

### Pod 模板 

​`.spec`​ 中唯一必需的字段是 ​`.spec.template`​。

​`.spec.template`​ 是一个 Pod 模板。 除了它是嵌套的，因而不具有 ​`apiVersion` ​或 ​`kind` ​字段之外，它与 Pod 具有相同的 schema。

除了 Pod 必需字段外，在 DaemonSet 中的 Pod 模板必须指定合理的标签（查看 Pod 选择算符）。

在 DaemonSet 中的 Pod 模板必须具有一个值为 ​`Always` ​的 ​`RestartPolicy`​。 当该值未指定时，默认是 ​`Always`​。

### Pod 选择算符 

​`.spec.selector`​ 字段表示 Pod 选择算符，它与 Job 的 ​`.spec.selector`​ 的作用是相同的。

你必须指定与 ​`.spec.template`​ 的标签匹配的 Pod 选择算符。 此外，一旦创建了 DaemonSet，它的 ​`.spec.selector`​ 就不能修改。 修改 Pod 选择算符可能导致 Pod 意外悬浮，并且这对用户来说是费解的。

​`spec.selector`​ 是一个对象，如下两个字段组成：

*   ​`matchLabels` ​- 与 ReplicationController 的 ​`.spec.selector`​ 的作用相同。
*   ​`matchExpressions` ​- 允许构建更加复杂的选择器，可以通过指定 key、value 列表以及将 key 和 value 列表关联起来的 operator。

当上述两个字段都指定时，结果会按逻辑与（AND）操作处理。

​`.spec.selector`​ 必须与 ​`.spec.template.metadata.labels`​ 相匹配。 如果配置中这两个字段不匹配，则会被 API 拒绝。

### 仅在某些节点上运行 Pod 

如果指定了 ​`.spec.template.spec.nodeSelector`​，DaemonSet 控制器将在能够与 Node 选择算符 匹配的节点上创建 Pod。 类似这种情况，可以指定 ​`.spec.template.spec.affinity`​，之后 DaemonSet 控制器 将在能够与节点亲和性 匹配的节点上创建 Pod。 如果根本就没有指定，则 DaemonSet Controller 将在所有节点上创建 Pod。

Daemon Pods 是如何被调度的 
--------------------

### 通过默认调度器调度 

FEATURE STATE: Kubernetes 1.17 \[stable\]

DaemonSet 确保所有符合条件的节点都运行该 Pod 的一个副本。 通常，运行 Pod 的节点由 Kubernetes 调度器选择。 不过，DaemonSet Pods 由 DaemonSet 控制器创建和调度。这就带来了以下问题：

*   Pod 行为的不一致性：正常 Pod 在被创建后等待调度时处于 ​`Pending` ​状态， DaemonSet Pods 创建后不会处于 ​`Pending` ​状态下。这使用户感到困惑。
*   Pod 抢占 由默认调度器处理。启用抢占后，DaemonSet 控制器将在不考虑 Pod 优先级和抢占 的情况下制定调度决策。

​`ScheduleDaemonSetPods` ​允许您使用默认调度器而不是 DaemonSet 控制器来调度 DaemonSets， 方法是将 ​`NodeAffinity` ​条件而不是 ​`.spec.nodeName`​ 条件添加到 DaemonSet Pods。 默认调度器接下来将 Pod 绑定到目标主机。 如果 DaemonSet Pod 的节点亲和性配置已存在，则被替换 （原始的节点亲和性配置在选择目标主机之前被考虑）。 DaemonSet 控制器仅在创建或修改 DaemonSet Pod 时执行这些操作， 并且不会更改 DaemonSet 的 ​`spec.template`​。

`nodeAffinity:   requiredDuringSchedulingIgnoredDuringExecution:     nodeSelectorTerms:     - matchFields:       - key: metadata.name         operator: In         values:         - target-host-name`
    

此外，系统会自动添加 ​`node.kubernetes.io/unschedulable：NoSchedule`​ 容忍度到 DaemonSet Pods。在调度 DaemonSet Pod 时，默认调度器会忽略 ​`unschedulable` ​节点。

### 污点和容忍度 

尽管 Daemon Pods 遵循污点和容忍度 规则，根据相关特性，控制器会自动将以下容忍度添加到 DaemonSet Pod：

容忍度键名

效果

版本

描述

`node.kubernetes.io/not-ready`

NoExecute

1.13+

当出现类似网络断开的情况导致节点问题时，DaemonSet Pod 不会被逐出。

`node.kubernetes.io/unreachable`

NoExecute

1.13+

当出现类似于网络断开的情况导致节点问题时，DaemonSet Pod 不会被逐出。

`node.kubernetes.io/disk-pressure`

NoSchedule

1.8+

DaemonSet Pod 被默认调度器调度时能够容忍磁盘压力属性。

`node.kubernetes.io/memory-pressure`

NoSchedule

1.8+

DaemonSet Pod 被默认调度器调度时能够容忍内存压力属性。

`node.kubernetes.io/unschedulable`

NoSchedule

1.12+

DaemonSet Pod 能够容忍默认调度器所设置的 `unschedulable` 属性.

`node.kubernetes.io/network-unavailable`

NoSchedule

1.12+

DaemonSet 在使用宿主网络时，能够容忍默认调度器所设置的 `network-unavailable` 属性。

与 Daemon Pods 通信 
-----------------

与 DaemonSet 中的 Pod 进行通信的几种可能模式如下：

*   推送（Push）：配置 DaemonSet 中的 Pod，将更新发送到另一个服务，例如统计数据库。 这些服务没有客户端。
*   NodeIP 和已知端口：DaemonSet 中的 Pod 可以使用 ​`hostPort`​，从而可以通过节点 IP 访问到 Pod。客户端能通过某种方法获取节点 IP 列表，并且基于此也可以获取到相应的端口。
*   DNS：创建具有相同 Pod 选择算符的 无头服务， 通过使用 ​`endpoints` ​资源或从 DNS 中检索到多个 A 记录来发现 DaemonSet。
*   Service：创建具有相同 Pod 选择算符的服务，并使用该服务随机访问到某个节点上的 守护进程（没有办法访问到特定节点）。

更新 DaemonSet 
-------------

如果节点的标签被修改，DaemonSet 将立刻向新匹配上的节点添加 Pod， 同时删除不匹配的节点上的 Pod。

你可以修改 DaemonSet 创建的 Pod。不过并非 Pod 的所有字段都可更新。 下次当某节点（即使具有相同的名称）被创建时，DaemonSet 控制器还会使用最初的模板。

您可以删除一个 DaemonSet。如果使用 ​`kubectl` ​并指定 ​`--cascade=orphan`​ 选项， 则 Pod 将被保留在节点上。接下来如果创建使用相同选择算符的新 DaemonSet， 新的 DaemonSet 会收养已有的 Pod。 如果有 Pod 需要被替换，DaemonSet 会根据其 ​`updateStrategy` ​来替换。

你可以对 DaemonSet 执行滚动更新操作。

DaemonSet 的替代方案 
----------------

### init 脚本

直接在节点上启动守护进程（例如使用 ​`init`​、​`upstartd` ​或 ​`systemd`​）的做法当然是可行的。 不过，基于 DaemonSet 来运行这些进程有如下一些好处：

*   像所运行的其他应用一样，DaemonSet 具备为守护进程提供监控和日志管理的能力。
*   为守护进程和应用所使用的配置语言和工具（如 Pod 模板、​`kubectl`​）是相同的。
*   在资源受限的容器中运行守护进程能够增加守护进程和应用容器的隔离性。 然而，这一点也可以通过在容器中运行守护进程但却不在 Pod 中运行之来实现。 例如，直接基于 Docker 启动。

### 裸 Pod 

直接创建 Pod并指定其运行在特定的节点上也是可以的。 然而，DaemonSet 能够替换由于任何原因（例如节点失败、例行节点维护、内核升级） 而被删除或终止的 Pod。 由于这个原因，你应该使用 DaemonSet 而不是单独创建 Pod。

### 静态 Pod 

通过在一个指定的、受 ​`kubelet` ​监视的目录下编写文件来创建 Pod 也是可行的。 这类 Pod 被称为静态 Pod。 不像 DaemonSet，静态 Pod 不受 ​`kubectl` ​和其它 Kubernetes API 客户端管理。 静态 Pod 不依赖于 API 服务器，这使得它们在启动引导新集群的情况下非常有用。 此外，静态 Pod 在将来可能会被废弃。

### Deployments

DaemonSet 与 Deployments 非常类似， 它们都能创建 Pod，并且 Pod 中的进程都不希望被终止（例如，Web 服务器、存储服务器）。

建议为无状态的服务使用 Deployments，比如前端服务。 对这些服务而言，对副本的数量进行扩缩容、平滑升级，比精确控制 Pod 运行在某个主机上要重要得多。 当需要 Pod 副本总是运行在全部或特定主机上，并且当该 DaemonSet 提供了节点级别的功能（允许其他 Pod 在该特定节点上正确运行）时， 应该使用 DaemonSet。

例如，网络插件通常包含一个以 DaemonSet 运行的组件。 这个 DaemonSet 组件确保它所在的节点的集群网络正常工作。

##  5.  Kubernetes Jobs
Jobs
----

Job 会创建一个或者多个 Pods，并将继续重试 Pods 的执行，直到指定数量的 Pods 成功终止。 随着 Pods 成功结束，Job 跟踪记录成功完成的 Pods 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pods。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。

一种简单的使用场景下，你会创建一个 Job 对象以便以一种可靠的方式运行某 Pod 直到完成。 当第一个 Pod 失败或者被删除（比如因为节点硬件失效或者重启）时，Job 对象会启动一个新的 Pod。

你也可以使用 Job 以并行的方式运行多个 Pod。

运行示例 Job 
---------

下面是一个 Job 配置示例。它负责计算 π 到小数点后 2000 位，并将结果打印出来。 此计算大约需要 10 秒钟完成。

`apiVersion: batch/v1 kind: Job metadata:   name: pi spec:   template:     spec:       containers:       - name: pi         image: perl         command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]       restartPolicy: Never   backoffLimit: 4`

你可以使用下面的命令来运行此示例：

`kubectl apply -f https://kubernetes.io/examples/controllers/job.yaml`

输出类似于：

`job.batch/pi created`

使用 ​`kubectl` ​来检查 Job 的状态：

`kubectl describe jobs/pi`

输出类似于：

`Name:           pi Namespace:      default Selector:       controller-uid=c9948307-e56d-4b5d-8302-ae2d7b7da67c Labels:         controller-uid=c9948307-e56d-4b5d-8302-ae2d7b7da67c                 job-name=pi Annotations:    kubectl.kubernetes.io/last-applied-configuration:                   {"apiVersion":"batch/v1","kind":"Job","metadata":{"annotations":{},"name":"pi","namespace":"default"},"spec":{"backoffLimit":4,"template":... Parallelism:    1 Completions:    1 Start Time:     Mon, 02 Dec 2019 15:20:11 +0200 Completed At:   Mon, 02 Dec 2019 15:21:16 +0200 Duration:       65s Pods Statuses:  0 Running / 1 Succeeded / 0 Failed Pod Template:   Labels:  controller-uid=c9948307-e56d-4b5d-8302-ae2d7b7da67c            job-name=pi   Containers:    pi:     Image:      perl     Port:       <none>     Host Port:  <none>     Command:       perl       -Mbignum=bpi       -wle       print bpi(2000)     Environment:  <none>     Mounts:       <none>   Volumes:        <none> Events:   Type    Reason            Age   From            Message   ----    ------            ----  ----            -------   Normal  SuccessfulCreate  14m   job-controller  Created pod: pi-5rwd7`

要查看 Job 对应的已完成的 Pods，可以执行 ​`kubectl get pods`​。

要以机器可读的方式列举隶属于某 Job 的全部 Pods，你可以使用类似下面这条命令：

`pods=$(kubectl get pods --selector=job-name=pi --output=jsonpath='{.items[*].metadata.name}') echo $pods`

输出类似于：

`pi-5rwd7`

这里，选择算符与 Job 的选择算符相同。​`--output=jsonpath`​ 选项给出了一个表达式， 用来从返回的列表中提取每个 Pod 的 name 字段。

查看其中一个 Pod 的标准输出：

`kubectl logs $pods`

输出类似于：

`3.1415926535 #后面为Π的无穷数`

编写 Job 规约 
----------

与 Kubernetes 中其他资源的配置类似，Job 也需要 ​`apiVersion`​、​`kind` ​和 ​`metadata` ​字段。 Job 的名字必须是合法的 DNS 子域名。

Job 配置还需要一个​`[.spec](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md target=)`​ 节。

### Pod 模版

Job 的 ​`.spec`​ 中只有 ​`.spec.template`​ 是必需的字段。

字段 ​`.spec.template`​ 的值是一个 Pod 模版。 其定义规范与 Pod 完全相同，只是其中不再需要 ​`apiVersion` ​或 ​`kind` ​字段。

除了作为 Pod 所必需的字段之外，Job 中的 Pod 模版必需设置合适的标签 （参见Pod 选择算符）和合适的重启策略。

Job 中 Pod 的 ​`RestartPolicy` ​只能设置为 ​`Never` ​或 ​`OnFailure` ​之一。

### Pod 选择算符 

字段 ​`.spec.selector`​ 是可选的。在绝大多数场合，你都不需要为其赋值。

### Job 的并行执行

适合以 Job 形式来运行的任务主要有三种：

1.  非并行 Job：

*   通常只启动一个 Pod，除非该 Pod 失败。
*   当 Pod 成功终止时，立即视 Job 为完成状态。

3.  具有 确定完成计数 的并行 Job：

*   ​`.spec.completions`​ 字段设置为非 0 的正数值。
*   Job 用来代表整个任务，当成功的 Pod 个数达到 ​`.spec.completions`​ 时，Job 被视为完成。
*   当使用 ​`.spec.completionMode="Indexed"`​ 时，每个 Pod 都会获得一个不同的 索引值，介于 0 和 ​`.spec.completions-1`​ 之间。

5.  带 工作队列 的并行 Job：

*   不设置 ​`spec.completions`​，默认值为 ​`.spec.parallelism`​。
*   多个 Pod 之间必须相互协调，或者借助外部服务确定每个 Pod 要处理哪个工作条目。 例如，任一 Pod 都可以从工作队列中取走最多 N 个工作条目。
*   每个 Pod 都可以独立确定是否其它 Pod 都已完成，进而确定 Job 是否完成。
*   当 Job 中 任何 Pod 成功终止，不再创建新 Pod。
*   一旦至少 1 个 Pod 成功完成，并且所有 Pod 都已终止，即可宣告 Job 成功完成。
*   一旦任何 Pod 成功退出，任何其它 Pod 都不应再对此任务执行任何操作或生成任何输出。 所有 Pod 都应启动退出过程。

对于 非并行 的 Job，你可以不设置 ​`spec.completions`​ 和 ​`spec.parallelism`​。 这两个属性都不设置时，均取默认值 1。

对于 确定完成计数 类型的 Job，你应该设置 ​`.spec.completions`​ 为所需要的完成个数。 你可以设置 ​`.spec.parallelism`​，也可以不设置。其默认值为 1。

对于一个 工作队列 Job，你不可以设置 ​`.spec.completions`​，但要将​`.spec.parallelism`​ 设置为一个非负整数。

#### 控制并行性 

并行性请求（​`.spec.parallelism`​）可以设置为任何非负整数。 如果未设置，则默认为 1。 如果设置为 0，则 Job 相当于启动之后便被暂停，直到此值被增加。

实际并行性（在任意时刻运行状态的 Pods 个数）可能比并行性请求略大或略小， 原因如下：

*   对于 确定完成计数 Job，实际上并行执行的 Pods 个数不会超出剩余的完成数。 如果 ​`.spec.parallelism`​ 值较高，会被忽略。
*   对于 工作队列 Job，有任何 Job 成功结束之后，不会有新的 Pod 启动。 不过，剩下的 Pods 允许执行完毕。
*   如果 Job 控制器 没有来得及作出响应，或者
*   如果 Job 控制器因为任何原因（例如，缺少 ​`ResourceQuota` ​或者没有权限）无法创建 Pods。 Pods 个数可能比请求的数目小。
*   Job 控制器可能会因为之前同一 Job 中 Pod 失效次数过多而压制新 Pod 的创建。
*   当 Pod 处于体面终止进程中，需要一定时间才能停止。

### 完成模式 

FEATURE STATE: Kubernetes v1.22 \[beta\]

带有 确定完成计数 的 Job，即 ​`.spec.completions`​ 不为 null 的 Job， 都可以在其 ​`.spec.completionMode`​ 中设置完成模式：

*   ​`NonIndexed`​（默认值）：当成功完成的 Pod 个数达到 ​`.spec.completions`​ 所 设值时认为 Job 已经完成。换言之，每个 Job 完成事件都是独立无关且同质的。 要注意的是，当 ​`.spec.completions`​ 取值为 null 时，Job 被隐式处理为 ​`NonIndexed`​。
*   ​`Indexed`​：Job 的 Pod 会获得对应的完成索引，取值为 0 到 ​`.spec.completions-1`​。 该索引可以通过三种方式获取：

*   Pod 注解 ​`batch.kubernetes.io/job-completion-index`​。
*   作为 Pod 主机名的一部分，遵循模式 ​`$(job-name)-$(index)`​。 当你同时使用带索引的 Job（Indexed Job）与 服务（Service）， Job 中的 Pods 可以通过 DNS 使用确切的主机名互相寻址。
*   对于容器化的任务，在环境变量 ​`JOB_COMPLETION_INDEX`​ 中。

当每个索引都对应一个完成完成的 Pod 时，Job 被认为是已完成的。需要注意的是，对同一索引值可能被启动的 Pod 不止一个，尽管这种情况很少发生。 这时，只有一个会被记入完成计数中。

处理 Pod 和容器失效
------------

Pod 中的容器可能因为多种不同原因失效，例如因为其中的进程退出时返回值非零， 或者容器因为超出内存约束而被杀死等等。 如果发生这类事件，并且 ​`.spec.template.spec.restartPolicy = "OnFailure"`​， Pod 则继续留在当前节点，但容器会被重新运行。 因此，你的程序需要能够处理在本地被重启的情况，或者要设置 ​`.spec.template.spec.restartPolicy = "Never"`​。

整个 Pod 也可能会失败，且原因各不相同。 例如，当 Pod 启动时，节点失效（被升级、被重启、被删除等）或者其中的容器失败而 ​`.spec.template.spec.restartPolicy = "Never"`​。 当 Pod 失败时，Job 控制器会启动一个新的 Pod。 这意味着，你的应用需要处理在一个新 Pod 中被重启的情况。 尤其是应用需要处理之前运行所产生的临时文件、锁、不完整的输出等问题。

注意，即使你将 ​`.spec.parallelism`​ 设置为 1，且将 ​`.spec.completions`​ 设置为 1，并且 ​`.spec.template.spec.restartPolicy`​ 设置为 "Never"，同一程序仍然有可能被启动两次。

如果你确实将 ​`.spec.parallelism`​ 和 ​`.spec.completions`​ 都设置为比 1 大的值， 那就有可能同时出现多个 Pod 运行的情况。 为此，你的 Pod 也必须能够处理并发性问题。

### Pod 回退失效策略

在有些情形下，你可能希望 Job 在经历若干次重试之后直接进入失败状态，因为这很 可能意味着遇到了配置错误。 为了实现这点，可以将 ​`.spec.backoffLimit`​ 设置为视 Job 为失败之前的重试次数。 失效回退的限制值默认为 6。 与 Job 相关的失效的 Pod 会被 Job 控制器重建，回退重试时间将会按指数增长 （从 10 秒、20 秒到 40 秒）最多至 6 分钟。 当 Job 的 Pod 被删除时，或者 Pod 成功时没有其它 Pod 处于失败状态，失效回退的次数也会被重置（为 0）。

> 如果你的 Job 的 ​`restartPolicy` ​被设置为 "OnFailure"，就要注意运行该 Job 的 Pod 会在 Job 到达失效回退次数上限时自动被终止。 这会使得调试 Job 中可执行文件的工作变得非常棘手。 我们建议在调试 Job 时将 ​`restartPolicy` ​设置为 "Never"， 或者使用日志系统来确保失效 Jobs 的输出不会意外遗失。

Job 终止与清理
---------

Job 完成时不会再创建新的 Pod，不过已有的 Pod 通常也不会被删除。 保留这些 Pod 使得你可以查看已完成的 Pod 的日志输出，以便检查错误、警告 或者其它诊断性输出。 Job 完成时 Job 对象也一样被保留下来，这样你就可以查看它的状态。 在查看了 Job 状态之后删除老的 Job 的操作留给了用户自己。 你可以使用 ​`kubectl` ​来删除 Job（例如，​`kubectl delete jobs/pi`​ 或者 ​`kubectl delete -f ./job.yaml`​）。 当使用 ​`kubectl` ​来删除 Job 时，该 Job 所创建的 Pods 也会被删除。

默认情况下，Job 会持续运行，除非某个 Pod 失败（​`restartPolicy=Never`​） 或者某个容器出错退出（​`restartPolicy=OnFailure`​）。 这时，Job 基于前述的 ​`spec.backoffLimit`​ 来决定是否以及如何重试。 一旦重试次数到达 ​`.spec.backoffLimit`​ 所设的上限，Job 会被标记为失败， 其中运行的 Pods 都会被终止。

终止 Job 的另一种方式是设置一个活跃期限。 你可以为 Job 的 ​`.spec.activeDeadlineSeconds`​ 设置一个秒数值。 该值适用于 Job 的整个生命期，无论 Job 创建了多少个 Pod。 一旦 Job 运行时间达到 ​`activeDeadlineSeconds` ​秒，其所有运行中的 Pod 都会被终止，并且 Job 的状态更新为 ​`type: Failed`​ 及 ​`reason: DeadlineExceeded`​。

注意 Job 的 ​`.spec.activeDeadlineSeconds`​ 优先级高于其 ​`.spec.backoffLimit`​ 设置。 因此，如果一个 Job 正在重试一个或多个失效的 Pod，该 Job 一旦到达 ​`activeDeadlineSeconds` ​所设的时限即不再部署额外的 Pod，即使其重试次数还未 达到 ​`backoffLimit` ​所设的限制。

例如：

`apiVersion: batch/v1 kind: Job metadata:   name: pi-with-timeout spec:   backoffLimit: 5   activeDeadlineSeconds: 100   template:     spec:       containers:       - name: pi         image: perl         command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]       restartPolicy: Never`

注意 Job 规约和 Job 中的 Pod 模版规约 都有 ​`activeDeadlineSeconds` ​字段。 请确保你在合适的层次设置正确的字段。

还要注意的是，​`restartPolicy` ​对应的是 Pod，而不是 Job 本身： 一旦 Job 状态变为 ​`type: Failed`​，就不会再发生 Job 重启的动作。 换言之，由 ​`.spec.activeDeadlineSeconds`​ 和 ​`.spec.backoffLimit`​ 所触发的 Job 终结机制 都会导致 Job 永久性的失败，而这类状态都需要手工干预才能解决。

自动清理完成的 Job 
------------

完成的 Job 通常不需要留存在系统中。在系统中一直保留它们会给 API 服务器带来额外的压力。 如果 Job 由某种更高级别的控制器来管理，例如 CronJobs， 则 Job 可以被 CronJob 基于特定的根据容量裁定的清理策略清理掉。

### 已完成 Job 的 TTL 机制 

FEATURE STATE: Kubernetes v1.23 \[stable\]

自动清理已完成 Job （状态为 ​`Complete` ​或 ​`Failed`​）的另一种方式是使用由 TTL 控制器所提供 的 TTL 机制。 通过设置 Job 的 ​`.spec.ttlSecondsAfterFinished`​ 字段，可以让该控制器清理掉 已结束的资源。

TTL 控制器清理 Job 时，会级联式地删除 Job 对象。 换言之，它会删除所有依赖的对象，包括 Pod 及 Job 本身。 注意，当 Job 被删除时，系统会考虑其生命周期保障，例如其 Finalizers。

例如：

`apiVersion: batch/v1 kind: Job metadata:   name: pi-with-ttl spec:   ttlSecondsAfterFinished: 100   template:     spec:       containers:       - name: pi         image: perl         command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]       restartPolicy: Never`

Job ​`pi-with-ttl`​ 在结束 100 秒之后，可以成为被自动删除的对象。

如果该字段设置为 ​`0`​，Job 在结束之后立即成为可被自动删除的对象。 如果该字段没有设置，Job 不会在结束之后被 TTL 控制器自动清除。

Job 模式 
-------

Job 对象可以用来支持多个 Pod 的可靠的并发执行。 Job 对象不是设计用来支持相互通信的并行进程的，后者一般在科学计算中应用较多。 Job 的确能够支持对一组相互独立而又有所关联的 工作条目 的并行处理。 这类工作条目可能是要发送的电子邮件、要渲染的视频帧、要编解码的文件、NoSQL 数据库中要扫描的主键范围等等。

在一个复杂系统中，可能存在多个不同的工作条目集合。这里我们仅考虑用户希望一起管理的 工作条目集合之一 — 批处理作业。

并行计算的模式有好多种，每种都有自己的强项和弱点。这里要权衡的因素有：

*   每个工作条目对应一个 Job 或者所有工作条目对应同一 Job 对象。 后者更适合处理大量工作条目的场景； 前者会给用户带来一些额外的负担，而且需要系统管理大量的 Job 对象。
*   创建与工作条目相等的 Pod 或者令每个 Pod 可以处理多个工作条目。 前者通常不需要对现有代码和容器做较大改动； 后者则更适合工作条目数量较大的场合，原因同上。
*   有几种技术都会用到工作队列。这意味着需要运行一个队列服务，并修改现有程序或容器 使之能够利用该工作队列。 与之比较，其他方案在修改现有容器化应用以适应需求方面可能更容易一些。

下面是对这些权衡的汇总，列 2 到 4 对应上面的权衡比较。

模式

单个 Job 对象

Pods 数少于工作条目数？

直接使用应用无需修改?

每工作条目一 Pod 的队列

✓

有时

Pod 数量可变的队列

✓

✓

静态任务分派的带索引的 Job

✓

✓

Job 模版扩展

✓

当你使用 ​`.spec.completions`​ 来设置完成数时，Job 控制器所创建的每个 Pod 使用完全相同的 ​`[spec](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md target=)`​。 这意味着任务的所有 Pod 都有相同的命令行，都使用相同的镜像和数据卷，甚至连 环境变量都（几乎）相同。 这些模式是让每个 Pod 执行不同工作的几种不同形式。

下表显示的是每种模式下 ​`.spec.parallelism`​ 和 ​`.spec.completions`​ 所需要的设置。 其中，​`W`​ 表示的是工作条目的个数。

模式

.spec.completions

.spec.parallelism

每工作条目一 Pod 的队列

W

任意值

Pod 个数可变的队列

1

任意值

静态任务分派的带索引的 Job

W

Job 模版扩展

1

应该为 1

高级用法 
-----

### 挂起 Job 

FEATURE STATE: Kubernetes v1.21 \[alpha\]

> 该特性在 Kubernetes 1.21 版本中是 Alpha 阶段，启用该特性需要额外的步骤； 请确保你正在阅读与集群版本一致的文档。

Job 被创建时，Job 控制器会马上开始执行 Pod 创建操作以满足 Job 的需求， 并持续执行此操作直到 Job 完成为止。 不过你可能想要暂时挂起 Job 执行，或启动处于挂起状态的job， 并拥有一个自定义控制器以后再决定什么时候开始。

要挂起一个 Job，你可以更新 ​`.spec.suspend`​ 字段为 true， 之后，当你希望恢复其执行时，将其更新为 false。 创建一个 ​`.spec.suspend`​ 被设置为 true 的 Job 本质上会将其创建为被挂起状态。

当 Job 被从挂起状态恢复执行时，其 ​`.status.startTime`​ 字段会被重置为 当前的时间。这意味着 ​`.spec.activeDeadlineSeconds`​ 计时器会在 Job 挂起时 被停止，并在 Job 恢复执行时复位。

要记住的是，挂起 Job 会删除其所有活跃的 Pod。当 Job 被挂起时，你的 Pod 会 收到 SIGTERM 信号而被终止。 Pod 的体面终止期限会被考虑，不过 Pod 自身也必须在此期限之内处理完信号。 处理逻辑可能包括保存进度以便将来恢复，或者取消已经做出的变更等等。 Pod 以这种形式终止时，不会被记入 Job 的 ​`completions` ​计数。

处于被挂起状态的 Job 的定义示例可能是这样子：

`kubectl get job myjob -o yaml`

`apiVersion: batch/v1 kind: Job metadata:   name: myjob spec:   suspend: true   parallelism: 1   completions: 5   template:     spec:       ...`

Job 的 ​`status` ​可以用来确定 Job 是否被挂起，或者曾经被挂起。

`kubectl get jobs/myjob -o yaml`

`apiVersion: batch/v1 kind: Job # .metadata and .spec omitted status:   conditions:   - lastProbeTime: "2021-02-05T13:14:33Z"     lastTransitionTime: "2021-02-05T13:14:33Z"     status: "True"     type: Suspended   startTime: "2021-02-05T13:13:48Z"`

Job 的 "Suspended" 类型的状况在状态值为 "True" 时意味着 Job 正被 挂起；​`lastTransitionTime` ​字段可被用来确定 Job 被挂起的时长。 如果此状况字段的取值为 "False"，则 Job 之前被挂起且现在在运行。 如果 "Suspended" 状况在 ​`status` ​字段中不存在，则意味着 Job 从未 被停止执行。

当 Job 被挂起和恢复执行时，也会生成事件：

`kubectl describe jobs/myjob`

`Name:           myjob ... Events:   Type    Reason            Age   From            Message   ----    ------            ----  ----            -------   Normal  SuccessfulCreate  12m   job-controller  Created pod: myjob-hlrpl   Normal  SuccessfulDelete  11m   job-controller  Deleted pod: myjob-hlrpl   Normal  Suspended         11m   job-controller  Job suspended   Normal  SuccessfulCreate  3s    job-controller  Created pod: myjob-jvb44   Normal  Resumed           3s    job-controller  Job resumed`

最后四个事件，特别是 "Suspended" 和 "Resumed" 事件，都是因为 ​`.spec.suspend`​ 字段值被改来改去造成的。在这两个事件之间，我们看到没有 Pod 被创建，不过当 Job 被恢复执行时，Pod 创建操作立即被重启执行。

### 可变调度指令

FEATURE STATE: Kubernetes v1.23 \[beta\]

> 为了使用此功能，你必须在 API 服务器上启用 ​`JobMutableNodeSchedulingDirectives`​ 特性门控。 默认情况下启用。

在大多数情况下，并行作业会希望 Pod 在一定约束条件下运行， 比如所有的 Pod 都在同一个区域，或者所有的 Pod 都在 GPU 型号 x 或 y 上，而不是两者的混合。

suspend 字段是实现这些语义的第一步。 suspend 允许自定义队列控制器，以决定工作何时开始；然而，一旦工作被取消暂停， 自定义队列控制器对 Job 中 Pods 的实际放置位置没有影响。

此特性允许在 Job 开始之前更新调度指令，从而为定制队列提供影响 Pod 放置的能力，同时将 Pod 与节点间的分配关系留给 kube-scheduler 决定。 这一特性仅适用于之前从未被暂停过的、已暂停的 Job。 控制器能够影响 Pod 放置，同时参考实际 pod-to-node 分配给 kube-scheduler。这仅适用于从未暂停的 Jobs。

Job 的 Pod 模板中可以更新的字段是节点亲和性、节点选择器、容忍、标签和注解。

### 指定你自己的 Pod 选择算符

通常，当你创建一个 Job 对象时，你不会设置 ​`.spec.selector`​。 系统的默认值填充逻辑会在创建 Job 时添加此字段。 它会选择一个不会与任何其他 Job 重叠的选择算符设置。

不过，有些场合下，你可能需要重载这个自动设置的选择算符。 为了实现这点，你可以手动设置 Job 的 ​`spec.selector`​ 字段。

做这个操作时请务必小心。 如果你所设定的标签选择算符并不唯一针对 Job 对应的 Pod 集合，甚或该算符还能匹配 其他无关的 Pod，这些无关的 Job 的 Pod 可能会被删除。 或者当前 Job 会将另外一些 Pod 当作是完成自身工作的 Pods， 又或者两个 Job 之一或者二者同时都拒绝创建 Pod，无法运行至完成状态。 如果所设置的算符不具有唯一性，其他控制器（如 RC 副本控制器）及其所管理的 Pod 集合可能会变得行为不可预测。 Kubernetes 不会在你设置 ​`.spec.selector`​ 时尝试阻止你犯这类错误。

下面是一个示例场景，在这种场景下你可能会使用刚刚讲述的特性。

假定名为 ​`old` ​的 Job 已经处于运行状态。 你希望已有的 Pod 继续运行，但你希望 Job 接下来要创建的其他 Pod 使用一个不同的 Pod 模版，甚至希望 Job 的名字也发生变化。 你无法更新现有的 Job，因为这些字段都是不可更新的。 因此，你会删除 ​`old` ​Job，但 允许该 Job 的 Pod 集合继续运行。 这是通过 ​`kubectl delete jobs/old --cascade=orphan`​ 实现的。 在删除之前，我们先记下该 Job 所使用的选择算符。

`kubectl get job old -o yaml`

输出类似于：

`kind: Job metadata:   name: old   ... spec:   selector:     matchLabels:       controller-uid: a8f3d00d-c6d2-11e5-9f87-42010af00002   ...`

接下来你会创建名为 ​`new` ​的新 Job，并显式地为其设置相同的选择算符。 由于现有 Pod 都具有标签 ​`controller-uid=a8f3d00d-c6d2-11e5-9f87-42010af00002`​， 它们也会被名为 ​`new` ​的 Job 所控制。

你需要在新 Job 中设置 ​`manualSelector: true`​，因为你并未使用系统通常自动为你 生成的选择算符。

`kind: Job metadata:   name: new   ... spec:   manualSelector: true   selector:     matchLabels:       controller-uid: a8f3d00d-c6d2-11e5-9f87-42010af00002   ...`

新的 Job 自身会有一个不同于 ​`a8f3d00d-c6d2-11e5-9f87-42010af00002`​ 的唯一 ID。 设置 ​`manualSelector: true`​ 是在告诉系统你知道自己在干什么并要求系统允许这种不匹配 的存在。

### 使用 Finalizer 追踪 Job 

FEATURE STATE: Kubernetes v1.23 \[beta\]

> 要使用该行为，你必须为 API 服务器 和控制器管理器 启用 ​`JobTrackingWithFinalizers` ​特性门控。 默认是启用的。  
> 启用后，控制面基于下述行为追踪新的 Job。在启用该特性之前创建的 Job 不受影响。 作为用户，你会看到的唯一区别是控制面对 Job 完成情况的跟踪更加准确。

该功能未启用时，Job 控制器（Controller） 依靠计算集群中存在的 Pod 来跟踪作业状态。 也就是说，维持一个统计 ​`succeeded` ​和 ​`failed` ​的 Pod 的计数器。 然而，Pod 可以因为一些原因被移除，包括：

*   当一个节点宕机时，垃圾收集器会删除孤立（Orphan）Pod。
*   垃圾收集器在某个阈值后删除已完成的 Pod（处于 ​`Succeeded` ​或 ​`Failed` ​阶段）。
*   人工干预删除 Job 的 Pod。
*   一个外部控制器（不包含于 Kubernetes）来删除或取代 Pod。

如果你为你的集群启用了 ​​`JobTrackingWithFinalizers` ​​特性，控制面会跟踪属于任何 Job 的 Pod。 并注意是否有任何这样的 Pod 被从 API 服务器上删除。 为了实现这一点，Job 控制器创建的 Pod 带有 ​Finalizer ​`batch.kubernetes.io/job-tracking`​​。 控制器只有在 Pod 被记入 Job 状态后才会移除 Finalizer，允许 Pod 可以被其他控制器或用户删除。

Job 控制器只对新的 Job 使用新的算法。在启用该特性之前创建的 Job 不受影响。 你可以根据检查 Job 是否含有 ​`batch.kubernetes.io/job-tracking`​ 注解，来确定 Job 控制器是否正在使用 Pod Finalizer 追踪 Job。 你不应该给 Job 手动添加或删除该注解。

替代方案 
-----

### 裸 Pod 

当 Pod 运行所在的节点重启或者失败，Pod 会被终止并且不会被重启。 Job 会重新创建新的 Pod 来替代已终止的 Pod。 因为这个原因，我们建议你使用 Job 而不是独立的裸 Pod， 即使你的应用仅需要一个 Pod。

### 副本控制器 

Job 与副本控制器是彼此互补的。 副本控制器管理的是那些不希望被终止的 Pod （例如，Web 服务器）， Job 管理的是那些希望被终止的 Pod（例如，批处理作业）。

正如在 Pod 生命期 中讨论的， ​`Job` ​仅适合于 ​`restartPolicy` ​设置为 ​`OnFailure` ​或 ​`Never` ​的 Pod。 注意：如果 ​`restartPolicy` ​未设置，其默认值是 ​`Always`​。

### 单个 Job 启动控制器 Pod

另一种模式是用唯一的 Job 来创建 Pod，而该 Pod 负责启动其他 Pod，因此扮演了一种 后启动 Pod 的控制器的角色。 这种模式的灵活性更高，但是有时候可能会把事情搞得很复杂，很难入门， 并且与 Kubernetes 的集成度很低。

这种模式的实例之一是用 Job 来启动一个运行脚本的 Pod，脚本负责启动 Spark 主控制器， 运行 Spark 驱动，之后完成清理工作。

这种方法的优点之一是整个过程得到了 Job 对象的完成保障， 同时维持了对创建哪些 Pod、如何向其分派工作的完全控制能力。

##  6.  Kubernetes 已完成 Job 的自动清理
已完成 Job 的自动清理
-------------

FEATURE STATE: Kubernetes v1.23 \[stable\]

TTL-after-finished 控制器 提供了一种 TTL 机制来限制已完成执行的资源对象的生命周期。 TTL 控制器目前只处理 Job。

TTL-after-finished 控制器
----------------------

TTL-after-finished 控制器只支持 Job。集群操作员可以通过指定 Job 的 ​`.spec.ttlSecondsAfterFinished`​ 字段来自动清理已结束的作业（​`Complete` ​或 ​`Failed`​）。

TTL-after-finished 控制器假设作业能在执行完成后的 TTL 秒内被清理，也就是当 TTL 过期后。 当 TTL 控制器清理作业时，它将做级联删除操作，即删除资源对象的同时也删除其依赖对象。 注意，当资源被删除时，由该资源的生命周期保证其终结器（Finalizers）等被执行。

可以随时设置 TTL 秒。以下是设置 Job 的 ​`.spec.ttlSecondsAfterFinished`​ 字段的一些示例：

*   在作业清单（manifest）中指定此字段，以便 Job 在完成后的某个时间被自动清除。
*   将此字段设置为现有的、已完成的作业，以采用此新功能。
*   在创建作业时使用 mutating admission webhook 动态设置该字段。集群管理员可以使用它对完成的作业强制执行 TTL 策略。
*   使用 mutating admission webhook 在作业完成后动态设置该字段，并根据作业状态、标签等选择不同的 TTL 值。

警告
--

### 更新 TTL 秒数

请注意，在创建 Job 或已经执行结束后，仍可以修改其 TTL 周期，例如 Job 的 ​`.spec.ttlSecondsAfterFinished`​ 字段。 但是一旦 Job 变为可被删除状态（当其 TTL 已过期时），即使您通过 API 增加其 TTL 时长得到了成功的响应，系统也不保证 Job 将被保留。

### 时间偏差 

由于 TTL-after-finished 控制器使用存储在 Kubernetes 资源中的时间戳来确定 TTL 是否已过期， 因此该功能对集群中的时间偏差很敏感，这可能导致 TTL-after-finished 控制器在错误的时间清理资源对象。

时钟并不总是如此正确，但差异应该很小。 设置非零 TTL 时请注意避免这种风险。

##  7.  Kubernetes CronJob
CronJob
-------

CronJob 用于执行周期性的动作，例如备份、报告生成等。 这些任务中的每一个都应该配置为周期性重复的（例如：每天/每周/每月一次）； 你可以定义任务开始执行的时间间隔。

FEATURE STATE: Kubernetes v1.21 \[stable\]

CronJob 创建基于时隔重复调度的 Jobs。

一个 CronJob 对象就像 crontab (cron table) 文件中的一行。 它用 Cron 格式进行编写， 并周期性地在给定的调度时间执行 Job。

> 所有 CronJob 的 ​`schedule`​: 时间都是基于 kube-controller-manager. 的时区。  
> 如果你的控制平面在 Pod 或是裸容器中运行了 kube-controller-manager， 那么为该容器所设置的时区将会决定 Cron Job 的控制器所使用的时区。

> Kubernetes 项目官方并不支持设置如 ​`CRON_TZ` ​或者 ​`TZ` ​等变量。 ​`CRON_TZ` ​或者 ​`TZ` ​是用于解析和计算下一个 Job 创建时间所使用的内部库中一个实现细节。 不建议在生产集群中使用它。

为 CronJob 资源创建清单时，请确保所提供的名称是一个合法的 DNS 子域名. 名称不能超过 52 个字符。 这是因为 CronJob 控制器将自动在提供的 Job 名称后附加 11 个字符，并且存在一个限制， 即 Job 名称的最大长度不能超过 63 个字符。

### 示例

下面的 CronJob 示例清单会在每分钟打印出当前时间和问候消息：

`apiVersion: batch/v1 kind: CronJob metadata:   name: hello spec:   schedule: "* * * * *"   jobTemplate:     spec:       template:         spec:           containers:           - name: hello             image: busybox:1.28             imagePullPolicy: IfNotPresent             command:             - /bin/sh             - -c             - date; echo Hello from the Kubernetes cluster           restartPolicy: OnFailure`

### Cron 时间表语法

`# ┌───────────── 分钟 (0 - 59) # │ ┌───────────── 小时 (0 - 23) # │ │ ┌───────────── 月的某天 (1 - 31) # │ │ │ ┌───────────── 月份 (1 - 12) # │ │ │ │ ┌───────────── 周的某天 (0 - 6)（周日到周一；在某些系统上，7 也是星期日） # │ │ │ │ │                          或者是 sun，mon，tue，web，thu，fri，sat # │ │ │ │ │ # │ │ │ │ │ # * * * * *`

输入

描述

相当于

@yearly (or @annually)

每年 1 月 1 日的午夜运行一次

0 0 1 1 \*

@monthly

每月第一天的午夜运行一次

0 0 1 \* \*

@weekly

每周的周日午夜运行一次

0 0 \* \* 0

@daily (or @midnight)

每天午夜运行一次

0 0 \* \* \*

@hourly

每小时的开始一次

0 \* \* \* \*

例如，下面这行指出必须在每个星期五的午夜以及每个月 13 号的午夜开始任务：

​`0 0 13 * 5` ​

要生成 CronJob 时间表表达式，你还可以使用 [crontab.guru](https://crontab.guru/) 之类的 Web 工具。

CronJob 限制 
-----------

CronJob 根据其计划编排，在每次该执行任务的时候大约会创建一个 Job。 我们之所以说 "大约"，是因为在某些情况下，可能会创建两个 Job，或者不会创建任何 Job。 我们试图使这些情况尽量少发生，但不能完全杜绝。因此，Job 应该是 幂等的。

如果 ​`startingDeadlineSeconds` ​设置为很大的数值或未设置（默认），并且 ​`concurrencyPolicy` ​设置为 ​`Allow`​，则作业将始终至少运行一次。

> 如果 ​`startingDeadlineSeconds` ​的设置值低于 10 秒钟，CronJob 可能无法被调度。 这是因为 CronJob 控制器每 10 秒钟执行一次检查。

对于每个 CronJob，CronJob 控制器（Controller） 检查从上一次调度的时间点到现在所错过了调度次数。如果错过的调度次数超过 100 次， 那么它就不会启动这个任务，并记录这个错误:

`Cannot determine if job needs to be started. Too many missed start time (> 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.`

需要注意的是，如果 ​`startingDeadlineSeconds` ​字段非空，则控制器会统计从 ​`startingDeadlineSeconds` ​设置的值到现在而不是从上一个计划时间到现在错过了多少次 Job。 例如，如果 ​`startingDeadlineSeconds` ​是 ​`200`​，则控制器会统计在过去 200 秒中错过了多少次 Job。

如果未能在调度时间内创建 CronJob，则计为错过。 例如，如果 ​`concurrencyPolicy` ​被设置为 ​`Forbid`​，并且当前有一个调度仍在运行的情况下， 试图调度的 CronJob 将被计算为错过。

例如，假设一个 CronJob 被设置为从 ​`08:30:00`​ 开始每隔一分钟创建一个新的 Job， 并且它的 ​`startingDeadlineSeconds` ​字段未被设置。如果 CronJob 控制器从 ​`08:29:00`​ 到 ​`10:21:00`​ 终止运行，则该 Job 将不会启动，因为其错过的调度 次数超过了 100。

为了进一步阐述这个概念，假设将 CronJob 设置为从 ​`08:30:00`​ 开始每隔一分钟创建一个新的 Job， 并将其 ​`startingDeadlineSeconds` ​字段设置为 200 秒。 如果 CronJob 控制器恰好在与上一个示例相同的时间段（​`08:29:00`​ 到 ​`10:21:00`​）终止运行， 则 Job 仍将从 ​`10:22:00`​ 开始。 造成这种情况的原因是控制器现在检查在最近 200 秒（即 3 个错过的调度）中发生了多少次错过的 Job 调度，而不是从现在为止的最后一个调度时间开始。

CronJob 仅负责创建与其调度时间相匹配的 Job，而 Job 又负责管理其代表的 Pod。

控制器版本 
------

从 Kubernetes v1.21 版本开始，CronJob 控制器的第二个版本被用作默认实现。 要禁用此默认 CronJob 控制器而使用原来的 CronJob 控制器，请在 kube-controller-manager 中设置特性门控 ​`CronJobControllerV2`​，将此标志设置为 ​`false`​。例如：

`--feature-gates="CronJobControllerV2=false"`

##  8.  Kubernetes ReplicationController
ReplicationController
---------------------

> 现在推荐使用配置 ReplicaSet 的 Deployment 来建立副本管理机制。

ReplicationController 确保在任何时候都有特定数量的 Pod 副本处于运行状态。 换句话说，ReplicationController 确保一个 Pod 或一组同类的 Pod 总是可用的。

ReplicationController 如何工作 
---------------------------

当 Pod 数量过多时，ReplicationController 会终止多余的 Pod。当 Pod 数量太少时，ReplicationController 将会启动新的 Pod。 与手动创建的 Pod 不同，由 ReplicationController 创建的 Pod 在失败、被删除或被终止时会被自动替换。 例如，在中断性维护（如内核升级）之后，你的 Pod 会在节点上重新创建。 因此，即使你的应用程序只需要一个 Pod，你也应该使用 ReplicationController 创建 Pod。 ReplicationController 类似于进程管理器，但是 ReplicationController 不是监控单个节点上的单个进程，而是监控跨多个节点的多个 Pod。

在讨论中，ReplicationController 通常缩写为 "rc"，并作为 kubectl 命令的快捷方式。

一个简单的示例是创建一个 ReplicationController 对象来可靠地无限期地运行 Pod 的一个实例。 更复杂的用例是运行一个多副本服务（如 web 服务器）的若干相同副本。

运行一个示例 ReplicationController 
-----------------------------

这个示例 ReplicationController 配置运行 nginx Web 服务器的三个副本。

`apiVersion: v1 kind: ReplicationController metadata:   name: nginx spec:   replicas: 3   selector:     app: nginx   template:     metadata:       name: nginx       labels:         app: nginx     spec:       containers:       - name: nginx         image: nginx         ports:         - containerPort: 80`

通过下载示例文件并运行以下命令来运行示例任务:

`kubectl apply -f https://k8s.io/examples/controllers/replication.yaml`

输出类似于：

`replicationcontroller/nginx created`

使用以下命令检查 ReplicationController 的状态:

`kubectl describe replicationcontrollers/nginx`

输出类似于：

`Name:        nginx Namespace:   default Selector:    app=nginx Labels:      app=nginx Annotations:    <none> Replicas:    3 current / 3 desired Pods Status: 0 Running / 3 Waiting / 0 Succeeded / 0 Failed Pod Template:   Labels:       app=nginx   Containers:    nginx:     Image:              nginx     Port:               80/TCP     Environment:        <none>     Mounts:             <none>   Volumes:              <none> Events:   FirstSeen       LastSeen     Count    From                        SubobjectPath    Type      Reason              Message   ---------       --------     -----    ----                        -------------    ----      ------              -------   20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-qrm3m   20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-3ntk0   20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-4ok8v`

在这里，创建了三个 Pod，但没有一个 Pod 正在运行，这可能是因为正在拉取镜像。 稍后，相同的命令可能会显示：

`Pods Status:    3 Running / 0 Waiting / 0 Succeeded / 0 Failed`

要以机器可读的形式列出属于 ReplicationController 的所有 Pod，可以使用如下命令：

`pods=$(kubectl get pods --selector=app=nginx --output=jsonpath={.items..metadata.name}) echo $pods`

输出类似于：

`nginx-3ntk0 nginx-4ok8v nginx-qrm3m`

这里，选择算符与 ReplicationController 的选择算符相同，并以不同的形式出现在 ​`replication.yaml`​ 中。 ​`--output=jsonpath`​ 选项指定了一个表达式，仅从返回列表中的每个 Pod 中获取名称。

编写一个 ReplicationController 规约
-----------------------------

与所有其它 Kubernetes 配置一样，ReplicationController 需要 ​`apiVersion`​、 ​`kind` ​和 ​`metadata` ​字段。

ReplicationController 也需要一个 ​`[.spec](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md target=)`​ 部分。

### Pod 模板 

​`.spec.template`​ 是 ​`.spec`​ 的唯一必需字段。

​`.spec.template`​ 是一个 Pod 模板。 它的模式与 Pod 完全相同，只是它是嵌套的，没有 ​`apiVersion` ​或 ​`kind` ​属性。

除了 Pod 所需的字段外，ReplicationController 中的 Pod 模板必须指定适当的标签和适当的重新启动策略。 对于标签，请确保不与其他控制器重叠。

只允许 ​`.spec.template.spec.restartPolicy`​ 等于 ​`Always`​，如果没有指定，这是默认值。

对于本地容器重启，ReplicationController 委托给节点上的代理， 例如 Kubelet 或 Docker。

### ReplicationController 上的标签 

ReplicationController 本身可以有标签 （​`.metadata.labels`​）。 通常，你可以将这些设置为 ​`.spec.template.metadata.labels`​； 如果没有指定 ​`.metadata.labels`​ 那么它默认为 ​`.spec.template.metadata.labels`​。

但是，Kubernetes 允许它们是不同的，​`.metadata.labels`​ 不会影响 ReplicationController 的行为。

### Pod 选择算符

​`.spec.selector`​ 字段是一个标签选择算符。 ReplicationController 管理标签与选择算符匹配的所有 Pod。 它不区分它创建或删除的 Pod 和其他人或进程创建或删除的 Pod。 这允许在不影响正在运行的 Pod 的情况下替换 ReplicationController。

如果指定了 ​`.spec.template.metadata.labels`​，它必须和 ​`.spec.selector`​ 相同，否则它将被 API 拒绝。 如果没有指定 ​`.spec.selector`​，它将默认为 ​`.spec.template.metadata.labels`​。

另外，通常不应直接使用另一个 ReplicationController 或另一个控制器（例如 Job） 来创建其标签与该选择算符匹配的任何 Pod。如果这样做，ReplicationController 会认为它创建了这些 Pod。 Kubernetes 并没有阻止你这样做。

如果你的确创建了多个控制器并且其选择算符之间存在重叠，那么你将不得不自己管理删除操作。

### 多个副本

你可以通过设置 ​`.spec.replicas`​ 来指定应该同时运行多少个 Pod。 在任何时候，处于运行状态的 Pod 个数都可能高于或者低于设定值。例如，副本个数刚刚被增加或减少时，或者一个 Pod 处于优雅终止过程中而其替代副本已经提前开始创建时。

如果你没有指定 ​`.spec.replicas`​ ，那么它默认是 1。

使用 ReplicationController
------------------------

### 删除一个 ReplicationController 以及它的 Pod

要删除一个 ReplicationController 以及它的 Pod，使用 ​`[kubectl delete](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=)`​。 kubectl 将 ReplicationController 缩放为 0 并等待以便在删除 ReplicationController 本身之前删除每个 Pod。 如果这个 kubectl 命令被中断，可以重新启动它。

当使用 REST API 或客户端库时，你需要明确地执行这些步骤（缩放副本为 0、 等待 Pod 删除，之后删除 ReplicationController 资源）。

### 只删除 ReplicationController

你可以删除一个 ReplicationController 而不影响它的任何 Pod。

使用 kubectl，为 ​`[kubectl delete](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=)`​ 指定 ​`--cascade=orphan`​ 选项。

当使用 REST API 或客户端库(/zh/docs/reference/using-api/client-libraries)时，只需删除 ReplicationController 对象。

一旦原始对象被删除，你可以创建一个新的 ReplicationController 来替换它。 只要新的和旧的 ​`.spec.selector`​ 相同，那么新的控制器将领养旧的 Pod。 但是，它不会做出任何努力使现有的 Pod 匹配新的、不同的 Pod 模板。 如果希望以受控方式更新 Pod 以使用新的 spec，请执行滚动更新操作。

### 从 ReplicationController 中隔离 Pod

通过更改 Pod 的标签，可以从 ReplicationController 的目标中删除 Pod。 此技术可用于从服务中删除 Pod 以进行调试、数据恢复等。以这种方式删除的 Pod 将被自动替换（假设复制副本的数量也没有更改）。

常见的使用模式
-------

### 重新调度

如上所述，无论你想要继续运行 1 个 Pod 还是 1000 个 Pod，一个 ReplicationController 都将确保存在指定数量的 Pod，即使在节点故障或 Pod 终止(例如，由于另一个控制代理的操作)的情况下也是如此。

### 扩缩容 

通过设置 ​`replicas` ​字段，ReplicationController 可以允许扩容或缩容副本的数量。 你可以手动或通过自动缩放控制代理来控制 ReplicationController 执行此操作。

### 滚动更新

ReplicationController 的设计目的是通过逐个替换 Pod 以方便滚动更新服务。

如 [#1353](https://github.com/kubernetes/kubernetes/issues/1353) PR 中所述，建议的方法是使用 1 个副本创建一个新的 ReplicationController， 逐个扩容新的（+1）和缩容旧的（-1）控制器，然后在旧的控制器达到 0 个副本后将其删除。 这一方法能够实现可控的 Pod 集合更新，即使存在意外失效的状况。

理想情况下，滚动更新控制器将考虑应用程序的就绪情况，并确保在任何给定时间都有足够数量的 Pod 有效地提供服务。

这两个 ReplicationController 将需要创建至少具有一个不同标签的 Pod，比如 Pod 主要容器的镜像标签，因为通常是镜像更新触发滚动更新。

滚动更新是在客户端工具 ​`[kubectl rolling-update](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=)`​ 中实现的。访问 kubectl rolling-update 任务以获得更多的具体示例。

### 多个版本跟踪

除了在滚动更新过程中运行应用程序的多个版本之外，通常还会使用多个版本跟踪来长时间， 甚至持续运行多个版本。这些跟踪将根据标签加以区分。

例如，一个服务可能把具有 ​`tier in (frontend), environment in (prod)`​ 的所有 Pod 作为目标。 现在假设你有 10 个副本的 Pod 组成了这个层。但是你希望能够 ​`canary` ​（金丝雀）发布这个组件的新版本。 你可以为大部分副本设置一个 ReplicationController，其中 ​`replicas` ​设置为 9， 标签为 ​`tier=frontend, environment=prod, track=stable`​ 而为 ​`canary` ​设置另一个 ReplicationController，其中 ​`replicas` ​设置为 1， 标签为 ​`tier=frontend, environment=prod, track=canary`​。 现在这个服务覆盖了 ​`canary` ​和非 ​`canary` ​Pod。但你可以单独处理 ReplicationController，以测试、监控结果等。

### 和服务一起使用 ReplicationController

多个 ReplicationController 可以位于一个服务的后面，例如，一部分流量流向旧版本， 一部分流量流向新版本。

一个 ReplicationController 永远不会自行终止，但它不会像服务那样长时间存活。 服务可以由多个 ReplicationController 控制的 Pod 组成，并且在服务的生命周期内 （例如，为了执行 Pod 更新而运行服务），可以创建和销毁许多 ReplicationController。 服务本身和它们的客户端都应该忽略负责维护服务 Pod 的 ReplicationController 的存在。

编写多副本的应用
--------

由 ReplicationController 创建的 Pod 是可替换的，语义上是相同的， 尽管随着时间的推移，它们的配置可能会变得异构。 这显然适合于多副本的无状态服务器，但是 ReplicationController 也可以用于维护主选、 分片和工作池应用程序的可用性。 这样的应用程序应该使用动态的工作分配机制，例如 RabbitMQ 工作队列， 而不是静态的或者一次性定制每个 Pod 的配置，这被认为是一种反模式。 执行的任何 Pod 定制，例如资源的垂直自动调整大小（例如，CPU 或内存）， 都应该由另一个在线控制器进程执行，这与 ReplicationController 本身没什么不同。

ReplicationController 的职责
-------------------------

ReplicationController 仅确保所需的 Pod 数量与其标签选择算符匹配，并且是可操作的。 目前，它的计数中只排除终止的 Pod。 未来，可能会考虑系统提供的[就绪状态](https://github.com/kubernetes/kubernetes/issues/620)和其他信息， 我们可能会对替换策略添加更多控制， 我们计划发出事件，这些事件可以被外部客户端用来实现任意复杂的替换和/或缩减策略。

ReplicationController 永远被限制在这个狭隘的职责范围内。 它本身既不执行就绪态探测，也不执行活跃性探测。 它不负责执行自动缩放，而是由外部自动缩放器控制（如 [#492](https://github.com/kubernetes/kubernetes/issues/492) 中所述），后者负责更改其 replicas 字段值。 我们不会向 ReplicationController 添加调度策略(例如， [spreading](https://github.com/kubernetes/kubernetes/issues/367 target=))。 它也不应该验证所控制的 Pod 是否与当前指定的模板匹配，因为这会阻碍自动调整大小和其他自动化过程。 类似地，完成期限、整理依赖关系、配置扩展和其他特性也属于其他地方。 我们甚至计划考虑批量创建 Pod 的机制（查阅 [#170](https://github.com/kubernetes/kubernetes/issues/170)）。

ReplicationController 旨在成为可组合的构建基元。 我们希望在它和其他补充原语的基础上构建更高级别的 API 或者工具，以便于将来的用户使用。 kubectl 目前支持的 "macro" 操作（运行、缩放、滚动更新）就是这方面的概念示例。 例如，我们可以想象类似于 [Asgard](https://netflixtechblog.com/asgard-web-based-cloud-management-and-deployment-2c9fc4e4d3a1) 的东西管理 ReplicationController、自动定标器、服务、调度策略、金丝雀发布等。

API 对象
------

在 Kubernetes REST API 中 Replication controller 是顶级资源。 更多关于 API 对象的详细信息可以在 [ReplicationController API 对象](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/ target=)找到

ReplicationController 的替代方案
---------------------------

### ReplicaSet

​`ReplicaSet` ​是下一代 ReplicationController， 支持新的基于集合的标签选择算符。 它主要被 ​`Deployment` ​用来作为一种编排 Pod 创建、删除及更新的机制。 请注意，我们推荐使用 Deployment 而不是直接使用 ReplicaSet，除非 你需要自定义更新编排或根本不需要更新。

### Deployment （推荐） 

​`Deployment` ​是一种更高级别的 API 对象，用于更新其底层 ReplicaSet 及其 Pod。 如果你想要这种滚动更新功能，那么推荐使用 Deployment，因为它们是声明式的、服务端的，并且具有其它特性。

### 裸 Pod

与用户直接创建 Pod 的情况不同，ReplicationController 能够替换因某些原因 被删除或被终止的 Pod ，例如在节点故障或中断节点维护的情况下，例如内核升级。 因此，我们建议你使用 ReplicationController，即使你的应用程序只需要一个 Pod。 可以将其看作类似于进程管理器，它只管理跨多个节点的多个 Pod ，而不是单个节点上的单个进程。 ReplicationController 将本地容器重启委托给节点上的某个代理(例如，Kubelet 或 Docker)。

### Job

对于预期会自行终止的 Pod (即批处理任务)，使用 ​`Job` ​而不是 ReplicationController。

### DaemonSet 

对于提供机器级功能（例如机器监控或机器日志记录）的 Pod， 使用 ​`DaemonSet` ​而不是 ReplicationController。 这些 Pod 的生命期与机器的生命期绑定：它们需要在其他 Pod 启动之前在机器上运行， 并且在机器准备重新启动或者关闭时安全地终止。

#  9.  Kubernetes 服务、负载均衡和联网

##  1.  Kubernetes 使用拓扑键实现拓扑感知的流量路由
使用拓扑键实现拓扑感知的流量路由
----------------

FEATURE STATE: Kubernetes v1.21 \[deprecated\]

> 此功能特性，尤其是 Alpha 阶段的 ​`topologyKeys` ​API，在 Kubernetes v1.21 版本中已被废弃。Kubernetes v1.21 版本中引入的 拓扑感知的提示, 提供类似的功能。

服务拓扑（Service Topology）可以让一个服务基于集群的 Node 拓扑进行流量路由。 例如，一个服务可以指定流量是被优先路由到一个和客户端在同一个 Node 或者在同一可用区域的端点。

拓扑感知的流量路由
---------

默认情况下，发往 ​`ClusterIP` ​或者 ​`NodePort` ​服务的流量可能会被路由到 服务的任一后端的地址。Kubernetes 1.7 允许将“外部”流量路由到接收到流量的 节点上的 Pod。对于 ​`ClusterIP` ​服务，无法完成同节点优先的路由，你也无法 配置集群优选路由到同一可用区中的端点。 通过在 Service 上配置 ​`topologyKeys`​，你可以基于来源节点和目标节点的 标签来定义流量路由策略。

通过对源和目的之间的标签匹配，作为集群操作者的你可以根据节点间彼此“较近”和“较远” 来定义节点集合。你可以基于符合自身需求的任何度量值来定义标签。 例如，在公有云上，你可能更偏向于把流量控制在同一区内，因为区间流量是有费用成本的， 而区内流量则没有。 其它常见需求还包括把流量路由到由 ​`DaemonSet` ​管理的本地 Pod 上，或者 把将流量转发到连接在同一机架交换机的节点上，以获得低延时。

使用服务拓扑
------

如果集群启用了 ​`ServiceTopology` ​特性门控， 你就可以在 Service 规约中设定 ​`topologyKeys` ​字段，从而控制其流量路由。 此字段是 ​`Node` ​标签的优先顺序字段，将用于在访问这个 ​`Service` ​时对端点进行排序。 流量会被定向到第一个标签值和源 ​`Node` ​标签值相匹配的 ​`Node`​。 如果这个 ​`Service` ​没有匹配的后端 ​`Node`​，那么第二个标签会被使用做匹配， 以此类推，直到没有标签。

如果没有匹配到，流量会被拒绝，就如同这个 ​`Service` ​根本没有后端。 换言之，系统根据可用后端的第一个拓扑键来选择端点。 如果这个字段被配置了而没有后端可以匹配客户端拓扑，那么这个 ​`Service` ​对那个客户端是没有后端的，链接应该是失败的。 这个字段配置为 ​`"*"`​ 意味着任意拓扑。 这个通配符值如果使用了，那么只有作为配置值列表中的最后一个才有用。

如果 ​`topologyKeys` ​没有指定或者为空，就没有启用这个拓扑约束。

一个集群中，其 ​`Node` ​的标签被打为其主机名，区域名和地区名。 那么就可以设置 ​`Service` ​的 ​`topologyKeys` ​的值，像下面的做法一样定向流量了。

*   只定向到同一个 ​`Node` ​上的端点，​`Node` ​上没有端点存在时就失败： 配置 \[​`"kubernetes.io/hostname"`​\]。
*   偏向定向到同一个 ​`Node` ​上的端点，回退同一区域的端点上，然后是同一地区， 其它情况下就失败：配置 \[​`​"kubernetes.io/hostname"​, "topology.kubernetes.io/zone", "topology.kubernetes.io/region"`​\]。 这或许很有用，例如，数据局部性很重要的情况下。
*   偏向于同一区域，但如果此区域中没有可用的终结点，则回退到任何可用的终结点： 配置 \[​`"topology.kubernetes.io/zone", "*"`​\]。

约束条件
----

*   服务拓扑和 ​`externalTrafficPolicy=Local`​ 是不兼容的，所以 ​`Service` ​不能同时使用这两种特性。 但是在同一个集群的不同 ​`Service` ​上是可以分别使用这两种特性的，只要不在同一个 ​`Service` ​上就可以。
*   有效的拓扑键目前只有：​`kubernetes.io/hostname`​、​`topology.kubernetes.io/zone`​ 和 ​`topology.kubernetes.io/region`​，但是未来会推广到其它的 ​`Node` ​标签。
*   拓扑键必须是有效的标签，并且最多指定16个。
*   通配符：​`"*"`​，如果要用，则必须是拓扑键值的最后一个值。

示例
--

以下是使用服务拓扑功能的常见示例。

### 仅节点本地端点 

仅路由到节点本地端点的一种服务。如果节点上不存在端点，流量则被丢弃：

`apiVersion: v1 kind: Service metadata:   name: my-service spec:   selector:     app: my-app   ports:     - protocol: TCP       port: 80       targetPort: 9376   topologyKeys:     - "kubernetes.io/hostname"`

### 首选节点本地端点

首选节点本地端点，如果节点本地端点不存在，则回退到集群范围端点的一种服务：

`apiVersion: v1 kind: Service metadata:   name: my-service spec:   selector:     app: my-app   ports:     - protocol: TCP       port: 80       targetPort: 9376   topologyKeys:     - "kubernetes.io/hostname"     - "*"`

### 仅地域或区域端点

首选地域端点而不是区域端点的一种服务。 如果以上两种范围内均不存在端点， 流量则被丢弃。

`apiVersion: v1 kind: Service metadata:   name: my-service spec:   selector:     app: my-app   ports:     - protocol: TCP       port: 80       targetPort: 9376   topologyKeys:     - "topology.kubernetes.io/zone"     - "topology.kubernetes.io/region"`

### 优先选择节点本地端点、地域端点，然后是区域端点

优先选择节点本地端点，地域端点，然后是区域端点，最后才是集群范围端点的 一种服务。

`apiVersion: v1 kind: Service metadata:   name: my-service spec:   selector:     app: my-app   ports:     - protocol: TCP       port: 80       targetPort: 9376   topologyKeys:     - "kubernetes.io/hostname"     - "topology.kubernetes.io/zone"     - "topology.kubernetes.io/region"     - "*"`

##  2.  Kubernetes 服务
服务
--

将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。

使用 Kubernetes，你无需修改应用程序即可使用不熟悉的服务发现机制。 Kubernetes 为 Pods 提供自己的 IP 地址，并为一组 Pod 提供相同的 DNS 名， 并且可以在它们之间进行负载均衡。

动机
--

创建和销毁 Kubernetes Pod 以匹配集群状态。 Pod 是非永久性资源。 如果你使用 Deployment 来运行你的应用程序，则它可以动态创建和销毁 Pod。

每个 Pod 都有自己的 IP 地址，但是在 Deployment 中，在同一时刻运行的 Pod 集合可能与稍后运行该应用程序的 Pod 集合不同。

这导致了一个问题： 如果一组 Pod（称为“后端”）为集群内的其他 Pod（称为“前端”）提供功能， 那么前端如何找出并跟踪要连接的 IP 地址，以便前端可以使用提供工作负载的后端部分？

进入 Services。

Service 资源
----------

Kubernetes Service 定义了这样一种抽象：逻辑上的一组 Pod，一种可以访问它们的策略 —— 通常称为微服务。 Service 所针对的 Pods 集合通常是通过选择算符来确定的。 

举个例子，考虑一个图片处理后端，它运行了 3 个副本。这些副本是可互换的 —— 前端不需要关心它们调用了哪个后端副本。 然而组成这一组后端程序的 Pod 实际上可能会发生变化， 前端客户端不应该也没必要知道，而且也不需要跟踪这一组后端的状态。

Service 定义的抽象能够解耦这种关联。

### 云原生服务发现

如果你想要在应用程序中使用 Kubernetes API 进行服务发现，则可以查询 API 服务器 的 Endpoints 资源，只要服务中的 Pod 集合发生更改，Endpoints 就会被更新。

对于非本机应用程序，Kubernetes 提供了在应用程序和后端 Pod 之间放置网络端口或负载均衡器的方法。

定义 Service
----------

Service 在 Kubernetes 中是一个 REST 对象，和 Pod 类似。 像所有的 REST 对象一样，Service 定义可以基于 POST 方式，请求 API server 创建新的实例。 Service 对象的名称必须是合法的 RFC 1035 标签名称.。

例如，假定有一组 Pod，它们对外暴露了 9376 端口，同时还被打上 ​`app=MyApp`​ 标签：

`apiVersion: v1 kind: Service metadata:   name: my-service spec:   selector:     app: MyApp   ports:     - protocol: TCP       port: 80       targetPort: 9376`

上述配置创建一个名称为 "my-service" 的 Service 对象，它会将请求代理到使用 TCP 端口 9376，并且具有标签 ​`"app=MyApp"`​ 的 Pod 上。

Kubernetes 为该服务分配一个 IP 地址（有时称为 "集群IP"），该 IP 地址由服务代理使用。

服务选择算符的控制器不断扫描与其选择器匹配的 Pod，然后将所有更新发布到也称为 “my-service” 的 Endpoint 对象。

> 需要注意的是，Service 能够将一个接收 ​`port` ​映射到任意的 ​`targetPort`​。 默认情况下，​`targetPort` ​将被设置为与 ​`port` ​字段相同的值。

Pod 中的端口定义是有名字的，你可以在服务的 ​`targetPort` ​属性中引用这些名称。 即使服务中使用单个配置的名称混合使用 Pod，并且通过不同的端口号提供相同的网络协议，此功能也可以使用。 这为部署和发展服务提供了很大的灵活性。 例如，你可以更改 Pods 在新版本的后端软件中公开的端口号，而不会破坏客户端。

服务的默认协议是 TCP；你还可以使用任何其他受支持的协议。

由于许多服务需要公开多个端口，因此 Kubernetes 在服务对象上支持多个端口定义。 每个端口定义可以具有相同的 ​`protocol`​，也可以具有不同的协议。

### 没有选择算符的 Service 

服务最常见的是抽象化对 Kubernetes Pod 的访问，但是它们也可以抽象化其他种类的后端。 实例:

*   希望在生产环境中使用外部的数据库集群，但测试环境使用自己的数据库。
*   希望服务指向另一个 名字空间（Namespace） 中或其它集群中的服务。
*   你正在将工作负载迁移到 Kubernetes。 在评估该方法时，你仅在 Kubernetes 中运行一部分后端。

在任何这些场景中，都能够定义没有选择算符的 Service。 实例:

`apiVersion: v1 kind: Service metadata:   name: my-service spec:   ports:     - protocol: TCP       port: 80       targetPort: 9376`

由于此服务没有选择算符，因此不会自动创建相应的 Endpoint 对象。 你可以通过手动添加 Endpoint 对象，将服务手动映射到运行该服务的网络地址和端口：

`apiVersion: v1 kind: Endpoints metadata:   name: my-service subsets:   - addresses:       - ip: 192.0.2.42     ports:       - port: 9376`

Endpoints 对象的名称必须是合法的 DNS 子域名。

> 端点 IPs 必须不可以 是：本地回路（IPv4 的 127.0.0.0/8, IPv6 的 ::1/128）或 本地链接（IPv4 的 169.254.0.0/16 和 224.0.0.0/24，IPv6 的 fe80::/64)。  
> 端点 IP 地址不能是其他 Kubernetes 服务的集群 IP，因为 kube-proxy 不支持将虚拟 IP 作为目标。

访问没有选择算符的 Service，与有选择算符的 Service 的原理相同。 请求将被路由到用户定义的 Endpoint，YAML 中为：​`192.0.2.42:9376`​（TCP）。

ExternalName Service 是 Service 的特例，它没有选择算符，但是使用 DNS 名称。

### 超出容量的 Endpoints 

如果某个 Endpoints 资源中包含的端点个数超过 1000，则 Kubernetes v1.22 版本 （及更新版本）的集群会将为该 Endpoints 添加注解 ​`endpoints.kubernetes.io/over-capacity: truncated`​。 这一注解表明所影响到的 Endpoints 对象已经超出容量，此外 Endpoints 控制器还会将 Endpoints 对象数量截断到 1000。

### EndpointSlices

FEATURE STATE: Kubernetes v1.21 \[stable\]

EndpointSlices 是一种 API 资源，可以为 Endpoints 提供更可扩展的替代方案。 尽管从概念上讲与 Endpoints 非常相似，但 EndpointSlices 允许跨多个资源分布网络端点。 默认情况下，一旦到达 100 个 Endpoint，该 EndpointSlice 将被视为“已满”， 届时将创建其他 EndpointSlices 来存储任何其他 Endpoints。

EndpointSlices 提供了附加的属性和功能，这些属性和功能在 EndpointSlices 中有详细描述。

### 应用协议 

FEATURE STATE: Kubernetes v1.20 \[stable\]

​`appProtocol` ​字段提供了一种为每个 Service 端口指定应用协议的方式。 此字段的取值会被映射到对应的 Endpoints 和 EndpointSlices 对象。

该字段遵循标准的 Kubernetes 标签语法。 其值可以是 [IANA 标准服务名称](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml) 或以域名为前缀的名称，如 ​`mycompany.com/my-custom-protocol`​。

虚拟 IP 和 Service 代理
------------------

在 Kubernetes 集群中，每个 Node 运行一个 ​`kube-proxy`​ 进程。 ​`kube-proxy`​ 负责为 Service 实现了一种 VIP（虚拟 IP）的形式，而不是 ​`ExternalName` ​的形式。

### 为什么不使用 DNS 轮询？

时不时会有人问到为什么 Kubernetes 依赖代理将入站流量转发到后端。那其他方法呢？ 例如，是否可以配置具有多个 A 值（或 IPv6 为 AAAA）的 DNS 记录，并依靠轮询名称解析？

使用服务代理有以下几个原因：

*   DNS 实现的历史由来已久，它不遵守记录 TTL，并且在名称查找结果到期后对其进行缓存。
*   有些应用程序仅执行一次 DNS 查找，并无限期地缓存结果。
*   即使应用和库进行了适当的重新解析，DNS 记录上的 TTL 值低或为零也可能会给 DNS 带来高负载，从而使管理变得困难。

### userspace 代理模式

这种模式，kube-proxy 会监视 Kubernetes 控制平面对 Service 对象和 Endpoints 对象的添加和移除操作。 对每个 Service，它会在本地 Node 上打开一个端口（随机选择）。 任何连接到“代理端口”的请求，都会被代理到 Service 的后端 ​`Pods` ​中的某个上面（如 ​`Endpoints` ​所报告的一样）。 使用哪个后端 Pod，是 kube-proxy 基于 ​`SessionAffinity` ​来确定的。

最后，它配置 iptables 规则，捕获到达该 Service 的 ​`clusterIP`​（是虚拟 IP） 和 ​`Port` ​的请求，并重定向到代理端口，代理端口再代理请求到后端Pod。

默认情况下，用户空间模式下的 kube-proxy 通过轮转算法选择后端。

![](https://atts.w3cschool.cn/attachments/image/20220506/1651803046551067.svg)  

### iptables 代理模式

这种模式，​`kube-proxy`​ 会监视 Kubernetes 控制节点对 Service 对象和 Endpoints 对象的添加和移除。 对每个 Service，它会配置 iptables 规则，从而捕获到达该 Service 的 ​`clusterIP` ​和端口的请求，进而将请求重定向到 Service 的一组后端中的某个 Pod 上面。 对于每个 Endpoints 对象，它也会配置 iptables 规则，这个规则会选择一个后端组合。

默认的策略是，kube-proxy 在 iptables 模式下随机选择一个后端。

使用 iptables 处理流量具有较低的系统开销，因为流量由 Linux netfilter 处理， 而无需在用户空间和内核空间之间切换。 这种方法也可能更可靠。

如果 kube-proxy 在 iptables 模式下运行，并且所选的第一个 Pod 没有响应， 则连接失败。 这与用户空间模式不同：在这种情况下，kube-proxy 将检测到与第一个 Pod 的连接已失败， 并会自动使用其他后端 Pod 重试。

你可以使用 Pod 就绪探测器 验证后端 Pod 可以正常工作，以便 iptables 模式下的 kube-proxy 仅看到测试正常的后端。 这样做意味着你避免将流量通过 kube-proxy 发送到已知已失败的 Pod。

![](https://atts.w3cschool.cn/attachments/image/20220506/1651803096285815.svg)  

### IPVS 代理模式

FEATURE STATE: Kubernetes v1.11 \[stable\]

在 ​`ipvs` ​模式下，kube-proxy 监视 Kubernetes 服务和端点，调用 ​`netlink` ​接口相应地创建 IPVS 规则， 并定期将 IPVS 规则与 Kubernetes 服务和端点同步。 该控制循环可确保IPVS 状态与所需状态匹配。访问服务时，IPVS 将流量定向到后端Pod之一。

IPVS代理模式基于类似于 iptables 模式的 netfilter 挂钩函数， 但是使用哈希表作为基础数据结构，并且在内核空间中工作。 这意味着，与 iptables 模式下的 kube-proxy 相比，IPVS 模式下的 kube-proxy 重定向通信的延迟要短，并且在同步代理规则时具有更好的性能。 与其他代理模式相比，IPVS 模式还支持更高的网络流量吞吐量。

IPVS 提供了更多选项来平衡后端 Pod 的流量。 这些是：

*   ​`rr`​：轮替（Round-Robin）
*   ​`lc`​：最少链接（Least Connection），即打开链接数量最少者优先
*   ​`dh`​：目标地址哈希（Destination Hashing）
*   ​`sh`​：源地址哈希（Source Hashing）
*   ​`sed`​：最短预期延迟（Shortest Expected Delay）
*   ​`nq`​：从不排队（Never Queue）

> 要在 IPVS 模式下运行 kube-proxy，必须在启动 kube-proxy 之前使 IPVS 在节点上可用。  
> 当 kube-proxy 以 IPVS 代理模式启动时，它将验证 IPVS 内核模块是否可用。 如果未检测到 IPVS 内核模块，则 kube-proxy 将退回到以 iptables 代理模式运行。

![](https://atts.w3cschool.cn/attachments/image/20220506/1651803184255528.svg)  

在这些代理模型中，绑定到服务 IP 的流量： 在客户端不了解 Kubernetes 或服务或 Pod 的任何信息的情况下，将 Port 代理到适当的后端。

如果要确保每次都将来自特定客户端的连接传递到同一 Pod， 则可以通过将 ​`service.spec.sessionAffinity`​ 设置为 "ClientIP" （默认值是 "None"），来基于客户端的 IP 地址选择会话关联。 你还可以通过适当设置 ​`service.spec.sessionAffinityConfig.clientIP.timeoutSeconds`​ 来设置最大会话停留时间。 （默认值为 10800 秒，即 3 小时）。

多端口 Service 
------------

对于某些服务，你需要公开多个端口。 Kubernetes 允许你在 Service 对象上配置多个端口定义。 为服务使用多个端口时，必须提供所有端口名称，以使它们无歧义。 例如：

`apiVersion: v1 kind: Service metadata:   name: my-service spec:   selector:     app: MyApp   ports:     - name: http       protocol: TCP       port: 80       targetPort: 9376     - name: https       protocol: TCP       port: 443       targetPort: 9377`

> 与一般的Kubernetes名称一样，端口名称只能包含小写字母数字字符 和 ​`-`​。 端口名称还必须以字母数字字符开头和结尾。  
> 例如，名称 ​`123-abc`​ 和 ​`web` ​有效，但是 ​`123_abc`​ 和 ​`-web`​ 无效。

选择自己的 IP 地址
-----------

在 ​`Service` ​创建的请求中，可以通过设置 ​`spec.clusterIP`​ 字段来指定自己的集群 IP 地址。 比如，希望替换一个已经已存在的 DNS 条目，或者遗留系统已经配置了一个固定的 IP 且很难重新配置。

用户选择的 IP 地址必须合法，并且这个 IP 地址在 ​`service-cluster-ip-range`​ CIDR 范围内， 这对 API 服务器来说是通过一个标识来指定的。 如果 IP 地址不合法，API 服务器会返回 HTTP 状态码 422，表示值不合法。

流量策略 
-----

### 外部流量策略 

你可以通过设置 ​`spec.externalTrafficPolicy`​ 字段来控制来自于外部的流量是如何路由的。 可选值有 ​`Cluster` ​和 ​`Local`​。字段设为 ​`Cluster` ​会将外部流量路由到所有就绪的端点， 设为 ​`Local` ​会只路由到当前节点上就绪的端点。 如果流量策略设置为 ​`Local`​，而且当前节点上没有就绪的端点，kube-proxy 不会转发请求相关服务的任何流量。

> FEATURE STATE: Kubernetes v1.22 \[alpha\]  
> 如果你启用了 kube-proxy 的 ​`ProxyTerminatingEndpoints` ​特性门控， kube-proxy 会检查节点是否有本地的端点，以及是否所有的本地端点都被标记为终止中。  
> 如果本地有端点，而且所有端点处于终止中的状态，那么 kube-proxy 会忽略任何设为 ​`Local` ​的外部流量策略。 在所有本地端点处于终止中的状态的同时，kube-proxy 将请求指定服务的流量转发到位于其它节点的 状态健康的端点，如同外部流量策略设为 ​`Cluster`​。  
> 针对处于正被终止状态的端点这一转发行为使得外部负载均衡器可以优雅地排出由 ​`NodePort` ​服务支持的连接，就算是健康检查节点端口开始失败也是如此。 否则，当节点还在负载均衡器的节点池内，在 Pod 终止过程中的流量会被丢掉，这些流量可能会丢失。

### 内部流量策略 

FEATURE STATE: Kubernetes v1.22 \[beta\]

你可以设置 ​`spec.internalTrafficPolicy`​ 字段来控制内部来源的流量是如何转发的。可设置的值有 ​`Cluster` ​和 ​`Local`​。 将字段设置为 ​`Cluster` ​会将内部流量路由到所有就绪端点，设置为 ​`Local` ​只会路由到当前节点上就绪的端点。 如果流量策略是 ​`Local`​，而且当前节点上没有就绪的端点，那么 kube-proxy 会丢弃流量。

服务发现 
-----

Kubernetes 支持两种基本的服务发现模式 —— 环境变量和 DNS。

### 环境变量 

当 Pod 运行在 ​`Node` ​上，kubelet 会为每个活跃的 Service 添加一组环境变量。 它同时支持 [Docker links](https://docs.docker.com/network/links/)兼容 变量、 简单的 ​`{SVCNAME}_SERVICE_HOST`​ 和 ​`{SVCNAME}_SERVICE_PORT`​ 变量。 这里 Service 的名称需大写，横线被转换成下划线。

举个例子，一个名称为 ​`redis-master`​ 的 Service 暴露了 TCP 端口 6379， 同时给它分配了 Cluster IP 地址 10.0.0.11，这个 Service 生成了如下环境变量：

`REDIS_MASTER_SERVICE_HOST=10.0.0.11 REDIS_MASTER_SERVICE_PORT=6379 REDIS_MASTER_PORT=tcp://10.0.0.11:6379 REDIS_MASTER_PORT_6379_TCP=tcp://10.0.0.11:6379 REDIS_MASTER_PORT_6379_TCP_PROTO=tcp REDIS_MASTER_PORT_6379_TCP_PORT=6379 REDIS_MASTER_PORT_6379_TCP_ADDR=10.0.0.11`

> 当你具有需要访问服务的 Pod 时，并且你正在使用环境变量方法将端口和集群 IP 发布到客户端 Pod 时，必须在客户端 Pod 出现 之前 创建服务。 否则，这些客户端 Pod 将不会设定其环境变量。  
> 如果仅使用 DNS 查找服务的集群 IP，则无需担心此设定问题。

### DNS

你可以（几乎总是应该）使用附加组件 为 Kubernetes 集群设置 DNS 服务。

支持集群的 DNS 服务器（例如 CoreDNS）监视 Kubernetes API 中的新服务，并为每个服务创建一组 DNS 记录。 如果在整个集群中都启用了 DNS，则所有 Pod 都应该能够通过其 DNS 名称自动解析服务。

例如，如果你在 Kubernetes 命名空间 ​`my-ns`​ 中有一个名为 ​`my-service`​ 的服务， 则控制平面和 DNS 服务共同为 ​`my-service.my-ns`​ 创建 DNS 记录。 ​`my-ns`​ 命名空间中的 Pod 应该能够通过按名检索 ​`my-service`​ 来找到服务 （​`my-service.my-ns`​ 也可以工作）。

其他命名空间中的 Pod 必须将名称限定为 ​`my-service.my-ns`​。 这些名称将解析为为服务分配的集群 IP。

Kubernetes 还支持命名端口的 DNS SRV（服务）记录。 如果 ​`my-service.my-ns`​ 服务具有名为 ​`http`的端口，且协议设置为 TCP， 则可以对 ​`_http._tcp.my-service.my-ns`​ 执行 DNS SRV 查询查询以发现该端口号, ​`"http"`​ 以及 IP 地址。

Kubernetes DNS 服务器是唯一的一种能够访问 ​`ExternalName` ​类型的 Service 的方式。 

无头服务（Headless Services） 
------------------------

有时不需要或不想要负载均衡，以及单独的 Service IP。 遇到这种情况，可以通过指定 Cluster IP（​`spec.clusterIP`​）的值为 ​`"None"`​ 来创建 ​`Headless` ​Service。

你可以使用无头 Service 与其他服务发现机制进行接口，而不必与 Kubernetes 的实现捆绑在一起。

对这无头 Service 并不会分配 Cluster IP，kube-proxy 不会处理它们， 而且平台也不会为它们进行负载均衡和路由。 DNS 如何实现自动配置，依赖于 Service 是否定义了选择算符。

### 带选择算符的服务

对定义了选择算符的无头服务，Endpoint 控制器在 API 中创建了 Endpoints 记录， 并且修改 DNS 配置返回 A 记录（IP 地址），通过这个地址直接到达 ​`Service` ​的后端 Pod 上。

### 无选择算符的服务 

对没有定义选择算符的无头服务，Endpoint 控制器不会创建 ​`Endpoints` ​记录。 然而 DNS 系统会查找和配置，无论是：

*   对于 ​`ExternalName` ​类型的服务，查找其 CNAME 记录
*   对所有其他类型的服务，查找与 Service 名称相同的任何 ​`Endpoints` ​的记录

发布服务（服务类型) 
-----------

对一些应用的某些部分（如前端），可能希望将其暴露给 Kubernetes 集群外部 的 IP 地址。

Kubernetes ​`ServiceTypes` ​允许指定你所需要的 Service 类型，默认是 ​`ClusterIP`​。

​`Type` ​的取值以及行为如下：

*   ​`ClusterIP`​：通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是默认的 ​`ServiceType`​。
*   ​`NodePort`​：通过每个节点上的 IP 和静态端口（​`NodePort`​）暴露服务。 ​`NodePort` ​服务会路由到自动创建的 ​`ClusterIP` ​服务。 通过请求 ​`<节点 IP>:<节点端口>`​，你可以从集群的外部访问一个 ​`NodePort` ​服务。
*   ​`LoadBalancer`​：使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 ​`NodePort` ​服务和 ​`ClusterIP` ​服务上。
*   ​`ExternalName`​：通过返回 ​`CNAME` ​和对应值，可以将服务映射到 ​`externalName` ​字段的内容（例如，​`foo.bar.example.com`​）。 无需创建任何类型代理。

> 你需要使用 kube-dns 1.7 及以上版本或者 CoreDNS 0.0.8 及以上版本才能使用 ​`ExternalName` ​类型。

你也可以使用 Ingress 来暴露自己的服务。 Ingress 不是一种服务类型，但它充当集群的入口点。 它可以将路由规则整合到一个资源中，因为它可以在同一IP地址下公开多个服务。

### NodePort 类型 

如果你将 ​`type` ​字段设置为 ​`NodePort`​，则 Kubernetes 控制平面将在 ​`--service-node-port-range`​ 标志指定的范围内分配端口（默认值：30000-32767）。 每个节点将那个端口（每个节点上的相同端口号）代理到你的服务中。 你的服务在其 ​`.spec.ports[*].nodePort`​ 字段中要求分配的端口。

如果你想指定特定的 IP 代理端口，则可以设置 kube-proxy 中的 ​`--nodeport-addresses`​ 参数 或者将kube-proxy 配置文件 中的等效 ​`nodePortAddresses` ​字段设置为特定的 IP 块。 该标志采用逗号分隔的 IP 块列表（例如，​`10.0.0.0/8`​、​`192.0.2.0/25`​）来指定 kube-proxy 应该认为是此节点本地的 IP 地址范围。

例如，如果你使用 ​`--nodeport-addresses=127.0.0.0/8`​ 标志启动 kube-proxy， 则 kube-proxy 仅选择 NodePort Services 的本地回路接口。 ​`--nodeport-addresses`​ 的默认值是一个空列表。 这意味着 kube-proxy 应该考虑 NodePort 的所有可用网络接口。 （这也与早期的 Kubernetes 版本兼容）。

如果需要特定的端口号，你可以在 ​`nodePort` ​字段中指定一个值。 控制平面将为你分配该端口或报告 API 事务失败。 这意味着你需要自己注意可能发生的端口冲突。 你还必须使用有效的端口号，该端口号在配置用于 NodePort 的范围内。

使用 NodePort 可以让你自由设置自己的负载均衡解决方案， 配置 Kubernetes 不完全支持的环境， 甚至直接暴露一个或多个节点的 IP。

需要注意的是，Service 能够通过 ​`<NodeIP>:spec.ports[*].nodePort`​ 和 ​`spec.clusterIp:spec.ports[*].port`​ 而对外可见。 如果设置了 kube-proxy 的 ​`--nodeport-addresses`​ 参数或 kube-proxy 配置文件中的等效字段， ​ `<NodeIP>`​ 将被过滤 NodeIP。

例如：

``apiVersion: v1 kind: Service metadata:   name: my-service spec:   type: NodePort   selector:     app: MyApp   ports:       # 默认情况下，为了方便起见，`targetPort` 被设置为与 `port` 字段相同的值。     - port: 80       targetPort: 80       # 可选字段       # 默认情况下，为了方便起见，Kubernetes 控制平面会从某个范围内分配一个端口号（默认：30000-32767）       nodePort: 30007``

### LoadBalancer 类型 

在使用支持外部负载均衡器的云提供商的服务时，设置 ​`type` ​的值为 ​`"LoadBalancer"`​， 将为 Service 提供负载均衡器。 负载均衡器是异步创建的，关于被提供的负载均衡器的信息将会通过 Service 的 ​`status.loadBalancer`​ 字段发布出去。

实例：

`apiVersion: v1 kind: Service metadata:   name: my-service spec:   selector:     app: MyApp   ports:     - protocol: TCP       port: 80       targetPort: 9376   clusterIP: 10.0.171.239   type: LoadBalancer status:   loadBalancer:     ingress:       - ip: 192.0.2.127`

来自外部负载均衡器的流量将直接重定向到后端 Pod 上，不过实际它们是如何工作的，这要依赖于云提供商。

某些云提供商允许设置 ​`loadBalancerIP`​。 在这些情况下，将根据用户设置的 ​`loadBalancerIP` ​来创建负载均衡器。 如果没有设置 ​`loadBalancerIP` ​字段，将会给负载均衡器指派一个临时 IP。 如果设置了 ​`loadBalancerIP`​，但云提供商并不支持这种特性，那么设置的 ​`loadBalancerIP` ​值将会被忽略掉。

> 在 Azure 上，如果要使用用户指定的公共类型 ​`loadBalancerIP`​，则 首先需要创建静态类型的公共 IP 地址资源。 此公共 IP 地址资源应与集群中其他自动创建的资源位于同一资源组中。 例如，​`MC_myResourceGroup_myAKSCluster_eastus`​。  
> 将分配的 IP 地址设置为 loadBalancerIP。确保你已更新云提供程序配置文件中的 securityGroupName。 有关对 ​`CreatingLoadBalancerFailed` ​权限问题进行故障排除的信息， 请参阅 [与 Azure Kubernetes 服务（AKS）负载平衡器一起使用静态 IP 地址](https://docs.microsoft.com/en-us/azure/aks/static-ip) 或 [在 AKS 集群上使用高级联网时出现 CreatingLoadBalancerFailed](https://github.com/Azure/AKS/issues/357)。

#### 混合协议类型的负载均衡器 

FEATURE STATE: Kubernetes v1.20 \[alpha\]

默认情况下，对于 LoadBalancer 类型的服务，当定义了多个端口时，所有 端口必须具有相同的协议，并且该协议必须是受云提供商支持的协议。

如果为 kube-apiserver 启用了 ​`MixedProtocolLBService` ​特性门控， 则当定义了多个端口时，允许使用不同的协议。

> 可用于 LoadBalancer 类型服务的协议集仍然由云提供商决定。

### 禁用负载均衡器节点端口分配

FEATURE STATE: Kubernetes v1.20 \[alpha\]

从 v1.20 版本开始， 你可以通过设置 ​`spec.allocateLoadBalancerNodePorts`​ 为 ​`false` ​对类型为 LoadBalancer 的服务禁用节点端口分配。 这仅适用于直接将流量路由到 Pod 而不是使用节点端口的负载均衡器实现。 默认情况下，​`spec.allocateLoadBalancerNodePorts`​ 为 ​`true`​， LoadBalancer 类型的服务继续分配节点端口。 如果现有服务已被分配节点端口，将参数 ​`spec.allocateLoadBalancerNodePorts`​ 设置为 ​`false` ​时，这些服务上已分配置的节点端口不会被自动释放。 你必须显式地在每个服务端口中删除 ​`nodePorts` ​项以释放对应端口。 你必须启用 ​`ServiceLBNodePortControl` ​特性门控才能使用该字段。

#### 设置负载均衡器实现的类别

FEATURE STATE: Kubernetes v1.22 \[beta\]

​`spec.loadBalancerClass`​ 允许你不使用云提供商的默认负载均衡器实现，转而使用指定的负载均衡器实现。 这个特性从 v1.21 版本开始可以使用，你在 v1.21 版本中使用这个字段必须启用 ​`ServiceLoadBalancerClass` ​特性门控，这个特性门控从 v1.22 版本及以后默认打开。 默认情况下，​`.spec.loadBalancerClass`​ 的取值是 ​`nil`​，如果集群使用 ​`--cloud-provider`​ 配置了云提供商， ​`LoadBalancer` ​类型服务会使用云提供商的默认负载均衡器实现。 如果设置了 ​`.spec.loadBalancerClass`​，则假定存在某个与所指定的类相匹配的 负载均衡器实现在监视服务变化。 所有默认的负载均衡器实现（例如，由云提供商所提供的）都会忽略设置了此字段 的服务。​`.spec.loadBalancerClass`​ 只能设置到类型为 ​`LoadBalancer` ​的 Service 之上，而且一旦设置之后不可变更。

​`.spec.loadBalancerClass`​ 的值必须是一个标签风格的标识符， 可以有选择地带有类似 "​`internal-vip`​" 或 "​`example.com/internal-vip`​" 这类 前缀。没有前缀的名字是保留给最终用户的。

#### 内部负载均衡器

在混合环境中，有时有必要在同一(虚拟)网络地址块内路由来自服务的流量。

在水平分割 DNS 环境中，你需要两个服务才能将内部和外部流量都路由到你的端点（Endpoints）。

如要设置内部负载均衡器，请根据你所使用的云运营商，为服务添加以下注解之一。

*   GCP

`[...] metadata:     name: my-service     annotations:         cloud.google.com/load-balancer-type: "Internal" [...]`

*   AWS
    
    `[...] metadata:     name: my-service     annotations:         service.beta.kubernetes.io/aws-load-balancer-internal: "true" [...]`
    
*   Azure
    
    `[...] metadata:     name: my-service     annotations:         service.beta.kubernetes.io/azure-load-balancer-internal: "true" [...]`
    
*   IBM Cloud
    
    `[...] metadata:     name: my-service     annotations:         service.kubernetes.io/ibm-load-balancer-cloud-provider-ip-type: "private" [...]`
    
*   OpenStack
    
    `[...] metadata:     name: my-service     annotations:         service.beta.kubernetes.io/openstack-internal-load-balancer: "true" [...]`
    
*   Baidu Cloud
    
    `[...] metadata:     name: my-service     annotations:         service.beta.kubernetes.io/cce-load-balancer-internal-vpc: "true" [...]`
    
*   Tencent Cloud
    
    `[...] metadata:   annotations:     service.kubernetes.io/qcloud-loadbalancer-internal-subnetid: subnet-xxxxx [...]`
    
*   Alibaba Cloud
    
    `[...] metadata:   annotations:     service.beta.kubernetes.io/alibaba-cloud-loadbalancer-address-type: "intranet" [...]`
    

### AWS TLS 支持

为了对在 AWS 上运行的集群提供 TLS/SSL 部分支持，你可以向 ​`LoadBalancer` ​服务添加三个注解：

`metadata:   name: my-service   annotations:     service.beta.kubernetes.io/aws-load-balancer-ssl-cert: arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012`

第一个指定要使用的证书的 ARN。 它可以是已上载到 IAM 的第三方颁发者的证书， 也可以是在 AWS Certificate Manager 中创建的证书。

`metadata:   name: my-service   annotations:     service.beta.kubernetes.io/aws-load-balancer-backend-protocol: (https|http|ssl|tcp)`

第二个注解指定 Pod 使用哪种协议。 对于 HTTPS 和 SSL，ELB 希望 Pod 使用证书 通过加密连接对自己进行身份验证。

HTTP 和 HTTPS 选择第7层代理：ELB 终止与用户的连接，解析标头，并在转发请求时向 ​`X-Forwarded-For`​ 标头注入用户的 IP 地址（Pod 仅在连接的另一端看到 ELB 的 IP 地址）。

TCP 和 SSL 选择第4层代理：ELB 转发流量而不修改报头。

在某些端口处于安全状态而其他端口未加密的混合使用环境中，可以使用以下注解：

`metadata:   name: my-service   annotations:     service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http     service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443,8443"`

在上例中，如果服务包含 ​`80`​、​`443` ​和 ​`8443` ​三个端口， 那么 ​`443` ​和 ​`8443` ​将使用 SSL 证书， 而 ​`80` ​端口将转发 HTTP 数据包。

从 Kubernetes v1.9 起可以使用 [预定义的 AWS SSL 策略](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-policy-table.html) 为你的服务使用 HTTPS 或 SSL 侦听器。 要查看可以使用哪些策略，可以使用 ​`aws` ​命令行工具：

`aws elb describe-load-balancer-policies --query 'PolicyDescriptions[].PolicyName'`
    

然后，你可以使用 "​`service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy`​" 注解; 例如：

`metadata:   name: my-service   annotations:     service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy: "ELBSecurityPolicy-TLS-1-2-2017-01"`

#### AWS 上的 PROXY 协议支持

为了支持在 AWS 上运行的集群，启用 [PROXY 协议](https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt)。 你可以使用以下服务注解：

`metadata:   name: my-service   annotations:     service.beta.kubernetes.io/aws-load-balancer-proxy-protocol: "*"`

从 1.3.0 版开始，此注解的使用适用于 ELB 代理的所有端口，并且不能进行其他配置。

#### AWS 上的 ELB 访问日志

有几个注解可用于管理 AWS 上 ELB 服务的访问日志。

注解 ​`service.beta.kubernetes.io/aws-load-balancer-access-log-enabled`​ 控制是否启用访问日志。

注解 ​`service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval`​ 控制发布访问日志的时间间隔（以分钟为单位）。你可以指定 5 分钟或 60 分钟的间隔。

注解 ​`service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name`​ 控制存储负载均衡器访问日志的 Amazon S3 存储桶的名称。

注解 ​`service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix`​ 指定为 Amazon S3 存储桶创建的逻辑层次结构。

`` metadata:   name: my-service   annotations:     service.beta.kubernetes.io/aws-load-balancer-access-log-enabled: "true"     # 指定是否为负载均衡器启用访问日志     service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval: "60"     # 发布访问日志的时间间隔。你可以将其设置为 5 分钟或 60 分钟。     service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name: "my-bucket"     # 用来存放访问日志的 Amazon S3 Bucket 名称     service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix: "my-bucket-prefix/prod"     # 你为 Amazon S3 Bucket 所创建的逻辑层次结构，例如 `my-bucket-prefix/prod` ``

#### AWS 上的连接排空 

可以将注解 ​`service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled`​ 设置为 ​`"true"`​ 来管理 ELB 的连接排空。 注解 ​`service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout`​ 也可以用于设置最大时间（以秒为单位），以保持现有连接在注销实例之前保持打开状态。

`metadata:   name: my-service   annotations:     service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled: "true"     service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout: "60"`
        

#### 其他 ELB 注解

还有其他一些注解，用于管理经典弹性负载均衡器，如下所述。

`metadata:   name: my-service   annotations:     # 按秒计的时间，表示负载均衡器关闭连接之前连接可以保持空闲     # （连接上无数据传输）的时间长度     service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "60"      # 指定该负载均衡器上是否启用跨区的负载均衡能力     service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"      # 逗号分隔列表值，每一项都是一个键-值耦对，会作为额外的标签记录于 ELB 中     service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags: "environment=prod,owner=devops"      # 将某后端视为健康、可接收请求之前需要达到的连续成功健康检查次数。     # 默认为 2，必须介于 2 和 10 之间     service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold: ""      # 将某后端视为不健康、不可接收请求之前需要达到的连续不成功健康检查次数。     # 默认为 6，必须介于 2 和 10 之间     service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold: "3"      # 对每个实例进行健康检查时，连续两次检查之间的大致间隔秒数     # 默认为 10，必须介于 5 和 300 之间     service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval: "20"      # 时长秒数，在此期间没有响应意味着健康检查失败     # 此值必须小于 service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval     # 默认值为 5，必须介于 2 和 60 之间     service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout: "5"      # 由已有的安全组所构成的列表，可以配置到所创建的 ELB 之上。     # 与注解 service.beta.kubernetes.io/aws-load-balancer-extra-security-groups 不同，     # 这一设置会替代掉之前指定给该 ELB 的所有其他安全组，也会覆盖掉为此     # ELB 所唯一创建的安全组。      # 此列表中的第一个安全组 ID 被用来作为决策源，以允许入站流量流入目标工作节点     # (包括服务流量和健康检查）。     # 如果多个 ELB 配置了相同的安全组 ID，为工作节点安全组添加的允许规则行只有一个，     # 这意味着如果你删除了这些 ELB 中的任何一个，都会导致该规则记录被删除，     # 以至于所有共享该安全组 ID 的其他 ELB 都无法访问该节点。     # 此注解如果使用不当，会导致跨服务的不可用状况。     service.beta.kubernetes.io/aws-load-balancer-security-groups: "sg-53fae93f"      # 额外的安全组列表，将被添加到所创建的 ELB 之上。     # 添加时，会保留为 ELB 所专门创建的安全组。     # 这样会确保每个 ELB 都有一个唯一的安全组 ID 和与之对应的允许规则记录，     # 允许请求（服务流量和健康检查）发送到目标工作节点。     # 这里顶一个安全组可以被多个服务共享。     service.beta.kubernetes.io/aws-load-balancer-extra-security-groups: "sg-53fae93f,sg-42efd82e"      # 用逗号分隔的一个键-值偶对列表，用来为负载均衡器选择目标节点     service.beta.kubernetes.io/aws-load-balancer-target-node-labels: "ingress-gw,gw-name=public-api"`

#### AWS 上网络负载均衡器支持

FEATURE STATE: Kubernetes v1.15 \[beta\]

要在 AWS 上使用网络负载均衡器，可以使用注解 ​`service.beta.kubernetes.io/aws-load-balancer-type`​，将其取值设为 ​`nlb`​。

`metadata:   name: my-service   annotations:     service.beta.kubernetes.io/aws-load-balancer-type: "nlb"`

> NLB 仅适用于某些实例类。有关受支持的实例类型的列表， 请参见 [AWS文档](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-register-targets.html target=) 中关于所支持的实例类型的 Elastic Load Balancing 说明。

与经典弹性负载平衡器不同，网络负载平衡器（NLB）将客户端的 IP 地址转发到该节点。 如果服务的 ​`.spec.externalTrafficPolicy`​ 设置为 ​`Cluster` ​，则客户端的IP地址不会传达到最终的 Pod。

通过将 ​`.spec.externalTrafficPolicy`​ 设置为 ​`Local`​，客户端IP地址将传播到最终的 Pod， 但这可能导致流量分配不均。 没有针对特定 LoadBalancer 服务的任何 Pod 的节点将无法通过自动分配的 ​`.spec.healthCheckNodePort`​ 进行 NLB 目标组的运行状况检查，并且不会收到任何流量。

为了获得均衡流量，请使用 DaemonSet 或指定 Pod 反亲和性 使其不在同一节点上。

你还可以将 NLB 服务与内部负载平衡器 注解一起使用。

为了使客户端流量能够到达 NLB 后面的实例，使用以下 IP 规则修改了节点安全组：

Rule

Protocol

Port(s)

IpRange(s)

IpRange Description

Health Check

TCP

NodePort(s) (`.spec.healthCheckNodePort` for `.spec.externalTrafficPolicy = Local`)

Subnet CIDR

kubernetes.io/rule/nlb/health=<loadBalancerName>

Client Traffic

TCP

NodePort(s)

`.spec.loadBalancerSourceRanges` (defaults to `0.0.0.0/0`)

kubernetes.io/rule/nlb/client=<loadBalancerName>

MTU Discovery

ICMP

3,4

`.spec.loadBalancerSourceRanges` (defaults to `0.0.0.0/0`)

kubernetes.io/rule/nlb/mtu=<loadBalancerName>

为了限制哪些客户端IP可以访问网络负载平衡器，请指定 ​`loadBalancerSourceRanges`​。

`spec:   loadBalancerSourceRanges:     - "143.231.0.0/16"`

> 如果未设置 ​`.spec.loadBalancerSourceRanges`​ ，则 Kubernetes 允许从 ​`0.0.0.0/0`​ 到节点安全组的流量。 如果节点具有公共 IP 地址，请注意，非 NLB 流量也可以到达那些修改后的安全组中的所有实例。

有关弹性 IP 注解和更多其他常见用例， 请参阅[AWS负载均衡控制器文档](https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.4/guide/service/annotations/)。

#### 腾讯 Kubernetes 引擎（TKE）上的 CLB 注解

以下是在 TKE 上管理云负载均衡器的注解。

`metadata:   name: my-service   annotations:     # 绑定负载均衡器到指定的节点。     service.kubernetes.io/qcloud-loadbalancer-backends-label: key in (value1, value2)      # 为已有负载均衡器添加 ID。     service.kubernetes.io/tke-existed-lbid：lb-6swtxxxx      # 负载均衡器（LB）的自定义参数尚不支持修改 LB 类型。     service.kubernetes.io/service.extensiveParameters: ""      # 自定义负载均衡监听器。     service.kubernetes.io/service.listenerParameters: ""      # 指定负载均衡类型。     # 可用参数: classic (Classic Cloud Load Balancer) 或 application (Application Cloud Load Balancer)     service.kubernetes.io/loadbalance-type: xxxxx      # 指定公用网络带宽计费方法。     # 可用参数: TRAFFIC_POSTPAID_BY_HOUR(bill-by-traffic) 和 BANDWIDTH_POSTPAID_BY_HOUR (bill-by-bandwidth).     service.kubernetes.io/qcloud-loadbalancer-internet-charge-type: xxxxxx      # 指定带宽参数 (取值范围： [1,2000] Mbps).     service.kubernetes.io/qcloud-loadbalancer-internet-max-bandwidth-out: "10"      # 当设置该注解时，负载平衡器将只注册正在运行 Pod 的节点，     # 否则所有节点将会被注册。     service.kubernetes.io/local-svc-only-bind-node-with-pod: true`

### ExternalName 类型 

类型为 ExternalName 的服务将服务映射到 DNS 名称，而不是典型的选择器，例如 ​`my-service`​ 或者 ​`cassandra`​。 你可以使用 ​`spec.externalName`​ 参数指定这些服务。

例如，以下 Service 定义将 ​`prod` ​名称空间中的 ​`my-service`​ 服务映射到 ​`my.database.example.com`​：

`apiVersion: v1 kind: Service metadata:   name: my-service   namespace: prod spec:   type: ExternalName   externalName: my.database.example.com`

> ExternalName 服务接受 IPv4 地址字符串，但作为包含数字的 DNS 名称，而不是 IP 地址。 类似于 IPv4 地址的外部名称不能由 CoreDNS 或 ingress-nginx 解析，因为外部名称旨在指定规范的 DNS 名称。 要对 IP 地址进行硬编码，请考虑使用 headless Services。

当查找主机 ​`my-service.prod.svc.cluster.local`​ 时，集群 DNS 服务返回 ​`CNAME` ​记录， 其值为 ​`my.database.example.com`​。 访问 ​`my-service`​ 的方式与其他服务的方式相同，但主要区别在于重定向发生在 DNS 级别，而不是通过代理或转发。 如果以后你决定将数据库移到集群中，则可以启动其 Pod，添加适当的选择器或端点以及更改服务的 ​`type`​。

> 对于一些常见的协议，包括 HTTP 和 HTTPS， 你使用 ExternalName 可能会遇到问题。 如果你使用 ExternalName，那么集群内客户端使用的主机名 与 ExternalName 引用的名称不同。  
> 对于使用主机名的协议，此差异可能会导致错误或意外响应。 HTTP 请求将具有源服务器无法识别的 Host: 标头；TLS 服 务器将无法提供与客户端连接的主机名匹配的证书。

> 本部分感谢 [Alen Komljen](https://akomljen.com/)的 [Kubernetes Tips - Part1](https://akomljen.com/kubernetes-tips-part-1/) 博客文章。

### 外部 IP 

如果外部的 IP 路由到集群中一个或多个 Node 上，Kubernetes Service 会被暴露给这些 externalIPs。 通过外部 IP（作为目的 IP 地址）进入到集群，打到 Service 的端口上的流量， 将会被路由到 Service 的 Endpoint 上。 ​`externalIPs` ​不会被 Kubernetes 管理，它属于集群管理员的职责范畴。

根据 Service 的规定，​`externalIPs` ​可以同任意的 ​`ServiceType` ​来一起指定。 在上面的例子中，​`my-service`​ 可以在 "​`80.11.12.10:80`​"(​`externalIP:port`​) 上被客户端访问。

`apiVersion: v1 kind: Service metadata:   name: my-service spec:   selector:     app: MyApp   ports:     - name: http       protocol: TCP       port: 80       targetPort: 9376   externalIPs:     - 80.11.12.10`

不足之处
----

为 VIP 使用用户空间代理，将只适合小型到中型规模的集群，不能够扩展到上千 Service 的大型集群。 查看[最初设计方案](https://github.com/kubernetes/kubernetes/issues/1107) 获取更多细节。

使用用户空间代理，隐藏了访问 Service 的数据包的源 IP 地址。 这使得一些类型的防火墙无法起作用。 iptables 代理不会隐藏 Kubernetes 集群内部的 IP 地址，但却要求客户端请求 必须通过一个负载均衡器或 Node 端口。

​`Type` ​字段支持嵌套功能 —— 每一层需要添加到上一层里面。 不会严格要求所有云提供商（例如，GCE 就没必要为了使一个 ​`LoadBalancer` ​能工作而分配一个 ​`NodePort`​，但是 AWS 需要 ），但当前 API 是强制要求的。

虚拟IP实施
------

对很多想使用 Service 的人来说，前面的信息应该足够了。 然而，有很多内部原理性的内容，还是值去理解的。

### 避免冲突

Kubernetes 最主要的哲学之一，是用户不应该暴露那些能够导致他们操作失败、但又不是他们的过错的场景。 对于 Service 资源的设计，这意味着如果用户的选择有可能与他人冲突，那就不要让用户自行选择端口号。 这是一个隔离性的失败。

为了使用户能够为他们的 Service 选择一个端口号，我们必须确保不能有2个 Service 发生冲突。 Kubernetes 通过为每个 Service 分配它们自己的 IP 地址来实现。

为了保证每个 Service 被分配到一个唯一的 IP，需要一个内部的分配器能够原子地更新 etcd 中的一个全局分配映射表， 这个更新操作要先于创建每一个 Service。 为了使 Service 能够获取到 IP，这个映射表对象必须在注册中心存在， 否则创建 Service 将会失败，指示一个 IP 不能被分配。

在控制平面中，一个后台 Controller 的职责是创建映射表 （需要支持从使用了内存锁的 Kubernetes 的旧版本迁移过来）。 同时 Kubernetes 会通过控制器检查不合理的分配（如管理员干预导致的） 以及清理已被分配但不再被任何 Service 使用的 IP 地址。

### Service IP 地址

不像 Pod 的 IP 地址，它实际路由到一个固定的目的地，Service 的 IP 实际上 不能通过单个主机来进行应答。 相反，我们使用 ​`iptables`​（Linux 中的数据包处理逻辑）来定义一个 虚拟 IP 地址（VIP），它可以根据需要透明地进行重定向。 当客户端连接到 VIP 时，它们的流量会自动地传输到一个合适的 Endpoint。 环境变量和 DNS，实际上会根据 Service 的 VIP 和端口来进行填充。

kube-proxy支持三种代理模式: 用户空间，iptables和IPVS；它们各自的操作略有不同。

#### Userspace 

作为一个例子，考虑前面提到的图片处理应用程序。 当创建后端 Service 时，Kubernetes master 会给它指派一个虚拟 IP 地址，比如 10.0.0.1。 假设 Service 的端口是 1234，该 Service 会被集群中所有的 ​`kube-proxy`​ 实例观察到。 当代理看到一个新的 Service， 它会打开一个新的端口，建立一个从该 VIP 重定向到 新端口的 iptables，并开始接收请求连接。

当一个客户端连接到一个 VIP，iptables 规则开始起作用，它会重定向该数据包到 "服务代理" 的端口。 "服务代理" 选择一个后端，并将客户端的流量代理到后端上。

这意味着 Service 的所有者能够选择任何他们想使用的端口，而不存在冲突的风险。 客户端可以连接到一个 IP 和端口，而不需要知道实际访问了哪些 Pod。

#### iptables

再次考虑前面提到的图片处理应用程序。 当创建后端 Service 时，Kubernetes 控制面板会给它指派一个虚拟 IP 地址，比如 10.0.0.1。 假设 Service 的端口是 1234，该 Service 会被集群中所有的 ​`kube-proxy`​ 实例观察到。 当代理看到一个新的 Service， 它会配置一系列的 iptables 规则，从 VIP 重定向到每个 Service 规则。 该特定于服务的规则连接到特定于 Endpoint 的规则，而后者会重定向（目标地址转译）到后端。

当客户端连接到一个 VIP，iptables 规则开始起作用。一个后端会被选择（或者根据会话亲和性，或者随机）， 数据包被重定向到这个后端。 不像用户空间代理，数据包从来不拷贝到用户空间，kube-proxy 不是必须为该 VIP 工作而运行， 并且客户端 IP 是不可更改的。

当流量打到 Node 的端口上，或通过负载均衡器，会执行相同的基本流程， 但是在那些案例中客户端 IP 是可以更改的。

#### IPVS

在大规模集群（例如 10000 个服务）中，iptables 操作会显着降低速度。 IPVS 专为负载平衡而设计，并基于内核内哈希表。 因此，你可以通过基于 IPVS 的 kube-proxy 在大量服务中实现性能一致性。 同时，基于 IPVS 的 kube-proxy 具有更复杂的负载均衡算法（最小连接、局部性、 加权、持久性）。

API 对象 
-------

Service 是 Kubernetes REST API 中的顶级资源。你可以在以下位置找到有关 API 对象的更多详细信息： [Service 对象 API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/ target=)

受支持的协议
------

### TCP

你可以将 TCP 用于任何类型的服务，这是默认的网络协议。

### UDP 

你可以将 UDP 用于大多数服务。 对于 type=LoadBalancer 服务，对 UDP 的支持取决于提供此功能的云提供商。

### SCTP

FEATURE STATE: Kubernetes v1.20 \[stable\]

一旦你使用了支持 SCTP 流量的网络插件，你就可以使用 SCTP 于更多的服务。 对于 type = LoadBalancer 的服务，SCTP 的支持取决于提供此设施的云供应商（大多数不支持）。

#### 警告

支持多宿主 SCTP 关联

> 支持多宿主SCTP关联要求 CNI 插件能够支持为一个 Pod 分配多个接口和IP地址。  
> 用于多宿主 SCTP 关联的 NAT 在相应的内核模块中需要特殊的逻辑。

##### Windows

> 基于 Windows 的节点不支持 SCTP。

##### 用户空间 kube-proxy

> 当 kube-proxy 处于用户空间模式时，它不支持 SCTP 关联的管理。

### HTTP 

如果你的云提供商支持它，则可以在 LoadBalancer 模式下使用服务来设置外部 HTTP/HTTPS 反向代理，并将其转发到该服务的 Endpoints。

> 你还可以使用 Ingress 代替 Service 来公开 HTTP/HTTPS 服务。

### PROXY 协议

如果你的云提供商支持它， 则可以在 LoadBalancer 模式下使用 Service 在 Kubernetes 本身之外配置负载均衡器， 该负载均衡器将转发前缀为 [PROXY 协议](https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt) 的连接。

负载平衡器将发送一系列初始字节，描述传入的连接，类似于此示例

`PROXY TCP4 192.0.2.202 10.0.42.7 12345 7\r\n`

上述是来自客户端的数据。

##  3.  Kubernetes Pod 与 Service 的 DNS
Pod 与 Service 的 DNS
-------------------

Kubernetes 为服务和 Pods 创建 DNS 记录。 你可以使用一致的 DNS 名称而非 IP 地址来访问服务。

介绍
--

Kubernetes DNS 在集群上调度 DNS Pod 和服务，并配置 kubelet 以告知各个容器 使用 DNS 服务的 IP 来解析 DNS 名称。

集群中定义的每个 Service （包括 DNS 服务器自身）都被赋予一个 DNS 名称。 默认情况下，客户端 Pod 的 DNS 搜索列表会包含 Pod 自身的名字空间和集群 的默认域。

### Service 的名字空间

DNS 查询可能因为执行查询的 Pod 所在的名字空间而返回不同的结果。 不指定名字空间的 DNS 查询会被限制在 Pod 所在的名字空间内。 要访问其他名字空间中的服务，需要在 DNS 查询中给出名字空间。

例如，假定名字空间 ​`test` ​中存在一个 Pod，​`prod` ​名字空间中存在一个服务 ​`data`​。

Pod 查询 ​`data` ​时没有返回结果，因为使用的是 Pod 的名字空间 ​`test`​。

Pod 查询​ `data.prod`​ 时则会返回预期的结果，因为查询中指定了名字空间。

DNS 查询可以使用 Pod 中的 ​`/etc/resolv.conf`​ 展开。kubelet 会为每个 Pod 生成此文件。例如，对 ​`data` ​的查询可能被展开为 ​`data.test.svc.cluster.local`​。 ​`search` ​选项的取值会被用来展开查询。要进一步了解 DNS 查询，可参阅 ​[`resolv.conf` ​手册页面](https://www.man7.org/linux/man-pages/man5/resolv.conf.5.html)。

`nameserver 10.32.0.10 search <namespace>.svc.cluster.local svc.cluster.local cluster.local options ndots:5`

概括起来，名字空间 ​`test` ​中的 Pod 可以成功地解析 ​`data.prod`​ 或者 ​`data.prod.svc.cluster.local`​。

### DNS 记录 

哪些对象会获得 DNS 记录呢？

1.  Services
2.  Pods

以下各节详细介绍了被支持的 DNS 记录类型和被支持的布局。 其它布局、名称或者查询即使碰巧可以工作，也应视为实现细节， 将来很可能被更改而且不会因此发出警告。 有关最新规范请查看 [Kubernetes 基于 DNS 的服务发现](https://github.com/kubernetes/dns/blob/master/docs/specification.md)。

### 服务 

#### A/AAAA 记录

“普通” 服务（除了无头服务）会以 ​`my-svc.my-namespace.svc.cluster-domain.example`​ 这种名字的形式被分配一个 DNS A 或 AAAA 记录，取决于服务的 IP 协议族。 该名称会解析成对应服务的集群 IP。

“无头（Headless）” 服务（没有集群 IP）也会以 ​`my-svc.my-namespace.svc.cluster-domain.example`​ 这种名字的形式被指派一个 DNS A 或 AAAA 记录， 具体取决于服务的 IP 协议族。 与普通服务不同，这一记录会被解析成对应服务所选择的 Pod 集合的 IP。 客户端要能够使用这组 IP，或者使用标准的轮转策略从这组 IP 中进行选择。

#### SRV 记录 

Kubernetes 会为命名端口创建 SRV 记录，这些端口是普通服务或 无头服务的一部分。 对每个命名端口，SRV 记录具有 ​`_my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster-domain.example`​ 这种形式。 对普通服务，该记录会被解析成端口号和域名：​`my-svc.my-namespace.svc.cluster-domain.example`​。 对无头服务，该记录会被解析成多个结果，服务对应的每个后端 Pod 各一个； 其中包含 Pod 端口号和形为 ​`auto-generated-name.my-svc.my-namespace.svc.cluster-domain.example`​ 的域名。

Pods
----

### A/AAAA 记录

一般而言，Pod 会对应如下 DNS 名字解析：

​`pod-ip-address.my-namespace.pod.cluster-domain.example` ​

例如，对于一个位于 ​`default` ​名字空间，IP 地址为 172.17.0.3 的 Pod， 如果集群的域名为 ​`cluster.local`​，则 Pod 会对应 DNS 名称：

​`172-17-0-3.default.pod.cluster.local`​

通过 Service 暴露出来的所有 Pod 都会有如下 DNS 解析名称可用：

​`pod-ip-address.service-name.my-namespace.svc.cluster-domain.example`​

### Pod 的 hostname 和 subdomain 字段

当前，创建 Pod 时其主机名取自 Pod 的 ​`metadata.name`​ 值。

Pod 规约中包含一个可选的 ​`hostname` ​字段，可以用来指定 Pod 的主机名。 当这个字段被设置时，它将优先于 Pod 的名字成为该 Pod 的主机名。 举个例子，给定一个 ​`hostname` ​设置为 "​`my-host`​" 的 Pod， 该 Pod 的主机名将被设置为 "​`my-host`​"。

Pod 规约还有一个可选的 ​`subdomain`​ 字段，可以用来指定 Pod 的子域名。 举个例子，某 Pod 的 ​`hostname` ​设置为 “​`foo`​”，​`subdomain` ​设置为 “​`bar`​”， 在名字空间 “​`my-namespace`​” 中对应的完全限定域名（FQDN）为 “​`foo.bar.my-namespace.svc.cluster-domain.example`​”。

示例：

`apiVersion: v1 kind: Service metadata:   name: default-subdomain spec:   selector:     name: busybox   clusterIP: None   ports:   - name: foo # 实际上不需要指定端口号     port: 1234     targetPort: 1234 --- apiVersion: v1 kind: Pod metadata:   name: busybox1   labels:     name: busybox spec:   hostname: busybox-1   subdomain: default-subdomain   containers:   - image: busybox:1.28     command:       - sleep       - "3600"     name: busybox --- apiVersion: v1 kind: Pod metadata:   name: busybox2   labels:     name: busybox spec:   hostname: busybox-2   subdomain: default-subdomain   containers:   - image: busybox:1.28     command:       - sleep       - "3600"     name: busybox`

如果某无头服务与某 Pod 在同一个名字空间中，且它们具有相同的子域名， 集群的 DNS 服务器也会为该 Pod 的全限定主机名返回 A 记录或 AAAA 记录。 例如，在同一个名字空间中，给定一个主机名为 “busybox-1”、 子域名设置为 “default-subdomain” 的 Pod，和一个名称为 “​`default-subdomain`​” 的无头服务，Pod 将看到自己的 FQDN 为 "​`busybox-1.default-subdomain.my-namespace.svc.cluster-domain.example`​"。 DNS 会为此名字提供一个 A 记录或 AAAA 记录，指向该 Pod 的 IP。 “​`busybox1`​” 和 “​`busybox2`​” 这两个 Pod 分别具有它们自己的 A 或 AAAA 记录。

Endpoints 对象可以为任何端点地址及其 IP 指定 ​`hostname`​。

> 因为没有为 Pod 名称创建 A 记录或 AAAA 记录，所以要创建 Pod 的 A 记录 或 AAAA 记录需要 ​`hostname`​。  
> 没有设置 ​`hostname` ​但设置了 ​`subdomain` ​的 Pod 只会为 无头服务创建 A 或 AAAA 记录（​`default-subdomain.my-namespace.svc.cluster-domain.example`​） 指向 Pod 的 IP 地址。 另外，除非在服务上设置了 ​`publishNotReadyAddresses=True`​，否则只有 Pod 进入就绪状态 才会有与之对应的记录。

### Pod 的 setHostnameAsFQDN 字段 

FEATURE STATE: Kubernetes v1.22 \[stable\]

前置条件：​`SetHostnameAsFQDN` ​特性门控 必须在 API 服务器 上启用。

当你在 Pod 规约中设置了 ​`setHostnameAsFQDN: true`​ 时，kubelet 会将 Pod 的全限定域名（FQDN）作为该 Pod 的主机名记录到 Pod 所在名字空间。 在这种情况下，​`hostname` ​和 ​`hostname --fqdn`​ 都会返回 Pod 的全限定域名。

> 在 Linux 中，内核的主机名字段（​`struct utsname`​ 的 ​`nodename` ​字段）限定 最多 64 个字符。  
> 如果 Pod 启用这一特性，而其 FQDN 超出 64 字符，Pod 的启动会失败。 Pod 会一直出于 ​`Pending` ​状态（通过 ​`kubectl` ​所看到的 ​`ContainerCreating`​）， 并产生错误事件，例如 "Failed to construct FQDN from pod hostname and cluster domain, FQDN ​`long-FQDN`​ is too long (64 characters is the max, 70 characters requested)." （无法基于 Pod 主机名和集群域名构造 FQDN，FQDN ​`long-FQDN`​ 过长，至多 64 字符，请求字符数为 70）。 对于这种场景而言，改善用户体验的一种方式是创建一个 准入 Webhook 控制器， 在用户创建顶层对象（如 Deployment）的时候控制 FQDN 的长度。

### Pod 的 DNS 策略 

DNS 策略可以逐个 Pod 来设定。目前 Kubernetes 支持以下特定 Pod 的 DNS 策略。 这些策略可以在 Pod 规约中的 ​`dnsPolicy` ​字段设置：

*   "​`Default`​": Pod 从运行所在的节点继承名称解析配置。
*   "​`ClusterFirst`​": 与配置的集群域后缀不匹配的任何 DNS 查询（例如 "www.kubernetes.io"） 都将转发到从节点继承的上游名称服务器。集群管理员可能配置了额外的存根域和上游 DNS 服务器。 
*   "​`ClusterFirstWithHostNet`​"：对于以 hostNetwork 方式运行的 Pod，应显式设置其 DNS 策略 "​`ClusterFirstWithHostNet`​"。
*   "​`None`​": 此设置允许 Pod 忽略 Kubernetes 环境中的 DNS 设置。Pod 会使用其 ​`dnsConfig` ​字段 所提供的 DNS 设置。

>  "Default" 不是默认的 DNS 策略。如果未明确指定 ​`dnsPolicy`​，则使用 "ClusterFirst"。

下面的示例显示了一个 Pod，其 DNS 策略设置为 "​`ClusterFirstWithHostNet`​"， 因为它已将 ​`hostNetwork` ​设置为 ​`true`​。

`apiVersion: v1 kind: Pod metadata:   name: busybox   namespace: default spec:   containers:   - image: busybox:1.28     command:       - sleep       - "3600"     imagePullPolicy: IfNotPresent     name: busybox   restartPolicy: Always   hostNetwork: true   dnsPolicy: ClusterFirstWithHostNet`

### Pod 的 DNS 配置 

FEATURE STATE: Kubernetes v1.14 \[stable\]

Pod 的 DNS 配置可让用户对 Pod 的 DNS 设置进行更多控制。

​`dnsConfig` ​字段是可选的，它可以与任何 ​`dnsPolicy` ​设置一起使用。 但是，当 Pod 的 ​`dnsPolicy` ​设置为 "​`None`​" 时，必须指定 ​`dnsConfig` ​字段。

用户可以在 ​`dnsConfig` ​字段中指定以下属性：

*   ​`nameservers`​：将用作于 Pod 的 DNS 服务器的 IP 地址列表。 最多可以指定 3 个 IP 地址。当 Pod 的 ​`dnsPolicy` ​设置为 "​`None`​" 时， 列表必须至少包含一个 IP 地址，否则此属性是可选的。 所列出的服务器将合并到从指定的 DNS 策略生成的基本名称服务器，并删除重复的地址。
*   ​`searches`​：用于在 Pod 中查找主机名的 DNS 搜索域的列表。此属性是可选的。 指定此属性时，所提供的列表将合并到根据所选 DNS 策略生成的基本搜索域名中。 重复的域名将被删除。Kubernetes 最多允许 6 个搜索域。
*   ​`options`​：可选的对象列表，其中每个对象可能具有 ​`name` ​属性（必需）和 ​`value` ​属性（可选）。 此属性中的内容将合并到从指定的 DNS 策略生成的选项。 重复的条目将被删除。

以下是具有自定义 DNS 设置的 Pod 示例：

`apiVersion: v1 kind: Pod metadata:   namespace: default   name: dns-example spec:   containers:     - name: test       image: nginx   dnsPolicy: "None"   dnsConfig:     nameservers:       - 1.2.3.4     searches:       - ns1.svc.cluster-domain.example       - my.dns.search.suffix     options:       - name: ndots         value: "2"       - name: edns0`

创建上面的 Pod 后，容器 ​`test` ​会在其 ​`/etc/resolv.conf`​ 文件中获取以下内容：

`nameserver 1.2.3.4 search ns1.svc.cluster-domain.example my.dns.search.suffix options ndots:2 edns0`

对于 IPv6 设置，搜索路径和名称服务器应按以下方式设置：

`kubectl exec -it dns-example -- cat /etc/resolv.conf`

输出类似于

`nameserver fd00:79:30::a search default.svc.cluster-domain.example svc.cluster-domain.example cluster-domain.example options ndots:5`

#### 扩展 DNS 配置 

FEATURE STATE: Kubernetes 1.22 \[alpha\]

对于 Pod DNS 配置，Kubernetes 默认允许最多 6 个 搜索域（ Search Domain） 以及一个最多 256 个字符的搜索域列表。

如果启用 kube-apiserver 和 kubelet 的特性门控 ​`ExpandedDNSConfig`​，Kubernetes 将可以有最多 32 个 搜索域以及一个最多 2048 个字符的搜索域列表。

##  4.  Kubernetes 使用 Service 连接到应用
Kubernetes 连接容器的模型
------------------

既然有了一个持续运行、可复制的应用，我们就能够将它暴露到网络上。

Kubernetes 假设 Pod 可与其它 Pod 通信，不管它们在哪个主机上。 Kubernetes 给每一个 Pod 分配一个集群私有 IP 地址，所以没必要在 Pod 与 Pod 之间创建连接或将容器的端口映射到主机端口。 这意味着同一个 Pod 内的所有容器能通过 localhost 上的端口互相连通，集群中的所有 Pod 也不需要通过 NAT 转换就能够互相看到。 本文档的剩余部分详述如何在上述网络模型之上运行可靠的服务。

本指南使用一个简单的 Nginx 服务器来演示概念验证原型。

在集群中暴露 Pod
----------

我们在之前的示例中已经做过，然而让我们以网络连接的视角再重做一遍。 创建一个 Nginx Pod，注意其中包含一个容器端口的规约：

`apiVersion: apps/v1 kind: Deployment metadata:   name: my-nginx spec:   selector:     matchLabels:       run: my-nginx   replicas: 2   template:     metadata:       labels:         run: my-nginx     spec:       containers:       - name: my-nginx         image: nginx         ports:         - containerPort: 80`

这使得可以从集群中任何一个节点来访问它。检查节点，该 Pod 正在运行：

`kubectl apply -f ./run-my-nginx.yaml kubectl get pods -l run=my-nginx -o wide`

`NAME                        READY     STATUS    RESTARTS   AGE       IP            NODE my-nginx-3800858182-jr4a2   1/1       Running   0          13s       10.244.3.4    kubernetes-minion-905m my-nginx-3800858182-kna2y   1/1       Running   0          13s       10.244.2.5    kubernetes-minion-ljyd`

检查 Pod 的 IP 地址：

`kubectl get pods -l run=my-nginx -o yaml | grep podIP     podIP: 10.244.3.4     podIP: 10.244.2.5`

你应该能够通过 ssh 登录到集群中的任何一个节点上，并使用诸如 ​`curl` ​之类的工具向这两个 IP 地址发出查询请求。 需要注意的是，容器不会使用该节点上的 80 端口，也不会使用任何特定的 NAT 规则去路由流量到 Pod 上。 这意味着可以在同一个节点上运行多个 Nginx Pod，使用相同的 ​`containerPort`​，并且可以从集群中任何其他的 Pod 或节点上使用 IP 的方式访问到它们。 如果你想的话，你依然可以将宿主节点的某个端口的流量转发到 Pod 中，但是出于网络模型的原因，你不必这么做。

创建 Service
----------

我们有一组在一个扁平的、集群范围的地址空间中运行 Nginx 服务的 Pod。 理论上，你可以直接连接到这些 Pod，但如果某个节点死掉了会发生什么呢？ Pod 会终止，Deployment 将创建新的 Pod，且使用不同的 IP。这正是 Service 要解决的问题。

Kubernetes Service 是集群中提供相同功能的一组 Pod 的抽象表达。 当每个 Service 创建时，会被分配一个唯一的 IP 地址（也称为 clusterIP）。 这个 IP 地址与 Service 的生命周期绑定在一起，只要 Service 存在，它就不会改变。 可以配置 Pod 使它与 Service 进行通信，Pod 知道与 Service 通信将被自动地负载均衡到该 Service 中的某些 Pod 上。

可以使用 ​`kubectl expose`​ 命令为 2个 Nginx 副本创建一个 Service：

`kubectl expose deployment/my-nginx`

`service/my-nginx exposed`

这等价于使用 ​`kubectl create -f`​ 命令及如下的 yaml 文件创建：

`apiVersion: v1 kind: Service metadata:   name: my-nginx   labels:     run: my-nginx spec:   ports:   - port: 80     protocol: TCP   selector:     run: my-nginx`

上述规约将创建一个 Service，该 Service 会将所有具有标签 ​`run: my-nginx`​ 的 Pod 的 TCP 80 端口暴露到一个抽象的 Service 端口上（​`targetPort`​：容器接收流量的端口；​`port`​：可任意取值的抽象的 Service 端口，其他 Pod 通过该端口访问 Service）。 查看 Service API 对象以了解 Service 所能接受的字段列表。 查看你的 Service 资源:

`kubectl get svc my-nginx`

    

`NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE my-nginx   ClusterIP   10.0.162.149   <none>        80/TCP    21s`

正如前面所提到的，一个 Service 由一组 Pod 提供支撑。这些 Pod 通过 ​`endpoints` ​暴露出来。 Service Selector 将持续评估，结果被 POST 到一个名称为 ​`my-nginx`​ 的 Endpoint 对象上。 当 Pod 终止后，它会自动从 Endpoint 中移除，新的能够匹配上 Service Selector 的 Pod 将自动地被添加到 Endpoint 中。 检查该 Endpoint，注意到 IP 地址与在第一步创建的 Pod 是相同的。

`kubectl describe svc my-nginx`

        

`Name:                my-nginx Namespace:           default Labels:              run=my-nginx Annotations:         <none> Selector:            run=my-nginx Type:                ClusterIP IP:                  10.0.162.149 Port:                <unset> 80/TCP Endpoints:           10.244.2.5:80,10.244.3.4:80 Session Affinity:    None Events:              <none>`

`kubectl get ep my-nginx`

`NAME       ENDPOINTS                     AGE my-nginx   10.244.2.5:80,10.244.3.4:80   1m`

现在，你应该能够从集群中任意节点上使用 curl 命令向 ​`<CLUSTER-IP>:<PORT>`​ 发送请求以访问 Nginx Service。

访问 Service
----------

Kubernetes支持两种查找服务的主要模式: 环境变量和 DNS。前者开箱即用，而后者则需要 [CoreDNS 集群插件](https://github.com/kubernetes/kubernetes/tree/v1.24.0/cluster/addons/dns/coredns)

> 如果不需要服务环境变量（因为可能与预期的程序冲突，可能要处理的变量太多，或者仅使用DNS等），则可以通过在 ​`[pod spec](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/ target=)`​ 上将 ​`enableServiceLinks` ​标志设置为 ​`false` ​来禁用此模式。

### 环境变量

当 Pod 在节点上运行时，kubelet 会针对每个活跃的 Service 为 Pod 添加一组环境变量。 这就引入了一个顺序的问题。为解释这个问题，让我们先检查正在运行的 Nginx Pod 的环境变量（你的环境中的 Pod 名称将会与下面示例命令中的不同）：

`kubectl exec my-nginx-3800858182-jr4a2 -- printenv | grep SERVICE`

`KUBERNETES_SERVICE_HOST=10.0.0.1 KUBERNETES_SERVICE_PORT=443 KUBERNETES_SERVICE_PORT_HTTPS=443`

            

能看到环境变量中并没有你创建的 Service 相关的值。这是因为副本的创建先于 Service。 这样做的另一个缺点是，调度器可能会将所有 Pod 部署到同一台机器上，如果该机器宕机则整个 Service 都会离线。 要改正的话，我们可以先终止这 2 个 Pod，然后等待 Deployment 去重新创建它们。 这次 Service 会先于副本存在。这将实现调度器级别的 Pod 按 Service 分布（假定所有的节点都具有同样的容量），并提供正确的环境变量：

`kubectl scale deployment my-nginx --replicas=0; kubectl scale deployment my-nginx --replicas=2;  kubectl get pods -l run=my-nginx -o wide`

                

`NAME                        READY     STATUS    RESTARTS   AGE     IP            NODE my-nginx-3800858182-e9ihh   1/1       Running   0          5s      10.244.2.7    kubernetes-minion-ljyd my-nginx-3800858182-j4rm4   1/1       Running   0          5s      10.244.3.8    kubernetes-minion-905m`

你可能注意到，Pod 具有不同的名称，这是因为它们是被重新创建的。

`kubectl exec my-nginx-3800858182-e9ihh -- printenv | grep SERVICE`

`KUBERNETES_SERVICE_PORT=443 MY_NGINX_SERVICE_HOST=10.0.162.149 KUBERNETES_SERVICE_HOST=10.0.0.1 MY_NGINX_SERVICE_PORT=80 KUBERNETES_SERVICE_PORT_HTTPS=443`

### DNS

Kubernetes 提供了一个自动为其它 Service 分配 DNS 名字的 DNS 插件 Service。 你可以通过如下命令检查它是否在工作：

`kubectl get services kube-dns --namespace=kube-system`

`NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE kube-dns   ClusterIP   10.0.0.10    <none>        53/UDP,53/TCP   8m`

                    

本段剩余的内容假设你已经有一个拥有持久 IP 地址的 Service（my-nginx），以及一个为其 IP 分配名称的 DNS 服务器。 这里我们使用 CoreDNS 集群插件（应用名为 ​`kube-dns`​）， 所以在集群中的任何 Pod 中，你都可以使用标准方法（例如：​`gethostbyname()`​）与该 Service 通信。 如果 CoreDNS 没有在运行，你可以参照  [CoreDNS README](https://github.com/coredns/deployment/tree/master/kubernetes) 或者安装 CoreDNS 来启用它。 让我们运行另一个 curl 应用来进行测试：

`kubectl run curl --image=radial/busyboxplus:curl -i --tty`

`Waiting for pod default/curl-131556218-9fnch to be running, status is Pending, pod ready: false Hit enter for command prompt`

然后，按回车并执行命令 ​`nslookup my-nginx`​：

`[ root@curl-131556218-9fnch:/ ]$ nslookup my-nginx Server:    10.0.0.10 Address 1: 10.0.0.10  Name:      my-nginx Address 1: 10.0.162.149`

保护 Service
----------

到现在为止，我们只在集群内部访问了 Nginx 服务器。在将 Service 暴露到因特网之前，我们希望确保通信信道是安全的。 为实现这一目的，需要：

*   用于 HTTPS 的自签名证书（除非已经有了一个身份证书）
*   使用证书配置的 Nginx 服务器
*   使 Pod 可以访问证书的 Secret

你可以从 [Nginx https 示例](https://github.com/kubernetes/examples/tree/master/staging/https-nginx/)获取所有上述内容。 你需要安装 go 和 make 工具。如果你不想安装这些软件，可以按照后文所述的手动执行步骤执行操作。简要过程如下：

`make keys KEY=/tmp/nginx.key CERT=/tmp/nginx.crt kubectl create secret tls nginxsecret --key /tmp/nginx.key --cert /tmp/nginx.crt`

`secret/nginxsecret created`

`kubectl get secrets`

`NAME                  TYPE                                  DATA      AGE default-token-il9rc   kubernetes.io/service-account-token   1         1d nginxsecret           kubernetes.io/tls                     2         1m`

                        

以下是 configmap：

`kubectl create configmap nginxconfigmap --from-file=default.conf`

`configmap/nginxconfigmap created`

`kubectl get configmaps`

                            

`NAME             DATA   AGE nginxconfigmap   1      114s`

以下是你在运行 make 时遇到问题时要遵循的手动步骤（例如，在 Windows 上）：

`# 创建公钥和相对应的私钥 openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /d/tmp/nginx.key -out /d/tmp/nginx.crt -subj "/CN=my-nginx/O=my-nginx" # 对密钥实施 base64 编码 cat /d/tmp/nginx.crt | base64 cat /d/tmp/nginx.key | base64`

使用前面命令的输出来创建 yaml 文件，如下所示。 base64 编码的值应全部放在一行上。(由于示例数值过长这里用……替代)

`apiVersion: "v1" kind: "Secret" metadata:   name: "nginxsecret"   namespace: "default" type: kubernetes.io/tls   data:   tls.crt: "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0t……"   tls.key: "LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0t……"`

现在使用文件创建 Secret：

`kubectl apply -f nginxsecrets.yaml kubectl get secrets`

`NAME                  TYPE                                  DATA      AGE default-token-il9rc   kubernetes.io/service-account-token   1         1d nginxsecret           kubernetes.io/tls                     2         1m`

现在修改 nginx 副本以启动一个使用 Secret 中的证书的 HTTPS 服务器以及相应的用于暴露其端口（80 和 443）的 Service：

`apiVersion: v1 kind: Service metadata:   name: my-nginx   labels:     run: my-nginx spec:   type: NodePort   ports:   - port: 8080     targetPort: 80     protocol: TCP     name: http   - port: 443     protocol: TCP     name: https   selector:     run: my-nginx --- apiVersion: apps/v1 kind: Deployment metadata:   name: my-nginx spec:   selector:     matchLabels:       run: my-nginx   replicas: 1   template:     metadata:       labels:         run: my-nginx     spec:       volumes:       - name: secret-volume         secret:           secretName: nginxsecret       - name: configmap-volume         configMap:           name: nginxconfigmap       containers:       - name: nginxhttps         image: bprashanth/nginxhttps:1.0         ports:         - containerPort: 443         - containerPort: 80         volumeMounts:         - mountPath: /etc/nginx/ssl           name: secret-volume         - mountPath: /etc/nginx/conf.d           name: configmap-volume`

关于 nginx-secure-app 清单，值得注意的几点如下：

*   它将 Deployment 和 Service 的规约放在了同一个文件中。
*   Nginx 服务器通过 80 端口处理 HTTP 流量，通过 443 端口处理 HTTPS 流量，而 Nginx Service 则暴露了这两个端口。
*   每个容器能通过挂载在 ​`/etc/nginx/ssl`​ 的卷访问秘钥。卷和密钥需要在 Nginx 服务器启动之前配置好。

`kubectl delete deployments,svc my-nginx; kubectl create -f ./nginx-secure-app.yaml`

这时，你可以从任何节点访问到 Nginx 服务器。

`kubectl get pods -o yaml | grep -i podip     podIP: 10.244.3.5 node $ curl -k https://10.244.3.5 ... <h1>Welcome to nginx!</h1>`

注意最后一步我们是如何提供 ​`-k`​ 参数执行 curl 命令的，这是因为在证书生成时， 我们不知道任何关于运行 nginx 的 Pod 的信息，所以不得不在执行 curl 命令时忽略 CName 不匹配的情况。 通过创建 Service，我们连接了在证书中的 CName 与在 Service 查询时被 Pod 使用的实际 DNS 名字。 让我们从一个 Pod 来测试（为了方便，这里使用同一个 Secret，Pod 仅需要使用 nginx.crt 去访问 Service）：

`apiVersion: apps/v1 kind: Deployment metadata:   name: curl-deployment spec:   selector:     matchLabels:       app: curlpod   replicas: 1   template:     metadata:       labels:         app: curlpod     spec:       volumes:       - name: secret-volume         secret:           secretName: nginxsecret       containers:       - name: curlpod         command:         - sh         - -c         - while true; do sleep 1; done         image: radial/busyboxplus:curl         volumeMounts:         - mountPath: /etc/nginx/ssl           name: secret-volume`

`kubectl apply -f ./curlpod.yaml kubectl get pods -l app=curlpod`

`NAME                               READY     STATUS    RESTARTS   AGE curl-deployment-1515033274-1410r   1/1       Running   0          1m`

`kubectl exec curl-deployment-1515033274-1410r -- curl https://my-nginx --cacert /etc/nginx/ssl/tls.crt ... <title>Welcome to nginx!</title> ...`

暴露 Service
----------

对应用的某些部分，你可能希望将 Service 暴露在一个外部 IP 地址上。 Kubernetes 支持两种实现方式：NodePort 和 LoadBalancer。 在上一段创建的 Service 使用了 ​`NodePort`​，因此，如果你的节点有一个公网 IP，那么 Nginx HTTPS 副本已经能够处理因特网上的流量。

`kubectl get svc my-nginx -o yaml | grep nodePort -C 5`

  `uid: 07191fb3-f61a-11e5-8ae5-42010af00002 spec:   clusterIP: 10.0.162.149   ports:   - name: http     nodePort: 31704     port: 8080     protocol: TCP     targetPort: 80   - name: https     nodePort: 32453     port: 443     protocol: TCP     targetPort: 443   selector:     run: my-nginx`

`kubectl get nodes -o yaml | grep ExternalIP -C 1`

  

    `- address: 104.197.41.11       type: ExternalIP     allocatable: --     - address: 23.251.152.56       type: ExternalIP     allocatable: ...  $ curl https://<EXTERNAL-IP>:<NODE-PORT> -k ... <h1>Welcome to nginx!</h1>`

让我们重新创建一个 Service 以使用云负载均衡器。 将 ​`my-nginx`​ Service 的 ​`Type` ​由 ​`NodePort` ​改成 ​`LoadBalancer`​：

`kubectl edit svc my-nginx kubectl get svc my-nginx`

`NAME       TYPE           CLUSTER-IP     EXTERNAL-IP        PORT(S)               AGE my-nginx   LoadBalancer   10.0.162.149   xx.xxx.xxx.xxx     8080:30163/TCP        21s`

`curl https://<EXTERNAL-IP> -k ... <title>Welcome to nginx!</title>`

在 ​`EXTERNAL-IP`​ 列中的 IP 地址能在公网上被访问到。​`CLUSTER-IP`​ 只能从集群/私有云网络中访问。

注意，在 AWS 上，类型 ​`LoadBalancer` ​的服务会创建一个 ELB，且 ELB 使用主机名（比较长），而不是 IP。 ELB 的主机名太长以至于不能适配标准 ​`kubectl get svc`​ 的输出，所以需要通过执行 ​`kubectl describe service my-nginx`​ 命令来查看它。 可以看到类似如下内容：

`kubectl describe service my-nginx ... LoadBalancer Ingress:   a320587ffd19711e5a37606cf4a74574-1142138393.us-east-1.elb.amazonaws.com ...`

##  5.  Kubernetes Ingress
Ingress
-------

FEATURE STATE: Kubernetes v1.19 \[stable\]

Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。

Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。

术语
--

为了表达更加清晰，本指南定义了以下术语：

*   节点（Node）: Kubernetes 集群中的一台工作机器，是集群的一部分。
*   集群（Cluster）: 一组运行由 Kubernetes 管理的容器化应用程序的节点。 在此示例和在大多数常见的 Kubernetes 部署环境中，集群中的节点都不在公共网络中。
*   边缘路由器（Edge Router）: 在集群中强制执行防火墙策略的路由器。可以是由云提供商管理的网关，也可以是物理硬件。
*   集群网络（Cluster Network）: 一组逻辑的或物理的连接，根据 Kubernetes 网络模型在集群内实现通信。
*   服务（Service）：Kubernetes 服务（Service）， 使用标签选择器（selectors）辨认一组 Pod。 除非另有说明，否则假定服务只具有在集群网络中可路由的虚拟 IP。

Ingress 是什么？
------------

[Ingress](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/ target=) 公开了从集群外部到集群内服务的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。

下面是一个将所有流量都发送到同一 Service 的简单 Ingress 示例：

![](https://atts.w3cschool.cn/attachments/image/20220506/1651816050984724.png)  

Ingress 可为 Service 提供外部可访问的 URL、负载均衡流量、终止 SSL/TLS，以及基于名称的虚拟托管。 Ingress 控制器 通常负责通过负载均衡器来实现 Ingress，尽管它也可以配置边缘路由器或其他前端来帮助处理流量。

Ingress 不会公开任意端口或协议。 将 HTTP 和 HTTPS 以外的服务公开到 Internet 时，通常使用 Service.Type=NodePort 或 Service.Type=LoadBalancer 类型的 Service。

环境准备
----

你必须拥有一个 Ingress 控制器 才能满足 Ingress 的要求。 仅创建 Ingress 资源本身没有任何效果。

你可能需要部署 Ingress 控制器，例如 [ingress-nginx](https://kubernetes.github.io/ingress-nginx/deploy/)。 你可以从许多 Ingress 控制器 中进行选择。

理想情况下，所有 Ingress 控制器都应符合参考规范。但实际上，不同的 Ingress 控制器操作略有不同。

> 确保你查看了 Ingress 控制器的文档，以了解选择它的注意事项。

Ingress 资源 
-----------

一个最小的 Ingress 资源示例：

`apiVersion: networking.k8s.io/v1 kind: Ingress metadata:   name: minimal-ingress   annotations:     nginx.ingress.kubernetes.io/rewrite-target: / spec:   ingressClassName: nginx-example   rules:   - http:       paths:       - path: /testpath         pathType: Prefix         backend:           service:             name: test             port:               number: 80`

Ingress 需要指定 ​`apiVersion`​、​`kind`​、 ​`metadata`​和 ​`spec` ​字段。 Ingress 对象的命名必须是合法的 DNS 子域名名称。 关于如何使用配置文件，请参见部署应用、 配置容器、 管理资源。 Ingress 经常使用注解（annotations）来配置一些选项，具体取决于 Ingress 控制器，例如 [重写目标注解](https://github.com/kubernetes/ingress-nginx/blob/main/docs/examples/rewrite/README.md)。 不同的 Ingress 控制器支持不同的注解。 查看你所选的 Ingress 控制器的文档，以了解其支持哪些注解。

Ingress [规约](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md target=) 提供了配置负载均衡器或者代理服务器所需的所有信息。 最重要的是，其中包含与所有传入请求匹配的规则列表。 Ingress 资源仅支持用于转发 HTTP(S) 流量的规则。

如果 ​`ingressClassName` ​被省略，那么你应该定义一个默认 Ingress 类。

有一些 Ingress 控制器不需要定义默认的 ​`IngressClass`​。比如：Ingress-NGINX 控制器可以通过[参数](https://kubernetes.github.io/ingress-nginx/ target=) ​`--watch-ingress-without-class`​ 来配置。 不过仍然 [推荐](https://kubernetes.github.io/ingress-nginx/ target=) 按下文所示来设置默认的 ​`IngressClass`​。

### Ingress 规则 

每个 HTTP 规则都包含以下信息：

*   可选的 ​`host`​。在此示例中，未指定 ​`host`​，因此该规则适用于通过指定 IP 地址的所有入站 HTTP 通信。 如果提供了 ​`host`​（例如 foo.bar.com），则 ​`rules` ​适用于该 ​`host`​。
*   路径列表 paths（例如，​`/testpath`​）,每个路径都有一个由 ​`serviceName` ​和 ​`servicePort` ​定义的关联后端。 在负载均衡器将流量定向到引用的服务之前，主机和路径都必须匹配传入请求的内容。
*   ​`backend`​（后端）是 Service 文档中所述的服务和端口名称的组合。 与规则的 ​`host` ​和 ​`path` ​匹配的对 Ingress 的 HTTP（和 HTTPS ）请求将发送到列出的 ​`backend`​。

通常在 Ingress 控制器中会配置 ​`defaultBackend`​（默认后端），以服务于无法与规约中 ​`path` ​匹配的所有请求。

### 默认后端 

没有设置规则的 Ingress 将所有流量发送到同一个默认后端，而 ​`.spec.defaultBackend`​ 则是在这种情况下处理请求的那个默认后端。 ​`defaultBackend` ​通常是 Ingress 控制器的配置选项，而非在 Ingress 资源中指定。 如果未设置任何的 ​`.spec.rules`​，那么必须指定 ​`.spec.defaultBackend`​。 如果未设置 ​`defaultBackend`​，那么如何处理所有与规则不匹配的流量将交由 Ingress 控制器决定（请参考你的 Ingress 控制器的文档以了解它是如何处理那些流量的）。

如果没有 ​`hosts` ​或 ​`paths` ​与 Ingress 对象中的 HTTP 请求匹配，则流量将被路由到默认后端。

### 资源后端 

​`Resource` ​后端是一个引用，指向同一命名空间中的另一个 Kubernetes 资源，将其作为 Ingress 对象。 ​`Resource` ​后端与 Service 后端是互斥的，在二者均被设置时会无法通过合法性检查。 ​`Resource` ​后端的一种常见用法是将所有入站数据导向带有静态资产的对象存储后端。

`apiVersion: networking.k8s.io/v1 kind: Ingress metadata:   name: ingress-resource-backend spec:   defaultBackend:     resource:       apiGroup: k8s.example.com       kind: StorageBucket       name: static-assets   rules:     - http:         paths:           - path: /icons             pathType: ImplementationSpecific             backend:               resource:                 apiGroup: k8s.example.com                 kind: StorageBucket                 name: icon-assets`

    

创建了如上的 Ingress 之后，你可以使用下面的命令查看它：

`kubectl describe ingress ingress-resource-backend`

`Name:             ingress-resource-backend Namespace:        default Address: Default backend:  APIGroup: k8s.example.com, Kind: StorageBucket, Name: static-assets Rules:   Host        Path  Backends   ----        ----  --------   *               /icons   APIGroup: k8s.example.com, Kind: StorageBucket, Name: icon-assets Annotations:  <none> Events:       <none>`

### 路径类型 

Ingress 中的每个路径都需要有对应的路径类型（Path Type）。未明确设置 ​`pathType` ​的路径无法通过合法性检查。当前支持的路径类型有三种：

*   ​`ImplementationSpecific`​：对于这种路径类型，匹配方法取决于 IngressClass。 具体实现可以将其作为单独的 ​`pathType` ​处理或者与 ​`Prefix` ​或 ​`Exact` ​类型作相同处理。
*   ​`Exact`​：精确匹配 URL 路径，且区分大小写。
*   ​`Prefix`​：基于以 ​`/`​ 分隔的 URL 路径前缀匹配。匹配区分大小写，并且对路径中的元素逐个完成。 路径元素指的是由 ​`/`​ 分隔符分隔的路径中的标签列表。 如果每个 p 都是请求路径 p 的元素前缀，则请求与路径 p 匹配。

> 如果路径的最后一个元素是请求路径中最后一个元素的子字符串，则不会匹配 （例如：​`/foo/bar`​ 匹配 ​`/foo/bar/baz`​, 但不匹配 ​`/foo/barbaz`​）。

### 示例

类型

路径

请求路径

匹配与否？

Prefix

`/`

（所有路径）

是

Exact

`/foo`

`/foo`

是

Exact

`/foo`

`/bar`

否

Exact

`/foo`

`/foo/`

否

Exact

`/foo/`

`/foo`

否

Prefix

`/foo`

`/foo`, `/foo/`

是

Prefix

`/foo/`

`/foo`, `/foo/`

是

Prefix

`/aaa/bb`

`/aaa/bbb`

否

Prefix

`/aaa/bbb`

`/aaa/bbb`

是

Prefix

`/aaa/bbb/`

`/aaa/bbb`

是，忽略尾部斜线

Prefix

`/aaa/bbb`

`/aaa/bbb/`

是，匹配尾部斜线

Prefix

`/aaa/bbb`

`/aaa/bbb/ccc`

是，匹配子路径

Prefix

`/aaa/bbb`

`/aaa/bbbxyz`

否，字符串前缀不匹配

Prefix

`/`, `/aaa`

`/aaa/ccc`

是，匹配 `/aaa` 前缀

Prefix

`/`, `/aaa`, `/aaa/bbb`

`/aaa/bbb`

是，匹配 `/aaa/bbb` 前缀

Prefix

`/`, `/aaa`, `/aaa/bbb`

`/ccc`

是，匹配 `/` 前缀

Prefix

`/aaa`

`/ccc`

否，使用默认后端

混合

`/foo` (Prefix), `/foo` (Exact)

`/foo`

是，优选 Exact 类型

#### 多重匹配 

在某些情况下，Ingress 中的多条路径会匹配同一个请求。 这种情况下最长的匹配路径优先。 如果仍然有两条同等的匹配路径，则精确路径类型优先于前缀路径类型。

主机名通配符 
-------

主机名可以是精确匹配（例如“​`foo.bar.com`​”）或者使用通配符来匹配 （例如“​`*.foo.com`​”）。 精确匹配要求 HTTP ​`host` ​头部字段与 ​`host` ​字段值完全匹配。 通配符匹配则要求 HTTP ​`host` ​头部字段与通配符规则中的后缀部分相同。

主机

host 头部

匹配与否？

`*.foo.com`

`bar.foo.com`

基于相同的后缀匹配

`*.foo.com`

`baz.bar.foo.com`

不匹配，通配符仅覆盖了一个 DNS 标签

`*.foo.com`

`foo.com`

不匹配，通配符仅覆盖了一个 DNS 标签

`apiVersion: networking.k8s.io/v1 kind: Ingress metadata:   name: ingress-wildcard-host spec:   rules:   - host: "foo.bar.com"     http:       paths:       - pathType: Prefix         path: "/bar"         backend:           service:             name: service1             port:               number: 80   - host: "*.foo.com"     http:       paths:       - pathType: Prefix         path: "/foo"         backend:           service:             name: service2             port:               number: 80`

Ingress 类 
----------

Ingress 可以由不同的控制器实现，通常使用不同的配置。 每个 Ingress 应当指定一个类，也就是一个对 IngressClass 资源的引用。 IngressClass 资源包含额外的配置，其中包括应当实现该类的控制器名称。

`apiVersion: networking.k8s.io/v1 kind: IngressClass metadata:   name: external-lb spec:   controller: example.com/ingress-controller   parameters:     apiGroup: k8s.example.com     kind: IngressParameters     name: external-lb`

IngressClass 中的 ​`.spec.parameters`​ 字段可用于引用其他资源以提供额外的相关配置。

参数（​`parameters`​）的具体类型取决于你在 ​`.spec.controller`​ 字段中指定的 Ingress 控制器。

### IngressClass 的作用域

取决于你的 Ingress 控制器，你可能可以使用集群范围设置的参数或某个名字空间范围的参数。

*   集群作用域

IngressClass 的参数默认是集群范围的。

如果你设置了 .spec.parameters 字段且未设置 .spec.parameters.scope 字段，或是将 .spec.parameters.scope 字段设为了 Cluster，那么该 IngressClass 所指代的即是一个集群作用域的资源。 参数的 kind（和 apiGroup 一起）指向一个集群作用域的 API（可能是一个定制资源（Custom Resource）），而它的 name 则为此 API 确定了一个具体的集群作用域的资源。

示例：

`--- apiVersion: networking.k8s.io/v1 kind: IngressClass metadata:   name: external-lb-1 spec:   controller: example.com/ingress-controller   parameters:     # 此 IngressClass 的配置定义在一个名为 “external-config-1” 的     # ClusterIngressParameter（API 组为 k8s.example.net）资源中。     # 这项定义告诉 Kubernetes 去寻找一个集群作用域的参数资源。     scope: Cluster     apiGroup: k8s.example.net     kind: ClusterIngressParameter     name: external-config-1`

*   命名空间作用域

FEATURE STATE: Kubernetes v1.23 \[stable\]

如果你设置了 ​`.spec.parameters`​ 字段且将 ​`.spec.parameters.scope`​ 字段设为了 ​`Namespace`​，那么该 IngressClass 将会引用一个命名空间作用域的资源。 ​`.spec.parameters.namespace`​ 必须和此资源所处的命名空间相同。

参数的 ​`kind`​（和 ​`apiGroup` ​一起）指向一个命名空间作用域的 API（例如：ConfigMap），而它的 ​`name` ​则确定了一个位于你指定的命名空间中的具体的资源。

命名空间作用域的参数帮助集群操作者将控制细分到用于工作负载的各种配置中（比如：负载均衡设置、API 网关定义）。如果你使用集群作用域的参数，那么你必须从以下两项中选择一项执行：

*   每次修改配置，集群操作团队需要批准其他团队的修改。
*   集群操作团队定义具体的准入控制，比如 RBAC 角色与角色绑定，以使得应用程序团队可以修改集群作用域的配置参数资源。

IngressClass API 本身是集群作用域的。

这里是一个引用命名空间作用域的配置参数的 IngressClass 的示例：

`--- apiVersion: networking.k8s.io/v1 kind: IngressClass metadata:   name: external-lb-2 spec:   controller: example.com/ingress-controller   parameters:     # 此 IngressClass 的配置定义在一个名为 “external-config” 的     # IngressParameter（API 组为 k8s.example.com）资源中，     # 该资源位于 “external-configuration” 命名空间中。     scope: Namespace     apiGroup: k8s.example.com     kind: IngressParameter     namespace: external-configuration     name: external-config`

### 废弃的注解 

在 Kubernetes 1.18 版本引入 IngressClass 资源和 ​`ingressClassName` ​字段之前，Ingress 类是通过 Ingress 中的一个 ​`kubernetes.io/ingress.class`​ 注解来指定的。 这个注解从未被正式定义过，但是得到了 Ingress 控制器的广泛支持。

Ingress 中新的 ​`ingressClassName` ​字段是该注解的替代品，但并非完全等价。 该注解通常用于引用实现该 Ingress 的控制器的名称，而这个新的字段则是对一个包含额外 Ingress 配置的 IngressClass 资源的引用，包括 Ingress 控制器的名称。

### 默认 Ingress 类 

你可以将一个特定的 IngressClass 标记为集群默认 Ingress 类。 将一个 IngressClass 资源的 ​`ingressclass.kubernetes.io/is-default-class`​ 注解设置为 ​`true` ​将确保新的未指定 ​`ingressClassName` ​字段的 Ingress 能够分配为这个默认的 IngressClass.

> 如果集群中有多个 IngressClass 被标记为默认，准入控制器将阻止创建新的未指定 ​`ingressClassName` ​的 Ingress 对象。 解决这个问题只需确保集群中最多只能有一个 IngressClass 被标记为默认。

有一些 Ingress 控制器不需要定义默认的 ​`IngressClass`​。比如：Ingress-NGINX 控制器可以通过[参数](https://kubernetes.github.io/ingress-nginx/ target=) ​`--watch-ingress-without-class`​ 来配置。 不过仍然[推荐](https://kubernetes.github.io/ingress-nginx/ target=) 设置默认的 ​`IngressClass`​。

`apiVersion: networking.k8s.io/v1 kind: IngressClass metadata:   labels:     app.kubernetes.io/component: controller   name: nginx-example   annotations:     ingressclass.kubernetes.io/is-default-class: "true" spec:   controller: k8s.io/ingress-nginx`

Ingress 类型 
-----------

### 由单个 Service 来完成的 Ingress 

现有的 Kubernetes 概念允许你暴露单个 Service。 你也可以通过指定无规则的 默认后端 来对 Ingress 进行此操作。

`apiVersion: networking.k8s.io/v1 kind: Ingress metadata:   name: test-ingress spec:   defaultBackend:     service:       name: test       port:         number: 80`

如果使用 ​`kubectl apply -f`​ 创建此 Ingress，则应该能够查看刚刚添加的 Ingress 的状态：

`kubectl get ingress test-ingress`

`NAME           CLASS         HOSTS   ADDRESS         PORTS   AGE test-ingress   external-lb   *       203.0.113.123   80      59s`

其中 ​`203.0.113.123`​ 是由 Ingress 控制器分配以满足该 Ingress 的 IP。

> 入口控制器和负载平衡器可能需要一两分钟才能分配 IP 地址。 在此之前，你通常会看到地址字段的值被设定为 ​ `<pending>`​。

### 简单扇出 

一个扇出（fanout）配置根据请求的 HTTP URI 将来自同一 IP 地址的流量路由到多个 Service。 Ingress 允许你将负载均衡器的数量降至最低。例如，这样的设置：

![](https://atts.w3cschool.cn/attachments/image/20220506/1651817058967921.png)  

将需要一个如下所示的 Ingress：

`apiVersion: networking.k8s.io/v1 kind: Ingress metadata:   name: simple-fanout-example spec:   rules:   - host: foo.bar.com     http:       paths:       - path: /foo         pathType: Prefix         backend:           service:             name: service1             port:               number: 4200       - path: /bar         pathType: Prefix         backend:           service:             name: service2             port:               number: 8080`

当你使用 ​`kubectl apply -f`​ 创建 Ingress 时：

`kubectl describe ingress simple-fanout-example`

`Name:             simple-fanout-example Namespace:        default Address:          178.91.123.132 Default backend:  default-http-backend:80 (10.8.2.3:8080) Rules:   Host         Path  Backends   ----         ----  --------   foo.bar.com                /foo   service1:4200 (10.8.0.90:4200)                /bar   service2:8080 (10.8.0.91:8080) Annotations:   nginx.ingress.kubernetes.io/rewrite-target:  / Events:   Type     Reason  Age                From                     Message   ----     ------  ----               ----                     -------   Normal   ADD     22s                loadbalancer-controller  default/test`

Ingress 控制器将提供实现特定的负载均衡器来满足 Ingress， 只要 Service (​`service1`​，​`service2`​) 存在。 当它这样做时，你会在 Address 字段看到负载均衡器的地址。

> 取决于你所使用的 Ingress 控制器， 你可能需要创建默认 HTTP 后端服务。

### 基于名称的虚拟托管 

基于名称的虚拟主机支持将针对多个主机名的 HTTP 流量路由到同一 IP 地址上。

![](https://atts.w3cschool.cn/attachments/image/20220506/1651817163509756.png)  

以下 Ingress 让后台负载均衡器基于[host 头部字段](https://datatracker.ietf.org/doc/html/rfc7230 target=) 来路由请求。

`apiVersion: networking.k8s.io/v1 kind: Ingress metadata:   name: name-virtual-host-ingress spec:   rules:   - host: foo.bar.com     http:       paths:       - pathType: Prefix         path: "/"         backend:           service:             name: service1             port:               number: 80   - host: bar.foo.com     http:       paths:       - pathType: Prefix         path: "/"         backend:           service:             name: service2             port:               number: 80`

如果你创建的 Ingress 资源没有在 ​`rules` ​中定义的任何 ​`hosts`​，则可以匹配指向 Ingress 控制器 IP 地址的任何网络流量，而无需基于名称的虚拟主机。

例如，以下 Ingress 会将请求 ​`first.bar.com`​ 的流量路由到 ​`service1`​，将请求 ​`second.bar.com`​ 的流量路由到 ​`service2`​，而所有其他流量都会被路由到 ​`service3`​。

`apiVersion: networking.k8s.io/v1 kind: Ingress metadata:   name: name-virtual-host-ingress-no-third-host spec:   rules:   - host: first.bar.com     http:       paths:       - pathType: Prefix         path: "/"         backend:           service:             name: service1             port:               number: 80   - host: second.bar.com     http:       paths:       - pathType: Prefix         path: "/"         backend:           service:             name: service2             port:               number: 80   - http:       paths:       - pathType: Prefix         path: "/"         backend:           service:             name: service3             port:               number: 80`

### TLS

你可以通过设定包含 TLS 私钥和证书的Secret 来保护 Ingress。 Ingress 只支持单个 TLS 端口 443，并假定 TLS 连接终止于 Ingress 节点（与 Service 及其 Pod 之间的流量都以明文传输）。 如果 Ingress 中的 TLS 配置部分指定了不同的主机，那么它们将根据通过 SNI TLS 扩展指定的主机名（如果 Ingress 控制器支持 SNI）在同一端口上进行复用。 TLS Secret 的数据中必须包含用于 TLS 的以键名 ​`tls.crt`​ 保存的证书和以键名 ​`tls.key`​ 保存的私钥。 例如：

`apiVersion: v1 kind: Secret metadata:   name: testsecret-tls   namespace: default data:   tls.crt: base64 编码的证书   tls.key: base64 编码的私钥 type: kubernetes.io/tls`

在 Ingress 中引用此 Secret 将会告诉 Ingress 控制器使用 TLS 加密从客户端到负载均衡器的通道。 你需要确保创建的 TLS Secret 创建自包含 ​`https-example.foo.com`​ 的公用名称（CN）的证书。 这里的公共名称也被称为全限定域名（FQDN）。

> 注意，默认规则上无法使用 TLS，因为需要为所有可能的子域名发放证书。 因此，​`tls` ​字段中的 ​`hosts` ​的取值需要与 ​`rules` ​字段中的 ​`host` ​完全匹配。

`apiVersion: networking.k8s.io/v1 kind: Ingress metadata:   name: tls-example-ingress spec:   tls:   - hosts:       - https-example.foo.com     secretName: testsecret-tls   rules:   - host: https-example.foo.com     http:       paths:       - path: /         pathType: Prefix         backend:           service:             name: service1             port:               number: 80`

> 各种 Ingress 控制器所支持的 TLS 功能之间存在差异。请参阅有关 [nginx](https://kubernetes.github.io/ingress-nginx/user-guide/tls/)、 [GCE](https://github.com/kubernetes/ingress-gce/blob/master/README.md target=) 或者任何其他平台特定的 Ingress 控制器的文档，以了解 TLS 如何在你的环境中工作。

### 负载均衡 

Ingress 控制器启动引导时使用一些适用于所有 Ingress 的负载均衡策略设置，例如负载均衡算法、后端权重方案等。 更高级的负载均衡概念（例如持久会话、动态权重）尚未通过 Ingress 公开。 你可以通过用于服务的负载均衡器来获取这些功能。

值得注意的是，尽管健康检查不是通过 Ingress 直接暴露的，在 Kubernetes 中存在并行的概念，比如 就绪检查， 允许你实现相同的目的。 请检查特定控制器的说明文档（[nginx](https://github.com/kubernetes/ingress-nginx/blob/main/README.md)、 [GCE](https://github.com/kubernetes/ingress-gce/blob/master/README.md target=)）以了解它们是怎样处理健康检查的。

更新 Ingress 
-----------

要更新现有的 Ingress 以添加新的 Host，可以通过编辑资源来对其进行更新：

`kubectl describe ingress test`

`Name:             test Namespace:        default Address:          178.91.123.132 Default backend:  default-http-backend:80 (10.8.2.3:8080) Rules:   Host         Path  Backends   ----         ----  --------   foo.bar.com                /foo   service1:80 (10.8.0.90:80) Annotations:   nginx.ingress.kubernetes.io/rewrite-target:  / Events:   Type     Reason  Age                From                     Message   ----     ------  ----               ----                     -------   Normal   ADD     35s                loadbalancer-controller  default/test`

`kubectl edit ingress test`

这一命令将打开编辑器，允许你以 YAML 格式编辑现有配置。 修改它来增加新的主机：

`spec:   rules:   - host: foo.bar.com     http:       paths:       - backend:           serviceName: service1           servicePort: 80         path: /foo         pathType: Prefix   - host: bar.baz.com     http:       paths:       - backend:           serviceName: service2           servicePort: 80         path: /foo         pathType: Prefix ..`

保存更改后，kubectl 将更新 API 服务器中的资源，该资源将告诉 Ingress 控制器重新配置负载均衡器。

验证：

`kubectl describe ingress test`

`Name:             test Namespace:        default Address:          178.91.123.132 Default backend:  default-http-backend:80 (10.8.2.3:8080) Rules:   Host         Path  Backends   ----         ----  --------   foo.bar.com                /foo   service1:80 (10.8.0.90:80)   bar.baz.com                /foo   service2:80 (10.8.0.91:80) Annotations:   nginx.ingress.kubernetes.io/rewrite-target:  / Events:   Type     Reason  Age                From                     Message   ----     ------  ----               ----                     -------   Normal   ADD     45s                loadbalancer-controller  default/test`

你也可以通过 ​`kubectl replace -f`​ 命令调用修改后的 Ingress yaml 文件来获得同样的结果。

跨可用区失败 
-------

不同的云厂商使用不同的技术来实现跨故障域的流量分布。

替代方案 
-----

不直接使用 Ingress 资源，也有多种方法暴露 Service：

*   使用 Service.Type=LoadBalancer
*   使用 Service.Type=NodePort

##  6.  Kubernetes Ingress 控制器
Ingress 控制器
-----------

为了让 Ingress 资源工作，集群必须有一个正在运行的 Ingress 控制器。

与作为 ​`kube-controller-manager`​ 可执行文件的一部分运行的其他类型的控制器不同， Ingress 控制器不是随集群自动启动的。 基于此页面，你可选择最适合你的集群的 ingress 控制器实现。

Kubernetes 作为一个项目，目前支持和维护 [AWS](https://github.com/kubernetes-sigs/aws-load-balancer-controller target=)、 [GCE](https://github.com/kubernetes/ingress-gce/blob/master/README.md) 和 [Nginx](https://github.com/kubernetes/ingress-nginx/blob/main/README.md target=) Ingress 控制器。

其他控制器
-----

*   [AKS 应用程序网关 Ingress 控制器](https://docs.microsoft.com/zh-cn/azure/application-gateway/tutorial-ingress-controller-add-on-existing?toc=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fazure%2Faks%2Ftoc.json&bc=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fazure%2Fbread%2Ftoc.json) 是一个配置 [Azure 应用程序网关](https://docs.microsoft.com/zh-cn/azure/application-gateway/overview) 的 Ingress 控制器。
*   [Ambassador](https://www.getambassador.io/) API 网关是一个基于 [Envoy](https://www.envoyproxy.io/) 的 Ingress 控制器。
*   [Apache APISIX Ingress 控制器](https://github.com/apache/apisix-ingress-controller) 是一个基于 [Apache APISIX 网关](https://github.com/apache/apisix) 的 Ingress 控制器。
*   [Avi Kubernetes Operator](https://github.com/vmware/load-balancer-and-ingress-services-for-kubernetes) 使用 [VMware NSX Advanced Load Balancer](https://avinetworks.com/) 提供第 4 到第 7 层的负载均衡。
*   [BFE Ingress 控制器](https://github.com/bfenetworks/ingress-bfe)是一个基于 [BFE](https://www.bfe-networks.net/) 的 Ingress 控制器。
*   [Citrix Ingress 控制器](https://github.com/citrix/citrix-k8s-ingress-controller target=) 可以用来与 Citrix Application Delivery Controller 一起使用。
*   [Contour](https://projectcontour.io/) 是一个基于 [Envoy](https://www.envoyproxy.io/) 的 Ingress 控制器。
*   [EnRoute](https://getenroute.io/) 是一个基于 [Envoy](https://www.envoyproxy.io/) 的 API 网关，可以用作 Ingress 控制器。
*   [Easegress IngressController](https://github.com/megaease/easegress/blob/main/doc/reference/ingresscontroller.md) 是一个基于 [Easegress](https://megaease.com/easegress/) 的 API 网关，可以用作 Ingress 控制器。
*   F5 BIG-IP 的 [用于 Kubernetes 的容器 Ingress 服务](https://clouddocs.f5.com/products/connectors/k8s-bigip-ctlr/latest) 让你能够使用 Ingress 来配置 F5 BIG-IP 虚拟服务器。
*   [Gloo](https://gloo.solo.io/) 是一个开源的、基于 [Envoy](https://www.envoyproxy.io/) 的 Ingress 控制器，能够提供 API 网关功能。
*   [HAProxy Ingress](https://haproxy-ingress.github.io/) 是一个针对 [HAProxy](https://www.haproxy.org/ target=) 的 Ingress 控制器。
*   [用于 Kubernetes 的 HAProxy Ingress 控制器](https://github.com/haproxytech/kubernetes-ingress target=) 也是一个针对 [HAProxy](https://www.haproxy.org/ target=) 的 Ingress 控制器。
*   [Istio Ingress](https://istio.io/latest/docs/tasks/traffic-management/ingress/kubernetes-ingress/) 是一个基于 [Istio](https://istio.io/) 的 Ingress 控制器。
*   [用于 Kubernetes 的 Kong Ingress 控制器](https://github.com/Kong/kubernetes-ingress-controller target=) 是一个用来驱动 [Kong Gateway](https://konghq.com/kong/) 的 Ingress 控制器。
*   [用于 Kubernetes 的 NGINX Ingress 控制器](https://www.nginx.com/products/nginx-ingress-controller/) 能够与 [NGINX](https://www.nginx.com/resources/glossary/nginx/) 网页服务器（作为代理）一起使用。
*   [Pomerium Ingress 控制器](https://www.pomerium.com/docs/k8s/ingress.html) 基于 [Pomerium](https://www.pomerium.com/)，能提供上下文感知的准入策略。
*   [Skipper](https://opensource.zalando.com/skipper/kubernetes/ingress-controller/) HTTP 路由器和反向代理可用于服务组装，支持包括 Kubernetes Ingress 这类使用场景，是一个用以构造你自己的定制代理的库。
*   [Traefik Kubernetes Ingress 提供程序](https://doc.traefik.io/traefik/providers/kubernetes-ingress/) 是一个用于 [Traefik](https://traefik.io/traefik/) 代理的 Ingress 控制器。
*   [Tyk Operator](https://github.com/TykTechnologies/tyk-operator) 使用自定义资源扩展 Ingress，为之带来 API 管理能力。Tyk Operator 使用开源的 Tyk Gateway & Tyk Cloud 控制面。
*   [Voyager](https://appscode.com/products/voyager) 是一个针对 [HAProxy](https://www.haproxy.org/ target=) 的 Ingress 控制器。

使用多个 Ingress 控制器
----------------

你可以使用 Ingress 类在集群中部署任意数量的 Ingress 控制器。 请注意你的 Ingress 类资源的 ​`.metadata.name`​ 字段。 当你创建 Ingress 时，你需要用此字段的值来设置 Ingress 对象的 ​`ingressClassName` ​字段。 ​`ingressClassName` ​是之前的注解做法的替代。

如果你不为 Ingress 指定一个 IngressClass，并且你的集群中只有一个 IngressClass 被标记为了集群默认，那么 Kubernetes 会应用此默认 IngressClass。 你可以通过将 ​`ingressclass.kubernetes.io/is-default-class`​ 注解 的值设置为 ​`"true"`​ 来将一个 IngressClass 标记为集群默认。

理想情况下，所有 Ingress 控制器都应满足此规范，但各种 Ingress 控制器的操作略有不同。

> 确保你查看了 ingress 控制器的文档，以了解选择它的注意事项。

##  7.  Kubernetes 拓扑感知提示
拓扑感知提示
------

FEATURE STATE: Kubernetes v1.23 \[beta\]

拓扑感知提示 包含客户怎么使用服务端点的建议，从而实现了拓扑感知的路由功能。 这种方法添加了元数据，以启用 EndpointSlice 和/或 Endpoints 对象的调用者， 这样，访问这些网络端点的请求流量就可以在它的发起点附近就近路由。

例如，你可以在一个地域内路由流量，以降低通信成本，或提高网络性能。

> “拓扑感知提示”特性处于 Beta 阶段，并且默认情况下未启用。 要试用此特性，你必须启用 ​`TopologyAwareHints` ​特性门控。

动机
--

Kubernetes 集群越来越多的部署到多区域环境中。 拓扑感知提示 提供了一种把流量限制在它的发起区域之内的机制。 这个概念一般被称之为 “拓扑感知路由”。 在计算 服务（Service） 的端点时， EndpointSlice 控制器会评估每一个端点的拓扑（地域和区域），填充提示字段，并将其分配到某个区域。 集群组件，例如kube-proxy 就可以使用这些提示信息，并用他们来影响流量的路由（倾向于拓扑上相邻的端点）。

使用拓扑感知提示
--------

你可以通过把注解 ​`service.kubernetes.io/topology-aware-hints`​ 的值设置为 ​`auto`​， 来激活服务的拓扑感知提示功能。 这告诉 EndpointSlice 控制器在它认为安全的时候来设置拓扑提示。 重要的是，这并不能保证总会设置提示（hints）。

工作原理 
-----

此特性启用的功能分为两个组件：EndpointSlice 控制器和 kube-proxy。 本节概述每个组件如何实现此特性。

### EndpointSlice 控制器

此特性开启后，EndpointSlice 控制器负责在 EndpointSlice 上设置提示信息。 控制器按比例给每个区域分配一定比例数量的端点。 这个比例来源于此区域中运行节点的 可分配 CPU 核心数。 例如，如果一个区域拥有 2 CPU 核心，而另一个区域只有 1 CPU 核心， 那控制器将给那个有 2 CPU 的区域分配两倍数量的端点。

以下示例展示了提供提示信息后 EndpointSlice 的样子：

`apiVersion: discovery.k8s.io/v1 kind: EndpointSlice metadata:   name: example-hints   labels:     kubernetes.io/service-name: example-svc addressType: IPv4 ports:   - name: http     protocol: TCP     port: 80 endpoints:   - addresses:       - "10.1.2.3"     conditions:       ready: true     hostname: pod-1     zone: zone-a     hints:       forZones:         - name: "zone-a"`

### kube-proxy

kube-proxy 组件依据 EndpointSlice 控制器设置的提示，过滤由它负责路由的端点。 在大多数场合，这意味着 kube-proxy 可以把流量路由到同一个区域的端点。 有时，控制器从某个不同的区域分配端点，以确保在多个区域之间更平均的分配端点。 这会导致部分流量被路由到其他区域。

保护措施
----

Kubernetes 控制平面和每个节点上的 kube-proxy，在使用拓扑感知提示功能前，会应用一些保护措施规则。 如果没有检出，kube-proxy 将无视区域限制，从集群中的任意节点上选择端点。

1.  端点数量不足： 如果一个集群中，端点数量少于区域数量，控制器不创建任何提示。
2.  不可能实现均衡分配： 在一些场合中，不可能实现端点在区域中的平衡分配。 例如，假设 zone-a 比 zone-b 大两倍，但只有 2 个端点， 那分配到 zone-a 的端点可能收到比 zone-b多两倍的流量。 如果控制器不能确定此“期望的过载”值低于每一个区域可接受的阈值，控制器将不指派提示信息。 重要的是，这不是基于实时反馈。所以对于单独的端点仍有可能超载。
3.  一个或多个节点信息不足： 如果任一节点没有设置标签 ​`topology.kubernetes.io/zone`​， 或没有上报可分配的 CPU 数据，控制平面将不会设置任何拓扑感知提示， 继而 kube-proxy 也就不能通过区域过滤端点。
4.  一个或多个端点没有设置区域提示： 当这类事情发生时， kube-proxy 会假设这是正在执行一个从/到拓扑感知提示的转移。 在这种场合下过滤Service 的端点是有风险的，所以 kube-proxy 回撤为使用所有的端点。
5.  不在提示中的区域： 如果 kube-proxy 不能根据一个指示在它所在的区域中发现一个端点， 它回撤为使用所有节点的端点。当你的集群新增一个新的区域时，这种情况发生概率很高。

限制
--

*   当 Service 的 ​`externalTrafficPolicy` ​或 ​`internalTrafficPolicy` ​设置值为 ​`Local` ​时， 拓扑感知提示功能不可用。 你可以在一个集群的不同服务中使用这两个特性，但不能在同一个服务中这么做。
*   这种方法不适用于大部分流量来自于一部分区域的服务。 相反的，这里假设入站流量将根据每个区域中节点的服务能力按比例的分配。
*   EndpointSlice 控制器在计算每一个区域的容量比例时，会忽略未就绪的节点。 在大量节点未就绪的场景下，这样做会带来非预期的结果。
*   EndpointSlice 控制器在计算每一个区域的部署比例时，并不会考虑 容忍度。 如果服务后台的 Pod 被限制只能运行在集群节点的一个子集上，这些信息并不会被使用。
*   这种方法和自动扩展机制之间不能很好的协同工作。例如，如果大量流量来源于一个区域， 那只有分配到该区域的端点才可用来处理流量。这会导致 Pod 自动水平扩展 要么不能拾取此事件，要么新增 Pod 被启动到其他区域。

##  8.  Kubernetes 服务内部流量策略
服务内部流量策略
--------

FEATURE STATE: Kubernetes v1.23 \[beta\]

服务内部流量策略 开启了内部流量限制，只路由内部流量到和发起方处于相同节点的服务端点。 这里的”内部“流量指当前集群中的 Pod 所发起的流量。 这种机制有助于节省开销，提升效率。

使用服务内部流量策略
----------

​`ServiceInternalTrafficPolicy` ​特性门控 是 Beta 功能，默认启用。 启用该功能后，你就可以通过将 Services 的 ​`.spec.internalTrafficPolicy`​ 项设置为 ​`Local`​， 来为它指定一个内部专用的流量策略。 此设置就相当于告诉 kube-proxy 对于集群内部流量只能使用本地的服务端口。

> 如果某节点上的 Pod 均不提供指定 Service 的服务端点， 即使该 Service 在其他节点上有可用的服务端点， Service 的行为看起来也像是它只有 0 个服务端点（只针对此节点上的 Pod）。

以下示例展示了把 Service 的 ​`.spec.internalTrafficPolicy`​ 项设为 ​`Local` ​时， Service 的样子：

`apiVersion: v1 kind: Service metadata:   name: my-service spec:   selector:     app: MyApp   ports:     - protocol: TCP       port: 80       targetPort: 9376   internalTrafficPolicy: Local`

工作原理
----

kube-proxy 基于 ​`spec.internalTrafficPolicy`​ 的设置来过滤路由的目标服务端点。 当它的值设为 ​`Local` ​时，只选择节点本地的服务端点。 当它的值设为 ​`Cluster` ​或缺省时，则选择所有的服务端点。 启用特性门控 ​`ServiceInternalTrafficPolicy` ​后， ​`spec.internalTrafficPolicy`​ 的值默认设为 ​`Cluster`​。

限制
--

*   在一个Service上，当 ​`externalTrafficPolicy` ​已设置为 ​`Local`​时，服务内部流量策略无法使用。 换句话说，在一个集群的不同 Service 上可以同时使用这两个特性，但在一个 Service 上不行。

##  9.  Kubernetes 端点切片（Endpoint Slices）
端点切片（Endpoint Slices）
---------------------

FEATURE STATE: Kubernetes v1.21 \[stable\]

端点切片（EndpointSlices） 提供了一种简单的方法来跟踪 Kubernetes 集群中的网络端点 （network endpoints）。它们为 Endpoints 提供了一种可伸缩和可拓展的替代方案。

动机 
---

Endpoints API 提供了在 Kubernetes 跟踪网络端点的一种简单而直接的方法。 不幸的是，随着 Kubernetes 集群和 服务 逐渐开始为更多的后端 Pods 处理和发送请求，原来的 API 的局限性变得越来越明显。 最重要的是那些因为要处理大量网络端点而带来的挑战。

由于任一服务的所有网络端点都保存在同一个 Endpoints 资源中，这类资源可能变得 非常巨大，而这一变化会影响到 Kubernetes 组件（比如主控组件）的性能，并 在 Endpoints 变化时产生大量的网络流量和额外的处理。 EndpointSlice 能够帮助你缓解这一问题，还能为一些诸如拓扑路由这类的额外 功能提供一个可扩展的平台。

Endpoint Slice 资源 
------------------

在 Kubernetes 中，​`EndpointSlice` ​包含对一组网络端点的引用。 指定选择器后控制面会自动为设置了 选择算符 的 Kubernetes 服务创建 EndpointSlice。 这些 EndpointSlice 将包含对与服务选择算符匹配的所有 Pod 的引用。 EndpointSlice 通过唯一的协议、端口号和服务名称将网络端点组织在一起。 EndpointSlice 的名称必须是合法的 DNS 子域名。

例如，下面是 Kubernetes 服务 ​`example` ​的 EndpointSlice 资源示例。

`apiVersion: discovery.k8s.io/v1 kind: EndpointSlice metadata:   name: example-abc   labels:     kubernetes.io/service-name: example addressType: IPv4 ports:   - name: http     protocol: TCP     port: 80 endpoints:   - addresses:     - "10.1.2.3"     conditions:       ready: true     hostname: pod-1     nodeName: node-1     zone: us-west2-a`

默认情况下，控制面创建和管理的 EndpointSlice 将包含不超过 100 个端点。 你可以使用 kube-controller-manager 的 ​`--max-endpoints-per-slice`​ 标志设置此值，最大值为 1000。

当涉及如何路由内部流量时，EndpointSlice 可以充当 kube-proxy 的决策依据。 启用该功能后，在服务的端点数量庞大时会有可观的性能提升。

地址类型
----

EndpointSlice 支持三种地址类型：

*   IPv4
*   IPv6
*   FQDN (完全合格的域名)

### 状况

EndpointSlice API 存储了可能对使用者有用的、有关端点的状况。 这三个状况分别是 ​`ready`​、​`serving` ​和 ​`terminating`​。

#### Ready（就绪）

​`ready` ​状况是映射 Pod 的 ​`Ready` ​状况的。 处于运行中的 Pod，它的 ​`Ready` ​状况被设置为 ​`True`​，应该将此 EndpointSlice 状况也设置为 ​`true`​。 出于兼容性原因，当 Pod 处于终止过程中，​`ready` ​永远不会为 ​`true`​。 消费者应参考 ​`serving` ​状况来检查处于终止中的 Pod 的就绪情况。 该规则的唯一例外是将 ​`spec.publishNotReadyAddresses`​ 设置为 ​`true` ​的服务。 这些服务（Service）的端点将始终将 ​`ready` ​状况设置为 ​`true`​。

#### Serving（服务中）

FEATURE STATE: Kubernetes v1.20 \[alpha\]

​`serving` ​状况与 ​`ready` ​状况相同，不同之处在于它不考虑终止状态。 如果 EndpointSlice API 的使用者关心 Pod 终止时的就绪情况，就应检查此状况。

> 尽管 ​`serving` ​与 ​`ready` ​几乎相同，但是它是为防止破坏 ​`ready` ​的现有含义而增加的。 如果对于处于终止中的端点，​`ready` ​可能是 ​`true`​，那么对于现有的客户端来说可能是有些意外的， 因为从始至终，Endpoints 或 EndpointSlice API 从未包含处于终止中的端点。 出于这个原因，​`ready` ​对于处于终止中的端点 总是 ​`false`​， 并且在 v1.20 中添加了新的状况 ​`serving`​，以便客户端可以独立于 ​`ready` ​的现有语义来跟踪处于终止中的 Pod 的就绪情况。

#### Terminating（终止中）

FEATURE STATE: Kubernetes v1.20 \[alpha\]

​`Terminating` ​是表示端点是否处于终止中的状况。 对于 Pod 来说，这是设置了删除时间戳的 Pod。

### 拓扑信息 

EndpointSlice 中的每个端点都可以包含一定的拓扑信息。 拓扑信息包括端点的位置，对应节点、可用区的信息。 这些信息体现为 EndpointSlices 的如下端点字段：

*   ​`nodeName` ​- 端点所在的 Node 名称；
*   ​`zone` ​- 端点所处的可用区。

> 在 v1 API 中，逐个端点设置的 ​`topology` ​实际上被去除，以鼓励使用专用 的字段 ​`nodeName` ​和 ​`zone`​。  
> 对 ​`EndpointSlice` ​对象的 ​`endpoint` ​字段设置任意的拓扑结构信息这一操作已被 废弃，不再被 v1 API 所支持。取而代之的是 v1 API 所支持的 ​`nodeName` ​和 ​`zone` ​这些独立的字段。这些字段可以在不同的 API 版本之间自动完成转译。 例如，v1beta1 API 中 ​`topology` ​字段的 ​`topology.kubernetes.io/zone`​ 取值可以 在 v1 API 中通过 ​`zone` ​字段访问。

### 管理 

通常，控制面（尤其是端点切片的 控制器） 会创建和管理 EndpointSlice 对象。EndpointSlice 对象还有一些其他使用场景， 例如作为服务网格（Service Mesh）的实现。这些场景都会导致有其他实体 或者控制器负责管理额外的 EndpointSlice 集合。

为了确保多个实体可以管理 EndpointSlice 而且不会相互产生干扰，Kubernetes 定义了 标签 ​`endpointslice.kubernetes.io/managed-by`​，用来标明哪个实体在管理某个 EndpointSlice。端点切片控制器会在自己所管理的所有 EndpointSlice 上将该标签值设置 为 ​`endpointslice-controller.k8s.io`​。 管理 EndpointSlice 的其他实体也应该为此标签设置一个唯一值。

### 属主关系 

在大多数场合下，EndpointSlice 都由某个 Service 所有，（因为）该端点切片正是 为该服务跟踪记录其端点。这一属主关系是通过为每个 EndpointSlice 设置一个 属主（owner）引用，同时设置 ​`kubernetes.io/service-name`​ 标签来标明的， 目的是方便查找隶属于某服务的所有 EndpointSlice。

### EndpointSlice 镜像 

在某些场合，应用会创建定制的 Endpoints 资源。为了保证这些应用不需要并发 的更改 Endpoints 和 EndpointSlice 资源，集群的控制面将大多数 Endpoints 映射到对应的 EndpointSlice 之上。

控制面对 Endpoints 资源进行映射的例外情况有：

*   Endpoints 资源上标签 ​`endpointslice.kubernetes.io/skip-mirror`​ 值为 ​`true`​。
*   Endpoints 资源包含标签 ​`control-plane.alpha.kubernetes.io/leader`​。
*   对应的 Service 资源不存在。
*   对应的 Service 的选择算符不为空。

每个 Endpoints 资源可能会被翻译到多个 EndpointSlices 中去。 当 Endpoints 资源中包含多个子网或者包含多个 IP 地址族（IPv4 和 IPv6）的端点时， 就有可能发生这种状况。 每个子网最多有 1000 个地址会被镜像到 EndpointSlice 中。

### EndpointSlices 的分布问题 

每个 EndpointSlice 都有一组端口值，适用于资源内的所有端点。 当为服务使用命名端口时，Pod 可能会就同一命名端口获得不同的端口号，因而需要 不同的 EndpointSlice。这有点像 Endpoints 用来对子网进行分组的逻辑。

控制面尝试尽量将 EndpointSlice 填满，不过不会主动地在若干 EndpointSlice 之间 执行再平衡操作。这里的逻辑也是相对直接的：

1.  列举所有现有的 EndpointSlices，移除那些不再需要的端点并更新那些已经 变化的端点。
2.  列举所有在第一步中被更改过的 EndpointSlices，用新增加的端点将其填满。
3.  如果还有新的端点未被添加进去，尝试将这些端点添加到之前未更改的切片中， 或者创建新切片。

这里比较重要的是，与在 EndpointSlice 之间完成最佳的分布相比，第三步中更看重 限制 EndpointSlice 更新的操作次数。例如，如果有 10 个端点待添加，有两个 EndpointSlice 中各有 5 个空位，上述方法会创建一个新的 EndpointSlice 而不是 将现有的两个 EndpointSlice 都填满。换言之，与执行多个 EndpointSlice 更新操作 相比较，方法会优先考虑执行一个 EndpointSlice 创建操作。

由于 kube-proxy 在每个节点上运行并监视 EndpointSlice 状态，EndpointSlice 的 每次变更都变得相对代价较高，因为这些状态变化要传递到集群中每个节点上。 这一方法尝试限制要发送到所有节点上的变更消息个数，即使这样做可能会导致有 多个 EndpointSlice 没有被填满。

在实践中，上面这种并非最理想的分布是很少出现的。大多数被 EndpointSlice 控制器 处理的变更都是足够小的，可以添加到某已有 EndpointSlice 中去的。并且，假使无法 添加到已有的切片中，不管怎样都会快就会需要一个新的 EndpointSlice 对象。 Deployment 的滚动更新为重新为 EndpointSlice 打包提供了一个自然的机会，所有 Pod 及其对应的端点在这一期间都会被替换掉。

### 重复的端点 

由于 EndpointSlice 变化的自身特点，端点可能会同时出现在不止一个 EndpointSlice 中。鉴于不同的 EndpointSlice 对象在不同时刻到达 Kubernetes 的监视/缓存中， 这种情况的出现是很自然的。 使用 EndpointSlice 的实现必须能够处理端点出现在多个切片中的状况。 关于如何执行端点去重（deduplication）的参考实现，你可以在 ​`kube-proxy`​ 的 ​`EndpointSlice` ​实现中找到。

##  10.  Kubernetes 网络策略
网络策略
----

如果你希望在 IP 地址或端口层面（OSI 第 3 层或第 4 层）控制网络流量， 则你可以考虑为集群中特定应用使用 Kubernetes 网络策略（NetworkPolicy）。 NetworkPolicy 是一种以应用为中心的结构，允许你设置如何允许 Pod 与网络上的各类网络“实体” （我们这里使用实体以避免过度使用诸如“端点”和“服务”这类常用术语， 这些术语在 Kubernetes 中有特定含义）通信。

Pod 可以通信的 Pod 是通过如下三个标识符的组合来辩识的：

1.  其他被允许的 Pods（例外：Pod 无法阻塞对自身的访问）
2.  被允许的名字空间
3.  IP 组块（例外：与 Pod 运行所在的节点的通信总是被允许的， 无论 Pod 或节点的 IP 地址）

在定义基于 Pod 或名字空间的 NetworkPolicy 时，你会使用 选择算符 来设定哪些流量 可以进入或离开与该算符匹配的 Pod。

同时，当基于 IP 的 NetworkPolicy 被创建时，我们基于 IP 组块（CIDR 范围） 来定义策略。

前置条件 
-----

网络策略通过网络插件 来实现。要使用网络策略，你必须使用支持 NetworkPolicy 的网络解决方案。 创建一个 NetworkPolicy 资源对象而没有控制器来使它生效的话，是没有任何作用的。

Pod 隔离的两种类型
-----------

Pod 有两种隔离: 出口的隔离和入口的隔离。它们涉及到可以建立哪些连接。 这里的“隔离”不是绝对的，而是意味着“有一些限制”。 另外的，“非隔离方向”意味着在所述方向上没有限制。这两种隔离（或不隔离）是独立声明的， 并且都与从一个 Pod 到另一个 Pod 的连接有关。

默认情况下，一个 Pod 的出口是非隔离的，即所有外向连接都是被允许的。如果有任何的 NetworkPolicy 选择该 Pod 并在其 ​`policyTypes` ​中包含 “Egress”，则该 Pod 是出口隔离的， 我们称这样的策略适用于该 Pod 的出口。当一个 Pod 的出口被隔离时， 唯一允许的来自 Pod 的连接是适用于出口的 Pod 的某个 NetworkPolicy 的 ​`egress` ​列表所允许的连接。 这些 ​`egress` ​列表的效果是相加的。

默认情况下，一个 Pod 对入口是非隔离的，即所有入站连接都是被允许的。如果有任何的 NetworkPolicy 选择该 Pod 并在其 ​`policyTypes` ​中包含 “Ingress”，则该 Pod 被隔离入口， 我们称这种策略适用于该 Pod 的入口。 当一个 Pod 的入口被隔离时，唯一允许进入该 Pod 的连接是来自该 Pod 节点的连接和适用于入口的 Pod 的某个 NetworkPolicy 的 ​`ingress` ​列表所允许的连接。这些 ​`ingress` ​列表的效果是相加的。

网络策略是相加的，所以不会产生冲突。如果策略适用于 Pod 某一特定方向的流量， Pod 在对应方向所允许的连接是适用的网络策略所允许的集合。 因此，评估的顺序不影响策略的结果。

要允许从源 Pod 到目的 Pod 的连接，源 Pod 的出口策略和目的 Pod 的入口策略都需要允许连接。 如果任何一方不允许连接，建立连接将会失败。

NetworkPolicy 资源
----------------

下面是一个 NetworkPolicy 的示例:

`apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata:   name: test-network-policy   namespace: default spec:   podSelector:     matchLabels:       role: db   policyTypes:     - Ingress     - Egress   ingress:     - from:         - ipBlock:             cidr: 172.17.0.0/16             except:               - 172.17.1.0/24         - namespaceSelector:             matchLabels:               project: myproject         - podSelector:             matchLabels:               role: frontend       ports:         - protocol: TCP           port: 6379   egress:     - to:         - ipBlock:             cidr: 10.0.0.0/24       ports:         - protocol: TCP           port: 5978`

> 除非选择支持网络策略的网络解决方案，否则将上述示例发送到API服务器没有任何效果。

必需字段：与所有其他的 Kubernetes 配置一样，NetworkPolicy 需要 ​`apiVersion`​、 ​`kind` ​和 ​`metadata` ​字段。

spec：NetworkPolicy 规约 中包含了在一个名字空间中定义特定网络策略所需的所有信息。

podSelector：每个 NetworkPolicy 都包括一个 ​`podSelector`​，它对该策略所 适用的一组 Pod 进行选择。示例中的策略选择带有 "role=db" 标签的 Pod。 空的 ​`podSelector` ​选择名字空间下的所有 Pod。

policyTypes: 每个 NetworkPolicy 都包含一个 ​`policyTypes` ​列表，其中包含 ​`Ingress` ​或 ​`Egress` ​或两者兼具。​`policyTypes` ​字段表示给定的策略是应用于 进入所选 Pod 的入站流量还是来自所选 Pod 的出站流量，或两者兼有。 如果 NetworkPolicy 未指定 ​`policyTypes` ​则默认情况下始终设置 ​`Ingress`​； 如果 NetworkPolicy 有任何出口规则的话则设置 ​`Egress`​。

ingress: 每个 NetworkPolicy 可包含一个 ​`ingress` ​规则的白名单列表。 每个规则都允许同时匹配 ​`from` ​和 ​`ports` ​部分的流量。示例策略中包含一条 简单的规则： 它匹配某个特定端口，来自三个来源中的一个，第一个通过 ​`ipBlock` ​指定，第二个通过 ​`namespaceSelector` ​指定，第三个通过 ​`podSelector` ​指定。

egress: 每个 NetworkPolicy 可包含一个 ​`egress` ​规则的白名单列表。 每个规则都允许匹配 ​`to` ​和 ​`port` ​部分的流量。该示例策略包含一条规则， 该规则将指定端口上的流量匹配到 ​`10.0.0.0/24`​ 中的任何目的地。

所以，该网络策略示例:

1.  隔离 "default" 名字空间下 "role=db" 的 Pod （如果它们不是已经被隔离的话）。
2.  （Ingress 规则）允许以下 Pod 连接到 "default" 名字空间下的带有 "role=db" 标签的所有 Pod 的 6379 TCP 端口：

*   "default" 名字空间下带有 "role=frontend" 标签的所有 Pod
*   带有 "project=myproject" 标签的所有名字空间中的 Pod
*   IP 地址范围为 172.17.0.0–172.17.0.255 和 172.17.2.0–172.17.255.255 （即，除了 172.17.1.0/24 之外的所有 172.17.0.0/16）

4.  （Egress 规则）允许从带有 "role=db" 标签的名字空间下的任何 Pod 到 CIDR 10.0.0.0/24 下 5978 TCP 端口的连接。

选择器 to 和 from 的行为 
------------------

可以在 ​`ingress` ​的 ​`from` ​部分或 ​`egress` ​的 ​`to` ​部分中指定四种选择器：

podSelector: 此选择器将在与 NetworkPolicy 相同的名字空间中选择特定的 Pod，应将其允许作为入站流量来源或出站流量目的地。

namespaceSelector：此选择器将选择特定的名字空间，应将所有 Pod 用作其 入站流量来源或出站流量目的地。

namespaceSelector 和 podSelector： 一个指定 ​`namespaceSelector` ​和 ​`podSelector` ​的 ​`to`​/​`from` ​条目选择特定名字空间中的特定 Pod。 注意使用正确的 YAML 语法；下面的策略：

  `...   ingress:   - from:     - namespaceSelector:         matchLabels:           user: alice       podSelector:         matchLabels:           role: client   ...`

在 ​`from` ​数组中仅包含一个元素，只允许来自标有 ​`role=client`​ 的 Pod 且 该 Pod 所在的名字空间中标有 ​`user=alice`​ 的连接。但是 这项 策略：

  `...   ingress:   - from:     - namespaceSelector:         matchLabels:           user: alice     - podSelector:         matchLabels:           role: client   ...`

在 ​`from` ​数组中包含两个元素，允许来自本地名字空间中标有 ​`role=client`​ 的 Pod 的连接，或 来自任何名字空间中标有 ​`user=alice`​ 的任何 Pod 的连接。

如有疑问，请使用 ​`kubectl describe`​ 查看 Kubernetes 如何解释该策略。

ipBlock: 此选择器将选择特定的 IP CIDR 范围以用作入站流量来源或出站流量目的地。 这些应该是集群外部 IP，因为 Pod IP 存在时间短暂的且随机产生。

集群的入站和出站机制通常需要重写数据包的源 IP 或目标 IP。 在发生这种情况时，不确定在 NetworkPolicy 处理之前还是之后发生， 并且对于网络插件、云提供商、​`Service` ​实现等的不同组合，其行为可能会有所不同。

对入站流量而言，这意味着在某些情况下，你可以根据实际的原始源 ​`IP` ​过滤传入的数据包， 而在其他情况下，NetworkPolicy 所作用的 源IP 则可能是 ​`LoadBalancer` ​或 Pod 的节点等。

对于出站流量而言，这意味着从 Pod 到被重写为集群外部 IP 的 ​`Service` ​IP 的连接可能会或可能不会受到基于 ​`ipBlock` ​的策略的约束

默认策略 
-----

默认情况下，如果名字空间中不存在任何策略，则所有进出该名字空间中 Pod 的流量都被允许。 以下示例使你可以更改该名字空间中的默认行为。

### 默认拒绝所有入站流量

你可以通过创建选择所有容器但不允许任何进入这些容器的入站流量的 NetworkPolicy 来为名字空间创建 “default” 隔离策略。

`apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata:   name: default-deny-ingress spec:   podSelector: {}   policyTypes:   - Ingress`

这样可以确保即使容器没有选择其他任何 NetworkPolicy，也仍然可以被隔离。 此策略不会更改默认的出口隔离行为。

### 默认允许所有入站流量

如果要允许所有流量进入某个名字空间中的所有 Pod（即使添加了导致某些 Pod 被视为 “隔离”的策略），则可以创建一个策略来明确允许该名字空间中的所有流量。

`apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata:   name: allow-all-ingress spec:   podSelector: {}   ingress:   - {}   policyTypes:   - Ingress`

### 默认拒绝所有出站流量

你可以通过创建选择所有容器但不允许来自这些容器的任何出站流量的 NetworkPolicy 来为名字空间创建 “default” 隔离策略。

`apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata:   name: default-deny-egress spec:   podSelector: {}   policyTypes:   - Egress`

此策略可以确保即使没有被其他任何 NetworkPolicy 选择的 Pod 也不会被允许流出流量。 此策略不会更改默认的入站流量隔离行为。

### 默认允许所有出站流量 

如果要允许来自名字空间中所有 Pod 的所有流量（即使添加了导致某些 Pod 被视为“隔离”的策略）， 则可以创建一个策略，该策略明确允许该名字空间中的所有出站流量。

`apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata:   name: allow-all-egress spec:   podSelector: {}   egress:   - {}   policyTypes:   - Egress`

### 默认拒绝所有入口和所有出站流量

你可以为名字空间创建“默认”策略，以通过在该名字空间中创建以下 NetworkPolicy 来阻止所有入站和出站流量。

`apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata:   name: default-deny-all spec:   podSelector: {}   policyTypes:   - Ingress   - Egress`

此策略可以确保即使没有被其他任何 NetworkPolicy 选择的 Pod 也不会被 允许入站或出站流量。

SCTP 支持
-------

FEATURE STATE: Kubernetes v1.20 \[stable\]

作为一个稳定特性，SCTP 支持默认是被启用的。 要在集群层面禁用 SCTP，你（或你的集群管理员）需要为 API 服务器指定 ​`--feature-gates=SCTPSupport=false,...`​ 来禁用 ​`SCTPSupport` ​特性门控。 启用该特性门控后，用户可以将 NetworkPolicy 的 ​`protocol` ​字段设置为 ​`SCTP`​。

> 你必须使用支持 SCTP 协议网络策略的 CNI 插件。

针对某个端口范围 
---------

FEATURE STATE: Kubernetes v1.22 \[beta\]

在编写 NetworkPolicy 时，你可以针对一个端口范围而不是某个固定端口。

这一目的可以通过使用 ​`endPort` ​字段来实现，如下例所示：

`apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata:   name: multi-port-egress   namespace: default spec:   podSelector:     matchLabels:       role: db   policyTypes:   - Egress   egress:   - to:     - ipBlock:         cidr: 10.0.0.0/24     ports:     - protocol: TCP       port: 32000       endPort: 32768`

上面的规则允许名字空间 ​`default` ​中所有带有标签 ​`role=db` ​的 Pod 使用 TCP 协议 与 ​`10.0.0.0/24`​ 范围内的 IP 通信，只要目标端口介于 32000 和 32768 之间就可以。

使用此字段时存在以下限制：

*   作为一种 Beta 阶段的特性，端口范围设定默认是被启用的。要在整个集群 范围内禁止使用 ​`endPort` ​字段，你（或者你的集群管理员）需要为 API 服务器设置 ​`-feature-gates=NetworkPolicyEndPort=false,...` ​以禁用 ​`NetworkPolicyEndPort` ​特性门控。
*   ​`endPort` ​字段必须等于或者大于 ​`port` ​字段的值。
*   两个字段的设置值都只能是数字。

> 你的集群所使用的 CNI 插件 必须支持在 NetworkPolicy 规约中使用 ​`endPort` ​字段。 如果你的网络插件 不支持 ​`endPort` ​字段，而你指定了一个包含 ​`endPort` ​字段的 NetworkPolicy， 策略只对单个 ​`port` ​字段生效。

基于名字指向某名字空间 
------------

FEATURE STATE: Kubernetes 1.22 \[stable\]

只要 ​`NamespaceDefaultLabelName` ​特性门控 被启用，Kubernetes 控制面会在所有名字空间上设置一个不可变更的标签 ​`kubernetes.io/metadata.name`​。该标签的值是名字空间的名称。

如果 NetworkPolicy 无法在某些对象字段中指向某名字空间，你可以使用标准的 标签方式来指向特定名字空间。

通过网络策略（至少目前还）无法完成的工作
--------------------

到 Kubernetes 1.24 为止，NetworkPolicy API 还不支持以下功能，不过 你可能可以使用操作系统组件（如 SELinux、OpenVSwitch、IPTables 等等） 或者第七层技术（Ingress 控制器、服务网格实现）或准入控制器来实现一些 替代方案。 如果你对 Kubernetes 中的网络安全性还不太了解，了解使用 NetworkPolicy API 还无法实现下面的用户场景是很值得的。

*   强制集群内部流量经过某公用网关（这种场景最好通过服务网格或其他代理来实现）；
*   与 TLS 相关的场景（考虑使用服务网格或者 Ingress 控制器）；
*   特定于节点的策略（你可以使用 CIDR 来表达这一需求不过你无法使用节点在 Kubernetes 中的其他标识信息来辩识目标节点）；
*   基于名字来选择服务（不过，你可以使用 标签 来选择目标 Pod 或名字空间，这也通常是一种可靠的替代方案）；
*   创建或管理由第三方来实际完成的“策略请求”；
*   实现适用于所有名字空间或 Pods 的默认策略（某些第三方 Kubernetes 发行版本 或项目可以做到这点）；
*   高级的策略查询或者可达性相关工具；
*   生成网络安全事件日志的能力（例如，被阻塞或接收的连接请求）；
*   显式地拒绝策略的能力（目前，NetworkPolicy 的模型默认采用拒绝操作， 其唯一的能力是添加允许策略）；
*   禁止本地回路或指向宿主的网络流量（Pod 目前无法阻塞 localhost 访问， 它们也无法禁止来自所在节点的访问请求）。

##  11.  Kubernetes IPv4/IPv6 双协议栈
IPv4/IPv6 双协议栈
--------------

FEATURE STATE: Kubernetes v1.23 \[stable\]

IPv4/IPv6 双协议栈网络能够将 IPv4 和 IPv6 地址分配给 Pod 和 Service。

从 1.21 版本开始，Kubernetes 集群默认启用 IPv4/IPv6 双协议栈网络， 以支持同时分配 IPv4 和 IPv6 地址。

支持的功能 
------

Kubernetes 集群的 IPv4/IPv6 双协议栈可提供下面的功能：

*   双协议栈 pod 网络 (每个 pod 分配一个 IPv4 和 IPv6 地址)
*   IPv4 和 IPv6 启用的服务
*   Pod 的集群外出口通过 IPv4 和 IPv6 路由

先决条件 
-----

为了使用 IPv4/IPv6 双栈的 Kubernetes 集群，需要满足以下先决条件：

*   Kubernetes 1.20 版本或更高版本，有关更早 Kubernetes 版本的使用双栈服务的信息， 请参考对应版本的 Kubernetes 文档。
*   提供商支持双协议栈网络（云提供商或其他提供商必须能够为 Kubernetes 节点提供可路由的 IPv4/IPv6 网络接口）
*   支持双协议栈的网络插件（如 Kubenet 或 Calico）

配置 IPv4/IPv6 双协议栈
-----------------

*   kube-apiserver:

*   ​`--service-cluster-ip-range=<IPv4 CIDR>,<IPv6 CIDR>`​

*   kube-controller-manager:

*   ​`--cluster-cidr=<IPv4 CIDR>,<IPv6 CIDR>`​
*   ​`--service-cluster-ip-range=<IPv4 CIDR>,<IPv6 CIDR>`​
*   ​`--node-cidr-mask-size-ipv4|--node-cidr-mask-size-ipv6`​ 对于 IPv4 默认为 /24，对于 IPv6 默认为 /64

*   kube-proxy:

*   ​`--cluster-cidr=<IPv4 CIDR>,<IPv6 CIDR>`​

*   kubelet:

*   当没有 ​`--cloud-provider`​ 时，管理员可以通过 ​`--node-ip`​ 来传递逗号分隔的 IP 地址， 为该节点手动配置双栈 ​`.status.addresses`​。 如果 Pod 以 HostNetwork 模式在该节点上运行，则 Pod 会用 ​`.status.podIPs`​ 字段来报告它的 IP 地址。 一个节点中的所有 ​`podIP` ​都会匹配该节点的由 ​`.status.addresses`​ 字段定义的 IP 组。

> IPv4 CIDR 的一个例子：​`10.244.0.0/16`​（尽管你会提供你自己的地址范围）。  
> IPv6 CIDR 的一个例子：​`fdXY:IJKL:MNOP:15::/64`​ （这里演示的是格式而非有效地址 - 请看 [RFC 4193](https://datatracker.ietf.org/doc/html/rfc4193)）。

服务
--

你可以使用 IPv4 或 IPv6 地址来创建 Service。 服务的地址族默认为第一个服务集群 IP 范围的地址族（通过 kube-apiserver 的 ​`--service-cluster-ip-range`​ 参数配置）。 当你定义服务时，可以选择将其配置为双栈。若要指定所需的行为，你可以设置 ​`.spec.ipFamilyPolicy`​ 字段为以下值之一：

*   ​`SingleStack`​：单栈服务。控制面使用第一个配置的服务集群 IP 范围为服务分配集群 IP。
*   ​`PreferDualStack`​：

*   为服务分配 IPv4 和 IPv6 集群 IP 地址。

*   ​`RequireDualStack`​：从 IPv4 和 IPv6 的地址范围分配服务的 ​`.spec.ClusterIPs` ​

*   从基于在 ​`.spec.ipFamilies`​ 数组中第一个元素的地址族的 ​`.spec.ClusterIPs`​ 列表中选择 ​`.spec.ClusterIP` ​

如果你想要定义哪个 IP 族用于单栈或定义双栈 IP 族的顺序，可以通过设置 服务上的可选字段 .spec.ipFamilies 来选择地址族。

> ​`.spec.ipFamilies`​ 字段是不可变的，因为系统无法为已经存在的服务重新分配 ​`.spec.ClusterIP`​。如果你想改变 ​`.spec.ipFamilies`​，则需要删除并重新创建服务。

你可以设置 ​`.spec.ipFamily`​ 为以下任何数组值：

*   ​`["IPv4"]` ​
*   ​`["IPv6"]` ​
*   ​`["IPv4","IPv6"]` ​（双栈）
*   ​`["IPv6","IPv4"]` ​（双栈）

你所列出的第一个地址族用于原来的 ​`.spec.ClusterIP`​ 字段。

### 双栈服务配置场景

以下示例演示多种双栈服务配置场景下的行为。

#### 新服务的双栈选项

1.  此服务规约中没有显式设定 ​`.spec.ipFamilyPolicy`​。当你创建此服务时，Kubernetes 从所配置的第一个 ​`service-cluster-ip-range`​ 种为服务分配一个集群IP，并设置 ​`.spec.ipFamilyPolicy`​ 为 ​`SingleStack`​。 （无选择算符的服务 和无头服务的行为方式 与此相同。）

`apiVersion: v1 kind: Service metadata:   name: my-service   labels:     app: MyApp spec:   selector:     app: MyApp   ports:     - protocol: TCP       port: 80`

        

3.  此服务规约显式地将 ​`.spec.ipFamilyPolicy`​ 设置为 ​`PreferDualStack`​。 当你在双栈集群上创建此服务时，Kubernetes 会为该服务分配 IPv4 和 IPv6 地址。 控制平面更新服务的 ​`.spec`​ 以记录 IP 地址分配。 字段 ​`.spec.ClusterIPs`​ 是主要字段，包含两个分配的 IP 地址；​`.spec.ClusterIP`​ 是次要字段， 其取值从 ​`.spec.ClusterIPs`​ 计算而来。

*   对于 .spec.ClusterIP 字段，控制面记录来自第一个服务集群 IP 范围 对应的地址族的 IP 地址。
*   对于单协议栈的集群，.spec.ClusterIPs 和 .spec.ClusterIP 字段都 仅仅列出一个地址。
*   对于启用了双协议栈的集群，将 .spec.ipFamilyPolicy 设置为 RequireDualStack 时，其行为与 PreferDualStack 相同。

`apiVersion: v1 kind: Service metadata:   name: my-service   labels:     app: MyApp spec:   ipFamilyPolicy: PreferDualStack   selector:     app: MyApp   ports:     - protocol: TCP       port: 80`

6.  下面的服务规约显式地在 ​`.spec.ipFamilies`​ 中指定 ​`IPv6` ​和 ​`IPv4`​，并 将 ​`.spec.ipFamilyPolicy`​ 设定为 ​`PreferDualStack`​。 当 Kubernetes 为 ​`.spec.ClusterIPs`​ 分配一个 IPv6 和一个 IPv4 地址时， ​`.spec.ClusterIP`​ 被设置成 IPv6 地址，因为它是 ​`.spec.ClusterIPs`​ 数组中的第一个元素， 覆盖其默认值。

`apiVersion: v1 kind: Service metadata:   name: my-service   labels:     app: MyApp spec:   ipFamilyPolicy: PreferDualStack   ipFamilies:   - IPv6   - IPv4   selector:     app: MyApp   ports:     - protocol: TCP       port: 80`

                

#### 现有服务的双栈默认值

下面示例演示了在服务已经存在的集群上新启用双栈时的默认行为。 （将现有集群升级到 1.21 或者更高版本会启用双协议栈支持。）

1.  在集群上启用双栈时，控制面会将现有服务（无论是 ​`IPv4` ​还是 ​`IPv6`​）配置 ​`.spec.ipFamilyPolicy`​ 为 ​`SingleStack` ​并设置​ `.spec.ipFamilies`​ 为服务的当前地址族。

`apiVersion: v1 kind: Service metadata:   name: my-service   labels:     app: MyApp spec:   selector:     app: MyApp   ports:     - protocol: TCP       port: 80`

你可以通过使用 kubectl 检查现有服务来验证此行为。

`kubectl get svc my-service -o yaml`

`apiVersion: v1 kind: Service metadata:   labels:     app: MyApp   name: my-service spec:   clusterIP: 10.0.197.123   clusterIPs:   - 10.0.197.123   ipFamilies:   - IPv4   ipFamilyPolicy: SingleStack   ports:   - port: 80     protocol: TCP     targetPort: 80   selector:     app: MyApp   type: ClusterIP status:   loadBalancer: {}`

6.  在集群上启用双栈时，带有选择算符的现有 无头服务 由控制面设置 ​`.spec.ipFamilyPolicy`​ 为 ​`SingleStack` ​并设置 ​`.spec.ipFamilies`​ 为第一个服务集群 IP 范围的地址族（通过配置 kube-apiserver 的 ​`--service-cluster-ip-range`​ 参数），即使 ​`.spec.ClusterIP`​ 的设置值为 ​`None` ​也如此。

`apiVersion: v1 kind: Service metadata:   name: my-service   labels:     app: MyApp spec:   selector:     app: MyApp   ports:     - protocol: TCP       port: 80`

        

你可以通过使用 kubectl 检查带有选择算符的现有无头服务来验证此行为。

`kubectl get svc my-service -o yaml`

`apiVersion: v1 kind: Service metadata:   labels:     app: MyApp   name: my-service spec:   clusterIP: None   clusterIPs:   - None   ipFamilies:   - IPv4   ipFamilyPolicy: SingleStack   ports:   - port: 80     protocol: TCP     targetPort: 80   selector:     app: MyApp`  

#### 在单栈和双栈之间切换服务

服务可以从单栈更改为双栈，也可以从双栈更改为单栈。

1.  要将服务从单栈更改为双栈，根据需要将 ​`.spec.ipFamilyPolicy`​ 从 ​`SingleStack` ​改为 ​`PreferDualStack` ​或 ​`RequireDualStack`​。 当你将此服务从单栈更改为双栈时，Kubernetes 将分配缺失的地址族，以便现在 该服务具有 IPv4 和 IPv6 地址。 编辑服务规约将 ​`.spec.ipFamilyPolicy`​ 从 ​`SingleStack` ​改为 ​`PreferDualStack`​。

之前：

`spec:   ipFamilyPolicy: SingleStack`

之后：

`spec:   ipFamilyPolicy: PreferDualStack`

6.  要将服务从双栈更改为单栈，请将 ​`.spec.ipFamilyPolicy`​ 从 ​`PreferDualStack` ​或 ​`RequireDualStack` ​改为 ​`SingleStack`​。 当你将此服务从双栈更改为单栈时，Kubernetes 只保留 ​`.spec.ClusterIPs`​ 数组中的第一个元素，并设置 ​`.spec.ClusterIP`​ 为那个 IP 地址， 并设置 ​`.spec.ipFamilies`​ 为 ​`.spec.ClusterIPs`​ 地址族。

### 无选择算符的无头服务

对于不带选择算符的无头服务， 若没有显式设置 ​`.spec.ipFamilyPolicy`​，则 ​`.spec.ipFamilyPolicy`​ 字段默认设置为 ​`RequireDualStack`​。

### LoadBalancer 类型服务

要为你的服务提供双栈负载均衡器：

*   将 ​`.spec.type`​ 字段设置为 ​`LoadBalancer` ​
*   将 ​`.spec.ipFamilyPolicy`​ 字段设置为 ​`PreferDualStack` ​或者 ​`RequireDualStack`​

> 为了使用双栈的负载均衡器类型服务，你的云驱动必须支持 IPv4 和 IPv6 的负载均衡器。

出站流量
----

如果你要启用出站流量，以便使用非公开路由 IPv6 地址的 Pod 到达集群外地址 （例如公网），则需要通过透明代理或 IP 伪装等机制使 Pod 使用公共路由的 IPv6 地址。 [ip-masq-agent](https://github.com/kubernetes-sigs/ip-masq-agent)项目 支持在双栈集群上进行 IP 伪装。

> 确认你的 CNI 驱动支持 IPv6。

#  10.  Kubernetes 存储

##  1.  Kubernetes 卷
卷
-

Container 中的文件在磁盘上是临时存放的，这给 Container 中运行的较重要的应用程序带来一些问题。 问题之一是当容器崩溃时文件丢失。 kubelet 会重新启动容器，但容器会以干净的状态重启。 第二个问题会在同一 ​`Pod` ​中运行多个容器并共享文件时出现。 Kubernetes 卷（Volume） 这一抽象概念能够解决这两个问题。

背景 
---

Docker 也有 [卷（Volume）](https://docs.docker.com/storage/) 的概念，但对它只有少量且松散的管理。 Docker 卷是磁盘上或者另外一个容器内的一个目录。 Docker 提供卷驱动程序，但是其功能非常有限。

Kubernetes 支持很多类型的卷。 Pod 可以同时使用任意数目的卷类型。 临时卷类型的生命周期与 Pod 相同，但持久卷可以比 Pod 的存活期长。 当 Pod 不再存在时，Kubernetes 也会销毁临时卷；不过 Kubernetes 不会销毁持久卷。 对于给定 Pod 中任何类型的卷，在容器重启期间数据都不会丢失。

卷的核心是一个目录，其中可能存有数据，Pod 中的容器可以访问该目录中的数据。 所采用的特定的卷类型将决定该目录如何形成的、使用何种介质保存数据以及目录中存放的内容。

使用卷时, 在 ​`.spec.volumes`​ 字段中设置为 Pod 提供的卷，并在 ​`.spec.containers[*].volumeMounts`​ 字段中声明卷在容器中的挂载位置。 容器中的进程看到的文件系统视图是由它们的 容器镜像 的初始内容以及挂载在容器中的卷（如果定义了的话）所组成的。 其中根文件系统同容器镜像的内容相吻合。 任何在该文件系统下的写入操作，如果被允许的话，都会影响接下来容器中进程访问文件系统时所看到的内容。

卷挂载在镜像中的指定路径下。 Pod 配置中的每个容器必须独立指定各个卷的挂载位置。

卷不能挂载到其他卷之上（不过存在一种使用 subPath 的相关机制），也不能与其他卷有硬链接。

卷类型 
----

Kubernetes 支持下列类型的卷：

### awsElasticBlockStore

​`awsElasticBlockStore` ​卷将 Amazon Web服务（AWS）[EBS 卷](https://aws.amazon.com/cn/ebs/) 挂载到你的 Pod 中。与 ​`emptyDir` ​在 Pod 被删除时也被删除不同，EBS 卷的内容在删除 Pod 时会被保留，卷只是被卸载掉了。 这意味着 EBS 卷可以预先填充数据，并且该数据可以在 Pod 之间共享。

你在使用 EBS 卷之前必须使用 ​`aws ec2 create-volume`​ 命令或者 AWS API 创建该卷。

使用 ​`awsElasticBlockStore` ​卷时有一些限制：

*   Pod 运行所在的节点必须是 AWS EC2 实例。
*   这些实例需要与 EBS 卷在相同的地域（Region）和可用区（Availability-Zone）。
*   EBS 卷只支持被挂载到单个 EC2 实例上。

#### 创建 EBS 卷

在将 EBS 卷用到 Pod 上之前，你首先要创建它。

`aws ec2 create-volume --availability-zone=eu-west-1a --size=10 --volume-type=gp2`

确保该区域与你的群集所在的区域相匹配。还要检查卷的大小和 EBS 卷类型都适合你的用途。

#### AWS EBS 配置示例

`apiVersion: v1 kind: Pod metadata:   name: test-ebs spec:   containers:   - image: k8s.gcr.io/test-webserver     name: test-container     volumeMounts:     - mountPath: /test-ebs       name: test-volume   volumes:   - name: test-volume     # 此 AWS EBS 卷必须已经存在     awsElasticBlockStore:       volumeID: "<volume-id>"       fsType: ext4`

如果 EBS 卷是分区的，你可以提供可选的字段 ​`partition: "<partition number>"`​ 来指定要挂载到哪个分区上。

#### AWS EBS CSI 卷迁移

FEATURE STATE: Kubernetes v1.17 \[beta\]

如果启用了对 ​`awsElasticBlockStore` ​的 ​`CSIMigration` ​特性支持，所有插件操作都不再指向树内插件（In-Tree Plugin），转而指向 ​`ebs.csi.aws.com`​ 容器存储接口（Container Storage Interface，CSI）驱动。 为了使用此特性，必须在集群中安装  [AWS EBS CSI 驱动](https://github.com/kubernetes-sigs/aws-ebs-csi-driver)， 并确保 ​`CSIMigration` ​和 ​`CSIMigrationAWS` ​Beta 功能特性被启用。

#### AWS EBS CSI 迁移结束

FEATURE STATE: Kubernetes v1.17 \[alpha\]

要禁止控制器管理器和 kubelet 加载 ​`awsElasticBlockStore` ​存储插件， 请将 ​`InTreePluginAWSUnregister` ​标志设置为 ​`true`​。

### azureDisk

​`azureDisk` ​卷类型用来在 Pod 上挂载 Microsoft Azure 数据盘（Data Disk） 。 若需了解更多详情，请参考 [azureDisk 卷插件](https://github.com/kubernetes/examples/blob/master/staging/volumes/azure_disk/README.md)。

#### azureDisk 的 CSI 迁移 

FEATURE STATE: Kubernetes v1.19 \[beta\]

启用 ​​`azureDisk` ​​的 ​​`CSIMigration` ​​功能后，所有插件操作从现有的树内插件重定向到 ​`disk.csi.azure.com`​ 容器存储接口（CSI）驱动程序。 为了使用此功能，必须在集群中安装 [​Azure 磁盘 CSI 驱动​程序](https://github.com/kubernetes-sigs/azuredisk-csi-driver)， 并且 ​`CSIMigration` ​和 ​`CSIMigrationAzureDisk` ​功能必须被启用。

#### azureDisk CSI 迁移完成

FEATURE STATE: Kubernetes v1.21 \[alpha\]

要禁止控制器管理器和 kubelet 加载 ​`azureDisk` ​存储插件， 请将 ​`InTreePluginAzureDiskUnregister` ​标志设置为 ​`true`​。

### azureFile

​`azureFile` ​卷类型用来在 Pod 上挂载 Microsoft Azure 文件卷（File Volume）（SMB 2.1 和 3.0）。 更多详情请参考 [azureFile 卷插件](https://github.com/kubernetes/examples/blob/master/staging/volumes/azure_file/README.md)。

#### azureFile CSI 迁移 

FEATURE STATE: Kubernetes v1.21 \[beta\]

启用 ​`azureFile` ​的 ​`CSIMigration` ​功能后，所有插件操作将从现有的树内插件重定向到 ​`file.csi.azure.com`​ 容器存储接口（CSI）驱动程序。要使用此功能，必须在集群中安装 Azure 文件 CSI 驱动程序， 并且 ​`CSIMigration` ​和 ​`CSIMigrationAzureFile` ​特性门控 必须被启用。

Azure 文件 CSI 驱动尚不支持为同一卷设置不同的 fsgroup。 如果 AzureFile CSI 迁移被启用，用不同的 fsgroup 来使用同一卷也是不被支持的。

#### azureDisk CSI 迁移完成

FEATURE STATE: Kubernetes v1.21 \[alpha\]

要禁止控制器管理器和 kubelet 加载 ​`azureDisk` ​存储插件， 请将 ​`InTreePluginAzureDiskUnregister` ​标志设置为 ​`true`​。

### cephfs

​`cephfs` ​卷允许你将现存的 CephFS 卷挂载到 Pod 中。 不像 ​`emptyDir` ​那样会在 Pod 被删除的同时也会被删除，​`cephfs` ​卷的内容在 Pod 被删除时会被保留，只是卷被卸载了。 这意味着 ​`cephfs` ​卷可以被预先填充数据，且这些数据可以在 Pod 之间共享。同一 ​`cephfs` ​卷可同时被多个写者挂载。

> 在使用 Ceph 卷之前，你的 Ceph 服务器必须已经运行并将要使用的 share 导出（exported）。

更多信息请参考 [CephFS 示例](https://github.com/kubernetes/examples/tree/master/volumes/cephfs/)。

### cinder

> Kubernetes 必须配置了 OpenStack Cloud Provider。

​`cinder` ​卷类型用于将 OpenStack Cinder 卷挂载到 Pod 中。

#### Cinder 卷示例配置

`apiVersion: v1 kind: Pod metadata:   name: test-cinder spec:   containers:   - image: k8s.gcr.io/test-webserver     name: test-cinder-container     volumeMounts:     - mountPath: /test-cinder       name: test-volume   volumes:   - name: test-volume     # 此 OpenStack 卷必须已经存在     cinder:       volumeID: "<volume-id>"       fsType: ext4`

#### OpenStack CSI 迁移

FEATURE STATE: Kubernetes v1.21 \[beta\]

Cinder 的 ​`CSIMigration` ​功能在 Kubernetes 1.21 版本中是默认被启用的。 此特性会将插件的所有操作从现有的树内插件重定向到 ​`cinder.csi.openstack.org`​ 容器存储接口（CSI）驱动程序。 为了使用此功能，必须在集群中安装 [OpenStack Cinder CSI 驱动程序](https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/cinder-csi-plugin/using-cinder-csi-plugin.md)， 你可以通过设置 ​`CSIMigrationOpenStack` ​特性门控 为 ​`false` ​来禁止 Cinder CSI 迁移。 如果你禁用了 ​`CSIMigrationOpenStack` ​功能特性，则树内的 Cinder 卷插件 会负责 Cinder 卷存储管理的方方面面。

### configMap

​`configMap` ​卷提供了向 Pod 注入配置数据的方法。 ConfigMap 对象中存储的数据可以被 ​`configMap` ​类型的卷引用，然后被 Pod 中运行的容器化应用使用。

引用 configMap 对象时，你可以在 volume 中通过它的名称来引用。 你可以自定义 ConfigMap 中特定条目所要使用的路径。 下面的配置显示了如何将名为 ​`log-config`​ 的 ConfigMap 挂载到名为 ​`configmap-pod`​ 的 Pod 中：

`apiVersion: v1 kind: Pod metadata:   name: configmap-pod spec:   containers:     - name: test       image: busybox:1.28       volumeMounts:         - name: config-vol           mountPath: /etc/config   volumes:     - name: config-vol       configMap:         name: log-config         items:           - key: log_level             path: log_level`

    

​`log-config`​ ConfigMap 以卷的形式挂载，并且存储在 ​`log_level` ​条目中的所有内容都被挂载到 Pod 的 ​`/etc/config/log_level`​ 路径下。 请注意，这个路径来源于卷的 ​`mountPath` ​和 ​`log_level` ​键对应的 ​`path`​。

> *   在使用 ConfigMap 之前你首先要创建它。
> *   容器以 subPath 卷挂载方式使用 ConfigMap 时，将无法接收 ConfigMap 的更新。
> *   文本数据挂载成文件时采用 UTF-8 字符编码。如果使用其他字符编码形式，可使用 ​`binaryData` ​字段。

### downwardAPI

​`downwardAPI` ​卷用于使 downward API 数据对应用程序可用。 这种卷类型挂载一个目录并在纯文本文件中写入所请求的数据。

> 容器以 subPath 卷挂载方式使用 downwardAPI 时，将不能接收到它的更新。

### emptyDir

当 Pod 分派到某个 Node 上时，​`emptyDir` ​卷会被创建，并且在 Pod 在该节点上运行期间，卷一直存在。 就像其名称表示的那样，卷最初是空的。 尽管 Pod 中的容器挂载 ​`emptyDir` ​卷的路径可能相同也可能不同，这些容器都可以读写 ​`emptyDir` ​卷中相同的文件。 当 Pod 因为某些原因被从节点上删除时，​`emptyDir` ​卷中的数据也会被永久删除。

> 容器崩溃并不会导致 Pod 被从节点上移除，因此容器崩溃期间 ​`emptyDir` ​卷中的数据是安全的。

​`emptyDir` ​的一些用途：

*   缓存空间，例如基于磁盘的归并排序。
*   为耗时较长的计算任务提供检查点，以便任务能方便地从崩溃前状态恢复执行。
*   在 Web 服务器容器服务数据时，保存内容管理器容器获取的文件。

取决于你的环境，​`emptyDir` ​卷存储在该节点所使用的介质上；这里的介质可以是磁盘或 SSD 或网络存储。但是，你可以将 ​`emptyDir.medium`​ 字段设置为 ​`"Memory"`​，以告诉 Kubernetes 为你挂载 tmpfs（基于 RAM 的文件系统）。 虽然 tmpfs 速度非常快，但是要注意它与磁盘不同。 tmpfs 在节点重启时会被清除，并且你所写入的所有文件都会计入容器的内存消耗，受容器内存限制约束。

> 当启用 ​`SizeMemoryBackedVolumes` ​特性门控 时，你可以为基于内存提供的卷指定大小。 如果未指定大小，则基于内存的卷的大小为 Linux 主机上内存的 50％。

#### emptyDir 配置示例 

`apiVersion: v1 kind: Pod metadata:   name: test-pd spec:   containers:   - image: k8s.gcr.io/test-webserver     name: test-container     volumeMounts:     - mountPath: /cache       name: cache-volume   volumes:   - name: cache-volume     emptyDir: {}`

### fc (光纤通道)

​`fc` ​卷类型允许将现有的光纤通道块存储卷挂载到 Pod 中。 可以使用卷配置中的参数 ​`targetWWNs` ​来指定单个或多个目标 WWN（World Wide Names）。 如果指定了多个 WWN，targetWWNs 期望这些 WWN 来自多路径连接。

> 你必须配置 FC SAN Zoning，以便预先向目标 WWN 分配和屏蔽这些 LUN（卷），这样 Kubernetes 主机才可以访问它们。

更多详情请参考 [FC 示例](https://github.com/kubernetes/examples/tree/master/staging/volumes/fibre_channel)。

### flocker （已弃用）

[Flocker](https://github.com/ClusterHQ/flocker) 是一个开源的、集群化的容器数据卷管理器。 Flocker 提供了由各种存储后端所支持的数据卷的管理和编排。

使用 ​`flocker` ​卷可以将一个 Flocker 数据集挂载到 Pod 中。 如果数据集在 Flocker 中不存在，则需要首先使用 Flocker CLI 或 Flocker API 创建数据集。 如果数据集已经存在，那么 Flocker 将把它重新附加到 Pod 被调度的节点。 这意味着数据可以根据需要在 Pod 之间共享。

> 在使用 Flocker 之前你必须先安装运行自己的 Flocker。

更多详情请参考 [Flocker 示例](https://github.com/kubernetes/examples/tree/master/staging/volumes/flocker)。

### gcePersistentDisk

​`gcePersistentDisk` ​卷能将谷歌计算引擎 (GCE) [持久盘（PD）](https://cloud.google.com/compute/docs/disks) 挂载到你的 Pod 中。 不像 ​`emptyDir` ​那样会在 Pod 被删除的同时也会被删除，持久盘卷的内容在删除 Pod 时会被保留，卷只是被卸载了。 这意味着持久盘卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。

> 在使用 PD 前，你必须使用 ​`gcloud` ​或者 GCE API 或 UI 创建它。

使用 ​`gcePersistentDisk` ​时有一些限制：

*   运行 Pod 的节点必须是 GCE VM
*   这些 VM 必须和持久盘位于相同的 GCE 项目和区域（zone）

GCE PD 的一个特点是它们可以同时被多个消费者以只读方式挂载。 这意味着你可以用数据集预先填充 PD，然后根据需要并行地在尽可能多的 Pod 中提供该数据集。 不幸的是，PD 只能由单个使用者以读写模式挂载 —— 即不允许同时写入。

在由 ReplicationController 所管理的 Pod 上使用 GCE PD 将会失败，除非 PD 是只读模式或者副本的数量是 0 或 1。

#### 创建 GCE 持久盘（PD） 

在 Pod 中使用 GCE 持久盘之前，你首先要创建它。

`gcloud compute disks create --size=500GB --zone=us-central1-a my-data-disk`

#### GCE 持久盘配置示例

`apiVersion: v1 kind: Pod metadata:   name: test-pd spec:   containers:   - image: k8s.gcr.io/test-webserver     name: test-container     volumeMounts:     - mountPath: /test-pd       name: test-volume   volumes:   - name: test-volume     # 此 GCE PD 必须已经存在     gcePersistentDisk:       pdName: my-data-disk       fsType: ext4`

#### 区域持久盘 

[区域持久盘](https://cloud.google.com/compute/docs/disks/ target=) 功能允许你创建能在同一区域的两个可用区中使用的持久盘。 要使用这个功能，必须以持久卷（PersistentVolume）的方式提供卷；直接从 Pod 引用这种卷是不可以的。

#### 手动供应基于区域 PD 的 PersistentVolume

使用为 GCE PD 定义的存储类 可以实现动态供应。在创建 PersistentVolume 之前，你首先要创建 PD。

`gcloud beta compute disks create --size=500GB my-data-disk     --region us-central1     --replica-zones us-central1-a,us-central1-b`

PersistentVolume 示例：

`apiVersion: v1 kind: PersistentVolume metadata:   name: test-volume   labels:     failure-domain.beta.kubernetes.io/zone: us-central1-a__us-central1-b spec:   capacity:     storage: 400Gi   accessModes:   - ReadWriteOnce   gcePersistentDisk:     pdName: my-data-disk     fsType: ext4   nodeAffinity:     required:       nodeSelectorTerms:       - matchExpressions:         # failure-domain.beta.kubernetes.io/zone 应在 1.21 之前使用         - key: topology.kubernetes.io/zone           operator: In           values:           - us-central1-a           - us-central1-b`

#### GCE CSI 迁移 

FEATURE STATE: Kubernetes v1.17 \[beta\]

启用 GCE PD 的 ​`CSIMigration` ​功能后，所有插件操作将从现有的树内插件重定向到 ​`pd.csi.storage.gke.io`​ 容器存储接口（ CSI ）驱动程序。 为了使用此功能，必须在集群中上安装 GCE PD CSI驱动程序， 并且 ​`CSIMigration` ​和 ​`CSIMigrationGCE` ​Beta 功能必须被启用。

#### GCE CSI 迁移完成

FEATURE STATE: Kubernetes v1.21 \[alpha\]

要禁止控制器管理器和 kubelet 加载 ​`gcePersistentDisk` ​存储插件，请将 ​`InTreePluginGCEUnregister` ​标志设置为 ​`true`​。

### gitRepo (已弃用) 

> ​`gitRepo` ​卷类型已经被废弃。如果需要在容器中提供 git 仓库，请将一个 EmptyDir 卷挂载到 InitContainer 中，使用 git 命令完成仓库的克隆操作，然后将 EmptyDir 卷挂载到 Pod 的容器中。

​`gitRepo` ​卷是一个卷插件的例子。 该查卷挂载一个空目录，并将一个 Git 代码仓库克隆到这个目录中供 Pod 使用。

下面给出一个 ​`gitRepo` ​卷的示例：

`apiVersion: v1 kind: Pod metadata:   name: server spec:   containers:   - image: nginx     name: nginx     volumeMounts:     - mountPath: /mypath       name: git-volume   volumes:   - name: git-volume     gitRepo:       repository: "git@somewhere:me/my-git-repository.git"       revision: "22f1d8406d464b0c0874075539c1f2e96c253775"`

### glusterfs

​`glusterfs` ​卷能将 [Glusterfs](https://www.gluster.org/) (一个开源的网络文件系统) 挂载到你的 Pod 中。不像 ​`emptyDir` ​那样会在删除 Pod 的同时也会被删除，​`glusterfs` ​卷的内容在删除 Pod 时会被保存，卷只是被卸载。 这意味着 ​`glusterfs` ​卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。 GlusterFS 可以被多个写者同时挂载。

> 在使用前你必须先安装运行自己的 GlusterFS。

更多详情请参考 [GlusterFS 示例](https://github.com/kubernetes/examples/tree/master/volumes/glusterfs)。

### hostPath

> HostPath 卷存在许多安全风险，最佳做法是尽可能避免使用 HostPath。 当必须使用 HostPath 卷时，它的范围应仅限于所需的文件或目录，并以只读方式挂载。  
> 如果通过 AdmissionPolicy 限制 HostPath 对特定目录的访问，则必须要求 ​`volumeMounts` ​使用 ​`readOnly` ​挂载以使策略生效。

​`hostPath` ​卷能将主机节点文件系统上的文件或目录挂载到你的 Pod 中。 虽然这不是大多数 Pod 需要的，但是它为一些应用程序提供了强大的逃生舱。

例如，​`hostPath` ​的一些用法有：

*   运行一个需要访问 Docker 内部机制的容器；可使用 ​`hostPath` ​挂载 ​`/var/lib/docker`​ 路径。
*   在容器中运行 cAdvisor 时，以 ​`hostPath` ​方式挂载 ​`/sys`​。
*   允许 Pod 指定给定的 ​`hostPath` ​在运行 Pod 之前是否应该存在，是否应该创建以及应该以什么方式存在。

除了必需的 ​`path` ​属性之外，用户可以选择性地为 ​`hostPath` ​卷指定 ​`type`​。

支持的 ​`type` ​值如下：

取值

行为

空字符串（默认）用于向后兼容，这意味着在安装 hostPath 卷之前不会执行任何检查。

`DirectoryOrCreate`

如果在给定路径上什么都不存在，那么将根据需要创建空目录，权限设置为 0755，具有与 kubelet 相同的组和属主信息。

`Directory`

在给定路径上必须存在的目录。

`FileOrCreate`

如果在给定路径上什么都不存在，那么将在那里根据需要创建空文件，权限设置为 0644，具有与 kubelet 相同的组和所有权。

`File`

在给定路径上必须存在的文件。

`Socket`

在给定路径上必须存在的 UNIX 套接字。

`CharDevice`

在给定路径上必须存在的字符设备。

`BlockDevice`

在给定路径上必须存在的块设备。

当使用这种类型的卷时要小心，因为：

*   HostPath 卷可能会暴露特权系统凭据（例如 Kubelet）或特权 API（例如容器运行时套接字），可用于容器逃逸或攻击集群的其他部分。
*   具有相同配置（例如基于同一 PodTemplate 创建）的多个 Pod 会由于节点上文件的不同而在不同节点上有不同的行为。
*   下层主机上创建的文件或目录只能由 root 用户写入。你需要在 特权容器 中以 root 身份运行进程，或者修改主机上的文件权限以便容器能够写入 ​`hostPath` ​卷。

#### hostPath 配置示例： 

`apiVersion: v1 kind: Pod metadata:   name: test-pd spec:   containers:   - image: k8s.gcr.io/test-webserver     name: test-container     volumeMounts:     - mountPath: /test-pd       name: test-volume   volumes:   - name: test-volume     hostPath:       # 宿主上目录位置       path: /data       # 此字段为可选       type: Directory`

> ​`FileOrCreate` ​模式不会负责创建文件的父目录。 如果欲挂载的文件的父目录不存在，Pod 启动会失败。 为了确保这种模式能够工作，可以尝试把文件和它对应的目录分开挂载，如 FileOrCreate 配置 所示。

#### hostPath FileOrCreate 配置示例 

`apiVersion: v1 kind: Pod metadata:   name: test-webserver spec:   containers:   - name: test-webserver     image: k8s.gcr.io/test-webserver:latest     volumeMounts:     - mountPath: /var/local/aaa       name: mydir     - mountPath: /var/local/aaa/1.txt       name: myfile   volumes:   - name: mydir     hostPath:       # 确保文件所在目录成功创建。       path: /var/local/aaa       type: DirectoryOrCreate   - name: myfile     hostPath:       path: /var/local/aaa/1.txt       type: FileOrCreate`

### iscsi

​`iscsi` ​卷能将 iSCSI (基于 IP 的 SCSI) 卷挂载到你的 Pod 中。 不像 ​`emptyDir` ​那样会在删除 Pod 的同时也会被删除，​`iscsi` ​卷的内容在删除 Pod 时会被保留，卷只是被卸载。 这意味着 ​`iscsi` ​卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。

> 在使用 iSCSI 卷之前，你必须拥有自己的 iSCSI 服务器，并在上面创建卷。

iSCSI 的一个特点是它可以同时被多个用户以只读方式挂载。 这意味着你可以用数据集预先填充卷，然后根据需要在尽可能多的 Pod 上使用它。 不幸的是，iSCSI 卷只能由单个使用者以读写模式挂载。不允许同时写入。

更多详情请参考 [iSCSI 示例](https://github.com/kubernetes/examples/tree/master/volumes/iscsi)。

### local

​`local` ​卷所代表的是某个被挂载的本地存储设备，例如磁盘、分区或者目录。

​`local` ​卷只能用作静态创建的持久卷。尚不支持动态配置。

与 ​`hostPath` ​卷相比，​`local` ​卷能够以持久和可移植的方式使用，而无需手动将 Pod 调度到节点。系统通过查看 PersistentVolume 的节点亲和性配置，就能了解卷的节点约束。

然而，​`local` ​卷仍然取决于底层节点的可用性，并不适合所有应用程序。 如果节点变得不健康，那么 ​`local` ​卷也将变得不可被 Pod 访问。使用它的 Pod 将不能运行。 使用 ​`local` ​卷的应用程序必须能够容忍这种可用性的降低，以及因底层磁盘的耐用性特征而带来的潜在的数据丢失风险。

下面是一个使用 ​`local` ​卷和 ​`nodeAffinity` ​的持久卷示例：

`apiVersion: v1 kind: PersistentVolume metadata:   name: example-pv spec:   capacity:     storage: 100Gi   volumeMode: Filesystem   accessModes:   - ReadWriteOnce   persistentVolumeReclaimPolicy: Delete   storageClassName: local-storage   local:     path: /mnt/disks/ssd1   nodeAffinity:     required:       nodeSelectorTerms:       - matchExpressions:         - key: kubernetes.io/hostname           operator: In           values:           - example-node`

使用 ​`local` ​卷时，你需要设置 PersistentVolume 对象的 ​`nodeAffinity` ​字段。 Kubernetes 调度器使用 PersistentVolume 的 ​`nodeAffinity` ​信息来将使用 ​`local` ​卷的 Pod 调度到正确的节点。

PersistentVolume 对象的 ​`volumeMode` ​字段可被设置为 "Block" （而不是默认值 "Filesystem"），以将 ​`local` ​卷作为原始块设备暴露出来。

使用 ​`local` ​卷时，建议创建一个 StorageClass 并将其 ​`volumeBindingMode` ​设置为 ​`WaitForFirstConsumer`​。要了解更多详细信息，请参考 local StorageClass 示例。 延迟卷绑定的操作可以确保 Kubernetes 在为 PersistentVolumeClaim 作出绑定决策时，会评估 Pod 可能具有的其他节点约束，例如：如节点资源需求、节点选择器、Pod亲和性和 Pod 反亲和性。

你可以在 Kubernetes 之外单独运行静态驱动以改进对 local 卷的生命周期管理。 请注意，此驱动尚不支持动态配置。 有关如何运行外部 ​`local` ​卷驱动，请参考 [local 卷驱动用户指南](https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner)。

> 如果不使用外部静态驱动来管理卷的生命周期，用户需要手动清理和删除 local 类型的持久卷。

### nfs

​`nfs` ​卷能将 NFS (网络文件系统) 挂载到你的 Pod 中。 不像 ​`emptyDir` ​那样会在删除 Pod 的同时也会被删除，​`nfs` ​卷的内容在删除 Pod 时会被保存，卷只是被卸载。 这意味着 ​`nfs` ​卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。

> 在使用 NFS 卷之前，你必须运行自己的 NFS 服务器并将目标 share 导出备用。

要了解更多详情请参考 [NFS 示例](https://github.com/kubernetes/examples/tree/master/staging/volumes/nfs)。

### persistentVolumeClaim

​`persistentVolumeClaim` ​卷用来将持久卷（PersistentVolume）挂载到 Pod 中。 持久卷申领（PersistentVolumeClaim）是用户在不知道特定云环境细节的情况下“申领”持久存储（例如 GCE PersistentDisk 或者 iSCSI 卷）的一种方法。

### portworxVolume

​`portworxVolume` ​是一个可伸缩的块存储层，能够以超融合（hyperconverged）的方式与 Kubernetes 一起运行。 [Portworx](https://portworx.com/use-case/kubernetes-storage/) 支持对服务器上存储的指纹处理、基于存储能力进行分层以及跨多个服务器整合存储容量。 Portworx 可以以 in-guest 方式在虚拟机中运行，也可以在裸金属 Linux 节点上运行。

​`portworxVolume` ​类型的卷可以通过 Kubernetes 动态创建，也可以预先配备并在 Kubernetes Pod 内引用。 下面是一个引用预先配备的 PortworxVolume 的示例 Pod：

`apiVersion: v1 kind: Pod metadata:   name: test-portworx-volume-pod spec:   containers:   - image: k8s.gcr.io/test-webserver     name: test-container     volumeMounts:     - mountPath: /mnt       name: pxvol   volumes:   - name: pxvol     # 此 Portworx 卷必须已经存在     portworxVolume:       volumeID: "pxvol"       fsType: "<fs-type>"`

> 在 Pod 中使用 portworxVolume 之前，你要确保有一个名为 ​`pxvol` ​的 PortworxVolume 存在。

更多详情可以参考 [Portworx 卷](https://github.com/kubernetes/examples/blob/master/staging/volumes/portworx/README.md)。

### projected （投射）

投射卷能将若干现有的卷来源映射到同一目录上。

### quobyte (已弃用)

​`quobyte` ​卷允许将现有的 [Quobyte](https://www.quobyte.com/) 卷挂载到你的 Pod 中。

> 在使用 Quobyte 卷之前，你首先要进行安装 Quobyte 并创建好卷。

Quobyte 支持容器存储接口（CSI）。 推荐使用 CSI 插件以在 Kubernetes 中使用 Quobyte 卷。 Quobyte 的 GitHub 项目包含以 CSI 形式部署 Quobyte 的 [说明](https://github.com/quobyte/quobyte-csi target=) 及使用示例。

### rbd

​`rbd` ​卷允许将 [Rados 块设备](https://docs.ceph.com/en/latest/rbd/)卷挂载到你的 Pod 中。 不像 ​`emptyDir` ​那样会在删除 Pod 的同时也会被删除，​`rbd` ​卷的内容在删除 Pod 时会被保存，卷只是被卸载。 这意味着 ​`rbd` ​卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。

> 在使用 RBD 之前，你必须安装运行 Ceph。

RBD 的一个特性是它可以同时被多个用户以只读方式挂载。 这意味着你可以用数据集预先填充卷，然后根据需要在尽可能多的 Pod 中并行地使用卷。 不幸的是，RBD 卷只能由单个使用者以读写模式安装。不允许同时写入。

更多详情请参考 [RBD 示例](https://github.com/kubernetes/examples/tree/master/volumes/rbd)。

#### RBD CSI 迁移

FEATURE STATE: Kubernetes v1.23 \[alpha\]

启用 RBD 的 ​`CSIMigration` ​功能后，所有插件操作从现有的树内插件重定向到 ​`rbd.csi.ceph.com`​ CSI 驱动程序。 要使用该功能，必须在集群内安装 [Ceph CSI 驱动](https://github.com/ceph/ceph-csi)，并启用 ​`CSIMigration` ​和 ​`csiMigrationRBD` ​特性门控。

> 作为一位管理存储的 Kubernetes 集群操作者，在尝试迁移到 RBD CSI 驱动前，你必须完成下列先决事项：  
> 
> *   你必须在集群中安装 v3.5.0 或更高版本的 Ceph CSI 驱动（​`rbd.csi.ceph.com`​）。
> *   因为 ​`clusterID` ​是 CSI 驱动程序必需的参数，而树内存储类又将 ​`monitors` ​作为一个必需的参数，所以 Kubernetes 存储管理者需要根据 ​`monitors` ​的哈希值（例：​`#echo -n '<monitors_string>' | md5sum`​）来创建 ​`clusterID`​，并保持该 ​`monitors` ​存在于该 ​`clusterID` ​的配置中。
> *   同时，如果树内存储类的 ​`adminId` ​的值不是 ​`admin`​，那么其 ​`adminSecretName` ​就需要被修改成 ​`adminId` ​参数的 base64 编码值。

### secret

​`secret` ​卷用来给 Pod 传递敏感信息，例如密码。你可以将 Secret 存储在 Kubernetes API 服务器上，然后以文件的形式挂在到 Pod 中，无需直接与 Kubernetes 耦合。 ​`secret` ​卷由 tmpfs（基于 RAM 的文件系统）提供存储，因此它们永远不会被写入非易失性（持久化的）存储器。

> 使用前你必须在 Kubernetes API 中创建 secret。

> 容器以 subPath 卷挂载方式挂载 Secret 时，将感知不到 Secret 的更新。

### storageOS (已弃用)

​`storageos` ​卷允许将现有的 [StorageOS](https://www.storageos.com/) 卷挂载到你的 Pod 中。

StorageOS 在 Kubernetes 环境中以容器的形式运行，这使得应用能够从 Kubernetes 集群中的任何节点访问本地的或挂接的存储。为应对节点失效状况，可以复制数据。 若需提高利用率和降低成本，可以考虑瘦配置（Thin Provisioning）和数据压缩。

作为其核心能力之一，StorageOS 为容器提供了可以通过文件系统访问的块存储。

StorageOS 容器需要 64 位的 Linux，并且没有其他的依赖关系。 StorageOS 提供免费的开发者授权许可。

> 你必须在每个希望访问 StorageOS 卷的或者将向存储资源池贡献存储容量的节点上运行 StorageOS 容器。有关安装说明，请参阅 [StorageOS 文档](https://docs.ondat.io/)。

``apiVersion: v1 kind: Pod metadata:   labels:     name: redis     role: master   name: test-storageos-redis spec:   containers:     - name: master       image: kubernetes/redis:v1       env:         - name: MASTER           value: "true"       ports:         - containerPort: 6379       volumeMounts:         - mountPath: /redis-master-data           name: redis-data   volumes:     - name: redis-data       storageos:         # `redis-vol01` 卷必须在 StorageOS 中存在，并位于 `default` 名字空间内         volumeName: redis-vol01         fsType: ext4``

关于 StorageOS 的进一步信息、动态供应和持久卷申领等等，请参考 [StorageOS 示例](https://github.com/kubernetes/examples/tree/master/volumes/storageos)。

### vsphereVolume

> 你必须配置 Kubernetes 的 vSphere 云驱动。云驱动的配置方法请参考 [vSphere 使用指南](https://github.com/vmware/)。

​`vsphereVolume` ​用来将 vSphere VMDK 卷挂载到你的 Pod 中。 在卸载卷时，卷的内容会被保留。 vSphereVolume 卷类型支持 VMFS 和 VSAN 数据仓库。

> 在挂载到 Pod 之前，你必须用下列方式之一创建 VMDK。

#### 创建 VMDK 卷 

选择下列方式之一创建 VMDK。

*   使用 vmkfstools 创建

首先 ssh 到 ESX，然后使用下面的命令来创建 VMDK：

`vmkfstools -c 2G /vmfs/volumes/DatastoreName/volumes/myDisk.vmdk`

*   使用 vmware-vdiskmanager 创建

使用下面的命令创建 VMDK：

`vmware-vdiskmanager -c -t 0 -s 40GB -a lsilogic myDisk.vmdk`

#### vSphere VMDK 配置示例 

`apiVersion: v1 kind: Pod metadata:   name: test-vmdk spec:   containers:   - image: k8s.gcr.io/test-webserver     name: test-container     volumeMounts:     - mountPath: /test-vmdk       name: test-volume   volumes:   - name: test-volume     # 此 VMDK 卷必须已经存在     vsphereVolume:       volumePath: "[DatastoreName] volumes/myDisk"       fsType: ext4`

进一步信息可参考 [vSphere 卷](https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere)。

#### vSphere CSI 迁移 

FEATURE STATE: Kubernetes v1.19 \[beta\]

当 ​`vsphereVolume` ​的 ​`CSIMigration` ​特性被启用时，所有插件操作都被从树内插件重定向到 ​`csi.vsphere.vmware.com`​ CSI 驱动。 为了使用此功能特性，必须在集群中安装 [vSphere CSI 驱动](https://github.com/kubernetes-sigs/vsphere-csi-driver)，并启用 ​`CSIMigration` ​和 ​`CSIMigrationvSphere` ​特性门控。

此特性还要求 vSphere vCenter/ESXi 的版本至少为 7.0u1，且 HW 版本至少为 VM version 15。

> vSphere CSI 驱动不支持内置 ​`vsphereVolume` ​的以下 StorageClass 参数：  
> 
> *   ​`diskformat`​
> *   ​`hostfailurestotolerate`​
> *   ​`forceprovisioning`​
> *   ​`cachereservation`​
> *   ​`diskstripes`​
> *   ​`objectspacereservation`​
> *   ​`iopslimit`​
> 
> 使用这些参数创建的现有卷将被迁移到 vSphere CSI 驱动，不过使用 vSphere CSI 驱动所创建的新卷都不会理会这些参数。

#### vSphere CSI 迁移完成 

FEATURE STATE: Kubernetes v1.19 \[beta\]

为了避免控制器管理器和 kubelet 加载 ​`vsphereVolume` ​插件，你需要将 ​`InTreePluginvSphereUnregister` ​特性设置为 ​`true`​。你还必须在所有工作节点上安装 ​`csi.vsphere.vmware.com`​ CSI 驱动。

#### Portworx CSI 迁移

FEATURE STATE: Kubernetes v1.23 \[alpha\]

Kubernetes 1.23 中加入了 Portworx 的 ​`CSIMigration` ​功能，但默认不会启用，因为该功能仍处于 alpha 阶段。 该功能会将所有的插件操作从现有的树内插件重定向到 ​`pxd.portworx.com`​ 容器存储接口（Container Storage Interface, CSI）驱动程序。 集群中必须安装  [Portworx CSI 驱动](https://docs.portworx.com/portworx-install-with-kubernetes/storage-operations/csi/)。 要启用此功能，请在 kube-controller-manager 和 kubelet 中设置 ​`CSIMigrationPortworx=true`​。

使用 subPath 
-----------

有时，在单个 Pod 中共享卷以供多方使用是很有用的。 ​`volumeMounts.subPath`​ 属性可用于指定所引用的卷内的子路径，而不是其根路径。

下面例子展示了如何配置某包含 LAMP 堆栈（Linux Apache MySQL PHP）的 Pod 使用同一共享卷。 此示例中的 ​`subPath` ​配置不建议在生产环境中使用。 PHP 应用的代码和相关数据映射到卷的 ​`html` ​文件夹，MySQL 数据库存储在卷的 ​`mysql` ​文件夹中：

`apiVersion: v1 kind: Pod metadata:   name: my-lamp-site spec:     containers:     - name: mysql       image: mysql       env:       - name: MYSQL_ROOT_PASSWORD         value: "rootpasswd"       volumeMounts:       - mountPath: /var/lib/mysql         name: site-data         subPath: mysql     - name: php       image: php:7.0-apache       volumeMounts:       - mountPath: /var/www/html         name: site-data         subPath: html     volumes:     - name: site-data       persistentVolumeClaim:         claimName: my-lamp-site-data`
        

### 使用带有扩展环境变量的 subPath 

FEATURE STATE: Kubernetes v1.17 \[stable\]

使用 ​`subPathExpr` ​字段可以基于 Downward API 环境变量来构造 ​`subPath` ​目录名。 ​`subPath` ​和 ​`subPathExpr` ​属性是互斥的。

在这个示例中，Pod 使用 ​`subPathExpr` ​来 hostPath 卷 ​`/var/log/pods`​ 中创建目录 ​`pod1`​。 ​`hostPath` ​卷采用来自 ​`downwardAPI` ​的 Pod 名称生成目录名。 宿主目录 ​`/var/log/pods/pod1`​ 被挂载到容器的 ​`/logs`​ 中。

`apiVersion: v1 kind: Pod metadata:   name: pod1 spec:   containers:   - name: container1     env:     - name: POD_NAME       valueFrom:         fieldRef:           apiVersion: v1           fieldPath: metadata.name     image: busybox:1.28     command: [ "sh", "-c", "while [ true ]; do echo 'Hello'; sleep 10; done | tee -a /logs/hello.txt" ]     volumeMounts:     - name: workdir1       mountPath: /logs       # 包裹变量名的是小括号，而不是大括号       subPathExpr: $(POD_NAME)   restartPolicy: Never   volumes:   - name: workdir1     hostPath:       path: /var/log/pods`
            

资源 
---

​`emptyDir` ​卷的存储介质（磁盘、SSD 等）是由保存 kubelet 数据的根目录（通常是 ​`/var/lib/kubelet`​）的文件系统的介质确定。 Kubernetes 对 ​`emptyDir` ​卷或者 ​`hostPath` ​卷可以消耗的空间没有限制，容器之间或 Pod 之间也没有隔离。

树外（Out-of-Tree）卷插件 
-------------------

Out-of-Tree 卷插件包括 容器存储接口（CSI） 和 FlexVolume（已弃用）。 它们使存储供应商能够创建自定义存储插件，而无需将插件源码添加到 Kubernetes 代码仓库。

以前，所有卷插件（如上面列出的卷类型）都是“树内（In-Tree）”的。 “树内”插件是与 Kubernetes 的核心组件一同构建、链接、编译和交付的。 这意味着向 Kubernetes 添加新的存储系统（卷插件）需要将代码合并到 Kubernetes 核心代码库中。

CSI 和 FlexVolume 都允许独立于 Kubernetes 代码库开发卷插件，并作为扩展部署（安装）在 Kubernetes 集群上。

对于希望创建树外（Out-Of-Tree）卷插件的存储供应商，请参考 [卷插件常见问题](https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md)。

### CSI

[容器存储接口](https://github.com/container-storage-interface/spec/blob/master/spec.md) (CSI) 为容器编排系统（如 Kubernetes）定义标准接口，以将任意存储系统暴露给它们的容器工作负载。

更多详情请阅读 [CSI 设计方案](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md)。

> Kubernetes v1.13 废弃了对 CSI 规范版本 0.2 和 0.3 的支持，并将在以后的版本中删除。

> CSI 驱动可能并非兼容所有的 Kubernetes 版本。 请查看特定 CSI 驱动的文档，以了解各个 Kubernetes 版本所支持的部署步骤以及兼容性列表。

一旦在 Kubernetes 集群上部署了 CSI 兼容卷驱动程序，用户就可以使用 ​`csi` ​卷类型来挂接、挂载 CSI 驱动所提供的卷。

​`csi` ​卷可以在 Pod 中以三种方式使用：

*   通过 PersistentVolumeClaim(#persistentvolumeclaim) 对象引用
*   使用一般性的临时卷 （Alpha 特性）
*   使用 CSI 临时卷， 前提是驱动支持这种用法（Beta 特性）

存储管理员可以使用以下字段来配置 CSI 持久卷：

*   ​`driver`​：指定要使用的卷驱动名称的字符串值。 这个值必须与 CSI 驱动程序在 ​`GetPluginInfoResponse` ​中返回的值相对应；该接口定义在 [CSI 规范](https://github.com/container-storage-interface/spec/blob/master/spec.md target=)中。 Kubernetes 使用所给的值来标识要调用的 CSI 驱动程序；CSI 驱动程序也使用该值来辨识哪些 PV 对象属于该 CSI 驱动程序。
*   ​`volumeHandle`​：唯一标识卷的字符串值。 该值必须与 CSI 驱动在 ​`CreateVolumeResponse` ​的 ​`volume_id` ​字段中返回的值相对应；接口定义在 [CSI 规范](https://github.com/container-storage-interface/spec/blob/master/spec.md target=) 中。 在所有对 CSI 卷驱动程序的调用中，引用该 CSI 卷时都使用此值作为 ​`volume_id` ​参数。
*   ​`readOnly`​：一个可选的布尔值，指示通过 ​`ControllerPublished` ​关联该卷时是否设置该卷为只读。默认值是 false。 该值通过 ​`ControllerPublishVolumeRequest` ​中的 ​`readonly` ​字段传递给 CSI 驱动。
*   ​`fsType`​：如果 PV 的 ​`VolumeMode` ​为 ​`Filesystem`​，那么此字段指定挂载卷时应该使用的文件系统。 如果卷尚未格式化，并且支持格式化，此值将用于格式化卷。 此值可以通过 ​`ControllerPublishVolumeRequest`​、​`NodeStageVolumeRequest` ​和 ​`NodePublishVolumeRequest` ​的 ​`VolumeCapability` ​字段传递给 CSI 驱动。
*   ​`volumeAttributes`​：一个字符串到字符串的映射表，用来设置卷的静态属性。 该映射必须与 CSI 驱动程序返回的 ​`CreateVolumeResponse` ​中的 ​`volume.attributes`​ 字段的映射相对应； [CSI 规范](https://github.com/container-storage-interface/spec/blob/master/spec.md target=) 中有相应的定义。 该映射通过​`ControllerPublishVolumeRequest`​、​`NodeStageVolumeRequest`​、和 ​`NodePublishVolumeRequest` ​中的 ​`volume_attributes` ​字段传递给 CSI 驱动。
*   ​`controllerPublishSecretRef`​：对包含敏感信息的 Secret 对象的引用； 该敏感信息会被传递给 CSI 驱动来完成 CSI ​`ControllerPublishVolume` ​和 ​`ControllerUnpublishVolume` ​调用。 此字段是可选的；在不需要 Secret 时可以是空的。 如果 Secret 对象包含多个 Secret 条目，则所有的 Secret 条目都会被传递。
*   ​`nodeStageSecretRef`​：对包含敏感信息的 Secret 对象的引用。 该信息会传递给 CSI 驱动来完成 CSI ​`NodeStageVolume` ​调用。 此字段是可选的，如果不需要 Secret，则可能是空的。 如果 Secret 对象包含多个 Secret 条目，则传递所有 Secret 条目。
*   ​`nodePublishSecretRef`​：对包含敏感信息的 Secret 对象的引用。 该信息传递给 CSI 驱动来完成 CSI ​`NodePublishVolume` ​调用。 此字段是可选的，如果不需要 Secret，则可能是空的。 如果 Secret 对象包含多个 Secret 条目，则传递所有 Secret 条目。

#### CSI 原始块卷支持 

FEATURE STATE: Kubernetes v1.18 \[stable\]

具有外部 CSI 驱动程序的供应商能够在 Kubernetes 工作负载中实现原始块卷支持。

你可以和以前一样，安装自己的 带有原始块卷支持的 PV/PVC， 采用 CSI 对此过程没有影响。

#### CSI 临时卷 

FEATURE STATE: Kubernetes v1.16 \[beta\]

你可以直接在 Pod 规约中配置 CSI 卷。采用这种方式配置的卷都是临时卷， 无法在 Pod 重新启动后继续存在。 进一步的信息可参阅临时卷。

有关如何开发 CSI 驱动的更多信息，请参考 [kubernetes-csi 文档](https://kubernetes-csi.github.io/docs/)。

#### 从树内插件迁移到 CSI 驱动程序 

FEATURE STATE: Kubernetes v1.17 \[beta\]

启用 ​`CSIMigration` ​功能后，针对现有树内插件的操作会被重定向到相应的 CSI 插件（应已安装和配置）。 因此，操作员在过渡到取代树内插件的 CSI 驱动时，无需对现有存储类、PV 或 PVC（指树内插件）进行任何配置更改。

所支持的操作和功能包括：配备（Provisioning）/删除、挂接（Attach）/解挂（Detach）、 挂载（Mount）/卸载（Unmount）和调整卷大小。

上面的卷类型节列出了支持 ​`CSIMigration` ​并已实现相应 CSI 驱动程序的树内插件。

### flexVolume

FEATURE STATE: Kubernetes v1.23 \[deprecated\]

FlexVolume 是一个使用基于 exec 的模型来与驱动程序对接的树外插件接口。 用户必须在每个节点上的预定义卷插件路径中安装 FlexVolume 驱动程序可执行文件，在某些情况下，控制平面节点中也要安装。

Pod 通过 ​`flexvolume` ​树内插件与 FlexVolume 驱动程序交互。 更多详情请参考 FlexVolume [README](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md target=) 文档。

> FlexVolume 已弃用。推荐使用树外 CSI 驱动来将外部存储整合进 Kubernetes。  
> FlexVolume 驱动的维护者应开发一个 CSI 驱动并帮助用户从 FlexVolume 驱动迁移到 CSI。 FlexVolume 用户应迁移工作负载以使用对等的 CSI 驱动。

挂载卷的传播 
-------

挂载卷的传播能力允许将容器安装的卷共享到同一 Pod 中的其他容器，甚至共享到同一节点上的其他 Pod。

卷的挂载传播特性由 ​`Container.volumeMounts`​ 中的 ​`mountPropagation` ​字段控制。 它的值包括：

*   ​`None` ​- 此卷挂载将不会感知到主机后续在此卷或其任何子目录上执行的挂载变化。 类似的，容器所创建的卷挂载在主机上是不可见的。这是默认模式。
该模式等同于 [Linux 内核文档](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt) 中描述的 ​`private` ​挂载传播选项。*   ​`HostToContainer` ​- 此卷挂载将会感知到主机后续针对此卷或其任何子目录的挂载操作。
换句话说，如果主机在此挂载卷中挂载任何内容，容器将能看到它被挂载在那里。 类似的，配置了 ​`Bidirectional` ​挂载传播选项的 Pod 如果在同一卷上挂载了内容，挂载传播设置为 ​`HostToContainer` ​的容器都将能看到这一变化。 该模式等同于 [Linux 内核文档](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt) 中描述的 rslave 挂载传播选项。*   ​`Bidirectional` ​- 这种卷挂载和 ​`HostToContainer` ​挂载表现相同。 另外，容器创建的卷挂载将被传播回至主机和使用同一卷的所有 Pod 的所有容器。
该模式等同于 [Linux 内核文档](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt) 中描述的 ​`rshared` ​挂载传播选项。

> ​`Bidirectional` ​形式的挂载传播可能比较危险。 它可以破坏主机操作系统，因此它只被允许在特权容器中使用。 强烈建议你熟悉 Linux 内核行为。 此外，由 Pod 中的容器创建的任何卷挂载必须在终止时由容器销毁（卸载）。

### 配置 

在某些部署环境中，挂载传播正常工作前，必须在 Docker 中正确配置挂载共享（mount share），如下所示。

编辑你的 Docker ​`systemd` ​服务文件，按下面的方法设置 ​`MountFlags`​：

`MountFlags=shared`

或者，如果存在 ​`MountFlags=slave`​ 就删除掉。然后重启 Docker 守护进程：

`sudo systemctl daemon-reload sudo systemctl restart docker`

##  2.  Kubernetes 持久卷
介绍 
---

存储的管理是一个与计算实例的管理完全不同的问题。PersistentVolume 子系统为用户 和管理员提供了一组 API，将存储如何供应的细节从其如何被使用中抽象出来。 为了实现这点，我们引入了两个新的 API 资源：PersistentVolume 和 PersistentVolumeClaim。

持久卷（PersistentVolume，PV）是集群中的一块存储，可以由管理员事先供应，或者 使用存储类（Storage Class）来动态供应。 持久卷是集群资源，就像节点也是集群资源一样。PV 持久卷和普通的 Volume 一样，也是使用 卷插件来实现的，只是它们拥有独立于任何使用 PV 的 Pod 的生命周期。 此 API 对象中记述了存储的实现细节，无论其背后是 NFS、iSCSI 还是特定于云平台的存储系统。

持久卷申领（PersistentVolumeClaim，PVC）表达的是用户对存储的请求。概念上与 Pod 类似。 Pod 会耗用节点资源，而 PVC 申领会耗用 PV 资源。Pod 可以请求特定数量的资源（CPU 和内存）；同样 PVC 申领也可以请求特定的大小和访问模式 （例如，可以要求 PV 卷能够以 ReadWriteOnce、ReadOnlyMany 或 ReadWriteMany 模式之一来挂载，参见访问模式）。

尽管 PersistentVolumeClaim 允许用户消耗抽象的存储资源，常见的情况是针对不同的 问题用户需要的是具有不同属性（如，性能）的 PersistentVolume 卷。 集群管理员需要能够提供不同性质的 PersistentVolume，并且这些 PV 卷之间的差别不 仅限于卷大小和访问模式，同时又不能将卷是如何实现的这些细节暴露给用户。 为了满足这类需求，就有了 存储类（StorageClass） 资源。

卷和申领的生命周期 
----------

PV 卷是集群中的资源。PVC 申领是对这些资源的请求，也被用来执行对资源的申领检查。 PV 卷和 PVC 申领之间的互动遵循如下生命周期：

### 供应 

PV 卷的供应有两种方式：静态供应或动态供应。

#### 静态供应 

集群管理员创建若干 PV 卷。这些卷对象带有真实存储的细节信息，并且对集群 用户可用（可见）。PV 卷对象存在于 Kubernetes API 中，可供用户消费（使用）。

#### 动态供应 

如果管理员所创建的所有静态 PV 卷都无法与用户的 PersistentVolumeClaim 匹配， 集群可以尝试为该 PVC 申领动态供应一个存储卷。 这一供应操作是基于 StorageClass 来实现的：PVC 申领必须请求某个 存储类，同时集群管理员必须 已经创建并配置了该类，这样动态供应卷的动作才会发生。 如果 PVC 申领指定存储类为 ​`""`​，则相当于为自身禁止使用动态供应的卷。

为了基于存储类完成动态的存储供应，集群管理员需要在 API 服务器上启用 ​`DefaultStorageClass` ​准入控制器。 举例而言，可以通过保证 ​`DefaultStorageClass` ​出现在 API 服务器组件的 ​`--enable-admission-plugins`​ 标志值中实现这点；该标志的值可以是逗号 分隔的有序列表。

### 绑定 

用户创建一个带有特定存储容量和特定访问模式需求的 PersistentVolumeClaim 对象； 在动态供应场景下，这个 PVC 对象可能已经创建完毕。 主控节点中的控制回路监测新的 PVC 对象，寻找与之匹配的 PV 卷（如果可能的话）， 并将二者绑定到一起。 如果为了新的 PVC 申领动态供应了 PV 卷，则控制回路总是将该 PV 卷绑定到这一 PVC 申领。 否则，用户总是能够获得他们所请求的资源，只是所获得的 PV 卷可能会超出所请求的配置。 一旦绑定关系建立，则 PersistentVolumeClaim 绑定就是排他性的，无论该 PVC 申领是 如何与 PV 卷建立的绑定关系。 PVC 申领与 PV 卷之间的绑定是一种一对一的映射，实现上使用 ClaimRef 来记述 PV 卷 与 PVC 申领间的双向绑定关系。

如果找不到匹配的 PV 卷，PVC 申领会无限期地处于未绑定状态。 当与之匹配的 PV 卷可用时，PVC 申领会被绑定。 例如，即使某集群上供应了很多 50 Gi 大小的 PV 卷，也无法与请求 100 Gi 大小的存储的 PVC 匹配。当新的 100 Gi PV 卷被加入到集群时，该 PVC 才有可能被绑定。

### 使用 

Pod 将 PVC 申领当做存储卷来使用。集群会检视 PVC 申领，找到所绑定的卷，并 为 Pod 挂载该卷。对于支持多种访问模式的卷，用户要在 Pod 中以卷的形式使用申领 时指定期望的访问模式。

一旦用户有了申领对象并且该申领已经被绑定，则所绑定的 PV 卷在用户仍然需要它期间 一直属于该用户。用户通过在 Pod 的 ​`volumes` ​块中包含 ​`persistentVolumeClaim` ​节区来调度 Pod，访问所申领的 PV 卷。 

### 保护使用中的存储对象 

保护使用中的存储对象（Storage Object in Use Protection）这一功能特性的目的 是确保仍被 Pod 使用的 PersistentVolumeClaim（PVC）对象及其所绑定的 PersistentVolume（PV）对象在系统中不会被删除，因为这样做可能会引起数据丢失。

> 当使用某 PVC 的 Pod 对象仍然存在时，认为该 PVC 仍被此 Pod 使用。

如果用户删除被某 Pod 使用的 PVC 对象，该 PVC 申领不会被立即移除。 PVC 对象的移除会被推迟，直至其不再被任何 Pod 使用。 此外，如果管理员删除已绑定到某 PVC 申领的 PV 卷，该 PV 卷也不会被立即移除。 PV 对象的移除也要推迟到该 PV 不再绑定到 PVC。

你可以看到当 PVC 的状态为 ​`Terminating` ​且其 ​`Finalizers` ​列表中包含 ​`kubernetes.io/pvc-protection`​ 时，PVC 对象是处于被保护状态的。

`kubectl describe pvc hostpath`

`Name:          hostpath Namespace:     default StorageClass:  example-hostpath Status:        Terminating Volume: Labels:        <none> Annotations:   volume.beta.kubernetes.io/storage-class=example-hostpath                volume.beta.kubernetes.io/storage-provisioner=example.com/hostpath Finalizers:    [kubernetes.io/pvc-protection]`

你也可以看到当 PV 对象的状态为 ​`Terminating` ​且其 ​`Finalizers` ​列表中包含 ​`kubernetes.io/pv-protection`​ 时，PV 对象是处于被保护状态的。

`kubectl describe pv task-pv-volume`

`Name:            task-pv-volume Labels:          type=local Annotations:     <none> Finalizers:      [kubernetes.io/pv-protection] StorageClass:    standard Status:          Terminating Claim: Reclaim Policy:  Delete Access Modes:    RWO Capacity:        1Gi Message: Source:     Type:          HostPath (bare host directory volume)     Path:          /tmp/data     HostPathType: Events:            <none>`

### 回收 

当用户不再使用其存储卷时，他们可以从 API 中将 PVC 对象删除，从而允许 该资源被回收再利用。PersistentVolume 对象的回收策略告诉集群，当其被 从申领中释放时如何处理该数据卷。 目前，数据卷可以被 Retained（保留）、Recycled（回收）或 Deleted（删除）。

#### 保留（Retain） 

回收策略 ​`Retain` ​使得用户可以手动回收资源。当 PersistentVolumeClaim 对象 被删除时，PersistentVolume 卷仍然存在，对应的数据卷被视为"已释放（released）"。 由于卷上仍然存在这前一申领人的数据，该卷还不能用于其他申领。 管理员可以通过下面的步骤来手动回收该卷：

1.  删除 PersistentVolume 对象。与之相关的、位于外部基础设施中的存储资产 （例如 AWS EBS、GCE PD、Azure Disk 或 Cinder 卷）在 PV 删除之后仍然存在。
2.  根据情况，手动清除所关联的存储资产上的数据。
3.  手动删除所关联的存储资产。

如果你希望重用该存储资产，可以基于存储资产的定义创建新的 PersistentVolume 卷对象。

#### 删除（Delete） 

对于支持 ​`Delete` ​回收策略的卷插件，删除动作会将 PersistentVolume 对象从 Kubernetes 中移除，同时也会从外部基础设施（如 AWS EBS、GCE PD、Azure Disk 或 Cinder 卷）中移除所关联的存储资产。 动态供应的卷会继承其 StorageClass 中设置的回收策略，该策略默认 为 ​`Delete`​。 管理员需要根据用户的期望来配置 StorageClass；否则 PV 卷被创建之后必须要被 编辑或者修补。

#### 回收（Recycle） 

> 回收策略 ​`Recycle` ​已被废弃。取而代之的建议方案是使用动态供应。

如果下层的卷插件支持，回收策略 ​`Recycle` ​会在卷上执行一些基本的 擦除（​`rm -rf /thevolume/*`​）操作，之后允许该卷用于新的 PVC 申领。

不过，管理员可以按 参考资料 中所述，使用 Kubernetes 控制器管理器命令行参数来配置一个定制的回收器（Recycler） Pod 模板。此定制的回收器 Pod 模板必须包含一个 ​`volumes` ​规约，如下例所示：

`apiVersion: v1 kind: Pod metadata:   name: pv-recycler   namespace: default spec:   restartPolicy: Never   volumes:   - name: vol     hostPath:       path: /any/path/it/will/be/replaced   containers:   - name: pv-recycler     image: "k8s.gcr.io/busybox"     command: ["/bin/sh", "-c", "test -e /scrub && rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  && test -z \"$(ls -A /scrub)\" || exit 1"]     volumeMounts:     - name: vol       mountPath: /scrub`

定制回收器 Pod 模板中在 ​`volumes` ​部分所指定的特定路径要替换为 正被回收的卷的路径。

### 预留 PersistentVolume 

通过在 PersistentVolumeClaim 中指定 PersistentVolume，你可以声明该特定 PV 与 PVC 之间的绑定关系。如果该 PersistentVolume 存在且未被通过其 ​`claimRef` ​字段预留给 PersistentVolumeClaim，则该 PersistentVolume 会和该 PersistentVolumeClaim 绑定到一起。

绑定操作不会考虑某些卷匹配条件是否满足，包括节点亲和性等等。 控制面仍然会检查 存储类、访问模式和所请求的 存储尺寸都是合法的。

`apiVersion: v1 kind: PersistentVolumeClaim metadata:   name: foo-pvc   namespace: foo spec:   storageClassName: "" # 此处须显式设置空字符串，否则会被设置为默认的 StorageClass   volumeName: foo-pv   ...`

此方法无法对 PersistentVolume 的绑定特权做出任何形式的保证。 如果有其他 PersistentVolumeClaim 可以使用你所指定的 PV，则你应该首先预留 该存储卷。你可以将 PV 的 ​`claimRef` ​字段设置为相关的 PersistentVolumeClaim 以确保其他 PVC 不会绑定到该 PV 卷。

`apiVersion: v1 kind: PersistentVolume metadata:   name: foo-pv spec:   storageClassName: ""   claimRef:     name: foo-pvc     namespace: foo   ...`

    

如果你想要使用 ​`claimPolicy` ​属性设置为 ​`Retain` ​的 PersistentVolume 卷 时，包括你希望复用现有的 PV 卷时，这点是很有用的

### 扩充 PVC 申领 

FEATURE STATE: Kubernetes v1.11 \[beta\]

现在，对扩充 PVC 申领的支持默认处于被启用状态。你可以扩充以下类型的卷：

*   azureDisk
*   azureFile
*   awsElasticBlockStore
*   cinder (deprecated)
*   csi
*   flexVolume (deprecated)
*   gcePersistentDisk
*   glusterfs
*   rbd
*   portworxVolume

只有当 PVC 的存储类中将 ​`allowVolumeExpansion` ​设置为 true 时，你才可以扩充该 PVC 申领。

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   name: gluster-vol-default provisioner: kubernetes.io/glusterfs parameters:   resturl: "http://192.168.10.100:8080"   restuser: ""   secretNamespace: ""   secretName: "" allowVolumeExpansion: true`

如果要为某 PVC 请求较大的存储卷，可以编辑 PVC 对象，设置一个更大的尺寸值。 这一编辑操作会触发为下层 PersistentVolume 提供存储的卷的扩充。 Kubernetes 不会创建新的 PV 卷来满足此申领的请求。 与之相反，现有的卷会被调整大小。

> 直接编辑 PersistentVolume 的大小可以阻止该卷自动调整大小。 如果对 PersistentVolume 的容量进行编辑，然后又将其所对应的 PersistentVolumeClaim 的 ​`.spec`​ 进行编辑，使该 PersistentVolumeClaim 的大小匹配 PersistentVolume 的话，则不会发生存储大小的调整。 Kubernetes 控制平面将看到两个资源的所需状态匹配，并认为其后备卷的大小 已被手动增加，无需调整。

#### CSI 卷的扩充 

FEATURE STATE: Kubernetes v1.16 \[beta\]

对 CSI 卷的扩充能力默认是被启用的，不过扩充 CSI 卷要求 CSI 驱动支持 卷扩充操作。

#### 重设包含文件系统的卷的大小

只有卷中包含的文件系统是 XFS、Ext3 或者 Ext4 时，你才可以重设卷的大小。

当卷中包含文件系统时，只有在 Pod 使用 ​`ReadWrite` ​模式来使用 PVC 申领的 情况下才能重设其文件系统的大小。 文件系统扩充的操作或者是在 Pod 启动期间完成，或者在下层文件系统支持在线 扩充的前提下在 Pod 运行期间完成。

如果 FlexVolumes 的驱动将 ​`RequiresFSResize` ​能力设置为 true，则该 FlexVolume 卷（于 Kubernetes v1.23 弃用）可以在 Pod 重启期间调整大小。

#### 重设使用中 PVC 申领的大小 

FEATURE STATE: Kubernetes v1.15 \[beta\]

> Kubernetes 从 1.15 版本开始将调整使用中 PVC 申领大小这一能力作为 Beta 特性支持；该特性在 1.11 版本以来处于 Alpha 阶段。 ​`ExpandInUsePersistentVolumes` ​特性必须被启用；在很多集群上，与此类似的 Beta 阶段的特性是自动启用的。

在这种情况下，你不需要删除和重建正在使用某现有 PVC 的 Pod 或 Deployment。 所有使用中的 PVC 在其文件系统被扩充之后，立即可供其 Pod 使用。 此功能特性对于没有被 Pod 或 Deployment 使用的 PVC 而言没有效果。 你必须在执行扩展操作之前创建一个使用该 PVC 的 Pod。

与其他卷类型类似，FlexVolume 卷也可以在被 Pod 使用期间执行扩充操作。

> FlexVolume 卷的重设大小只能在下层驱动支持重设大小的时候才可进行。

> 扩充 EBS 卷的操作非常耗时。同时还存在另一个配额限制： 每 6 小时只能执行一次（尺寸）修改操作。

#### 处理扩充卷过程中的失败 

如果用户指定的新大小过大，底层存储系统无法满足，PVC 的扩展将不断重试， 直到用户或集群管理员采取一些措施。这种情况是不希望发生的，因此 Kubernetes 提供了以下从此类故障中恢复的方法。

*   集群管理员手动处理

如果扩充下层存储的操作失败，集群管理员可以手动地恢复 PVC 申领的状态并 取消重设大小的请求。否则，在没有管理员干预的情况下，控制器会反复重试 重设大小的操作。

1.  将绑定到 PVC 申领的 PV 卷标记为 ​`Retain` ​回收策略；
2.  删除 PVC 对象。由于 PV 的回收策略为 ​`Retain`​，我们不会在重建 PVC 时丢失数据。
3.  删除 PV 规约中的 ​`claimRef` ​项，这样新的 PVC 可以绑定到该卷。 这一操作会使得 PV 卷变为 "可用（Available）"。
4.  使用小于 PV 卷大小的尺寸重建 PVC，设置 PVC 的 ​`volumeName` ​字段为 PV 卷的名称。 这一操作将把新的 PVC 对象绑定到现有的 PV 卷。
5.  不要忘记恢复 PV 卷上设置的回收策略。

*   通过请求扩展为更小尺寸

FEATURE STATE: Kubernetes v1.23 \[alpha\]

> Kubernetes 从 1.23 版本开始将允许用户恢复失败的 PVC 扩展这一能力作为 alpha 特性支持。 ​`RecoverVolumeExpansionFailure` ​必须被启用以允许使用此功能。

如果集群中的特性门控 ​`ExpandPersistentVolumes` ​和 ​`RecoverVolumeExpansionFailure` ​都已启用，在 PVC 的扩展发生失败时，你可以使用比先前请求的值更小的尺寸来重试扩展。 要使用一个更小的尺寸尝试请求新的扩展，请编辑该 PVC 的 ​`.spec.resources`​ 并选择 一个比你之前所尝试的值更小的值。 如果由于容量限制而无法成功扩展至更高的值，这将很有用。 如果发生了这种情况，或者你怀疑可能发生了这种情况，你可以通过指定一个在底层存储供应容量 限制内的尺寸来重试扩展。你可以通过查看 ​`.status.resizeStatus`​ 以及 PVC 上的事件 来监控调整大小操作的状态。

请注意， 尽管你可以指定比之前的请求更低的存储量，新值必须仍然高于 ​`.status.capacity`​。 Kubernetes 不支持将 PVC 缩小到小于其当前的尺寸。

持久卷的类型 
-------

PV 持久卷是用插件的形式来实现的。Kubernetes 目前支持以下插件：

*   awsElasticBlockStore - AWS 弹性块存储（EBS）
*   azureDisk - Azure Disk
*   azureFile - Azure File
*   cephfs - CephFS volume
*   csi - 容器存储接口 (CSI)
*   fc - Fibre Channel (FC) 存储
*   gcePersistentDisk - GCE 持久化盘
*   glusterfs - Glusterfs 卷
*   hostPath - HostPath 卷 （仅供单节点测试使用；不适用于多节点集群； 请尝试使用 local 卷作为替代）
*   iscsi - iSCSI (SCSI over IP) 存储
*   local - 节点上挂载的本地存储设备
*   nfs - 网络文件系统 (NFS) 存储
*   portworxVolume - Portworx 卷
*   rbd - Rados 块设备 (RBD) 卷
*   vsphereVolume - vSphere VMDK 卷

以下的持久卷已被弃用。这意味着当前仍是支持的，但是 Kubernetes 将来的发行版会将其移除。

*   cinder - Cinder（OpenStack 块存储）（于 v1.18 弃用）
*   flexVolume - FlexVolume （于 v1.23 弃用）
*   flocker - Flocker 存储（于 v1.22 弃用）
*   quobyte - Quobyte 卷 （于 v1.22 弃用）
*   storageos - StorageOS 卷（于 v1.22 弃用）

旧版本的 Kubernetes 仍支持这些“树内（In-Tree）”持久卷类型：

*   ​`photonPersistentDisk` ​- Photon 控制器持久化盘。（v1.15 之后 不可用）
*   scaleIO - ScaleIO 卷（v1.21 之后 不可用）

持久卷 
----

每个 PV 对象都包含 ​`spec` ​部分和 ​`status` ​部分，分别对应卷的规约和状态。 PersistentVolume 对象的名称必须是合法的 DNS 子域名.

`apiVersion: v1 kind: PersistentVolume metadata:   name: pv0003 spec:   capacity:     storage: 5Gi   volumeMode: Filesystem   accessModes:     - ReadWriteOnce   persistentVolumeReclaimPolicy: Recycle   storageClassName: slow   mountOptions:     - hard     - nfsvers=4.1   nfs:     path: /tmp     server: 172.17.0.2`

> 在集群中使用持久卷存储通常需要一些特定于具体卷类型的辅助程序。 在这个例子中，PersistentVolume 是 NFS 类型的，因此需要辅助程序 ​`/sbin/mount.nfs`​ 来支持挂载 NFS 文件系统。

### 容量 

一般而言，每个 PV 卷都有确定的存储容量。 容量属性是使用 PV 对象的 ​`capacity` ​属性来设置的。

目前，存储大小是可以设置和请求的唯一资源。 未来可能会包含 IOPS、吞吐量等属性。

### 卷模式 

FEATURE STATE: Kubernetes v1.18 \[stable\]

针对 PV 持久卷，Kubernetes 支持两种卷模式（​`volumeModes`​）：​`Filesystem（文件系统）`​ 和 ​`Block（块）`​。 ​`volumeMode` ​是一个可选的 API 参数。 如果该参数被省略，默认的卷模式是 ​`Filesystem`​。

​`volumeMode` ​属性设置为 ​`Filesystem` ​的卷会被 Pod 挂载（Mount） 到某个目录。 如果卷的存储来自某块设备而该设备目前为空，Kuberneretes 会在第一次挂载卷之前 在设备上创建文件系统。

你可以将 ​`volumeMode` ​设置为 ​`Block`​，以便将卷作为原始块设备来使用。 这类卷以块设备的方式交给 Pod 使用，其上没有任何文件系统。 这种模式对于为 Pod 提供一种使用最快可能方式来访问卷而言很有帮助，Pod 和 卷之间不存在文件系统层。另外，Pod 中运行的应用必须知道如何处理原始块设备。 

### 访问模式 

PersistentVolume 卷可以用资源提供者所支持的任何方式挂载到宿主系统上。 如下表所示，提供者（驱动）的能力不同，每个 PV 卷的访问模式都会设置为 对应卷所支持的模式值。 例如，NFS 可以支持多个读写客户，但是某个特定的 NFS PV 卷可能在服务器 上以只读的方式导出。每个 PV 卷都会获得自身的访问模式集合，描述的是 特定 PV 卷的能力。

访问模式有：

*   ​`ReadWriteOnce`​
卷可以被一个节点以读写方式挂载。 ReadWriteOnce 访问模式也允许运行在同一节点上的多个 Pod 访问卷。<*   ​`ReadOnlyMany`​
卷可以被多个节点以只读方式挂载。*   ​`ReadWriteMany`​
卷可以被多个节点以读写方式挂载。*   ​`ReadWriteOncePod`​
卷可以被单个 Pod 以读写方式挂载。 如果你想确保整个集群中只有一个 Pod 可以读取或写入该 PVC， 请使用ReadWriteOncePod 访问模式。这只支持 CSI 卷以及需要 Kubernetes 1.22 以上版本。

在命令行接口（CLI）中，访问模式也使用以下缩写形式：

*   RWO - ReadWriteOnce
*   ROX - ReadOnlyMany
*   RWX - ReadWriteMany
*   RWOP - ReadWriteOncePod

> 重要提醒！ 每个卷同一时刻只能以一种访问模式挂载，即使该卷能够支持 多种访问模式。例如，一个 GCEPersistentDisk 卷可以被某节点以 ReadWriteOnce 模式挂载，或者被多个节点以 ReadOnlyMany 模式挂载，但不可以同时以两种模式 挂载。

卷插件

ReadWriteOnce

ReadOnlyMany

ReadWriteMany

ReadWriteOncePod

AWSElasticBlockStore

✓

\-

\-

\-

AzureFile

✓

✓

✓

\-

AzureDisk

✓

\-

\-

\-

CephFS

✓

✓

✓

\-

Cinder

✓

\-

\-

\-

CSI

取决于驱动

取决于驱动

取决于驱动

取决于驱动

FC

✓

✓

\-

\-

FlexVolume

✓

✓

取决于驱动

\-

Flocker

✓

\-

\-

\-

GCEPersistentDisk

✓

✓

\-

\-

Glusterfs

✓

✓

✓

\-

HostPath

✓

\-

\-

\-

iSCSI

✓

✓

\-

\-

Quobyte

✓

✓

✓

\-

NFS

✓

✓

✓

\-

RBD

✓

✓

\-

\-

VsphereVolume

✓

\-

\- （Pod 运行于同一节点上时可行）

\-

PortworxVolume

✓

\-

✓

\-

StorageOS

✓

\-

\-

\-

### 类 

每个 PV 可以属于某个类（Class），通过将其 ​`storageClassName` ​属性设置为某个 StorageClass 的名称来指定。 特定类的 PV 卷只能绑定到请求该类存储卷的 PVC 申领。 未设置 ​`storageClassName` ​的 PV 卷没有类设定，只能绑定到那些没有指定特定 存储类的 PVC 申领。

早前，Kubernetes 使用注解 ​`volume.beta.kubernetes.io/storage-class`​ 而不是 ​`storageClassName` ​属性。这一注解目前仍然起作用，不过在将来的 Kubernetes 发布版本中该注解会被彻底废弃。

### 回收策略 

目前的回收策略有：

*   Retain -- 手动回收
*   Recycle -- 基本擦除 (​`rm -rf /thevolume/*`​)
*   Delete -- 诸如 AWS EBS、GCE PD、Azure Disk 或 OpenStack Cinder 卷这类关联存储资产也被删除

目前，仅 NFS 和 HostPath 支持回收（Recycle）。 AWS EBS、GCE PD、Azure Disk 和 Cinder 卷都支持删除（Delete）。

### 挂载选项 

Kubernetes 管理员可以指定持久卷被挂载到节点上时使用的附加挂载选项。

> 并非所有持久卷类型都支持挂载选项。

以下卷类型支持挂载选项：

*   ​`awsElasticBlockStore` ​
*   ​`azureDisk` ​
*   ​`azureFile` ​
*   ​`cephfs` ​
*   ​`cinder` ​(已弃用于 v1.18)
*   ​`gcePersistentDisk` ​
*   ​`glusterfs` ​
*   ​`iscsi` ​
*   ​`nfs` ​
*   ​`quobyte` ​(已弃用于 v1.22)
*   ​`rbd` ​
*   ​`storageos` ​(已弃用于 v1.22)
*   ​`vsphereVolume`​

Kubernetes 不对挂载选项执行合法性检查。如果挂载选项是非法的，挂载就会失败。

早前，Kubernetes 使用注解 ​`volume.beta.kubernetes.io/mount-options`​ 而不是 ​`mountOptions` ​属性。这一注解目前仍然起作用，不过在将来的 Kubernetes 发布版本中该注解会被彻底废弃。

### 节点亲和性 

每个 PV 卷可以通过设置节点亲和性来定义一些约束，进而限制从哪些节点上可以访问此卷。 使用这些卷的 Pod 只会被调度到节点亲和性规则所选择的节点上执行。 要设置节点亲和性，配置 PV 卷 ​`.spec`​ 中的 ​`nodeAffinity`​。

> 对大多数类型的卷而言，你不需要设置节点亲和性字段。 AWS EBS、 GCE PD 和 Azure Disk 卷类型都能 自动设置相关字段。 你需要为 local 卷显式地设置 此属性。

### 阶段 

每个卷会处于以下阶段（Phase）之一：

*   Available（可用）-- 卷是一个空闲资源，尚未绑定到任何申领；
*   Bound（已绑定）-- 该卷已经绑定到某申领；
*   Released（已释放）-- 所绑定的申领已被删除，但是资源尚未被集群回收；
*   Failed（失败）-- 卷的自动回收操作失败。

命令行接口能够显示绑定到某 PV 卷的 PVC 对象。

PersistentVolumeClaims
----------------------

每个 PVC 对象都有 ​`spec` ​和 ​`status` ​部分，分别对应申领的规约和状态。 PersistentVolumeClaim 对象的名称必须是合法的 DNS 子域名.

`apiVersion: v1 kind: PersistentVolumeClaim metadata:   name: myclaim spec:   accessModes:     - ReadWriteOnce   volumeMode: Filesystem   resources:     requests:       storage: 8Gi   storageClassName: slow   selector:     matchLabels:       release: "stable"     matchExpressions:       - {key: environment, operator: In, values: [dev]}`

### 访问模式

申领在请求具有特定访问模式的存储时，使用与卷相同的访问模式约定。

### 卷模式

申领使用与卷相同的约定来表明是将卷作为文件系统还是块设备来使用。

### 资源 

申领和 Pod 一样，也可以请求特定数量的资源。在这个上下文中，请求的资源是存储。 卷和申领都使用相同的 [资源模型](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/resources.md)。

### 选择算符 

申领可以设置标签选择算符 来进一步过滤卷集合。只有标签与选择算符相匹配的卷能够绑定到申领上。 选择算符包含两个字段：

*   ​`matchLabels` ​- 卷必须包含带有此值的标签
*   ​`matchExpressions` ​- 通过设定键（key）、值列表和操作符（operator） 来构造的需求。合法的操作符有 In、NotIn、Exists 和 DoesNotExist。

来自 ​`matchLabels` ​和 ​`matchExpressions` ​的所有需求都按逻辑与的方式组合在一起。 这些需求都必须被满足才被视为匹配。

### 类 

申领可以通过为 ​`storageClassName` ​属性设置 StorageClass 的名称来请求特定的存储类。 只有所请求的类的 PV 卷，即 ​`storageClassName` ​值与 PVC 设置相同的 PV 卷， 才能绑定到 PVC 申领。

PVC 申领不必一定要请求某个类。如果 PVC 的 ​`storageClassName` ​属性值设置为 ​`""`​， 则被视为要请求的是没有设置存储类的 PV 卷，因此这一 PVC 申领只能绑定到未设置 存储类的 PV 卷（未设置注解或者注解值为 ​`""`​ 的 PersistentVolume（PV）对象在系统中不会被删除，因为这样做可能会引起数据丢失。 未设置 ​`storageClassName` ​的 PVC 与此大不相同，也会被集群作不同处理。 具体筛查方式取决于 ​`DefaultStorageClass` ​准入控制器插件 是否被启用。

*   如果准入控制器插件被启用，则管理员可以设置一个默认的 StorageClass。 所有未设置 ​`storageClassName` ​的 PVC 都只能绑定到隶属于默认存储类的 PV 卷。 设置默认 StorageClass 的工作是通过将对应 StorageClass 对象的注解 ​`storageclass.kubernetes.io/is-default-class`​ 赋值为 ​`true` ​来完成的。 如果管理员未设置默认存储类，集群对 PVC 创建的处理方式与未启用准入控制器插件 时相同。如果设定的默认存储类不止一个，准入控制插件会禁止所有创建 PVC 操作。
*   如果准入控制器插件被关闭，则不存在默认 StorageClass 的说法。 所有未设置 ​`storageClassName` ​的 PVC 都只能绑定到未设置存储类的 PV 卷。 在这种情况下，未设置 ​`storageClassName` ​的 PVC 与 ​`storageClassName` ​设置未 ​`""`​ 的 PVC 的处理方式相同。

取决于安装方法，默认的 StorageClass 可能在集群安装期间由插件管理器（Addon Manager）部署到集群中。

当某 PVC 除了请求 StorageClass 之外还设置了 ​`selector`​，则这两种需求会按 逻辑与关系处理：只有隶属于所请求类且带有所请求标签的 PV 才能绑定到 PVC。

> 目前，设置了非空 ​`selector` ​的 PVC 对象无法让集群为其动态供应 PV 卷。

早前，Kubernetes 使用注解 ​`volume.beta.kubernetes.io/storage-class`​ 而不是 ​`storageClassName` ​属性。这一注解目前仍然起作用，不过在将来的 Kubernetes 发布版本中该注解会被彻底废弃。

使用申领作为卷 
--------

Pod 将申领作为卷来使用，并藉此访问存储资源。 申领必须位于使用它的 Pod 所在的同一名字空间内。 集群在 Pod 的名字空间中查找申领，并使用它来获得申领所使用的 PV 卷。 之后，卷会被挂载到宿主上并挂载到 Pod 中。

`apiVersion: v1 kind: Pod metadata:   name: mypod spec:   containers:     - name: myfrontend       image: nginx       volumeMounts:       - mountPath: "/var/www/html"         name: mypd   volumes:     - name: mypd       persistentVolumeClaim:         claimName: myclaim`

### 关于名字空间的说明 

PersistentVolume 卷的绑定是排他性的。 由于 PersistentVolumeClaim 是名字空间作用域的对象，使用 "Many" 模式（​`ROX`​、​`RWX`​）来挂载申领的操作只能在同一名字空间内进行。

### 类型为 hostpath 的 PersistentVolume 

​`hostPath` ​PersistentVolume 使用节点上的文件或目录来模拟网络附加（network-attached）存储。

原始块卷支持 
-------

FEATURE STATE: Kubernetes v1.18 \[stable\]

以下卷插件支持原始块卷，包括其动态供应（如果支持的话）的卷：

*   AWSElasticBlockStore
*   AzureDisk
*   CSI
*   FC （光纤通道）
*   GCEPersistentDisk
*   iSCSI
*   Local 卷
*   OpenStack Cinder
*   RBD （Ceph 块设备）
*   VsphereVolume

### 使用原始块卷的持久卷 

`apiVersion: v1 kind: PersistentVolume metadata:   name: block-pv spec:   capacity:     storage: 10Gi   accessModes:     - ReadWriteOnce   volumeMode: Block   persistentVolumeReclaimPolicy: Retain   fc:     targetWWNs: ["50060e801049cfd1"]     lun: 0     readOnly: false`

### 申请原始块卷的 PVC 申领 

`apiVersion: v1 kind: PersistentVolumeClaim metadata:   name: block-pvc spec:   accessModes:     - ReadWriteOnce   volumeMode: Block   resources:     requests:       storage: 10Gi`

卷填充器（Populator）与数据源 
--------------------

FEATURE STATE: Kubernetes v1.22 \[alpha\]

> Kubernetes 支持自定义的卷填充器；Kubernetes 1.18 版本引入了这个 alpha 特性。 Kubernetes 1.22 使用重新设计的 API 重新实现了该机制。 确认你正在阅读与你的集群版本一致的 Kubernetes 文档。 要检查版本，请输入 ​`kubectl version`​。  
> 要使用自定义的卷填充器，你必须为 kube-apiserver 和 kube-controller-manager 启用 ​`AnyVolumeDataSource` ​特性门控。

卷填充器利用了 PVC 规约字段 ​`dataSourceRef`​。 不像 ​`dataSource` ​字段只能包含对另一个持久卷申领或卷快照的引用， ​`dataSourceRef` ​字段可以包含对同一命名空间中任何对象的引用（不包含除 PVC 以外的核心资源）。 对于启用了特性门控的集群，使用 ​`dataSourceRef` ​比 ​`dataSource` ​更好。

数据源引用 
------

​`dataSourceRef` ​字段的行为与 ​`dataSource` ​字段几乎相同。 如果其中一个字段被指定而另一个字段没有被指定，API 服务器将给两个字段相同的值。 这两个字段都不能在创建后改变，如果试图为这两个字段指定不同的值，将导致验证错误。 因此，这两个字段将总是有相同的内容。

在 ​`dataSourceRef` ​字段和 ​`dataSource` ​字段之间有两个用户应该注意的区别：

*   ​`dataSource` ​字段会忽略无效的值（如同是空值）， 而 ​`dataSourceRef` ​字段永远不会忽略值，并且若填入一个无效的值，会导致错误。 无效值指的是 PVC 之外的核心对象（没有 apiGroup 的对象）。
*   ​`dataSourceRef` ​字段可以包含不同类型的对象，而 ​`dataSource` ​字段只允许 PVC 和卷快照。

用户应该始终在启用了特性门控的集群上使用 ​`dataSourceRef`​，而在没有启用特性门控的集群上使用 ​`dataSource`​。 在任何情况下都没有必要查看这两个字段。 这两个字段的值看似相同但是语义稍微不一样，是为了向后兼容。 特别是混用旧版本和新版本的控制器时，它们能够互通。

使用卷填充器 
-------

卷填充器是能创建非空卷的控制器， 其卷的内容通过一个自定义资源决定。 用户通过使用 ​`dataSourceRef` ​字段引用自定义资源来创建一个被填充的卷：

`apiVersion: v1 kind: PersistentVolumeClaim metadata:   name: populated-pvc spec:   dataSourceRef:     name: example-name     kind: ExampleDataSource     apiGroup: example.storage.k8s.io   accessModes:     - ReadWriteOnce   resources:     requests:       storage: 10Gi`

因为卷填充器是外部组件，如果没有安装所有正确的组件，试图创建一个使用卷填充器的 PVC 就会失败。 外部控制器应该在 PVC 上产生事件，以提供创建状态的反馈，包括在由于缺少某些组件而无法创建 PVC 的情况下发出警告。

你可以把 alpha 版本的[卷数据源验证器](https://github.com/kubernetes-csi/volume-data-source-validator) 控制器安装到你的集群中。 如果没有填充器处理该数据源的情况下，该控制器会在 PVC 上产生警告事件。 当一个合适的填充器被安装到 PVC 上时，该控制器的职责是上报与卷创建有关的事件，以及在该过程中发生的问题。

### 在容器中添加原始块设备路径的 Pod 规约 

`apiVersion: v1 kind: Pod metadata:   name: pod-with-block-volume spec:   containers:     - name: fc-container       image: fedora:26       command: ["/bin/sh", "-c"]       args: [ "tail -f /dev/null" ]       volumeDevices:         - name: data           devicePath: /dev/xvda   volumes:     - name: data       persistentVolumeClaim:         claimName: block-pvc`

> 向 Pod 中添加原始块设备时，你要在容器内设置设备路径而不是挂载路径。

### 绑定块卷 

如果用户通过 PersistentVolumeClaim 规约的 ​`volumeMode` ​字段来表明对原始 块设备的请求，绑定规则与之前版本中未在规约中考虑此模式的实现略有不同。 下面列举的表格是用户和管理员可以为请求原始块设备所作设置的组合。 此表格表明在不同的组合下卷是否会被绑定。

静态供应卷的卷绑定矩阵：

PV volumeMode

PVC volumeMode

Result

未指定

未指定

绑定

未指定

Block

不绑定

未指定

Filesystem

绑定

Block

未指定

不绑定

Block

Block

绑定

Block

Filesystem

不绑定

Filesystem

Filesystem

绑定

Filesystem

Block

不绑定

Filesystem

未指定

绑定

> Alpha 发行版本中仅支持静态供应的卷。 管理员需要在处理原始块设备时小心处理这些值。

对卷快照及从卷快照中恢复卷的支持
----------------

FEATURE STATE: Kubernetes v1.17 \[beta\]

卷快照（Volume Snapshot）功能的添加仅是为了支持 CSI 卷插件。

要启用从卷快照数据源恢复数据卷的支持，可在 API 服务器和控制器管理器上启用 ​`VolumeSnapshotDataSource` ​特性门控。

### 基于卷快照创建 PVC 申领 

`apiVersion: v1 kind: PersistentVolumeClaim metadata:   name: restore-pvc spec:   storageClassName: csi-hostpath-sc   dataSource:     name: new-snapshot-test     kind: VolumeSnapshot     apiGroup: snapshot.storage.k8s.io   accessModes:     - ReadWriteOnce   resources:     requests:       storage: 10Gi`

卷克隆 
----

卷克隆功能特性仅适用于 CSI 卷插件。

### 基于现有 PVC 创建新的 PVC 申领

`apiVersion: v1 kind: PersistentVolumeClaim metadata:   name: cloned-pvc spec:   storageClassName: my-csi-plugin   dataSource:     name: existing-src-pvc-name     kind: PersistentVolumeClaim   accessModes:     - ReadWriteOnce   resources:     requests:       storage: 10Gi`

编写可移植的配置 
---------

如果你要编写配置模板和示例用来在很多集群上运行并且需要持久性存储，建议你使用以下模式：

*   将 PersistentVolumeClaim 对象包含到你的配置包（Bundle）中，和 Deployment 以及 ConfigMap 等放在一起。
*   不要在配置中包含 PersistentVolume 对象，因为对配置进行实例化的用户很可能 没有创建 PersistentVolume 的权限。
*   为用户提供在实例化模板时指定存储类名称的能力。

*   仍按用户提供存储类名称，将该名称放到 ​`persistentVolumeClaim.storageClassName`​ 字段中。 这样会使得 PVC 在集群被管理员启用了存储类支持时能够匹配到正确的存储类，
*   如果用户未指定存储类名称，将 ​`persistentVolumeClaim.storageClassName`​ 留空（nil）。 这样，集群会使用默认 ​`StorageClass` ​为用户自动供应一个存储卷。 很多集群环境都配置了默认的 ​`StorageClass`​，或者管理员也可以自行创建默认的 ​`StorageClass`​。

*   在你的工具链中，监测经过一段时间后仍未被绑定的 PVC 对象，要让用户知道这些对象， 因为这可能意味着集群不支持动态存储（因而用户必须先创建一个匹配的 PV），或者 集群没有配置存储系统（因而用户无法配置需要 PVC 的工作负载配置）。

##  3.  Kubernetes 投射卷
介绍 
---

一个 ​`projected` ​卷可以将若干现有的卷源映射到同一个目录之上。

目前，以下类型的卷源可以被投射：

*   secret
*   downwardAPI
*   configMap
*   serviceAccountToken

所有的卷源都要求处于 Pod 所在的同一个名字空间内。进一步的详细信息，可参考 [一体化卷设计文档](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/all-in-one-volume.md)。

### 带有 Secret、DownwardAPI 和 ConfigMap 的配置示例 

`apiVersion: v1 kind: Pod metadata:   name: volume-test spec:   containers:   - name: container-test     image: busybox:1.28     volumeMounts:     - name: all-in-one       mountPath: "/projected-volume"       readOnly: true   volumes:   - name: all-in-one     projected:       sources:       - secret:           name: mysecret           items:             - key: username               path: my-group/my-username       - downwardAPI:           items:             - path: "labels"               fieldRef:                 fieldPath: metadata.labels             - path: "cpu_limit"               resourceFieldRef:                 containerName: container-test                 resource: limits.cpu       - configMap:           name: myconfigmap           items:             - key: config               path: my-group/my-config`

### 带有非默认权限模式设置的 Secret 的配置示例

`apiVersion: v1 kind: Pod metadata:   name: volume-test spec:   containers:   - name: container-test     image: busybox:1.28     volumeMounts:     - name: all-in-one       mountPath: "/projected-volume"       readOnly: true   volumes:   - name: all-in-one     projected:       sources:       - secret:           name: mysecret           items:             - key: username               path: my-group/my-username       - secret:           name: mysecret2           items:             - key: password               path: my-group/my-password               mode: 511`

每个被投射的卷源都列举在规约中的 ​`sources` ​下面。参数几乎相同，只有两个例外：

*   对于 Secret，​`secretName` ​字段被改为 ​`name` ​以便于 ConfigMap 的命名一致；
*   ​`defaultMode` ​只能在投射层级设置，不能在卷源层级设置。不过，正如上面所展示的， 你可以显式地为每个投射单独设置 ​`mode` ​属性。

serviceAccountToken 投射卷
-----------------------

当 ​`TokenRequestProjection` ​特性被启用时，你可以将当前 服务账号 的令牌注入到 Pod 中特定路径下。例如：

`apiVersion: v1 kind: Pod metadata:   name: sa-token-test spec:   containers:   - name: container-test     image: busybox:1.28     volumeMounts:     - name: token-vol       mountPath: "/service-account"       readOnly: true   serviceAccountName: default   volumes:   - name: token-vol     projected:       sources:       - serviceAccountToken:           audience: api           expirationSeconds: 3600           path: token`

示例 Pod 中包含一个投射卷，其中包含注入的服务账号令牌。 此 Pod 中的容器可以使用该令牌访问 Kubernetes API 服务器， 使用 pod 的 ServiceAccount 进行身份验证。​`audience` ​字段包含令牌所针对的受众。 收到令牌的主体必须使用令牌受众中所指定的某个标识符来标识自身，否则应该拒绝该令牌。 此字段是可选的，默认值为 API 服务器的标识。

字段 ​`expirationSeconds` ​是服务账号令牌预期的生命期长度。默认值为 1 小时， 必须至少为 10 分钟（600 秒）。管理员也可以通过设置 API 服务器的命令行参数 ​`--service-account-max-token-expiration`​ 来为其设置最大值上限。​`path` ​字段给出 与投射卷挂载点之间的相对路径。

> 以 ​`subPath` ​形式使用投射卷源的容器无法收到对应卷源的更新。

与 SecurityContext 间的关系 
-----------------------

[关于在投射的服务账号卷中处理文件访问权限的提案](https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/2451-service-account-token-volumes target=) 介绍了如何使得所投射的文件具有合适的属主访问权限。

### Linux

在包含了投射卷并在 ​`SecurityContext` ​中设置了 ​`RunAsUser` ​属性的 Linux Pod 中，投射文件具有正确的属主属性设置， 其中包含了容器用户属主。

### Windows

在包含了投射卷并在 ​`SecurityContext` ​中设置了 ​`RunAsUsername` ​的 Windows Pod 中, 由于 Windows 中用户账号的管理方式问题，文件的属主无法正确设置。 Windows 在名为安全账号管理器（Security Account Manager，SAM） 的数据库中保存本地用户和组信息。每个容器会维护其自身的 SAM 数据库实例， 宿主系统无法窥视到容器运行期间数据库内容。Windows 容器被设计用来运行操作系统的用户态部分， 与宿主系统之间隔离，因此维护了一个虚拟的 SAM 数据库。 所以，在宿主系统上运行的 kubelet 无法动态为虚拟的容器账号配置宿主文件的属主。 如果需要将宿主机器上的文件与容器共享，建议将它们放到挂载于 ​`C:\`​ 之外 的独立卷中。

默认情况下，所投射的文件会具有如下例所示的属主属性设置：

`PS C:\> Get-Acl C:\var\run\secrets\kubernetes.io\serviceaccount\..2021_08_31_22_22_18.318230061\ca.crt | Format-List  Path   : Microsoft.PowerShell.Core\FileSystem::C:\var\run\secrets\kubernetes.io\serviceaccount\..2021_08_31_22_22_18.318230061\ca.crt Owner  : BUILTIN\Administrators Group  : NT AUTHORITY\SYSTEM Access : NT AUTHORITY\SYSTEM Allow  FullControl          BUILTIN\Administrators Allow  FullControl          BUILTIN\Users Allow  ReadAndExecute, Synchronize Audit  : Sddl   : O:BAG:SYD:AI(A;ID;FA;;;SY)(A;ID;FA;;;BA)(A;ID;0x1200a9;;;BU)`

这意味着，所有类似 ​`ContainerAdministrator` ​的管理员用户都具有读、写和执行访问权限， 而非管理员用户将具有读和执行访问权限。

> 总体而言，为容器授予访问宿主系统的权限这种做法是不推荐的，因为这样做可能会打开潜在的安全性攻击之门。  
> 在创建 Windows Pod 时，如过在其 ​`SecurityContext` ​中设置了 ​`RunAsUser`​， Pod 会一直阻塞在 ​`ContainerCreating` ​状态。因此，建议不要在 Windows 节点上使用仅针对 Linux 的 ​`RunAsUser` ​选项。

##  4.  Kubernetes 临时卷
临时卷
---

本文档描述 Kubernetes 中的 临时卷（Ephemeral Volume）。 建议先了解卷，特别是 PersistentVolumeClaim 和 PersistentVolume。

有些应用程序需要额外的存储，但并不关心数据在重启后仍然可用。 例如，缓存服务经常受限于内存大小，将不常用的数据转移到比内存慢、但对总体性能的影响很小的存储中。

另有些应用程序需要以文件形式注入的只读数据，比如配置数据或密钥。

临时卷 就是为此类用例设计的。因为卷会遵从 Pod 的生命周期，与 Pod 一起创建和删除， 所以停止和重新启动 Pod 时，不会受持久卷在何处可用的限制。

临时卷在 Pod 规范中以 内联 方式定义，这简化了应用程序的部署和管理。

临时卷的类型 
-------

Kubernetes 为了不同的目的，支持几种不同类型的临时卷：

*   emptyDir： Pod 启动时为空，存储空间来自本地的 kubelet 根目录（通常是根磁盘）或内存
*   configMap、 downwardAPI、 secret： 将不同类型的 Kubernetes 数据注入到 Pod 中
*   CSI 临时卷： 类似于前面的卷类型，但由专门[支持此特性](https://kubernetes-csi.github.io/docs/drivers.html) 的指定 [CSI 驱动程序](https://github.com/container-storage-interface/spec/blob/master/spec.md)提供
*   通用临时卷： 它可以由所有支持持久卷的存储驱动程序提供

​`emptyDir`​、​`configMap`​、​`downwardAPI`​、​`secret` ​是作为 本地临时存储 提供的。它们由各个节点上的 kubelet 管理。

CSI 临时卷 必须 由第三方 CSI 存储驱动程序提供。

通用临时卷 可以 由第三方 CSI 存储驱动程序提供，也可以由支持动态配置的任何其他存储驱动程序提供。 一些专门为 CSI 临时卷编写的 CSI 驱动程序，不支持动态供应：因此这些驱动程序不能用于通用临时卷。

使用第三方驱动程序的优势在于，它们可以提供 Kubernetes 本身不支持的功能， 例如，与 kubelet 管理的磁盘具有不同运行特征的存储，或者用来注入不同的数据

CSI 临时卷
-------

FEATURE STATE: Kubernetes v1.16 \[beta\]

该特性需要启用参数 ​`CSIInlineVolume` ​特性门控（feature gate）。 该参数从 Kubernetes 1.16 开始默认启用。

> 只有一部分 CSI 驱动程序支持 CSI 临时卷。Kubernetes CSI [驱动程序列表](https://kubernetes-csi.github.io/docs/drivers.html) 显示了支持临时卷的驱动程序。

从概念上讲，CSI 临时卷类似于 ​`configMap`​、​`downwardAPI` ​和 ​`secret` ​类型的卷： 其存储在每个节点本地管理，并在将 Pod 调度到节点后与其他本地资源一起创建。 在这个阶段，Kubernetes 没有重新调度 Pods 的概念。卷创建不太可能失败，否则 Pod 启动将会受阻。 特别是，这些卷 不 支持感知存储容量的 Pod 调度。 它们目前也没包括在 Pod 的存储资源使用限制中，因为 kubelet 只能对它自己管理的存储强制执行。

下面是使用 CSI 临时存储的 Pod 的示例清单：

`kind: Pod apiVersion: v1 metadata:   name: my-csi-app spec:   containers:     - name: my-frontend       image: busybox:1.28       volumeMounts:       - mountPath: "/data"         name: my-csi-inline-vol       command: [ "sleep", "1000000" ]   volumes:     - name: my-csi-inline-vol       csi:         driver: inline.storage.kubernetes.io         volumeAttributes:           foo: bar`

​`volumeAttributes` ​决定驱动程序准备什么样的卷。这些属性特定于每个驱动程序，且没有实现标准化。 有关进一步的说明，请参阅每个 CSI 驱动程序的文档。

CSI 驱动程序限制
----------

FEATURE STATE: Kubernetes v1.21 \[deprecated\]

作为一个集群管理员，你可以使用 PodSecurityPolicy 来控制在 Pod 中可以使用哪些 CSI 驱动程序， 具体则是通过 ​`[allowedCSIDrivers](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/ target=) 字段`​ 指定。

> PodSecurityPolicy 已弃用，并将在 Kubernetes v1.25 版本中移除。

> CSI 临时卷仅有 CSI 驱动程序的一个子集支持。 Kubernetes CSI [驱动列表](https://kubernetes-csi.github.io/docs/drivers.html)显示了哪些驱动程序支持临时卷。

通用临时卷 
------

FEATURE STATE: Kubernetes v1.23 \[stable\]

通用临时卷类似于 ​`emptyDir` ​卷，因为它为每个 Pod 提供临时数据存放目录， 在最初制备完毕时一般为空。不过通用临时卷也有一些额外的功能特性：

*   存储可以是本地的，也可以是网络连接的。
*   卷可以有固定的大小，pod不能超量使用。
*   卷可能有一些初始数据，这取决于驱动程序和参数。
*   当驱动程序支持，卷上的典型操作将被支持，包括 （快照、 克隆、 调整大小和 存储容量跟踪）。

示例：

`kind: Pod apiVersion: v1 metadata:   name: my-app spec:   containers:     - name: my-frontend       image: busybox:1.28       volumeMounts:       - mountPath: "/scratch"         name: scratch-volume       command: [ "sleep", "1000000" ]   volumes:     - name: scratch-volume       ephemeral:         volumeClaimTemplate:           metadata:             labels:               type: my-frontend-volume           spec:             accessModes: [ "ReadWriteOnce" ]             storageClassName: "scratch-storage-class"             resources:               requests:                 storage: 1Gi`

生命周期和 PersistentVolumeClaim 
----------------------------

关键的设计思想是在 Pod 的卷来源中允许使用 卷申领的参数。 PersistentVolumeClaim 的标签、注解和整套字段集均被支持。 创建这样一个 Pod 后， 临时卷控制器在 Pod 所属的命名空间中创建一个实际的 PersistentVolumeClaim 对象， 并确保删除 Pod 时，同步删除 PersistentVolumeClaim。

如上设置将触发卷的绑定与/或准备操作，相应动作或者在 StorageClass 使用即时卷绑定时立即执行， 或者当 Pod 被暂时性调度到某节点时执行 (​`WaitForFirstConsumer` ​卷绑定模式)。 对于常见的临时卷，建议采用后者，这样调度器就可以自由地为 Pod 选择合适的节点。 对于即时绑定，调度器则必须选出一个节点，使得在卷可用时，能立即访问该卷。

就资源所有权而言， 拥有通用临时存储的 Pod 是提供临时存储 (ephemeral storage) 的 PersistentVolumeClaim 的所有者。 当 Pod 被删除时，Kubernetes 垃圾收集器会删除 PVC， 然后 PVC 通常会触发卷的删除，因为存储类的默认回收策略是删除卷。 你可以使用带有 ​`retain` ​回收策略的 StorageClass 创建准临时 (quasi-ephemeral) 本地存储： 该存储比 Pod 寿命长，在这种情况下，你需要确保单独进行卷清理。

当这些 PVC 存在时，它们可以像其他 PVC 一样使用。 特别是，它们可以被引用作为批量克隆或快照的数据源。 PVC对象还保持着卷的当前状态。

PersistentVolumeClaim 的命名
-------------------------

自动创建的 PVCs 的命名是确定的：此名称是 Pod 名称和卷名称的组合，中间由连字符(​`-`​)连接。 在上面的示例中，PVC 将命名为 ​`my-app-scratch-volume`​ 。 这种确定性命名方式使得与 PVC 交互变得更容易，因为一旦知道 Pod 名称和卷名，就不必搜索它。

这种确定性命名方式也引入了潜在的冲突， 比如在不同的 Pod 之间（名为 “Pod-a” 的 Pod 挂载名为 "scratch" 的卷， 和名为 "pod" 的 Pod 挂载名为 “a-scratch” 的卷，这两者均会生成名为 "pod-a-scratch" 的PVC），或者在 Pod 和手工创建的 PVC 之间。

以下冲突会被检测到：如果 PVC 是为 Pod 创建的，那么它只用于临时卷。 此检测基于所有权关系。现有的 PVC 不会被覆盖或修改。 但这并不能解决冲突，因为如果没有正确的 PVC，Pod 就无法启动。

> 当命名 Pods 和卷出现在同一个命名空间中时，要小心，以防止发生此类冲突。

安全
--

启用 GenericEphemeralVolume 特性会导致那些没有 PVCs 创建权限的用户， 在创建 Pods 时，被允许间接的创建 PVCs。 集群管理员必须意识到这一点。 如果这不符合他们的安全模型，他们有如下选择：

*   通过特性门控显式禁用该特性。
*   使用一个准入 Webhook 拒绝包含通用临时卷的 Pods。
*   当 ​`volumes` ​列表不包含 ​`ephemeral` ​卷类型时，使用 Pod 安全策略。 （这一方式在 Kubernetes 1.21 版本已经弃用）

为 PVC 卷所设置的逐名字空间的配额 仍然有效，因此即使允许用户使用这种新机制，他们也不能使用它来规避其他策略。

##  5.  Kubernetes 存储类
介绍
--

StorageClass 为管理员提供了描述存储 "类" 的方法。 不同的类型可能会映射到不同的服务质量等级或备份策略，或是由集群管理员制定的任意策略。 Kubernetes 本身并不清楚各种类代表的什么。这个类的概念在其他存储系统中有时被称为 "配置文件"。

StorageClass 资源
---------------

每个 StorageClass 都包含 ​`provisioner`​、​`parameters` ​和 ​`reclaimPolicy` ​字段， 这些字段会在 StorageClass 需要动态分配 PersistentVolume 时会使用到。

StorageClass 对象的命名很重要，用户使用这个命名来请求生成一个特定的类。 当创建 StorageClass 对象时，管理员设置 StorageClass 对象的命名和其他参数，一旦创建了对象就不能再对其更新。

管理员可以为没有申请绑定到特定 StorageClass 的 PVC 指定一个默认的存储类。

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   name: standard provisioner: kubernetes.io/aws-ebs parameters:   type: gp2 reclaimPolicy: Retain allowVolumeExpansion: true mountOptions:   - debug volumeBindingMode: Immediate`

### 存储制备器 

每个 StorageClass 都有一个制备器（Provisioner），用来决定使用哪个卷插件制备 PV。 该字段必须指定。

卷插件

内置制备器

配置例子

AWSElasticBlockStore

✓

AWS EBS

AzureFile

✓

Azure File

AzureDisk

✓

Azure Disk

CephFS

\-

\-

Cinder

✓

OpenStack Cinder

FC

\-

\-

FlexVolume

\-

\-

Flocker

✓

\-

GCEPersistentDisk

✓

GCE PD

Glusterfs

✓

Glusterfs

iSCSI

\-

\-

Quobyte

✓

Quobyte

NFS

\-

NFS

RBD

✓

Ceph RBD

VsphereVolume

✓

vSphere

PortworxVolume

✓

Portworx Volume

ScaleIO

✓

ScaleIO

StorageOS

✓

StorageOS

Local

\-

Local

你不限于指定此处列出的 "内置" 制备器（其名称前缀为 "kubernetes.io" 并打包在 Kubernetes 中）。 你还可以运行和指定外部制备器，这些独立的程序遵循由 Kubernetes 定义的 [规范](https://github.com/kubernetes/design-proposals-archive/blob/main/storage/volume-provisioning.md)。 外部供应商的作者完全可以自由决定他们的代码保存于何处、打包方式、运行方式、使用的插件（包括 Flex）等。 代码仓库 [kubernetes-sigs/sig-storage-lib-external-provisioner](https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner) 包含一个用于为外部制备器编写功能实现的类库。你可以访问代码仓库  [kubernetes-sigs/sig-storage-lib-external-provisioner](https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner) 了解外部驱动列表。

例如，NFS 没有内部制备器，但可以使用外部制备器。 也有第三方存储供应商提供自己的外部制备器。

### 回收策略

由 StorageClass 动态创建的 PersistentVolume 会在类的 ​`reclaimPolicy` ​字段中指定回收策略，可以是 ​`Delete` ​或者 ​`Retain`​。如果 StorageClass 对象被创建时没有指定 ​`reclaimPolicy`​，它将默认为 ​`Delete`​。

通过 StorageClass 手动创建并管理的 PersistentVolume 会使用它们被创建时指定的回收政策。

### 允许卷扩展

FEATURE STATE: Kubernetes v1.11 \[beta\]

PersistentVolume 可以配置为可扩展。将此功能设置为 ​`true` ​时，允许用户通过编辑相应的 PVC 对象来调整卷大小。

当下层 StorageClass 的 ​`allowVolumeExpansion` ​字段设置为 true 时，以下类型的卷支持卷扩展。

卷类型

Kubernetes 版本要求

gcePersistentDisk

1.11

awsElasticBlockStore

1.11

Cinder

1.11

glusterfs

1.11

rbd

1.11

Azure File

1.11

Azure Disk

1.11

Portworx

1.11

FlexVolume

1.13

CSI

1.14 (alpha), 1.16 (beta)

> 此功能仅可用于扩容卷，不能用于缩小卷。

### 挂载选项

由 StorageClass 动态创建的 PersistentVolume 将使用类中 ​`mountOptions` ​字段指定的挂载选项。

如果卷插件不支持挂载选项，却指定了挂载选项，则制备操作会失败。 挂载选项在 StorageClass 和 PV 上都不会做验证，如果其中一个挂载选项无效，那么这个 PV 挂载操作就会失败。

### 卷绑定模式

​`volumeBindingMode` ​字段控制了卷绑定和动态制备 应该发生在什么时候。

默认情况下，​`Immediate` ​模式表示一旦创建了 PersistentVolumeClaim 也就完成了卷绑定和动态制备。 对于由于拓扑限制而非集群所有节点可达的存储后端，PersistentVolume 会在不知道 Pod 调度要求的情况下绑定或者制备。

集群管理员可以通过指定 ​`WaitForFirstConsumer` ​模式来解决此问题。 该模式将延迟 PersistentVolume 的绑定和制备，直到使用该 PersistentVolumeClaim 的 Pod 被创建。 PersistentVolume 会根据 Pod 调度约束指定的拓扑来选择或制备。这些包括但不限于 资源需求、 节点筛选器、 pod 亲和性和互斥性、 以及污点和容忍度。

以下插件支持动态供应的 ​`WaitForFirstConsumer` ​模式:

*   AWSElasticBlockStore
*   GCEPersistentDisk
*   AzureDisk

以下插件支持预创建绑定 PersistentVolume 的 ​`WaitForFirstConsumer` ​模式：

*   上述全部
*   Local

FEATURE STATE: Kubernetes v1.17 \[stable\]

动态配置和预先创建的 PV 也支持 CSI卷， 但是你需要查看特定 CSI 驱动程序的文档以查看其支持的拓扑键名和例子。

> 如果你选择使用 ​`WaitForFirstConsumer`​，请不要在 Pod 规约中使用 ​`nodeName` ​来指定节点亲和性。 如果在这种情况下使用 ​`nodeName`​，Pod 将会绕过调度程序，PVC 将停留在 ​`pending` ​状态。  
> 相反，在这种情况下，你可以使用节点选择器作为主机名，如下所示

`apiVersion: v1 kind: Pod metadata:   name: task-pv-pod spec:   nodeSelector:     kubernetes.io/hostname: kube-01   volumes:     - name: task-pv-storage       persistentVolumeClaim:         claimName: task-pv-claim   containers:     - name: task-pv-container       image: nginx       ports:         - containerPort: 80           name: "http-server"       volumeMounts:         - mountPath: "/usr/share/nginx/html"           name: task-pv-storage`

### 允许的拓扑结构 

FEATURE STATE: Kubernetes v1.12 \[beta\]

当集群操作人员使用了 ​`WaitForFirstConsumer` ​的卷绑定模式， 在大部分情况下就没有必要将制备限制为特定的拓扑结构。 然而，如果还有需要的话，可以使用 ​`allowedTopologies`​。

这个例子描述了如何将供应卷的拓扑限制在特定的区域，在使用时应该根据插件 支持情况替换 ​`zone` ​和 ​`zones` ​参数。

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   name: standard provisioner: kubernetes.io/gce-pd parameters:   type: pd-standard volumeBindingMode: WaitForFirstConsumer allowedTopologies: - matchLabelExpressions:   - key: failure-domain.beta.kubernetes.io/zone     values:     - us-central-1a     - us-central-1b`

参数
--

Storage Classes 的参数描述了存储类的卷。取决于制备器，可以接受不同的参数。 例如，参数 type 的值 io1 和参数 iopsPerGB 特定于 EBS PV。 当参数被省略时，会使用默认值。

一个 StorageClass 最多可以定义 512 个参数。这些参数对象的总长度不能 超过 256 KiB, 包括参数的键和值。

### AWS EBS

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   name: slow provisioner: kubernetes.io/aws-ebs parameters:   type: io1   iopsPerGB: "10"   fsType: ext4`

*   ​`type`​：​`io1`​，​`gp2`​，​`sc1`​，​`st1`​。详细信息参见 [AWS 文档](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html)。默认值：​`gp2`​。
*   ​`zone`​(弃用)：AWS 区域。如果没有指定 ​`zone` ​和 ​`zones`​， 通常卷会在 Kubernetes 集群节点所在的活动区域中轮询调度分配。 ​`zone` ​和 ​`zones` ​参数不能同时使用。
*   ​`zones`​(弃用)：以逗号分隔的 AWS 区域列表。 如果没有指定 ​`zone` ​和 ​`zones`​，通常卷会在 Kubernetes 集群节点所在的 活动区域中轮询调度分配。​`zone`​和​`zones`​参数不能同时使用。
*   ​`iopsPerGB`​：只适用于 ​`io1` ​卷。每 GiB 每秒 I/O 操作。 AWS 卷插件将其与请求卷的大小相乘以计算 IOPS 的容量， 并将其限制在 20000 IOPS（AWS 支持的最高值，请参阅 [AWS 文档](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html)。 这里需要输入一个字符串，即 ​`"10"`​，而不是 ​`10`​。
*   ​`fsType`​：受 Kubernetes 支持的文件类型。默认值：​`"ext4"`​。
*   ​`encrypted`​：指定 EBS 卷是否应该被加密。合法值为 ​`"true"`​ 或者 ​`"false"`​。 这里需要输入字符串，即 ​`"true"`​, 而非 ​`true`​。
*   ​`kmsKeyId`​：可选。加密卷时使用密钥的完整 Amazon 资源名称。 如果没有提供，但 ​`encrypted` ​值为 true，AWS 生成一个密钥。关于有效的 ARN 值，请参阅 AWS 文档。

> ​`zone` ​和 ​`zones` ​已被弃用并被 允许的拓扑结构 取代。

### GCE PD 

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   name: slow provisioner: kubernetes.io/gce-pd parameters:   type: pd-standard    fstype: ext4   replication-type: none`

*   ​`type`​：​`pd-standard`​ 或者 ​`pd-ssd`​。默认：​`pd-standard` ​
*   ​`zone`​(弃用)：GCE 区域。如果没有指定 ​`zone` ​和 ​`zones`​，通常 卷会在 Kubernetes 集群节点所在的活动区域中轮询调度分配。 ​`zone` ​和 ​`zones` ​参数不能同时使用。
*   ​`zones`​(弃用)：逗号分隔的 GCE 区域列表。如果没有指定 ​`zone` ​和 ​`zones`​， 通常卷会在 Kubernetes 集群节点所在的活动区域中轮询调度（round-robin）分配。 ​`zone` ​和 ​`zones` ​参数不能同时使用。
*   ​`fstype`​: ​`ext4` ​或 ​`xfs`​。 默认: ​`ext4`​。宿主机操作系统必须支持所定义的文件系统类型。
*   ​`replication-type`​：​`none` ​或者 ​`regional-pd`​。默认值：​`none`​。

如果 ​`replication-type`​ 设置为 ​`none`​，会制备一个常规（当前区域内的）持久化磁盘。

如果 ​`replication-type`​ 设置为 ​`regional-pd`​，会制备一个 [区域性持久化磁盘（Regional Persistent Disk）](https://cloud.google.com/compute/docs/disks/ target=)。

强烈建议设置 ​`volumeBindingMode: WaitForFirstConsumer`​，这样设置后， 当你创建一个 Pod，它使用的 PersistentVolumeClaim 使用了这个 StorageClass， 区域性持久化磁盘会在两个区域里制备。 其中一个区域是 Pod 所在区域。 另一个区域是会在集群管理的区域中任意选择。磁盘区域可以通过 ​`allowedTopologies` ​加以限制。

> ​`zone` ​和 ​`zones` ​已被弃用并被 allowedTopologies 取代。

### Glusterfs

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   name: slow provisioner: kubernetes.io/glusterfs parameters:   resturl: "http://127.0.0.1:8081"   clusterid: "630372ccdc720a92c681fb928f27b53f"   restauthenabled: "true"   restuser: "admin"   secretNamespace: "default"   secretName: "heketi-secret"   gidMin: "40000"   gidMax: "50000"   volumetype: "replicate:3"`

*   ​`resturl`​：制备 gluster 卷的需求的 Gluster REST 服务/Heketi 服务 url。 通用格式应该是 ​`IPaddress:Port`​，这是 GlusterFS 动态制备器的必需参数。 如果 Heketi 服务在 OpenShift/kubernetes 中安装并暴露为可路由服务，则可以使用类似于 ​`http://heketi-storage-project.cloudapps.mystorage.com`​ 的格式，其中 fqdn 是可解析的 heketi 服务网址。
*   ​`restauthenabled`​：Gluster REST 服务身份验证布尔值，用于启用对 REST 服务器的身份验证。 如果此值为 'true'，则必须填写 ​`restuser` ​和 ​`restuserkey` ​或 ​`secretNamespace` ​+ ​`secretName`​。 此选项已弃用，当在指定 ​`restuser`​、​`restuserkey`​、​`secretName` ​或 ​`secretNamespace` ​时，身份验证被启用。
*   ​`restuser`​：在 Gluster 可信池中有权创建卷的 Gluster REST服务/Heketi 用户。
*   ​`restuserkey`​：Gluster REST 服务/Heketi 用户的密码将被用于对 REST 服务器进行身份验证。 此参数已弃用，取而代之的是 ​`secretNamespace` ​+ ​`secretName`​。
*   ​`secretNamespace`​，​`secretName`​：Secret 实例的标识，包含与 Gluster REST 服务交互时使用的用户密码。 这些参数是可选的，​`secretNamespace` ​和 ​`secretName` ​都省略时使用空密码。 所提供的 Secret 必须将类型设置为 "kubernetes.io/glusterfs"，例如以这种方式创建：

`kubectl create secret generic heketi-secret \   --type="kubernetes.io/glusterfs" --from-literal=key='opensesame' \   --namespace=default`

Secret 的例子可以在 [glusterfs-provisioning-secret.yaml](https://github.com/kubernetes/examples/blob/master/staging/persistent-volume-provisioning/glusterfs/glusterfs-secret.yaml) 中找到。

*   ​`clusterid`​：​`630372ccdc720a92c681fb928f27b53f`​ 是集群的 ID，当制备卷时， Heketi 将会使用这个文件。它也可以是一个 clusterid 列表，例如： ​`"8452344e2becec931ece4e33c4674e4e,42982310de6c63381718ccfa6d8cf397"`​。这个是可选参数。
*   ​`gidMin`​，​`gidMax`​：StorageClass GID 范围的最小值和最大值。 在此范围（gidMin-gidMax）内的唯一值（GID）将用于动态制备卷。这些是可选的值。 如果不指定，所制备的卷为一个 2000-2147483647 之间的值，这是 gidMin 和 gidMax 的默认值。
*   ​`volumetype`​：卷的类型及其参数可以用这个可选值进行配置。如果未声明卷类型，则 由制备器决定卷的类型。 例如：

*   'Replica volume': ​`volumetype: replicate:3`​ 其中 '3' 是 replica 数量.
*   'Disperse/EC volume': ​`volumetype: disperse:4:2`​ 其中 '4' 是数据，'2' 是冗余数量.
*   'Distribute volume': ​`volumetype: none`​

有关可用的卷类型和管理选项，请参阅 [管理指南](https://access.redhat.com/documentation/en-us/red_hat_gluster_storage/3.1)。

更多相关的参考信息，请参阅 [如何配置 Heketi](https://github.com/heketi/heketi/wiki/Setting-up-the-topology)。

当动态制备持久卷时，Gluster 插件自动创建名为 ​`gluster-dynamic-<claimname>`​ 的端点和无头服务。在 PVC 被删除时动态端点和无头服务会自动被删除。

### NFS

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   name: example-nfs provisioner: example.com/external-nfs parameters:   server: nfs-server.example.com   path: /share   readOnly: "false"`

*   ​`server`​：NFS 服务器的主机名或 IP 地址。
*   ​`path`​：NFS 服务器导出的路径。
*   ​`readOnly`​：是否将存储挂载为只读的标志（默认为 false）。

Kubernetes 不包含内部 NFS 驱动。你需要使用外部驱动为 NFS 创建 StorageClass。 这里有些例子：

*   [NFS Ganesha 服务器和外部驱动](https://github.com/kubernetes-sigs/nfs-ganesha-server-and-external-provisioner)
*   [NFS subdir 外部驱动](https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner)

### OpenStack Cinder 

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   name: gold provisioner: kubernetes.io/cinder parameters:   availability: nova`

*   ​`availability`​：可用区域。如果没有指定，通常卷会在 Kubernetes 集群节点 所在的活动区域中轮转调度。

> FEATURE STATE: Kubernetes 1.11 \[deprecated\]  
> OpenStack 的内部驱动已经被弃用。请使用 [OpenStack 的外部云驱动](https://github.com/kubernetes/cloud-provider-openstack)。

### vSphere

vSphere 存储类有两种制备器

*   CSI 制备器: ​`csi.vsphere.vmware.com` ​
*   vCP 制备器: ​`kubernetes.io/vsphere-volume` ​

树内制备器已经被 弃用。

#### CSI 制备器

vSphere CSI StorageClass 制备器在 Tanzu Kubernetes 集群下运行。示例请参 [vSphere CSI 仓库](https://github.com/kubernetes-sigs/vsphere-csi-driver/blob/master/example/vanilla-k8s-RWM-filesystem-volumes/example-sc.yaml)。

#### vCP 制备器

以下示例使用 VMware Cloud Provider (vCP) StorageClass 调度器

1.  使用用户指定的磁盘格式创建一个 StorageClass。

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   name: fast provisioner: kubernetes.io/vsphere-volume parameters:   diskformat: zeroedthick`

​`diskformat`​: ​`thin`​, ​`zeroedthick` ​和 ​`eagerzeroedthick`​。默认值: ​`"thin"`​。

4.  在用户指定的数据存储上创建磁盘格式的 StorageClass。

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   name: fast provisioner: kubernetes.io/vsphere-volume parameters:     diskformat: zeroedthick     datastore: VSANDatastore`

​`datastore`​：用户也可以在 StorageClass 中指定数据存储。 卷将在 storage class 中指定的数据存储上创建，在这种情况下是 ​`VSANDatastore`​。 该字段是可选的。 如果未指定数据存储，则将在用于初始化 vSphere Cloud Provider 的 vSphere 配置文件中指定的数据存储上创建该卷。

7.  Kubernetes 中的存储策略管理

*   使用现有的 vCenter SPBM 策略
vSphere 用于存储管理的最重要特性之一是基于策略的管理。 基于存储策略的管理（SPBM）是一个存储策略框架，提供单一的统一控制平面的 跨越广泛的数据服务和存储解决方案。 SPBM 使能 vSphere 管理员克服先期的存储配置挑战，如容量规划，差异化服务等级和管理容量空间。 SPBM 策略可以在 StorageClass 中使用 ​`storagePolicyName` ​参数声明。*   Kubernetes 内的 Virtual SAN 策略支持
Vsphere Infrastructure（VI）管理员将能够在动态卷配置期间指定自定义 Virtual SAN 存储功能。你现在可以在动态制备卷期间以存储能力的形式定义存储需求，例如性能和可用性。 存储能力需求会转换为 Virtual SAN 策略，之后当持久卷（虚拟磁盘）被创建时， 会将其推送到 Virtual SAN 层。虚拟磁盘分布在 Virtual SAN 数据存储中以满足要求。 你可以参考[基于存储策略的动态制备卷管理](https://github.com/vmware/)， 进一步了解有关持久卷管理的存储策略的详细信息。

有几个 [vSphere 例子](https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere) 供你在 Kubernetes for vSphere 中尝试进行持久卷管理。

### Ceph RBD 

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   name: fast provisioner: kubernetes.io/rbd parameters:   monitors: 10.16.153.105:6789   adminId: kube   adminSecretName: ceph-secret   adminSecretNamespace: kube-system   pool: kube   userId: kube   userSecretName: ceph-secret-user   userSecretNamespace: default   fsType: ext4   imageFormat: "2"   imageFeatures: "layering"`

*   ​`monitors`​：Ceph monitor，逗号分隔。该参数是必需的。
*   ​`adminId`​：Ceph 客户端 ID，用于在池 ceph 池中创建映像。默认是 "admin"。
*   ​`adminSecret`​：​`adminId` ​的 Secret 名称。该参数是必需的。 提供的 secret 必须有值为 "kubernetes.io/rbd" 的 type 参数。
*   ​`adminSecretNamespace`​：​`adminSecret` ​的命名空间。默认是 "default"。
*   ​`pool`​: Ceph RBD 池. 默认是 "rbd"。
*   ​`userId`​：Ceph 客户端 ID，用于映射 RBD 镜像。默认与 ​`adminId` ​相同。
*   ​`userSecretName`​：用于映射 RBD 镜像的 ​`userId` ​的 Ceph Secret 的名字。 它必须与 PVC 存在于相同的 namespace 中。该参数是必需的。 提供的 secret 必须具有值为 "kubernetes.io/rbd" 的 type 参数，例如以这样的方式创建：

`kubectl create secret generic ceph-secret --type="kubernetes.io/rbd" \   --from-literal=key='QVFEQ1pMdFhPUnQrSmhBQUFYaERWNHJsZ3BsMmNjcDR6RFZST0E9PQ==' \   --namespace=kube-system`
        

*   ​`userSecretNamespace`​：​`userSecretName`​ 的命名空间。
*   ​`fsType`​：Kubernetes 支持的 fsType。默认：​`"ext4"`​。
*   ​`imageFormat`​：Ceph RBD 镜像格式，"1" 或者 "2"。默认值是 "1"。
*   ​`imageFeatures`​：这个参数是可选的，只能在你将 ​`imageFormat` ​设置为 "2" 才使用。 目前支持的功能只是 ​`layering`​。默认是 ""，没有功能打开。

### Quobyte 

FEATURE STATE: Kubernetes v1.22 \[deprecated\]

Quobyte 树内（in-tree）存储插件已弃用， 你可以在 Quobyte CSI 仓库中找到用于树外（out-of-tree）Quobyte 插件的 ​`StorageClass` ​[示例](https://github.com/quobyte/quobyte-csi/blob/master/example/StorageClass.yaml)。

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:    name: slow provisioner: kubernetes.io/quobyte parameters:     quobyteAPIServer: "http://138.68.74.142:7860"     registry: "138.68.74.142:7861"     adminSecretName: "quobyte-admin-secret"     adminSecretNamespace: "kube-system"     user: "root"     group: "root"     quobyteConfig: "BASE"     quobyteTenant: "DEFAULT"`

*   ​`quobyteAPIServer`​：Quobyte API 服务器的格式是 ​`"http(s)://api-server:7860"` ​
*   ​`registry`​：用于挂载卷的 Quobyte 仓库。你可以指定仓库为 ​`<host>:<port>`​ 或者如果你想指定多个 registry，在它们之间添加逗号，例如 ​`<host1>:<port>,<host2>:<port>,<host3>:<port>`​。 主机可以是一个 IP 地址，或者如果你有正在运行的 DNS，你也可以提供 DNS 名称。
*   ​`adminSecretNamespace`​：​`adminSecretName` ​的名字空间。 默认值是 "default"。
*   ​`adminSecretName`​：保存关于 Quobyte 用户和密码的 Secret，用于对 API 服务器进行身份验证。 提供的 secret 必须有值为 "kubernetes.io/quobyte" 的 type 参数和 ​`user` ​与 ​`password` ​的键值， 例如以这种方式创建：

`kubectl create secret generic quobyte-admin-secret \   --type="kubernetes.io/quobyte" --from-literal=key='opensesame' \   --namespace=kube-system`

*   ​`user`​：对这个用户映射的所有访问权限。默认是 "root"。
*   ​`group`​：对这个组映射的所有访问权限。默认是 "nfsnobody"。
*   ​`quobyteConfig`​：使用指定的配置来创建卷。你可以创建一个新的配置， 或者，可以修改 Web 控制台或 quobyte CLI 中现有的配置。默认是 "BASE"。
*   ​`quobyteTenant`​：使用指定的租户 ID 创建/删除卷。这个 Quobyte 租户必须 已经于 Quobyte 中存在。默认是 "DEFAULT"。

### Azure 磁盘

#### Azure Unmanaged Disk Storage Class（非托管磁盘存储类）

`kind: StorageClass apiVersion: storage.k8s.io/v1 metadata:   name: slow provisioner: kubernetes.io/azure-disk parameters:   skuName: Standard_LRS   location: eastus   storageAccount: azure_storage_account_name`

*   ​`skuName`​：Azure 存储帐户 Sku 层。默认为空。
*   ​`location`​：Azure 存储帐户位置。默认为空。
*   ​`storageAccount`​：Azure 存储帐户名称。 如果提供存储帐户，它必须位于与集群相同的资源组中，并且 ​`location` ​是被忽略的。如果未提供存储帐户，则会在与群集相同的资源组中创建新的存储帐户。

#### Azure 磁盘 Storage Class（从 v1.7.2 开始）

`kind: StorageClass apiVersion: storage.k8s.io/v1 metadata:   name: slow provisioner: kubernetes.io/azure-disk parameters:   storageaccounttype: Standard_LRS   kind: managed`

*   ​`storageaccounttype`​：Azure 存储帐户 Sku 层。默认为空。
*   ​`kind`​：可能的值是 ​`shared`​、​`dedicated` ​和 ​`managed`​（默认）。 当 ​`kind` ​的值是 ​`shared` ​时，所有非托管磁盘都在集群的同一个资源组中的几个共享存储帐户中创建。 当 ​`kind` ​的值是 ​`dedicated` ​时，将为在集群的同一个资源组中新的非托管磁盘创建新的专用存储帐户。
*   ​`resourceGroup`​: 指定要创建 Azure 磁盘所属的资源组。必须是已存在的资源组名称。 若未指定资源组，磁盘会默认放入与当前 Kubernetes 集群相同的资源组中。
*   Premium VM 可以同时添加 Standard\_LRS 和 Premium\_LRS 磁盘，而 Standard 虚拟机只能添加 Standard\_LRS 磁盘。
*   托管虚拟机只能连接托管磁盘，非托管虚拟机只能连接非托管磁盘。

### Azure 文件

`kind: StorageClass apiVersion: storage.k8s.io/v1 metadata:   name: azurefile provisioner: kubernetes.io/azure-file parameters:   skuName: Standard_LRS   location: eastus   storageAccount: azure_storage_account_name`

*   ​`skuName`​：Azure 存储帐户 Sku 层。默认为空。
*   ​`location`​：Azure 存储帐户位置。默认为空。
*   ​`storageAccount`​：Azure 存储帐户名称。默认为空。 如果不提供存储帐户，会搜索所有与资源相关的存储帐户，以找到一个匹配 ​`skuName` ​和 ​`location` ​的账号。 如果提供存储帐户，它必须存在于与集群相同的资源组中，​`skuName` ​和 ​`location` ​会被忽略。
*   ​`secretNamespace`​：包含 Azure 存储帐户名称和密钥的密钥的名称空间。 默认值与 Pod 相同。
*   ​`secretName`​：包含 Azure 存储帐户名称和密钥的密钥的名称。 默认值为 ​`azure-storage-account-<accountName>-secret` ​
*   ​`readOnly`​：指示是否将存储安装为只读的标志。默认为 false，表示"读/写"挂载。 该设置也会影响VolumeMounts中的 ​`ReadOnly` ​设置。

在存储制备期间，为挂载凭证创建一个名为 ​`secretName` ​的 Secret。如果集群同时启用了 RBAC 和 控制器角色， 为 ​`system:controller:persistent-volume-binder`​ 的 clusterrole 添加 ​`Secret` ​资源的 ​`create` ​权限。

在多租户上下文中，强烈建议显式设置 ​`secretNamespace` ​的值，否则 其他用户可能会读取存储帐户凭据。

### Portworx 卷 

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   name: portworx-io-priority-high provisioner: kubernetes.io/portworx-volume parameters:   repl: "1"   snap_interval:   "70"   priority_io:  "high"`

*   ​`fs`​：选择的文件系统：​`none/xfs/ext4`​（默认：​`ext4`​）。
*   ​`block_size`​：以 Kbytes 为单位的块大小（默认值：​`32`​）。
*   ​`repl`​：同步副本数量，以复制因子 ​`1..3`​（默认值：​`1`​）的形式提供。 这里需要填写字符串，即，​`"1"`​ 而不是 ​`1`​。
*   ​`io_priority`​：决定是否从更高性能或者较低优先级存储创建卷 ​`high/medium/low`​（默认值：​`low`​）。
*   ​`snap_interval`​：触发快照的时钟/时间间隔（分钟）。 快照是基于与先前快照的增量变化，0 是禁用快照（默认：​`0`​）。 这里需要填写字符串，即，是​ `"70"` ​而不是 ​`70`​。
*   ​`aggregation_level`​：指定卷分配到的块数量，0 表示一个非聚合卷（默认：​`0`​）。 这里需要填写字符串，即，是 ​`"0"` ​而不是 ​`0`​。
*   ​`ephemeral`​：指定卷在卸载后进行清理还是持久化。 ​`emptyDir` ​的使用场景可以将这个值设置为 true ， ​`persistent volumes`​ 的使用场景可以将这个值设置为 false （例如 Cassandra 这样的数据库） ​`true/false`​（默认为 ​`false`​）。这里需要填写字符串，即， 是 ​`"true"` ​而不是 ​`true`​。

### ScaleIO 

`kind: StorageClass apiVersion: storage.k8s.io/v1 metadata:   name: slow provisioner: kubernetes.io/scaleio parameters:   gateway: https://192.168.99.200:443/api   system: scaleio   protectionDomain: pd0   storagePool: sp1   storageMode: ThinProvisioned   secretRef: sio-secret   readOnly: "false"   fsType: xfs`

*   ​`provisioner`​：属性设置为 ​`kubernetes.io/scaleio` ​
*   ​`gateway` ​到 ScaleIO API 网关的地址（必需）
*   ​`system`​：ScaleIO 系统的名称（必需）
*   ​`protectionDomain`​：ScaleIO 保护域的名称（必需）
*   ​`storagePool`​：卷存储池的名称（必需）
*   ​`storageMode`​：存储提供模式：​`ThinProvisioned`​（默认）或 ​`ThickProvisioned` ​
*   ​`secretRef`​：对已配置的 Secret 对象的引用（必需）
*   ​`readOnly`​：指定挂载卷的访问模式（默认为 false）
*   ​`fsType`​：卷的文件系统（默认是 ext4）

ScaleIO Kubernetes 卷插件需要配置一个 Secret 对象。 Secret 必须用 ​`kubernetes.io/scaleio`​ 类型创建，并与引用它的 PVC 所属的名称空间使用相同的值。如下面的命令所示：

`kubectl create secret generic sio-secret --type="kubernetes.io/scaleio" \   --from-literal=username=sioadmin --from-literal=password=d2NABDNjMA== \   --namespace=default`

### StorageOS

`apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   name: fast provisioner: kubernetes.io/storageos parameters:   pool: default   description: Kubernetes volume   fsType: ext4   adminSecretNamespace: default   adminSecretName: storageos-secret`

*   ​`pool`​：制备卷的 StorageOS 分布式容量池的名称。如果未指定，则使用 通常存在的 ​`default` ​池。
*   ​`description`​：指定给动态创建的卷的描述。所有卷描述对于存储类而言都是相同的， 但不同的 storage class 可以使用不同的描述，以区分不同的使用场景。 默认为 ​`Kubernetes volume`​。
*   ​`fsType`​：请求的默认文件系统类型。 请注意，在 StorageOS 中用户定义的规则可以覆盖此值。默认为 ​`ext4` ​
*   ​`adminSecretNamespace`​：API 配置 secret 所在的命名空间。 如果设置了 adminSecretName，则是必需的。
*   ​`adminSecretName`​：用于获取 StorageOS API 凭证的 secret 名称。 如果未指定，则将尝试默认值。

StorageOS Kubernetes 卷插件可以使 Secret 对象来指定用于访问 StorageOS API 的端点和凭据。 只有当默认值已被更改时，这才是必须的。 Secret 必须使用 ​`kubernetes.io/storageos`​ 类型创建，如以下命令：

`kubectl create secret generic storageos-secret \ --type="kubernetes.io/storageos" \ --from-literal=apiAddress=tcp://localhost:5705 \ --from-literal=apiUsername=storageos \ --from-literal=apiPassword=storageos \ --namespace=default`

用于动态制备卷的 Secret 可以在任何名称空间中创建，并通过 ​`adminSecretNamespace` ​参数引用。 预先配置的卷使用的 Secret 必须在与引用它的 PVC 在相同的名称空间中。

### 本地

FEATURE STATE: Kubernetes v1.14 \[stable\]

`kind: StorageClass apiVersion: storage.k8s.io/v1 metadata:   name: local-storage provisioner: kubernetes.io/no-provisioner volumeBindingMode: WaitForFirstConsumer`

本地卷还不支持动态制备，然而还是需要创建 StorageClass 以延迟卷绑定， 直到完成 Pod 的调度。这是由 ​`WaitForFirstConsumer` ​卷绑定模式指定的。

延迟卷绑定使得调度器在为 PersistentVolumeClaim 选择一个合适的 PersistentVolume 时能考虑到所有 Pod 的调度限制。

#  11.  Kubernetes 配置

##  1.  Kubernetes 配置最佳实践
一般配置提示
------

*   定义配置时，请指定最新的稳定 API 版本。
*   在推送到集群之前，配置文件应存储在版本控制中。 这允许你在必要时快速回滚配置更改。 它还有助于集群重新创建和恢复。
*   使用 YAML 而不是 JSON 编写配置文件。虽然这些格式几乎可以在所有场景中互换使用，但 YAML 往往更加用户友好。
*   只要有意义，就将相关对象分组到一个文件中。 一个文件通常比几个文件更容易管理。 请参阅 [guestbook-all-in-one.yaml](https://github.com/kubernetes/examples/blob/master/guestbook/all-in-one/guestbook-all-in-one.yaml) 文件作为此语法的示例。
*   另请注意，可以在目录上调用许多​`kubectl`​命令。 例如，你可以在配置文件的目录中调用​`kubectl apply`​。
*   除非必要，否则不指定默认值：简单的最小配置会降低错误的可能性。
*   将对象描述放在注释中，以便更好地进行内省。

“Naked” Pods 与 ReplicaSet，Deployment 和 Jobs
-------------------------------------------

*   如果可能，不要使用独立的 Pods（即，未绑定到 ReplicaSet 或 Deployment 的 Pod）。 如果节点发生故障，将不会重新调度独立的 Pods。

Deployment 既可以创建一个 ReplicaSet 来确保预期个数的 Pod 始终可用，也可以指定替换 Pod 的策略（例如 RollingUpdate）。 除了一些显式的 ​`restartPolicy: Never`​ 场景外，Deployment 通常比直接创建 Pod 要好得多。Job 也可能是合适的选择。

服务 
---

*   在创建相应的后端工作负载（Deployment 或 ReplicaSet），以及在需要访问它的任何工作负载之前创建 服务。 当 Kubernetes 启动容器时，它提供指向启动容器时正在运行的所有服务的环境变量。 例如，如果存在名为 ​`foo` ​的服务，则所有容器将在其初始环境中获得以下变量。

`FOO_SERVICE_HOST=<the host the Service is running on> FOO_SERVICE_PORT=<the port the Service is running on>`

这确实意味着在顺序上的要求 - 必须在 ​`Pod` ​本身被创建之前创建 ​`Pod` ​想要访问的任何 ​`Service`​， 否则将环境变量不会生效。DNS 没有此限制。

*   一个可选（尽管强烈推荐）的集群插件 是 DNS 服务器。DNS 服务器为新的 ​`Services` ​监视 Kubernetes API，并为每个创建一组 DNS 记录。 如果在整个集群中启用了 DNS，则所有 Pods 应该能够自动对 ​`Services` ​进行名称解析。
*   除非绝对必要，否则不要为 Pod 指定 ​`hostPort`​。 将 Pod 绑定到​`hostPort`​时，它会限制 Pod 可以调度的位置数，因为每个 ​`<hostIP, hostPort, protocol>`​组合必须是唯一的。 如果你没有明确指定 ​`hostIP` ​和 ​`protocol`​，Kubernetes 将使用 ​`0.0.0.0`​ 作为默认 ​`hostIP` ​和 ​`TCP` ​作为默认 ​`protocol`​。

如果你只需要访问端口以进行调试，则可以使用 apiserver proxy或 kubectl port-forward。

如果你明确需要在节点上公开 Pod 的端口，请在使用 ​`hostPort` ​之前考虑使用 NodePort 服务。

*   避免使用 ​`hostNetwork`​，原因与 ​`hostPort` ​相同。
*   当你不需要 ​`kube-proxy`​ 负载均衡时，使用 无头服务(​`ClusterIP` ​被设置为 ​`None`​)以便于服务发现。

使用标签 
-----

*   定义并使用标签来识别应用程序 或 Deployment 的 语义属性，例如​`{ app: myapp, tier: frontend, phase: test, deployment: v3 }`​。 你可以使用这些标签为其他资源选择合适的 Pod； 例如，一个选择所有 ​`tier: frontend`​ Pod 的服务，或者 ​`app: myapp`​ 的所有 ​`phase: test`​ 组件。 有关此方法的示例，请参阅 [guestbook](https://github.com/kubernetes/examples/tree/master/guestbook/) 。

通过从选择器中省略特定发行版的标签，可以使服务跨越多个 Deployment。 当你需要不停机的情况下更新正在运行的服务，可以使用Deployment。

Deployment 描述了对象的期望状态，并且如果对该规范的更改被成功应用， 则 Deployment 控制器以受控速率将实际状态改变为期望状态。

*   对于常见场景，应使用 Kubernetes 通用标签。 这些标准化的标签丰富了对象的元数据，使得包括 ​`kubectl` ​和 仪表板（Dashboard） 这些工具能够以可互操作的方式工作。
*   你可以操纵标签进行调试。 由于 Kubernetes 控制器（例如 ReplicaSet）和服务使用选择器标签来匹配 Pod， 从 Pod 中删除相关标签将阻止其被控制器考虑或由服务提供服务流量。 如果删除现有 Pod 的标签，其控制器将创建一个新的 Pod 来取代它。 这是在"隔离"环境中调试先前"活跃"的 Pod 的有用方法。 要以交互方式删除或添加标签，请使用 [kubectl label](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=)。

使用 kubectl 
-----------

*   使用 ​`kubectl apply -f <directory>`​。 它在 ​`<directory>`​ 中的所有 ​`.yaml`​、​`.yml`​ 和 ​`.json`​ 文件中查找 Kubernetes 配置，并将其传递给 ​`apply`​。
*   使用标签选择器进行 ​`get` ​和 ​`delete` ​操作，而不是特定的对象名称。
*   使用​`kubectl run`​和​`kubectl expose`​来快速创建单容器部署和服务。

##  2.  Kubernetes ConfigMap
ConfigMap
---------

ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时， Pods 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。

ConfigMap 将你的环境配置信息和 容器镜像 解耦，便于应用配置的修改。

> **Caution:**  
> ConfigMap 并不提供保密或者加密功能。 如果你想存储的数据是机密的，请使用 Secret， 或者使用其他第三方工具来保证你的数据的私密性，而不是用 ConfigMap。

动机 
---

使用 ConfigMap 来将你的配置数据和应用程序代码分开。

比如，假设你正在开发一个应用，它可以在你自己的电脑上（用于开发）和在云上 （用于实际流量）运行。 你的代码里有一段是用于查看环境变量 ​`DATABASE_HOST`​，在本地运行时， 你将这个变量设置为 ​`localhost`​，在云上，你将其设置为引用 Kubernetes 集群中的 公开数据库组件的 服务。

这让你可以获取在云中运行的容器镜像，并且如果有需要的话，在本地调试完全相同的代码。

ConfigMap 在设计上不是用来保存大量数据的。在 ConfigMap 中保存的数据不可超过 1 MiB。如果你需要保存超出此尺寸限制的数据，你可能希望考虑挂载存储卷 或者使用独立的数据库或者文件服务。

ConfigMap 对象
------------

ConfigMap 是一个 API 对象， 让你可以存储其他对象所需要使用的配置。 和其他 Kubernetes 对象都有一个 ​`spec` ​不同的是，ConfigMap 使用 ​`data` ​和 ​`binaryData` ​字段。这些字段能够接收键-值对作为其取值。​`data` ​和 ​`binaryData` ​字段都是可选的。​`data` ​字段设计用来保存 UTF-8 字符串，而 ​`binaryData` ​则被设计用来保存二进制数据作为 base64 编码的字串。

ConfigMap 的名字必须是一个合法的 DNS 子域名。

​`data` ​或 ​`binaryData` ​字段下面的每个键的名称都必须由字母数字字符或者 ​`-`​、​`_`​ 或 ​`.`​ 组成。在 data 下保存的键名不可以与在 ​`binaryData` ​下出现的键名有重叠。

从 v1.19 开始，你可以添加一个 ​`immutable` ​字段到 ConfigMap 定义中， 创建不可变更的 ConfigMap。

ConfigMaps 和 Pods
-----------------

你可以写一个引用 ConfigMap 的 Pod 的 ​`spec`​，并根据 ConfigMap 中的数据在该 Pod 中配置容器。这个 Pod 和 ConfigMap 必须要在同一个 名字空间 中。

> ​`Note`​: 静态 Pod 中的 spec 字段不能引用 ConfigMap 或任何其他 API 对象。

这是一个 ConfigMap 的示例，它的一些键只有一个值，其他键的值看起来像是 配置的片段格式。

`apiVersion: v1 kind: ConfigMap metadata:   name: game-demo data:   # 类属性键；每一个键都映射到一个简单的值   player_initial_lives: "3"   ui_properties_file_name: "user-interface.properties"    # 类文件键   game.properties: |     enemy.types=aliens,monsters     player.maximum-lives=5       user-interface.properties: |     color.good=purple     color.bad=yellow     allow.textmode=true`

你可以使用四种方式来使用 ConfigMap 配置 Pod 中的容器：

1.  在容器命令和参数内
2.  容器的环境变量
3.  在只读卷里面添加一个文件，让应用来读取
4.  编写代码在 Pod 中运行，使用 Kubernetes API 来读取 ConfigMap

这些不同的方法适用于不同的数据使用方式。 对前三个方法，kubelet 使用 ConfigMap 中的数据在 Pod 中启动容器。

第四种方法意味着你必须编写代码才能读取 ConfigMap 和它的数据。然而， 由于你是直接使用 Kubernetes API，因此只要 ConfigMap 发生更改， 你的应用就能够通过订阅来获取更新，并且在这样的情况发生的时候做出反应。 通过直接进入 Kubernetes API，这个技术也可以让你能够获取到不同的名字空间里的 ConfigMap。

下面是一个 Pod 的示例，它通过使用 ​`game-demo`​ 中的值来配置一个 Pod：

`apiVersion: v1 kind: Pod metadata:   name: configmap-demo-pod spec:   containers:     - name: demo       image: alpine       command: ["sleep", "3600"]       env:         # 定义环境变量         - name: PLAYER_INITIAL_LIVES # 请注意这里和 ConfigMap 中的键名是不一样的           valueFrom:             configMapKeyRef:               name: game-demo           # 这个值来自 ConfigMap               key: player_initial_lives # 需要取值的键         - name: UI_PROPERTIES_FILE_NAME           valueFrom:             configMapKeyRef:               name: game-demo               key: ui_properties_file_name       volumeMounts:       - name: config         mountPath: "/config"         readOnly: true   volumes:     # 你可以在 Pod 级别设置卷，然后将其挂载到 Pod 内的容器中     - name: config       configMap:         # 提供你想要挂载的 ConfigMap 的名字         name: game-demo         # 来自 ConfigMap 的一组键，将被创建为文件         items:         - key: "game.properties"           path: "game.properties"         - key: "user-interface.properties"           path: "user-interface.properties"`

ConfigMap 不会区分单行属性值和多行类似文件的值，重要的是 Pods 和其他对象如何使用这些值。

上面的例子定义了一个卷并将它作为 ​`/config`​ 文件夹挂载到 ​`demo` ​容器内， 创建两个文件，​`/config/game.properties`​ 和 ​`/config/user-interface.properties`​， 尽管 ConfigMap 中包含了四个键。 这是因为 Pod 定义中在 ​`volumes` ​节指定了一个 ​`items` ​数组。 如果你完全忽略 ​`items` ​数组，则 ConfigMap 中的每个键都会变成一个与该键同名的文件， 因此你会得到四个文件。

使用 ConfigMap 
-------------

ConfigMap 可以作为数据卷挂载。ConfigMap 也可被系统的其他组件使用， 而不一定直接暴露给 Pod。例如，ConfigMap 可以保存系统中其他组件要使用的配置数据。

ConfigMap 最常见的用法是为同一命名空间里某 Pod 中运行的容器执行配置。 你也可以单独使用 ConfigMap。

比如，你可能会遇到基于 ConfigMap 来调整其行为的 插件 或者 operator。

### 在 Pod 中将 ConfigMap 当做文件使用

要在一个 Pod 的存储卷中使用 ConfigMap:

1.  创建一个 ConfigMap 对象或者使用现有的 ConfigMap 对象。多个 Pod 可以引用同一个 ConfigMap。
2.  修改 Pod 定义，在 ​`spec.volumes[]`​ 下添加一个卷。 为该卷设置任意名称，之后将 ​`spec.volumes[].configMap.name`​ 字段设置为对你的 ConfigMap 对象的引用。
3.  为每个需要该 ConfigMap 的容器添加一个 ​`.spec.containers[].volumeMounts[]`​。 设置 ​`.spec.containers[].volumeMounts[].readOnly=true`​ 并将 ​`.spec.containers[].volumeMounts[].mountPath`​ 设置为一个未使用的目录名， ConfigMap 的内容将出现在该目录中。
4.  更改你的镜像或者命令行，以便程序能够从该目录中查找文件。ConfigMap 中的每个 ​`data` ​键会变成 ​`mountPath` ​下面的一个文件名。

下面是一个将 ConfigMap 以卷的形式进行挂载的 Pod 示例：

`apiVersion: v1 kind: Pod metadata:   name: mypod spec:   containers:   - name: mypod     image: redis     volumeMounts:     - name: foo       mountPath: "/etc/foo"       readOnly: true   volumes:   - name: foo     configMap:       name: myconfigmap`

你希望使用的每个 ConfigMap 都需要在 ​`spec.volumes`​ 中被引用到。

如果 Pod 中有多个容器，则每个容器都需要自己的 ​`volumeMounts` ​块，但针对每个 ConfigMap，你只需要设置一个 ​`spec.volumes`​ 块

#### 被挂载的 ConfigMap 内容会被自动更新

当卷中使用的 ConfigMap 被更新时，所投射的键最终也会被更新。 kubelet 组件会在每次周期性同步时检查所挂载的 ConfigMap 是否为最新。 不过，kubelet 使用的是其本地的高速缓存来获得 ConfigMap 的当前值。 高速缓存的类型可以通过 KubeletConfiguration 结构. 的 ​`ConfigMapAndSecretChangeDetectionStrategy` ​字段来配置。

ConfigMap 既可以通过 watch 操作实现内容传播（默认形式），也可实现基于 TTL 的缓存，还可以直接经过所有请求重定向到 API 服务器。 因此，从 ConfigMap 被更新的那一刻算起，到新的主键被投射到 Pod 中去， 这一时间跨度可能与 kubelet 的同步周期加上高速缓存的传播延迟相等。 这里的传播延迟取决于所选的高速缓存类型 （分别对应 watch 操作的传播延迟、高速缓存的 TTL 时长或者 0）。

以环境变量方式使用的 ConfigMap 数据不会被自动更新。 更新这些数据需要重新启动 Pod。

> Note: 使用 ConfigMap 作为 subPath 卷挂载的容器将不会收到 ConfigMap 的更新。

不可变更的 ConfigMap 
----------------

FEATURE STATE: Kubernetes v1.21 \[stable\]

Kubernetes 特性 Immutable Secret 和 ConfigMaps 提供了一种将各个 Secret 和 ConfigMap 设置为不可变更的选项。对于大量使用 ConfigMap 的集群 （至少有数万个各不相同的 ConfigMap 给 Pod 挂载）而言，禁止更改 ConfigMap 的数据有以下好处：

*   保护应用，使之免受意外（不想要的）更新所带来的负面影响。
*   通过大幅降低对 kube-apiserver 的压力提升集群性能， 这是因为系统会关闭对已标记为不可变更的 ConfigMap 的监视操作。

此功能特性由 ​`ImmutableEphemeralVolumes` ​特性门控来控制。 你可以通过将 ​`immutable` ​字段设置为 ​`true` ​创建不可变更的 ConfigMap。 例如：

`apiVersion: v1 kind: ConfigMap metadata:   ... data:   ... immutable: true`

一旦某 ConfigMap 被标记为不可变更，则 无法 逆转这一变化，，也无法更改 ​`data` ​或 ​`binaryData` ​字段的内容。你只能删除并重建 ConfigMap。 因为现有的 Pod 会维护一个已被删除的 ConfigMap 的挂载点，建议重新创建这些 Pods。

##  3.  Kubernetes Secret
Secret
------

Secret 是一种包含少量敏感信息例如密码、令牌或密钥的对象。 这样的信息可能会被放在 Pod 规约中或者镜像中。 使用 Secret 意味着你不需要在应用程序代码中包含机密数据。

由于创建 Secret 可以独立于使用它们的 Pod， 因此在创建、查看和编辑 Pod 的工作流程中暴露 Secret（及其数据）的风险较小。 Kubernetes 和在集群中运行的应用程序也可以对 Secret 采取额外的预防措施， 例如避免将机密数据写入非易失性存储。

Secret 类似于 ConfigMap 但专门用于保存机密数据。

> Caution:  
> 默认情况下，Kubernetes Secret 未加密地存储在 API 服务器的底层数据存储（etcd）中。 任何拥有 API 访问权限的人都可以检索或修改 Secret，任何有权访问 etcd 的人也可以。 此外，任何有权限在命名空间中创建 Pod 的人都可以使用该访问权限读取该命名空间中的任何 Secret； 这包括间接访问，例如创建 Deployment 的能力。  
> 为了安全地使用 Secret，请至少执行以下步骤：  
> 
> 1.  为 Secret 启用静态加密；
> 2.  启用或配置 RBAC 规则来限制读取和写入 Secret 的数据（包括通过间接方式）。需要注意的是，被准许创建 Pod 的人也隐式地被授权获取 Secret 内容。
> 3.  在适当的情况下，还可以使用 RBAC 等机制来限制允许哪些主体创建新 Secret 或替换现有 Secret。

Secret 的使用
----------

Pod 可以用三种方式之一来使用 Secret：

*   作为挂载到一个或多个容器上的卷 中的文件。
*   作为容器的环境变量。
*   由 kubelet 在为 Pod 拉取镜像时使用。

Kubernetes 控制面也使用 Secret； 例如，引导令牌 Secret 是一种帮助自动化节点注册的机制。

### Secret 的替代方案 

除了使用 Secret 来保护机密数据，你也可以选择一些替代方案。

下面是一些选项：

*   如果你的云原生组件需要执行身份认证来访问你所知道的、在同一 Kubernetes 集群中运行的另一个应用， 你可以使用 ServiceAccount 及其令牌来标识你的客户端身份。
*   你可以运行的第三方工具也有很多，这些工具可以运行在集群内或集群外，提供机密数据管理。 例如，这一工具可能是 Pod 通过 HTTPS 访问的一个服务，该服务在客户端能够正确地通过身份认证 （例如，通过 ServiceAccount 令牌）时，提供机密数据内容。
*   就身份认证而言，你可以为 X.509 证书实现一个定制的签名者，并使用 CertificateSigningRequest 来让该签名者为需要证书的 Pod 发放证书。
*   你可以使用一个设备插件 来将节点本地的加密硬件暴露给特定的 Pod。例如，你可以将可信任的 Pod 调度到提供可信平台模块（Trusted Platform Module，TPM）的节点上。 这类节点是另行配置的。

你还可以将如上选项的两种或多种进行组合，包括直接使用 Secret 对象本身也是一种选项。

例如：实现（或部署）一个 operator， 从外部服务取回生命期很短的会话令牌，之后基于这些生命期很短的会话令牌来创建 Secret。 运行在集群中的 Pod 可以使用这些会话令牌，而 Operator 则确保这些令牌是合法的。 这种责权分离意味着你可以运行那些不了解会话令牌如何发放与刷新的确切机制的 Pod。

使用 Secret 
----------

### 创建 Secret

*   使用 kubectl 命令来创建 Secret
*   基于配置文件来创建 Secret
*   使用 kustomize 来创建 Secret

#### 对 Secret 名称与数据的约束

Secret 对象的名称必须是合法的 DNS 子域名。

在为创建 Secret 编写配置文件时，你可以设置 ​`data` ​与/或 ​`stringData` ​字段。 ​`data` ​和 ​`stringData` ​字段都是可选的。​`data` ​字段中所有键值都必须是 base64 编码的字符串。如果不希望执行这种 base64 字符串的转换操作，你可以选择设置 ​`stringData` ​字段，其中可以使用任何字符串作为其取值。

​`data` ​和 ​`stringData` ​中的键名只能包含字母、数字、​`-`​、​`_`​ 或 ​`.`​ 字符。 ​`stringData` ​字段中的所有键值对都会在内部被合并到 ​`data` ​字段中。 如果某个主键同时出现在 ​`data` ​和 ​`stringData` ​字段中，​`stringData` ​所指定的键值具有高优先级。

#### 尺寸限制 

每个 Secret 的尺寸最多为 1MiB。施加这一限制是为了避免用户创建非常大的 Secret， 进而导致 API 服务器和 kubelet 内存耗尽。不过创建很多小的 Secret 也可能耗尽内存。 你可以使用资源配额来约束每个名字空间中 Secret（或其他资源）的个数。

### 编辑 Secret 

你可以使用 kubectl 来编辑一个已有的 Secret：

`kubectl edit secrets mysecret`

这一命令会启动你的默认编辑器，允许你更新 ​`data` ​字段中存放的 base64 编码的 Secret 值； 例如：

`# Please edit the object below. Lines beginning with a '#' will be ignored, # and an empty file will abort the edit. If an error occurs while saving this file, it will be # reopened with the relevant failures. # apiVersion: v1 data:   username: YWRtaW4=   password: MWYyZDFlMmU2N2Rm kind: Secret metadata:   annotations:     kubectl.kubernetes.io/last-applied-configuration: { ... }   creationTimestamp: 2020-01-22T18:41:56Z   name: mysecret   namespace: default   resourceVersion: "164619"   uid: cfee02d6-c137-11e5-8d73-42010af00002 type: Opaque`

这一示例清单定义了一个 Secret，其 ​`data` ​字段中包含两个主键：​`username` ​和 ​`password`​。 清单中的字段值是 Base64 字符串，不过，当你在 Pod 中使用 Secret 时，kubelet 为 Pod 及其中的容器提供的是解码后的数据。

你可以在一个 Secret 中打包多个主键和数值，也可以选择使用多个 Secret， 完全取决于哪种方式最方便。

### 使用 Secret 

Secret 可以以数据卷的形式挂载，也可以作为环境变量 暴露给 Pod 中的容器使用。Secret 也可用于系统中的其他部分，而不是一定要直接暴露给 Pod。 例如，Secret 也可以包含系统中其他部分在替你与外部系统交互时要使用的凭证数据。

Kubernetes 会检查 Secret 的卷数据源，确保所指定的对象引用确实指向类型为 Secret 的对象。因此，如果 Pod 依赖于某 Secret，该 Secret 必须先于 Pod 被创建。

如果 Secret 内容无法取回（可能因为 Secret 尚不存在或者临时性地出现 API 服务器网络连接问题），kubelet 会周期性地重试 Pod 运行操作。kubelet 也会为该 Pod 报告 Event 事件，给出读取 Secret 时遇到的问题细节。

#### 可选的 Secret 

当你定义一个基于 Secret 的环境变量时，你可以将其标记为可选。 默认情况下，所引用的 Secret 都是必需的。

只有所有非可选的 Secret 都可用时，Pod 中的容器才能启动运行。

如果 Pod 引用了 Secret 中的特定主键，而虽然 Secret 本身存在，对应的主键不存在， Pod 启动也会失败。

### 在 Pod 中以文件形式使用 Secret 

如果你希望在 Pod 中访问 Secret 内的数据，一种方式是让 Kubernetes 将 Secret 以 Pod 中一个或多个容器的文件系统中的文件的形式呈现出来。

要配置这种行为，你需要：

1.  创建一个 Secret 或者使用已有的 Secret。多个 Pod 可以引用同一个 Secret。
2.  更改 Pod 定义，在 ​`.spec.volumes[]`​ 下添加一个卷。根据需要为卷设置其名称， 并将 ​`.spec.volumes[].secret.secretName`​ 字段设置为 Secret 对象的名称。
3.  为每个需要该 Secret 的容器添加 ​`.spec.containers[].volumeMounts[]`​。 并将 ​`.spec.containers[].volumeMounts[].readyOnly`​ 设置为 ​`true`​， 将 ​`.spec.containers[].volumeMounts[].mountPath`​ 设置为希望 Secret 被放置的、目前尚未被使用的路径名。
4.  更改你的镜像或命令行，以便程序读取所设置的目录下的文件。Secret 的 ​`data`​ 映射中的每个主键都成为 ​`mountPath` ​下面的文件名。

下面是一个通过卷来挂载名为 ​`mysecret` ​的 Secret 的 Pod 示例：

`apiVersion: v1 kind: Pod metadata:   name: mypod spec:   containers:   - name: mypod     image: redis     volumeMounts:     - name: foo       mountPath: "/etc/foo"       readOnly: true   volumes:   - name: foo     secret:       secretName: mysecret       optional: false # 默认设置，意味着 "mysecret" 必须已经存在`

你要访问的每个 Secret 都需要通过 ​`.spec.volumes`​ 来引用。

如果 Pod 中包含多个容器，则每个容器需要自己的 ​`volumeMounts` ​块， 不过针对每个 Secret 而言，只需要一份 ​`.spec.volumes`​ 设置。

> Note:  
> Kubernetes v1.22 版本之前都会自动创建用来访问 Kubernetes API 的凭证。 这一老的机制是基于创建可被挂载到 Pod 中的令牌 Secret 来实现的。 在最近的版本中，包括 Kubernetes v1.24 中，API 凭据是直接通过 TokenRequest API 来获得的，这一凭据会使用投射卷 挂载到 Pod 中。使用这种方式获得的令牌有确定的生命期，并且在挂载它们的 Pod 被删除时自动作废。  
> 你仍然可以手动创建 服务账号令牌。例如，当你需要一个永远都不过期的令牌时。 不过，仍然建议使用 TokenRequest 子资源来获得访问 API 服务器的令牌。

#### 将 Secret 键投射到特定目录

你也可以控制 Secret 键所投射到的卷中的路径。 你可以使用 ​`.spec.volumes[].secret.items`​ 字段来更改每个主键的目标路径：

`apiVersion: v1 kind: Pod metadata:   name: mypod spec:   containers:   - name: mypod     image: redis     volumeMounts:     - name: foo       mountPath: "/etc/foo"       readOnly: true   volumes:   - name: foo     secret:       secretName: mysecret       items:       - key: username         path: my-group/my-username`

将发生的事情如下：

*   ​`mysecret` ​中的键 ​`username` ​会出现在容器中的路径为 ​`/etc/foo/my-group/my-username`​， 而不是​ `/etc/foo/username`​。
*   Secret 对象的 ​`password` ​键不会被投射。

如果使用了 ​`.spec.volumes[].secret.items`​，则只有 ​`items` ​中指定了的主键会被投射。 如果要使用 Secret 中的所有主键，则需要将它们全部枚举到 ​`items` ​字段中。

如果你显式地列举了主键，则所列举的主键都必须在对应的 Secret 中存在。 否则所在的卷不会被创建。

#### Secret 文件的访问权限

你可以为某个 Secret 主键设置 POSIX 文件访问权限位。 如果你不指定访问权限，默认会使用 ​`0644`​。 你也可以为整个 Secret 卷设置默认的访问模式，然后再根据需要在主键层面重载。

例如，你可以像下面这样设置默认的模式：

`apiVersion: v1 kind: Pod metadata:   name: mypod spec:   containers:   - name: mypod     image: redis     volumeMounts:     - name: foo       mountPath: "/etc/foo"   volumes:   - name: foo     secret:       secretName: mysecret       defaultMode: 0400`

该 Secret 被挂载在 ​`/etc/foo`​ 下，Secret 卷挂载所创建的所有文件的访问模式都是 ​`0400`​。

> Note:  
> 如果你是使用 JSON 来定义 Pod 或 Pod 模板，需要注意 JSON 规范不支持八进制的记数方式。 你可以在 ​`defaultMode` ​中设置十进制的值（例如，八进制中的 0400 在十进制中为 256）。 如果你使用 YAML 来编写定义，你可以用八进制值来设置 ​`defaultMode`​。

#### 使用来自卷中的 Secret 值 

在挂载了 Secret 卷的容器内，Secret 的主键都呈现为文件。 Secret 的取值都是 Base64 编码的，保存在这些文件中。

下面是在上例中的容器内执行命令的结果：

`ls /etc/foo/`

输出类似于：

`username password`

`cat /etc/foo/username`

输出类似于：

`admin`

`cat /etc/foo/password`

输出类似于：

`1f2d1e2e67df`

容器中的程序要负责根据需要读取 Secret 数据。

#### 挂载的 Secret 是被自动更新的 

当卷中包含来自 Secret 的数据，而对应的 Secret 被更新，Kubernetes 会跟踪到这一操作并更新卷中的数据。更新的方式是保证最终一致性。

> Note:  
> 对于以 subPath 形式挂载 Secret 卷的容器而言， 它们无法收到自动的 Secret 更新。

Kubelet 组件会维护一个缓存，在其中保存节点上 Pod 卷中使用的 Secret 的当前主键和取值。 你可以配置 kubelet 如何检测所缓存数值的变化。 kubelet 配置中的 ​`configMapAndSecretChangeDetectionStrategy` ​字段控制 kubelet 所采用的策略。 默认的策略是 ​`Watch`​。

对 Secret 的更新操作既可以通过 API 的 watch 机制（默认）来传播， 基于设置了生命期的缓存获取，也可以通过 kubelet 的同步回路来从集群的 API 服务器上轮询获取。

因此，从 Secret 被更新到新的主键被投射到 Pod 中，中间存在一个延迟。 这一延迟的上限是 kubelet 的同步周期加上缓存的传播延迟， 其中缓存的传播延迟取决于所选择的缓存类型。 对应上一段中提到的几种传播机制，延迟时长为 watch 的传播延迟、所配置的缓存 TTL 或者对于直接轮询而言是零。

### 以环境变量的方式使用 Secret

如果需要在 Pod 中以环境变量 的形式使用 Secret：

1.  创建 Secret（或者使用现有 Secret）。多个 Pod 可以引用同一个 Secret。
2.  更改 Pod 定义，在要使用 Secret 键值的每个容器中添加与所使用的主键对应的环境变量。 读取 Secret 主键的环境变量应该在 ​`env[].valueFrom.secretKeyRef`​ 中填写 Secret 的名称和主键名称。
3.  更改你的镜像或命令行，以便程序读取环境变量中保存的值。

下面是一个通过环境变量来使用 Secret 的示例 Pod：

`apiVersion: v1 kind: Pod metadata:   name: secret-env-pod spec:   containers:   - name: mycontainer     image: redis     env:       - name: SECRET_USERNAME         valueFrom:           secretKeyRef:             name: mysecret             key: username             optional: false # 此值为默认值；意味着 "mysecret"                             # 必须存在且包含名为 "username" 的主键       - name: SECRET_PASSWORD         valueFrom:           secretKeyRef:             name: mysecret             key: password             optional: false # 此值为默认值；意味着 "mysecret"                             # 必须存在且包含名为 "password" 的主键   restartPolicy: Never`

#### 非法环境变量 

对于通过 ​`envFrom` ​字段来填充环境变量的 Secret 而言， 如果其中包含的主键不能被当做合法的环境变量名，这些主键会被忽略掉。 Pod 仍然可以启动。

如果你定义的 Pod 中包含非法的变量名称，则 Pod 可能启动失败， 会形成 reason 为 ​`InvalidVariableNames` ​的事件，以及列举被略过的非法主键的消息。 下面的例子中展示了一个 Pod，引用的是名为 ​`mysecret` ​的 Secret， 其中包含两个非法的主键：​`1badkey` ​和 ​`2alsobad`​。

`kubectl get events`

    

输出类似于：

`LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON 0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names.`

#### 通过环境变量使用 Secret 值

在通过环境变量来使用 Secret 的容器中，Secret 主键展现为普通的环境变量。 这些变量的取值是 Secret 数据的 Base64 解码值。

下面是在前文示例中的容器内执行命令的结果：

`echo "$SECRET_USERNAME"`

输出类似于：

`admin`

`echo "$SECRET_PASSWORD"`

输出类似于：

`1f2d1e2e67df`

> Note:  
> 如果容器已经在通过环境变量来使用 Secret，Secret 更新在容器内是看不到的， 除非容器被重启。有一些第三方的解决方案，能够在 Secret 发生变化时触发容器重启。

### 容器镜像拉取 Secret 

如果你尝试从私有仓库拉取容器镜像，你需要一种方式让每个节点上的 kubelet 能够完成与镜像库的身份认证。你可以配置 镜像拉取 Secret 来实现这点。 Secret 是在 Pod 层面来配置的。

Pod 的 ​`imagePullSecrets` ​字段是一个对 Pod 所在的名字空间中的 Secret 的引用列表。你可以使用 ​`imagePullSecrets` ​来将镜像仓库访问凭据传递给 kubelet。 kubelet 使用这个信息来替你的 Pod 拉取私有镜像。

#### 使用 imagePullSecrets

​`imagePullSecrets` ​字段是一个列表，包含对同一名字空间中 Secret 的引用。 你可以使用 ​`imagePullSecrets` ​将包含 Docker（或其他）镜像仓库密码的 Secret 传递给 kubelet。kubelet 使用此信息来替 Pod 拉取私有镜像。

##### 手动设定 imagePullSecret

你可以通过阅读[容器镜像](https://www.w3cschool.cn/kubernetes/kubernetes-x2c93nvr.html?RECACHE=1) 文档了解如何设置 ​`imagePullSecrets`​。

##### 设置 imagePullSecrets 为自动挂载

你可以手动创建 ​`imagePullSecret`​，并在一个 ServiceAccount 中引用它。 对使用该 ServiceAccount 创建的所有 Pod，或者默认使用该 ServiceAccount 创建的 Pod 而言，其 ​`imagePullSecrets` ​字段都会设置为该服务账号。

### 在静态 Pod 中使用 Secret 

你不可以在静态 Pod. 中使用 ConfigMap 或 Secret。

使用场景 
-----

### 使用场景：作为容器环境变量

创建 Secret：

`apiVersion: v1 kind: Secret metadata:   name: mysecret type: Opaque data:   USER_NAME: YWRtaW4=   PASSWORD: MWYyZDFlMmU2N2Rm`

创建 Secret：

`kubectl apply -f mysecret.yaml`

使用 ​`envFrom` ​来将 Secret 的所有数据定义为容器的环境变量。 来自 Secret 的主键成为 Pod 中的环境变量名称：

`apiVersion: v1 kind: Pod metadata:   name: secret-test-pod spec:   containers:     - name: test-container       image: k8s.gcr.io/busybox       command: [ "/bin/sh", "-c", "env" ]       envFrom:       - secretRef:           name: mysecret   restartPolicy: Never`

### 使用场景：带 SSH 密钥的 Pod

创建包含一些 SSH 密钥的 Secret：

`kubectl create secret generic ssh-key-secret --from-file=ssh-privatekey=/path/to/.ssh/id_rsa --from-file=ssh-publickey=/path/to/.ssh/id_rsa.pub`

输出类似于：

`secret "ssh-key-secret" created`

你也可以创建一个 ​`kustomization.yaml`​ 文件，在其 ​`secretGenerator` ​字段中包含 SSH 密钥。

> Caution:  
> 在提供你自己的 SSH 密钥之前要仔细思考：集群的其他用户可能有权访问该 Secret。  
> 你也可以创建一个 SSH 私钥，代表一个你希望与你共享 Kubernetes 集群的其他用户分享的服务标识。 当凭据信息被泄露时，你可以收回该访问权限。

现在你可以创建一个 Pod，在其中访问包含 SSH 密钥的 Secret，并通过卷的方式来使用它：

`apiVersion: v1 kind: Pod metadata:   name: secret-test-pod   labels:     name: secret-test spec:   volumes:   - name: secret-volume     secret:       secretName: ssh-key-secret   containers:   - name: ssh-test-container     image: mySshImage     volumeMounts:     - name: secret-volume       readOnly: true       mountPath: "/etc/secret-volume"`

容器命令执行时，秘钥的数据可以在下面的位置访问到：

`/etc/secret-volume/ssh-publickey /etc/secret-volume/ssh-privatekey`

容器就可以随便使用 Secret 数据来建立 SSH 连接。

### 使用场景：带有生产、测试环境凭据的 Pod 

这一示例所展示的一个 Pod 会使用包含生产环境凭据的 Secret，另一个 Pod 使用包含测试环境凭据的 Secret。

你可以创建一个带有 ​`secretGenerator` ​字段的 ​`kustomization.yaml`​ 文件或者运行 ​`kubectl create secret`​ 来创建 Secret。

`kubectl create secret generic prod-db-secret --from-literal=username=produser --from-literal=password=Y4nys7f11`

输出类似于：

`secret "prod-db-secret" created`

你也可以创建一个包含测试环境凭据的 Secret：

`kubectl create secret generic test-db-secret --from-literal=username=testuser --from-literal=password=iluvtests`

输出类似于：

`secret "test-db-secret" created`

> Note:  
> 特殊字符（例如 ​`$`​、​`\`​、​`*`​、​`=`​ 和 ​`!`​）会被你的 [Shell](https://en.wikipedia.org/wiki/Shell_(computing))解释，因此需要转义。  
> 在大多数 Shell 中，对密码进行转义的最简单方式是用单引号（​`'`​）将其括起来。 例如，如果你的实际密码是 ​`S!B\*d$zDsb`​，则应通过以下方式执行命令：
> 
> `kubectl create secret generic dev-db-secret --from-literal=username=devuser --from-literal=password='S!B\*d$zDsb='`
> 
> 你无需对文件中的密码（​`--from-file`​）中的特殊字符进行转义。

现在生成 Pod：

`cat <<EOF > pod.yaml apiVersion: v1 kind: List items: - kind: Pod   apiVersion: v1   metadata:     name: prod-db-client-pod     labels:       name: prod-db-client   spec:     volumes:     - name: secret-volume       secret:         secretName: prod-db-secret     containers:     - name: db-client-container       image: myClientImage       volumeMounts:       - name: secret-volume         readOnly: true         mountPath: "/etc/secret-volume" - kind: Pod   apiVersion: v1   metadata:     name: test-db-client-pod     labels:       name: test-db-client   spec:     volumes:     - name: secret-volume       secret:         secretName: test-db-secret     containers:     - name: db-client-container       image: myClientImage       volumeMounts:       - name: secret-volume         readOnly: true         mountPath: "/etc/secret-volume" EOF`

将 Pod 添加到同一 ​`kustomization.yaml`​ 文件中：

`cat <<EOF >> kustomization.yaml resources: - pod.yaml EOF`

通过下面的命令在 API 服务器上应用所有这些对象：

`kubectl apply -k .`

两个文件都会在其文件系统中出现下面面的文件，文件中内容是各个容器的环境值：

`/etc/secret-volume/username /etc/secret-volume/password`

注意这两个 Pod 的规约中只有一个字段不同。 这便于基于相同的 Pod 模板生成具有不同能力的 Pod。

你可以通过使用两个服务账号来进一步简化这一基本的 Pod 规约：

1.  ​`prod-user`​ 服务账号使用 ​`prod-db-secret` ​
2.  ​`test-user`​ 服务账号使用 ​`test-db-secret` ​

Pod 规约简化为：

`apiVersion: v1 kind: Pod metadata:   name: prod-db-client-pod   labels:     name: prod-db-client spec:   serviceAccount: prod-db-client   containers:   - name: db-client-container     image: myClientImage`

### 使用场景：在 Secret 卷中带句点的文件 

通过定义以句点（​`.`​）开头的主键，你可以“隐藏”你的数据。 这些主键代表的是以句点开头的文件或“隐藏”文件。 例如，当下面的 Secret 被挂载到 ​`secret-volume`​ 卷中时：

`apiVersion: v1 kind: Secret metadata:   name: dotfile-secret data:   .secret-file: dmFsdWUtMg0KDQo= --- apiVersion: v1 kind: Pod metadata:   name: secret-dotfiles-pod spec:   volumes:   - name: secret-volume     secret:       secretName: dotfile-secret   containers:   - name: dotfile-test-container     image: k8s.gcr.io/busybox     command:     - ls     - "-l"     - "/etc/secret-volume"     volumeMounts:     - name: secret-volume       readOnly: true       mountPath: "/etc/secret-volume"`

卷中会包含一个名为 ​`.secret-file`​ 的文件，并且容器 ​`dotfile-test-container`​ 中此文件位于路径 ​`/etc/secret-volume/.secret-file`​ 处。

> Note:  
> 以句点开头的文件会在 ​`ls -l`​ 的输出中被隐藏起来； 列举目录内容时你必须使用 ​`ls -la`​ 才能看到它们。

### 使用场景：仅对 Pod 中一个容器可见的 Secret 

考虑一个需要处理 HTTP 请求，执行某些复杂的业务逻辑，之后使用 HMAC 来对某些消息进行签名的程序。因为这一程序的应用逻辑很复杂， 其中可能包含未被注意到的远程服务器文件读取漏洞， 这种漏洞可能会把私钥暴露给攻击者。

这一程序可以分隔成两个容器中的两个进程：前端容器要处理用户交互和业务逻辑， 但无法看到私钥；签名容器可以看到私钥，并对来自前端的简单签名请求作出响应 （例如，通过本地主机网络）。

采用这种划分的方法，攻击者现在必须欺骗应用服务器来做一些其他操作， 而这些操作可能要比读取一个文件要复杂很多。

Secret 的类型 
-----------

创建 Secret 时，你可以使用 Secret 资源的 ​`type` ​字段，或者与其等价的 ​`kubectl` ​命令行参数（如果有的话）为其设置类型。 Secret 类型有助于对 Secret 数据进行编程处理。

Kubernetes 提供若干种内置的类型，用于一些常见的使用场景。 针对这些类型，Kubernetes 所执行的合法性检查操作以及对其所实施的限制各不相同。

内置类型

用法

`Opaque`

用户定义的任意数据

`kubernetes.io/service-account-token`

服务账号令牌

`kubernetes.io/dockercfg`

`~/.dockercfg` 文件的序列化形式

`kubernetes.io/dockerconfigjson`

`~/.docker/config.json` 文件的序列化形式

`kubernetes.io/basic-auth`

用于基本身份认证的凭据

`kubernetes.io/ssh-auth`

用于 SSH 身份认证的凭据

`kubernetes.io/tls`

用于 TLS 客户端或者服务器端的数据

`bootstrap.kubernetes.io/token`

启动引导令牌数据

通过为 Secret 对象的 ​`type` ​字段设置一个非空的字符串值，你也可以定义并使用自己 Secret 类型。如果 ​`type` ​值为空字符串，则被视为 ​`Opaque` ​类型。

Kubernetes 并不对类型的名称作任何限制。不过，如果你要使用内置类型之一， 则你必须满足为该类型所定义的所有要求。

如果你要定义一种公开使用的 Secret 类型，请遵守 Secret 类型的约定和结构， 在类型名签名添加域名，并用 ​`/`​ 隔开。 例如：​`cloud-hosting.example.net/cloud-api-credentials`​。

### Opaque Secret 

当 Secret 配置文件中未作显式设定时，默认的 Secret 类型是 ​`Opaque`​。 当你使用 ​`kubectl` ​来创建一个 Secret 时，你会使用 ​`generic` ​子命令来标明 要创建的是一个 ​`Opaque` ​类型 Secret。 例如，下面的命令会创建一个空的 ​`Opaque` ​类型 Secret 对象：

`kubectl create secret generic empty-secret kubectl get secret empty-secret`
        

输出类似于

`NAME           TYPE     DATA   AGE empty-secret   Opaque   0      2m6s`

​`DATA` ​列显示 Secret 中保存的数据条目个数。 在这个例子种，​`0`​ 意味着我们刚刚创建了一个空的 Secret。

### 服务账号令牌 Secret 

类型为 ​`kubernetes.io/service-account-token`​ 的 Secret 用来存放标识某 服务账号的令牌。 使用这种 Secret 类型时，你需要确保对象的注解 ​`kubernetes.io/service-account-name`​ 被设置为某个已有的服务账号名称。某个 Kubernetes 控制器会填写 Secret 的其它字段，例如 ​`kubernetes.io/service-account.uid`​ 注解以及 ​`data` ​字段中的 ​`token` ​键值，使之包含实际的令牌内容。

下面的配置实例声明了一个服务账号令牌 Secret：

`apiVersion: v1 kind: Secret metadata:   name: secret-sa-sample   annotations:     kubernetes.io/service-account.name: "sa-name" type: kubernetes.io/service-account-token data:   # 你可以像 Opaque Secret 一样在这里添加额外的键/值偶对   extra: YmFyCg==`

Kubernetes 在创建 Pod 时会自动创建一个服务账号 Secret 并自动修改你的 Pod 以使用该 Secret。该服务账号令牌 Secret 中包含了访问 Kubernetes API 所需要的凭据。

如果需要，可以禁止或者重载这种自动创建并使用 API 凭据的操作。 不过，如果你仅仅是希望能够安全地访问 API 服务器，这是建议的工作方式。

### Docker 配置 Secret 

你可以使用下面两种 ​`type` ​值之一来创建 Secret，用以存放访问 Docker 仓库 来下载镜像的凭据。

*   ​`kubernetes.io/dockercfg` ​
*   ​`kubernetes.io/dockerconfigjson`​

​`kubernetes.io/dockercfg`​ 是一种保留类型，用来存放 ​`~/.dockercfg`​ 文件的序列化形式。 该文件是配置 Docker 命令行的一种老旧形式。使用此 Secret 类型时，你需要确保 Secret 的 ​`data` ​字段中包含名为 ​`.dockercfg`​ 的主键，其对应键值是用 base64 编码的某 ​`~/.dockercfg`​ 文件的内容。

类型 ​`kubernetes.io/dockerconfigjson`​ 被设计用来保存 JSON 数据的序列化形式， 该 JSON 也遵从 ​`~/.docker/config.json`​ 文件的格式规则，而后者是 ​`~/.dockercfg`​ 的新版本格式。使用此 Secret 类型时，Secret 对象的 ​`data` ​字段必须包含 ​`.dockerconfigjson`​ 键，其键值为 base64 编码的字符串包含 ​`~/.docker/config.json`​ 文件的内容。

下面是一个 ​`kubernetes.io/dockercfg`​ 类型 Secret 的示例：

`apiVersion: v1 kind: Secret metadata:   name: secret-dockercfg type: kubernetes.io/dockercfg data:   .dockercfg: |         "<base64 encoded ~/.dockercfg file>"`

> Note:  
> 如果你不希望执行 base64 编码转换，可以使用 ​`stringData`​ 字段代替。

当你使用清单文件来创建这两类 Secret 时，API 服务器会检查 ​`data` ​字段中是否 存在所期望的主键，并且验证其中所提供的键值是否是合法的 JSON 数据。 不过，API 服务器不会检查 JSON 数据本身是否是一个合法的 Docker 配置文件内容。

`kubectl create secret docker-registry secret-tiger-docker \   --docker-email=tiger@acme.example \   --docker-username=tiger \   --docker-password=pass113 \   --docker-server=my-registry.example:5000`

上面的命令创建一个类型为 ​`kubernetes.io/dockerconfigjson`​ 的 Secret。 如果你对 ​`.data.dockerconfigjson`​ 内容进行转储并执行 base64 解码：

`{   "auths": {     "my-registry.example:5000": {       "username": "tiger",       "password": "pass113",       "email": "tiger@acme.com",       "auth": "dGlnZXI6cGFzczExMw=="     }   } }`

> Note:  
> ​`auths` ​值是 base64 编码的，其内容被屏蔽但未被加密。 任何能够读取该 Secret 的人都可以了解镜像库的访问令牌。

### 基本身份认证 Secret 

​`kubernetes.io/basic-auth`​ 类型用来存放用于基本身份认证所需的凭据信息。 使用这种 Secret 类型时，Secret 的 ​`data` ​字段必须包含以下两个键：

*   ​`username`​: 用于身份认证的用户名；
*   ​`password`​: 用于身份认证的密码或令牌。

以上两个键的键值都是 base64 编码的字符串。 当然你也可以在创建 Secret 时使用 ​`stringData` ​字段来提供明文形式的内容。 下面的 YAML 是基本身份认证 Secret 的一个示例清单：

`apiVersion: v1 kind: Secret metadata:   name: secret-basic-auth type: kubernetes.io/basic-auth stringData:   username: admin      #  kubernetes.io/basic-auth 类型的必需字段   password: t0p-Secret # kubernetes.io/basic-auth 类型的必需字段`

提供基本身份认证类型的 Secret 仅仅是出于方便性考虑。 你也可以使用 ​`Opaque` ​类型来保存用于基本身份认证的凭据。 不过，使用预定义的、公开的 Secret 类型（​`kubernetes.io/basic-auth`​） 有助于帮助其他用户理解 Secret 的目的，并且对其中存在的主键形成一种约定。 API 服务器会检查 Secret 配置中是否提供了所需要的主键。

### SSH 身份认证 Secret

Kubernetes 所提供的内置类型 ​`kubernetes.io/ssh-auth`​ 用来存放 SSH 身份认证中 所需要的凭据。使用这种 Secret 类型时，你就必须在其 ​`data` ​（或 ​`stringData`​） 字段中提供一个 ​`ssh-privatekey`​ 键值对，作为要使用的 SSH 凭据。

下面的清单是一个 SSH 公钥/私钥身份认证的 Secret 示例：

`apiVersion: v1 kind: Secret metadata:   name: secret-ssh-auth type: kubernetes.io/ssh-auth data:   # 此例中的实际数据被截断   ssh-privatekey: |           MIIEpQIBAAKCAQEAulqb/Y ...`

提供 SSH 身份认证类型的 Secret 仅仅是出于用户方便性考虑。 你也可以使用 ​`Opaque` ​类型来保存用于 SSH 身份认证的凭据。 不过，使用预定义的、公开的 Secret 类型（​`kubernetes.io/ssh-auth`​） 有助于其他人理解你的 Secret 的用途，也可以就其中包含的主键名形成约定。 API 服务器确实会检查 Secret 配置中是否提供了所需要的主键。

> Caution:  
> SSH 私钥自身无法建立 SSH 客户端与服务器端之间的可信连接。 需要其它方式来建立这种信任关系，以缓解“中间人（Man In The Middle）” 攻击，例如向 ConfigMap 中添加一个 ​`known_hosts` ​文件。

### TLS Secret

Kubernetes 提供一种内置的 ​`kubernetes.io/tls Secret`​ 类型，用来存放 TLS 场合通常要使用的证书及其相关密钥。 TLS Secret 的一种典型用法是为 Ingress 资源配置传输过程中的数据加密，不过也可以用于其他资源或者直接在负载中使用。 当使用此类型的 Secret 时，Secret 配置中的 ​`data` ​（或 ​`stringData`​）字段必须包含 ​`tls.key`​ 和 ​`tls.crt`​ 主键，尽管 API 服务器实际上并不会对每个键的取值作进一步的合法性检查。

下面的 YAML 包含一个 TLS Secret 的配置示例：

`apiVersion: v1 kind: Secret metadata:   name: secret-tls type: kubernetes.io/tls data:   # 此例中的数据被截断   tls.crt: |         MIIC2DCCAcCgAwIBAgIBATANBgkqh ...   tls.key: |         MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...`

提供 TLS 类型的 Secret 仅仅是出于用户方便性考虑。 你也可以使用 ​`Opaque` ​类型来保存用于 TLS 服务器与/或客户端的凭据。 不过，使用内置的 Secret 类型的有助于对凭据格式进行归一化处理，并且 API 服务器确实会检查 Secret 配置中是否提供了所需要的主键。

当使用 ​`kubectl` ​来创建 TLS Secret 时，你可以像下面的例子一样使用 ​`tls` ​子命令：

`kubectl create secret tls my-tls-secret \   --cert=path/to/cert/file \   --key=path/to/key/file`

这里的公钥/私钥对都必须事先已存在。用于 ​`--cert`​ 的公钥证书必须是 [RFC 7468 中 5.1 节](https://datatracker.ietf.org/doc/html/rfc7468 target=) 中所规定的 DER 格式，且与 ​`--key`​ 所给定的私钥匹配。 私钥必须是 DER 格式的 PKCS #8 （参见  [RFC 7468 第 11节](https://datatracker.ietf.org/doc/html/rfc7468 target=)）。

> Note:  
> 类型为 ​`kubernetes.io/tls`​ 的 Secret 中包含密钥和证书的 DER 数据，以 Base64 格式编码。 如果你熟悉私钥和证书的 PEM 格式，base64 与该格式相同，只是你需要略过 PEM 数据中所包含的第一行和最后一行。  
> 例如，对于证书而言，你 不要 包含 ​`--------BEGIN CERTIFICATE-----`​ 和 ​`-------END CERTIFICATE----`​ 这两行。

### 启动引导令牌 Secret 

通过将 Secret 的 ​`type` ​设置为 ​`bootstrap.kubernetes.io/token`​ 可以创建 启动引导令牌类型的 Secret。这种类型的 Secret 被设计用来支持节点的启动引导过程。 其中包含用来为周知的 ConfigMap 签名的令牌。

启动引导令牌 Secret 通常创建于 ​`kube-system`​ 名字空间内，并以 ​`bootstrap-token-<令牌 ID>` ​的形式命名；其中 ​`<令牌 ID>`​ 是一个由 6 个字符组成 的字符串，用作令牌的标识。

以 Kubernetes 清单文件的形式，某启动引导令牌 Secret 可能看起来像下面这样：

`apiVersion: v1 kind: Secret metadata:   name: bootstrap-token-5emitj   namespace: kube-system type: bootstrap.kubernetes.io/token data:   auth-extra-groups: c3lzdGVtOmJvb3RzdHJhcHBlcnM6a3ViZWFkbTpkZWZhdWx0LW5vZGUtdG9rZW4=   expiration: MjAyMC0wOS0xM1QwNDozOToxMFo=   token-id: NWVtaXRq   token-secret: a3E0Z2lodnN6emduMXAwcg==   usage-bootstrap-authentication: dHJ1ZQ==   usage-bootstrap-signing: dHJ1ZQ==`

启动引导令牌类型的 Secret 会在 ​`data` ​字段中包含如下主键：

*   ​`token-id`​：由 6 个随机字符组成的字符串，作为令牌的标识符。必需。
*   ​`token-secret`​：由 16 个随机字符组成的字符串，包含实际的令牌机密。必需。
*   ​`description`​：供用户阅读的字符串，描述令牌的用途。可选。
*   ​`expiration`​：一个使用 RFC3339 来编码的 UTC 绝对时间，给出令牌要过期的时间。可选。
*   ​`usage-bootstrap-<usage>`​：布尔类型的标志，用来标明启动引导令牌的其他用途。
*   ​`auth-extra-groups`​：用逗号分隔的组名列表，身份认证时除被认证为 system:bootstrappers 组之外，还会被添加到所列的用户组中。

上面的 YAML 文件可能看起来令人费解，因为其中的数值均为 base64 编码的字符串。 实际上，你完全可以使用下面的 YAML 来创建一个一模一样的 Secret：

`apiVersion: v1 kind: Secret metadata:   # 注意 Secret 的命名方式   name: bootstrap-token-5emitj   # 启动引导令牌 Secret 通常位于 kube-system 名字空间   namespace: kube-system type: bootstrap.kubernetes.io/token stringData:   auth-extra-groups: "system:bootstrappers:kubeadm:default-node-token"   expiration: "2020-09-13T04:39:10Z"   # 此令牌 ID 被用于生成 Secret 名称   token-id: "5emitj"   token-secret: "kq4gihvszzgn1p0r"   # 此令牌还可用于 authentication （身份认证）   usage-bootstrap-authentication: "true"   # 且可用于 signing （证书签名）   usage-bootstrap-signing: "true"`

不可更改的 Secret 
-------------

FEATURE STATE: Kubernetes v1.21 \[stable\]

Kubernetes 允许你将特定的 Secret（和 ConfigMap）标记为 不可更改（Immutable）。 禁止更改现有 Secret 的数据有下列好处：

*   防止意外（或非预期的）更新导致应用程序中断
*   （对于大量使用 Secret 的集群而言，至少数万个不同的 Secret 供 Pod 挂载）， 通过将 Secret 标记为不可变，可以极大降低 kube-apiserver 的负载，提升集群性能。 kubelet 不需要监视那些被标记为不可更改的 Secret。

### 将 Secret 标记为不可更改 

你可以通过将 Secret 的 ​`immutable` ​字段设置为 ​`true` ​创建不可更改的 Secret。 例如：

`apiVersion: v1 kind: Secret metadata:   ... data:   ... immutable: true`

你也可以更改现有的 Secret，令其不可更改。

> Note:  
> 一旦一个 Secret 或 ConfigMap 被标记为不可更改，撤销此操作或者更改 ​`data` ​字段的内容都是 不 可能的。 只能删除并重新创建这个 Secret。现有的 Pod 将维持对已删除 Secret 的挂载点 -- 建议重新创建这些 Pod。

Secret 的信息安全问题
--------------

尽管 ConfigMap 和 Secret 的工作方式类似，但 Kubernetes 对 Secret 有一些额外的保护。

Secret 通常保存重要性各异的数值，其中很多都可能会导致 Kubernetes 中 （例如，服务账号令牌）或对外部系统的特权提升。 即使某些个别应用能够推导它期望使用的 Secret 的能力， 同一名字空间中的其他应用可能会让这种假定不成立。

只有当某个节点上的 Pod 需要某 Secret 时，对应的 Secret 才会被发送到该节点上。 如果将 Secret 挂载到 Pod 中，kubelet 会将数据的副本保存在在 ​`tmpfs` ​中， 这样机密的数据不会被写入到持久性存储中。 一旦依赖于该 Secret 的 Pod 被删除，kubelet 会删除来自于该 Secret 的机密数据的本地副本。

同一个 Pod 中可能包含多个容器。默认情况下，你所定义的容器只能访问默认 ServiceAccount 及其相关 Secret。你必须显式地定义环境变量或者将卷映射到容器中，才能为容器提供对其他 Secret 的访问。

针对同一节点上的多个 Pod 可能有多个 Secret。不过，只有某个 Pod 所请求的 Secret 才有可能对 Pod 中的容器可见。因此，一个 Pod 不会获得访问其他 Pod 的 Secret 的权限。

> Warning:  
> 节点上的所有特权容器都可能访问到该节点上使用的所有 Secret。

### 针对开发人员的安全性建议 

*   应用在从环境变量或卷中读取了机密信息内容之后仍要对其进行保护。例如， 你的应用应该避免用明文的方式将 Secret 数据写入日志，或者将其传递给不可信的第三方。
*   如果你在一个 Pod 中定义了多个容器，而只有一个容器需要访问某 Secret， 定义卷挂载或环境变量配置时，应确保其他容器无法访问该 Secret。
*   如果你通过清单来配置某 Secret， Secret 数据以 Base64 的形式编码，将此文件共享，或者将其检入到某源码仓库， 都意味着 Secret 对于任何可以读取清单的人都是可见的。 Base64 编码 不是 一种加密方法，与明文相比没有任何安全性提升。
*   部署与 Secret API 交互的应用时，你应该使用 RBAC 这类鉴权策略来限制访问。
*   在 Kubernetes API 中，名字空间内对 Secret 对象的 ​`watch` ​和 ​`list` ​请求是非常强大的能力。 在可能的时候应该避免授予这类访问权限，因为通过列举 Secret， 客户端能够查看对应名字空间内所有 Secret 的取值。

### 针对集群管理员的安全性建议

> Caution:  
> 能够创建使用 Secret 的 Pod 的用户也可以查看该 Secret 的取值。 即使集群策略不允许某用户直接读取 Secret 对象，这一用户仍然可以通过运行一个 Pod 来访问 Secret 的内容。

*   保留（使用 Kubernetes API）对集群中所有 Secret 对象执行 ​`watch` ​或 ​`list` ​操作的能力， 这样只有特权级最高、系统级别的组件能够执行这类操作。
*   在部署需要通过 Secret API 交互的应用时，你应该通过使用 RBAC 这类鉴权策略来限制访问。
*   在 API 服务器上，对象（包括 Secret）会被持久化到 etcd 中； 因此：

*   只应准许集群管理员访问 etcd（包括只读访问）；
*   为 Secret 对象启用静态加密， 这样这些 Secret 的数据就不会以明文的形式保存到 etcd 中；
*   当 etcd 的持久化存储不再被使用时，请考虑彻底擦除存储介质；
*   如果存在多个 etcd 实例，请确保 etcd 使用 SSL/TLS 来完成其对等通信。

##  4.  Kubernetes 为 Pod 和容器管理资源
为 Pod 和容器管理资源
-------------

当你定义 Pod 时可以选择性地为每个 容器设定所需要的资源数量。 最常见的可设定资源是 CPU 和内存（RAM）大小；此外还有其他类型的资源。

当你为 Pod 中的 Container 指定了资源 请求 时， kube-scheduler 就利用该信息决定将 Pod 调度到哪个节点上。 当你还为 Container 指定了资源 约束 时，kubelet 就可以确保运行的容器不会使用超出所设约束的资源。 kubelet 还会为容器预留所 请求 数量的系统资源，供其使用。

请求和约束 
------

如果 Pod 运行所在的节点具有足够的可用资源，容器可能（且可以）使用超出对应资源 ​`request`​ 属性所设置的资源量。不过，容器不可以使用超出其资源 ​`limit` ​属性所设置的资源量。

例如，如果你将容器的 ​`memory` ​的请求量设置为 256 MiB，而该容器所处的 Pod 被调度到一个具有 8 GiB 内存的节点上，并且该节点上没有其他 Pods 运行，那么该容器就可以尝试使用更多的内存。

如果你将某容器的 ​`memory` ​约束设置为 4 GiB，kubelet （和 容器运行时） 就会确保该约束生效。 容器运行时会禁止容器使用超出所设置资源约束的资源。 例如：当容器中进程尝试使用超出所允许内存量的资源时，系统内核会将尝试申请内存的进程终止， 并引发内存不足（OOM）错误。

约束值可以以被动方式来实现（系统会在发现违例时进行干预），或者通过强制生效的方式实现 （系统会避免容器用量超出约束值）。不同的容器运行时采用不同方式来实现相同的限制。

> Note:  
> 如果你为某个资源指定了限制，但不指定请求， 并且没有应用准入时机制为该资源设置默认请求， 然后 Kubernetes 复制你所指定的限制值，将其用作资源的请求值。

资源类型 
-----

CPU 和 内存 都是 资源类型。每种资源类型具有其基本单位。 CPU 表达的是计算处理能力，其单位是 Kubernetes CPUs。 内存的单位是字节。 对于 Linux 负载，则可以指定巨页（Huge Page）资源。 巨页是 Linux 特有的功能，节点内核在其中分配的内存块比默认页大小大得多。

例如，在默认页面大小为 4KiB 的系统上，你可以指定约束 ​`hugepages-2Mi: 80Mi`​。 如果容器尝试分配 40 个 2MiB 大小的巨页（总共 80 MiB ），则分配请求会失败。

> Note:  
> 你不能过量使用 ​`hugepages- *`​ 资源。 这与 ​`memory` ​和 ​`cpu` ​资源不同。

CPU 和内存统称为“计算资源”，或简称为“资源”。 计算资源的数量是可测量的，可以被请求、被分配、被消耗。 它们与 API 资源 不同。 API 资源（如 Pod 和 Service）是可通过 Kubernetes API 服务器读取和修改的对象。

Pod 和 容器的资源请求和约束 
-----------------

针对每个容器，你都可以指定其资源约束和请求，包括如下选项：

*   ​`spec.containers[].resources.limits.cpu` ​
*   ​`spec.containers[].resources.limits.memory` ​
*   ​`spec.containers[].resources.limits.hugepages-<size>` ​
*   ​`spec.containers[].resources.requests.cpu` ​
*   ​`spec.containers[].resources.requests.memory` ​
*   ​`spec.containers[].resources.requests.hugepages-<size>`​

尽管你只能逐个容器地指定请求和限制值，考虑 Pod 的总体资源请求和约束也是有用的。 对特定资源而言，Pod 的资源请求/约束值是 Pod 中各容器对该类型资源的请求/约束值的总和。

Kubernetes 中的资源单位 
------------------

### CPU 资源单位 

CPU 资源的约束和请求以 “cpu” 为单位。 在 Kubernetes 中，一个 CPU 等于1 个物理 CPU 核 或者 一个虚拟核， 取决于节点是一台物理主机还是运行在某物理主机上的虚拟机。

你也可以表达带小数 CPU 的请求。 当你定义一个容器，将其 ​`spec.containers[].resources.requests.cpu`​ 设置为 0.5 时， 你所请求的 CPU 是你请求 ​`1.0`​ CPU 时的一半。 对于 CPU 资源单位，数量 表达式 ​`0.1`​ 等价于表达式 ​`100m`​，可以看作 “100 millicpu”。 有些人说成是“一百毫核”，其实说的是同样的事情。

CPU 资源总是设置为资源的绝对数量而非相对数量值。 例如，无论容器运行在单核、双核或者 48-核的机器上，​`500m`​ CPU 表示的是大约相同的计算能力。

> Note:  
> Kubernetes 不允许设置精度小于 ​`1m`​ 的 CPU 资源。 因此，当 CPU 单位小于 ​`1`​ 或 ​`1000m`​ 时，使用毫核的形式是有用的； 例如 ​`5m`​ 而不是 ​`0.005`​。

内存资源单位 
-------

​`memory` ​的约束和请求以字节为单位。 你可以使用普通的证书，或者带有以下 数量后缀 的定点数字来表示内存：E、P、T、G、M、k。 你也可以使用对应的 2 的幂数：Ei、Pi、Ti、Gi、Mi、Ki。 例如，以下表达式所代表的是大致相同的值：

`128974848、129e6、129M、128974848000m、123Mi`

请注意后缀的大小写。如果你请求 ​`400m`​ 内存，实际上请求的是 0.4 字节。 如果有人这样设定资源请求或限制，可能他的实际想法是申请 400 兆字节（​`400Mi`​） 或者 400M 字节。

容器资源示例 
-------

以下 Pod 有两个容器。每个容器的请求为 0.25 CPU 和 64MiB（226 字节）内存， 每个容器的资源约束为 0.5 CPU 和 128MiB 内存。 你可以认为该 Pod 的资源请求为 0.5 CPU 和 128 MiB 内存，资源限制为 1 CPU 和 256MiB 内存。

`apiVersion: v1 kind: Pod metadata:   name: frontend spec:   containers:   - name: app     image: images.my-company.example/app:v4     resources:       requests:         memory: "64Mi"         cpu: "250m"       limits:         memory: "128Mi"         cpu: "500m"   - name: log-aggregator     image: images.my-company.example/log-aggregator:v6     resources:       requests:         memory: "64Mi"         cpu: "250m"       limits:         memory: "128Mi"         cpu: "500m"`

    

带资源请求的 Pod 如何调度 
----------------

当你创建一个 Pod 时，Kubernetes 调度程序将为 Pod 选择一个节点。 每个节点对每种资源类型都有一个容量上限：可为 Pod 提供的 CPU 和内存量。 调度程序确保对于每种资源类型，所调度的容器的资源请求的总和小于节点的容量。 请注意，尽管节点上的实际内存或 CPU 资源使用量非常低，如果容量检查失败， 调度程序仍会拒绝在该节点上放置 Pod。 当稍后节点上资源用量增加，例如到达请求率的每日峰值区间时，节点上也不会出现资源不足的问题。

Kubernetes 应用资源请求与约束的方式
-----------------------

当 kubelet 启动 Pod 中的容器时，它会将容器的 CPU 和内存请求与约束信息传递给容器运行时。

在 Linux 系统上，容器运行时通常会配置内核 CGroups，负责应用并实施所定义的请求。

*   CPU 约束值定义的是容器可使用的 CPU 时间的硬性上限。 在每个调度周期（时间片）期间，Linux 内核检查是否已经超出该约束值； 内核会在允许该 cgroup 恢复执行之前会等待。
*   CPU 请求值定义的是一个权重值。如果若干不同的容器（CGroups）需要在一个共享的系统上竞争运行， CPU 请求值大的负载会获得比请求值小的负载更多的 CPU 时间。
*   内存请求值主要用于（Kubernetes）Pod 调度期间。在一个启用了 CGroup v2 的节点上， 容器运行时可能会使用内存请求值作为设置 ​`memory.min`​ 和 ​`memory.low`​ 的提示值。
*   内存约束值定义的是 CGroup 的内存约束。如果容器尝试分配的内存量超出约束值， 则 Linux 内核的内存不足处理子系统会被激活，并停止尝试分配内存的容器中的某个进程。 如果该进程在容器中 PID 为 1，而容器被标记为可重新启动，则 Kubernetes 会重新启动该容器。
*   Pod 或容器的内存约束值也适用于通过内存供应的卷，例如 ​`emptyDir` ​卷。 kubelet 会跟踪 ​`tmpfs` ​形式的 emptyDir 卷用量，将其作为容器的内存用量， 而不是临时存储用量。

如果某容器内存用量超过其内存请求值并且所在节点内存不足时，容器所处的 Pod 可能被逐出.

每个容器可能被允许也可能不被允许使用超过其 CPU 约束的处理时间。 但是，容器运行时不会由于 CPU 使用率过高而杀死 Pod 或容器。

监控计算和内存资源用量
-----------

kubelet 会将 Pod 的资源使用情况作为 Pod ​`status` ​的一部分来报告的。

如果为集群配置了可选的监控工具， 则可以直接从指标 API 或者监控工具获得 Pod 的资源使用情况。

本地临时存储 
-------

FEATURE STATE: Kubernetes v1.10 \[beta\]

节点通常还可以具有本地的临时性存储，由本地挂接的可写入设备或者有时也用 RAM 来提供支持。 “临时（Ephemeral）”意味着对所存储的数据不提供长期可用性的保证。

Pods 通常可以使用临时性本地存储来实现缓冲区、保存日志等功能。 kubelet 可以为使用本地临时存储的 Pods 提供这种存储空间，允许后者使用 ​`emptyDir` ​类型的 卷将其挂载到容器中。

kubelet 也使用此类存储来保存 节点层面的容器日志， 容器镜像文件、以及运行中容器的可写入层。

> Caution: 如果节点失效，存储在临时性存储中的数据会丢失。 你的应用不能对本地临时性存储的性能 SLA（例如磁盘 IOPS）作任何假定。

作为一种 beta 阶段功能特性，Kubernetes 允许你跟踪、预留和限制 Pod 可消耗的临时性本地存储数量。

### 本地临时性存储的配置

Kubernetes 有两种方式支持节点上配置本地临时性存储：

*   单一文件系统

采用这种配置时，你会把所有类型的临时性本地数据（包括 ​`emptyDir` ​卷、可写入容器层、容器镜像、日志等）放到同一个文件系统中。 作为最有效的 kubelet 配置方式，这意味着该文件系统是专门提供给 Kubernetes （kubelet）来保存数据的。

kubelet 也会生成 节点层面的容器日志， 并按临时性本地存储的方式对待之。

kubelet 会将日志写入到所配置的日志目录（默认为 ​`/var/log`​）下的文件中； 还会针对其他本地存储的数据使用同一个基础目录（默认为 ​`/var/lib/kubelet`​）。

通常，​`/var/lib/kubelet`​ 和 ​`/var/log`​ 都是在系统的根文件系统中。kubelet 的设计也考虑到这一点。

你的集群节点当然可以包含其他的、并非用于 Kubernetes 的很多文件系统。

*   双文件系统

你使用节点上的某个文件系统来保存运行 Pods 时产生的临时性数据：日志和 ​`emptyDir` ​卷等。你可以使用这个文件系统来保存其他数据（例如：与 Kubernetes 无关的其他系统日志）；这个文件系统还可以是根文件系统。

kubelet 也将 节点层面的容器日志 写入到第一个文件系统中，并按临时性本地存储的方式对待之。

同时你使用另一个由不同逻辑存储设备支持的文件系统。在这种配置下，你会告诉 kubelet 将容器镜像层和可写层保存到这第二个文件系统上的某个目录中。

第一个文件系统中不包含任何镜像层和可写层数据。

当然，你的集群节点上还可以有很多其他与 Kubernetes 没有关联的文件系统。

kubelet 能够度量其本地存储的用量。实现度量机制的前提是：

*   ​`LocalStorageCapacityIsolation` ​特性门控 被启用（默认状态），并且
*   你已经对节点进行了配置，使之使用所支持的本地临时性储存配置方式之一

如果你的节点配置不同于以上预期，kubelet 就无法对临时性本地存储的资源约束实施限制。

> Note: kubelet 会将 ​`tmpfs` ​emptyDir 卷的用量当作容器内存用量，而不是本地临时性存储来统计。

### 为本地临时性存储设置请求和约束值

你可以使用 ​`ephemeral-storage`​ 来管理本地临时性存储。 Pod 中的每个容器可以设置以下属性：

*   ​`spec.containers[].resources.limits.ephemeral-storage` ​
*   ​`spec.containers[].resources.requests.ephemeral-storage` ​

​`ephemeral-storage`​ 的请求和约束值是按量纲计量的。你可以使用一般整数或者定点数字 加上下面的后缀来表达存储量：E、P、T、G、M、K。 你也可以使用对应的 2 的幂级数来表达：Ei、Pi、Ti、Gi、Mi、Ki。 例如，下面的表达式所表达的大致是同一个值：

*   ​`128974848` ​
*   ​`129e6` ​
*   ​`129M` ​
*   ​`123Mi`​

在下面的例子中，Pod 包含两个容器。每个容器请求 2 GiB 大小的本地临时性存储。 每个容器都设置了 4 GiB 作为其本地临时性存储的约束值。 因此，整个 Pod 的本地临时性存储请求是 4 GiB，且其本地临时性存储的约束为 8 GiB。

`apiVersion: v1 kind: Pod metadata:   name: frontend spec:   containers:   - name: app     image: images.my-company.example/app:v4     resources:       requests:         ephemeral-storage: "2Gi"       limits:         ephemeral-storage: "4Gi"     volumeMounts:     - name: ephemeral       mountPath: "/tmp"   - name: log-aggregator     image: images.my-company.example/log-aggregator:v6     resources:       requests:         ephemeral-storage: "2Gi"       limits:         ephemeral-storage: "4Gi"     volumeMounts:     - name: ephemeral       mountPath: "/tmp"   volumes:     - name: ephemeral       emptyDir: {}`

### 带临时性存储的 Pods 的调度行为

当你创建一个 Pod 时，Kubernetes 调度器会为 Pod 选择一个节点来运行之。 每个节点都有一个本地临时性存储的上限，是其可提供给 Pods 使用的总量。

调度器会确保所调度的容器的资源请求总和不会超出节点的资源容量。

### 临时性存储消耗的管理

如果 kubelet 将本地临时性存储作为资源来管理，则 kubelet 会度量以下各处的存储用量：

*   ​`emptyDir` ​卷，除了 tmpfs ​`emptyDir` ​卷
*   保存节点层面日志的目录
*   可写入的容器镜像层

如果某 Pod 的临时存储用量超出了你所允许的范围，kubelet 会向其发出逐出（eviction）信号，触发该 Pod 被逐出所在节点。

就容器层面的隔离而言，如果某容器的可写入镜像层和日志用量超出其存储约束， kubelet 也会将所在的 Pod 标记为逐出候选。

就 Pod 层面的隔离而言，kubelet 会将 Pod 中所有容器的约束值相加，得到 Pod 存储约束的总值。如果所有容器的本地临时性存储用量总和加上 Pod 的 ​`emptyDir` ​卷的用量超出 Pod 存储约束值，kubelet 也会将该 Pod 标记为逐出候选。

> Caution:  
> 如果 kubelet 没有度量本地临时性存储的用量，即使 Pod 的本地存储用量超出其约束值也不会被逐出。  
> 不过，如果用于可写入容器镜像层、节点层面日志或者 ​`emptyDir` ​卷的文件系统中可用空间太少， 节点会为自身设置本地存储不足的污点 标签。 这一污点会触发对那些无法容忍该污点的 Pods 的逐出操作。  

kubelet 支持使用不同方式来度量 Pod 的存储用量：

*   周期性扫描

kubelet 按预定周期执行扫描操作，检查 ​`emptyDir` ​卷、容器日志目录以及可写入容器镜像层。

这一扫描会度量存储空间用量。

> Note:  
> 在这种模式下，kubelet 并不检查已删除文件所对应的、仍处于打开状态的文件描述符。  
> 如果你（或者容器）在 ​`emptyDir` ​卷中创建了一个文件，写入一些内容之后再次打开 该文件并执行了删除操作，所删除文件对应的 inode 仍然存在，直到你关闭该文件为止。 kubelet 不会将该文件所占用的空间视为已使用空间。

*   文件系统项目配额

FEATURE STATE: Kubernetes v1.15 \[alpha\]

项目配额（Project Quota）是一个操作系统层的功能特性，用来管理文件系统中的存储用量。 在 Kubernetes 中，你可以启用项目配额以监视存储用量。 你需要确保节点上为 ​`emptyDir` ​提供存储的文件系统支持项目配额。 例如，XFS 和 ext4fs 文件系统都支持项目配额。

> Note: 项目配额可以帮你监视存储用量，但无法对存储约束执行限制。

Kubernetes 所使用的项目 ID 始于 ​`1048576`​。 所使用的 IDs 会注册在 ​`/etc/projects`​ 和 ​`/etc/projid`​ 文件中。 如果该范围中的项目 ID 已经在系统中被用于其他目的，则已占用的项目 IDs 也必须注册到 ​`/etc/projects`​ 和 ​`/etc/projid`​ 中，这样 Kubernetes 才不会使用它们。

配额方式与目录扫描方式相比速度更快，结果更精确。当某个目录被分配给某个项目时， 该目录下所创建的所有文件都属于该项目，内核只需要跟踪该项目中的文件所使用的存储块个数。 如果某文件被创建后又被删除，但对应文件描述符仍处于打开状态， 该文件会继续耗用存储空间。配额跟踪技术能够精确第记录对应存储空间的状态， 而目录扫描方式会忽略被删除文件所占用的空间。

如果你希望使用项目配额，你需要：

*   在 kubelet 配置中使用 ​`featureGates` ​字段 或者使用 ​`--feature-gates`​ 命令行参数 启用 ​`LocalStorageCapacityIsolationFSQuotaMonitoring=true`​ 特性门控 。
*   确保根文件系统（或者可选的运行时文件系统）启用了项目配额。所有 XFS 文件系统都支持项目配额。 对 extf 文件系统而言，你需要在文件系统尚未被挂载时启用项目配额跟踪特性：

`# 对 ext4 而言，在 /dev/block-device 尚未被挂载时执行下面操作 sudo tune2fs -O project -Q prjquota /dev/block-device`

*   确保根文件系统（或者可选的运行时文件系统）在挂载时项目配额特性是被启用了的。 对于 XFS 和 ext4fs 而言，对应的挂载选项称作 ​`prjquota`​。

扩展资源（Extended Resources） 
-------------------------

扩展资源是 ​`kubernetes.io`​ 域名之外的标准资源名称。 它们使得集群管理员能够颁布非 Kubernetes 内置资源，而用户可以使用他们。

使用扩展资源需要两个步骤。首先，集群管理员必须颁布扩展资源。 其次，用户必须在 Pod 中请求扩展资源。

### 管理扩展资源 

#### 节点级扩展资源 

节点级扩展资源绑定到节点。

##### 其他资源 

为了颁布新的节点级扩展资源，集群操作员可以向 API 服务器提交 ​`PATCH` ​HTTP 请求， 以在集群中节点的 ​`status.capacity`​ 中为其配置可用数量。 完成此操作后，节点的 ​`status.capacity`​ 字段中将包含新资源。 kubelet 会异步地对 ​`status.allocatable`​ 字段执行自动更新操作，使之包含新资源。

由于调度器在评估 Pod 是否适合在某节点上执行时会使用节点的 ​`status.allocatable`​ 值， 调度器只会考虑异步更新之后的新值。 在更新节点容量使之包含新资源之后和请求该资源的第一个 Pod 被调度到该节点之间， 可能会有短暂的延迟。

示例：

这是一个示例，显示了如何使用 ​`curl` ​构造 HTTP 请求，公告主节点为 ​`k8s-master`​ 的节点 ​`k8s-node-1`​ 上存在五个 ​`example.com/foo`​ 资源。

`curl --header "Content-Type: application/json-patch+json" \ --request PATCH \ --data '[{"op": "add", "path": "/status/capacity/example.com~1foo", "value": "5"}]' \ http://k8s-master:8080/api/v1/nodes/k8s-node-1/status`

> Note: 在前面的请求中，​`~1`​ 是在 patch 路径中对字符 ​`/`​ 的编码。 JSON-Patch 中的操作路径的值被视为 JSON-Pointer 类型。 有关更多详细信息，请参见 [IETF RFC 6901 第 3 节](https://datatracker.ietf.org/doc/html/rfc6901 target=)。

#### 集群层面的扩展资源 

集群层面的扩展资源并不绑定到具体节点。 它们通常由调度器扩展程序（Scheduler Extenders）管理，这些程序处理资源消耗和资源配额。

你可以在调度器策略配置 中指定由调度器扩展程序处理的扩展资源。

示例：

下面的调度器策略配置标明集群层扩展资源 "example.com/foo" 由调度器扩展程序处理。

*   仅当 Pod 请求 "example.com/foo" 时，调度器才会将 Pod 发送到调度器扩展程序。
*   ​`ignoredByScheduler` ​字段指定调度器不要在其 ​`PodFitsResources` ​断言中检查 "example.com/foo" 资源。

`{   "kind": "Policy",   "apiVersion": "v1",   "extenders": [     {       "urlPrefix":"<extender-endpoint>",       "bindVerb": "bind",       "managedResources": [         {           "name": "example.com/foo",           "ignoredByScheduler": true         }       ]     }   ] }`

### 使用扩展资源 

就像 CPU 和内存一样，用户可以在 Pod 的规约中使用扩展资源。 调度器负责资源的核算，确保同时分配给 Pod 的资源总量不会超过可用数量。

> Note: 扩展资源取代了非透明整数资源（Opaque Integer Resources，OIR）。 用户可以使用 ​`kubernetes.io`​ （保留）以外的任何域名前缀。

要在 Pod 中使用扩展资源，请在容器规范的 ​`spec.containers[].resources.limits`​ 映射中包含资源名称作为键。

> Note: 扩展资源不能过量使用，因此如果容器规范中同时存在请求和约束，则它们的取值必须相同。

仅当所有资源请求（包括 CPU、内存和任何扩展资源）都被满足时，Pod 才能被调度。 在资源请求无法满足时，Pod 会保持在 ​`PENDING` ​状态。

示例：

下面的 Pod 请求 2 个 CPU 和 1 个 "example.com/foo"（扩展资源）。

`apiVersion: v1 kind: Pod metadata:   name: my-pod spec:   containers:   - name: my-container     image: myimage     resources:       requests:         cpu: 2         example.com/foo: 1       limits:         example.com/foo: 1`

PID 限制 
-------

进程 ID（PID）限制允许对 kubelet 进行配置，以限制给定 Pod 可以消耗的 PID 数量。

疑难解答
----

### 我的 Pod 处于悬决状态且事件信息显示 FailedScheduling

如果调度器找不到该 Pod 可以匹配的任何节点，则该 Pod 将保持未被调度状态， 直到找到一个可以被调度到的位置。每当调度器找不到 Pod 可以调度的地方时， 会产生一个 Event。 你可以使用 ​`kubectl` ​来查看 Pod 的事件；例如：

`kubectl describe pod frontend | grep -A 9999999999 Events`

`Events:   Type     Reason            Age   From               Message   ----     ------            ----  ----               -------   Warning  FailedScheduling  23s   default-scheduler  0/42 nodes available: insufficient cpu`

在上述示例中，由于节点上的 CPU 资源不足，名为 “frontend” 的 Pod 无法被调度。 由于内存不足（PodExceedsFreeMemory）而导致失败时，也有类似的错误消息。 一般来说，如果 Pod 处于悬决状态且有这种类型的消息时，你可以尝试如下几件事情：

*   向集群添加更多节点。
*   终止不需要的 Pod，为悬决的 Pod 腾出空间。
*   检查 Pod 所需的资源是否超出所有节点的资源容量。例如，如果所有节点的容量都是​`cpu：1`​， 那么一个请求为 ​`cpu: 1.1`​ 的 Pod 永远不会被调度。
*   检查节点上的污点设置。如果集群中节点上存在污点，而新的 Pod 不能容忍污点， 调度器只会考虑将 Pod 调度到不带有该污点的节点上。

你可以使用 ​`kubectl describe nodes`​ 命令检查节点容量和已分配的资源数量。 例如：

`kubectl describe nodes e2e-test-node-pool-4lw4`

`Name:            e2e-test-node-pool-4lw4 [ ... 这里忽略了若干行以便阅读 ...] Capacity:  cpu:                               2  memory:                            7679792Ki  pods:                              110 Allocatable:  cpu:                               1800m  memory:                            7474992Ki  pods:                              110 [ ... 这里忽略了若干行以便阅读 ...] Non-terminated Pods:        (5 in total)   Namespace    Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits   ---------    ----                                  ------------  ----------  ---------------  -------------   kube-system  fluentd-gcp-v1.38-28bv1               100m (5%)     0 (0%)      200Mi (2%)       200Mi (2%)   kube-system  kube-dns-3297075139-61lj3             260m (13%)    0 (0%)      100Mi (1%)       170Mi (2%)   kube-system  kube-proxy-e2e-test-...               100m (5%)     0 (0%)      0 (0%)           0 (0%)   kube-system  monitoring-influxdb-grafana-v4-z1m12  200m (10%)    200m (10%)  600Mi (8%)       600Mi (8%)   kube-system  node-problem-detector-v0.1-fj7m3      20m (1%)      200m (10%)  20Mi (0%)        100Mi (1%) Allocated resources:   (Total limits may be over 100 percent, i.e., overcommitted.)   CPU Requests    CPU Limits    Memory Requests    Memory Limits   ------------    ----------    ---------------    -------------   680m (34%)      400m (20%)    920Mi (12%)        1070Mi (14%)`

在上面的输出中，你可以看到如果 Pod 请求超过 1120m CPU 或者 6.23Gi 内存，节点将无法满足。

通过查看 "Pods" 部分，你将看到哪些 Pod 占用了节点上的资源。

Pods 可用的资源量低于节点的资源总量，因为系统守护进程也会使用一部分可用资源。 在 Kubernetes API 中，每个 Node 都有一个 ​`.status.allocatable`​ 字段。

字段 ​`.status.allocatable`​ 描述节点上可以用于 Pod 的资源总量（例如：15 个虚拟 CPU、7538 MiB 内存）。

你可以配置资源配额功能特性以限制每个名字空间可以使用的资源总量。 当某名字空间中存在 ResourceQuota 时，Kubernetes 会在该名字空间中的对象强制实施配额。 例如，如果你为不同的团队分配名字空间，你可以为这些名字空间添加 ResourceQuota。 设置资源配额有助于防止一个团队占用太多资源，以至于这种占用会影响其他团队。

你还需要考虑为这些名字空间设置授权访问： 为名字空间提供 全部 的写权限时，具有合适权限的人可能删除所有资源， 包括所配置的 ResourceQuota。

### 我的容器被终止了

你的容器可能因为资源紧张而被终止。要查看容器是否因为遇到资源限制而被杀死， 请针对相关的 Pod 执行 ​`kubectl describe pod`​：

`kubectl describe pod simmemleak-hra99`

输出类似于：

`Name:                           simmemleak-hra99 Namespace:                      default Image(s):                       saadali/simmemleak Node:                           kubernetes-node-tf0f/10.240.216.66 Labels:                         name=simmemleak Status:                         Running Reason: Message: IP:                             10.244.2.75 Containers:   simmemleak:     Image:  saadali/simmemleak     Limits:       cpu:                      100m       memory:                   50Mi     State:                      Running       Started:                  Tue, 07 Jul 2015 12:54:41 -0700     Last Termination State:     Terminated       Exit Code:                1       Started:                  Fri, 07 Jul 2015 12:54:30 -0700       Finished:                 Fri, 07 Jul 2015 12:54:33 -0700     Ready:                      False     Restart Count:              5 Conditions:   Type      Status   Ready     False Events:   Type    Reason     Age   From               Message   ----    ------     ----  ----               -------   Normal  Scheduled  42s   default-scheduler  Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f   Normal  Pulled     41s   kubelet            Container image "saadali/simmemleak:latest" already present on machine   Normal  Created    41s   kubelet            Created container simmemleak   Normal  Started    40s   kubelet            Started container simmemleak   Normal  Killing    32s   kubelet            Killing container with id ead3fb35-5cf5-44ed-9ae1-488115be66c6: Need to kill Pod`

在上面的例子中，​`Restart Count: 5`​ 意味着 Pod 中的 ​`simmemleak` ​容器被终止并且（到目前为止）重启了五次。 原因 ​`OOMKilled` ​显示容器尝试使用超出其限制的内存量。

你接下来要做的或许是检查应用代码，看看是否存在内存泄露。 如果你发现应用的行为与你所预期的相同，则可以考虑为该容器设置一个更高的内存约束 （也可能需要设置请求值）。

##  5.  Kubernetes 使用 kubeconfig 文件组织集群访问
使用 kubeconfig 文件组织集群访问
----------------------

使用 kubeconfig 文件来组织有关集群、用户、命名空间和身份认证机制的信息。 ​`kubectl` ​命令行工具使用 kubeconfig 文件来查找选择集群所需的信息，并与集群的 API 服务器进行通信。

> Note: 用于配置集群访问的文件称为“kubeconfig 文件”。 这是引用配置文件的通用方法，并不意味着有一个名为 ​`kubeconfig` ​的文件

> Warning: 只使用来源可靠的 kubeconfig 文件。使用特制的 kubeconfig 文件可能会导致恶意代码执行或文件暴露。 如果必须使用不受信任的 kubeconfig 文件，请首先像检查 shell 脚本一样仔细检查它。

默认情况下，​`kubectl` ​在 ​`$HOME/.kube`​ 目录下查找名为 ​`config` ​的文件。 你可以通过设置 ​`KUBECONFIG` ​环境变量或者设置 ​`[--kubeconfig](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands)`​参数来指定其他 kubeconfig 文件。

支持多集群、用户和身份认证机制
---------------

假设你有多个集群，并且你的用户和组件以多种方式进行身份认证。比如：

*   正在运行的 kubelet 可能使用证书在进行认证。
*   用户可能通过令牌进行认证。
*   管理员可能拥有多个证书集合提供给各用户。

使用 kubeconfig 文件，你可以组织集群、用户和命名空间。你还可以定义上下文，以便在集群和命名空间之间快速轻松地切换。

上下文（Context）
------------

通过 kubeconfig 文件中的 context 元素，使用简便的名称来对访问参数进行分组。 每个 context 都有三个参数：cluster、namespace 和 user。 默认情况下，​`kubectl` ​命令行工具使用 当前上下文 中的参数与集群进行通信。

选择当前上下文

`kubectl config use-context`

KUBECONFIG 环境变量
---------------

​`KUBECONFIG` ​环境变量包含一个 kubeconfig 文件列表。 对于 Linux 和 Mac，列表以冒号分隔。对于 Windows，列表以分号分隔。 ​`KUBECONFIG` ​环境变量不是必要的。 如果 ​`KUBECONFIG` ​环境变量不存在，​`kubectl` ​使用默认的 kubeconfig 文件，​`$HOME/.kube/config`​。

如果 ​`KUBECONFIG` ​环境变量存在，​`kubectl` ​使用 ​`KUBECONFIG` ​环境变量中列举的文件合并后的有效配置。

合并 kubeconfig 文件
----------------

要查看配置，输入以下命令：

`kubectl config view`

如前所述，输出可能来自 kubeconfig 文件，也可能是合并多个 kubeconfig 文件的结果。

以下是 ​`kubectl` ​在合并 kubeconfig 文件时使用的规则。

1.  如果设置了 --kubeconfig 参数，则仅使用指定的文件。不进行合并。此参数只能使用一次。

否则，如果设置了 KUBECONFIG 环境变量，将它用作应合并的文件列表。根据以下规则合并 KUBECONFIG 环境变量中列出的文件：

*   忽略空文件名。
*   对于内容无法反序列化的文件，产生错误信息。
*   第一个设置特定值或者映射键的文件将生效。
*   永远不会更改值或者映射键。示例：保留第一个文件的上下文以设置 current-context。示例：如果两个文件都指定了 red-user，则仅使用第一个文件的 red-user 中的值。即使第二个文件在 red-user 下有非冲突条目，也要丢弃它们。

否则，使用默认的 kubeconfig 文件， ​`$HOME/.kube/config`​，不进行合并。

4.  根据此链中的第一个匹配确定要使用的上下文。

*   如果存在，使用 ​`--context`​ 命令行参数。
*   使用合并的 kubeconfig 文件中的 ​`current-context`​。

这种场景下允许空上下文。

7.  确定集群和用户。此时，可能有也可能没有上下文。根据此链中的第一个匹配确定集群和用户，这将运行两次：一次用于用户，一次用于集群。

*   如果存在，使用命令行参数：​`--user`​ 或者 ​`--cluster`​。
*   如果上下文非空，从上下文中获取用户或集群。

这种场景下用户和集群可以为空。

10.  确定要使用的实际集群信息。此时，可能有也可能没有集群信息。基于此链构建每个集群信息；第一个匹配项会被采用：

*   如果存在：​`--server`​、​`--certificate-authority`​ 和 ​`--insecure-skip-tls-verify`​，使用命令行参数。
*   如果合并的 kubeconfig 文件中存在集群信息属性，则使用它们。
*   如果没有 server 配置，则配置无效。

12.  确定要使用的实际用户信息。使用与集群信息相同的规则构建用户信息，但每个用户只允许一种身份认证技术：

*   如果存在：​`--client-certificate`​、​`--client-key`​、​`--username`​、​`--password`​ 和 ​`--token`​，使用命令行参数。
*   使用合并的 kubeconfig 文件中的 ​`user` ​字段。
*   如果存在两种冲突技术，则配置无效。

14.  对于仍然缺失的任何信息，使用其对应的默认值，并可能提示输入身份认证信息。

文件引用
----

kubeconfig 文件中的文件和路径引用是相对于 kubeconfig 文件的位置。 命令行上的文件引用是相对于当前工作目录的。 在 ​`$HOME/.kube/config`​ 中，相对路径按相对路径存储，绝对路径按绝对路径存储。

代理
--

你可以在 ​`kubeconfig`​ 文件中设置 ​`proxy-url`​ 来为 ​`kubectl` ​使用代理，例如:

`apiVersion: v1 kind: Config  proxy-url: https://proxy.host:3128  clusters: - cluster:   name: development  users: - name: developer  contexts: - context:   name: development`

##  6.  Kubernetes Windows 节点的资源管理
Windows 节点的资源管理
---------------

本页概述了 Linux 和 Windows 在资源管理方式上的差异。

在 Linux 节点上，cgroups用作资源控制的 pod 边界。容器是在该边界内创建的，用于网络、进程和文件系统隔离。Linux cgroup API 可用于收集 CPU、I/O 和内存使用统计信息。

相比之下，Windows 使用带有系统命名空间过滤器的每个容器的作业对象来包含容器中的所有进程并提供与主机的逻辑隔离。（Job 对象是一种 Windows 进程隔离机制，不同于 Kubernetes 所说的工作）。

如果没有适当的命名空间过滤，就无法运行 Windows 容器。这意味着无法在主机上下文中声明系统特权，因此特权容器在 Windows 上不可用。容器不能假设来自主机的身份，因为安全帐户管理器 (SAM) 是独立的

内存预留
----

Windows 没有 Linux 那样的内存不足进程杀手。Windows 始终将所有用户模式内存分配视为虚拟的，并且页面文件是强制性的。

Windows 节点不会为容器中运行的进程过度使用内存。最终结果是 Windows 不会像 Linux 那样达到内存不足的情况，并且将页面处理到磁盘而不是受到内存不足 (OOM) 终止的影响。如果内存过度配置并且所有物理内存都用尽了，那么分页会降低性能。

您可以使用 kubelet 参数​`--kubelet-reserve`​和​`/`​或​`--system-reserve`​;限制工作负载的内存使用。这些考虑了节点（容器外部）的内存使用情况，并减少 了 NodeAllocatable。在部署工作负载时，请设置容器的资源限制。​`NodeAllocatable`​一旦节点已满，这也会减少 并阻止调度程序添加更多 pod。

> 注意：当您为 Windows 容器设置内存资源限制时，您应该设置一个限制并且不指定内存请求，或者将请求设置为等于该限制。

在 Windows 上，避免过度配置的良好做法是为 kubelet 配置至少 2GiB 的系统保留内存，以解决 Windows、Kubernetes 和容器运行时开销。

CPU 预留
------

要考虑操作系统、容器运行时和 Kubernetes 主机进程（例如 kubelet）的 CPU 使用情况，您可以（并且应该）保留总 CPU 的百分比。您应该根据节点上可用的 CPU 内核数来确定此 CPU 预留。要确定要保留的 CPU 百分比，请确定每个节点的最大 pod 密度并监控在其中运行的系统服务的 CPU 使用率，然后选择一个满足您的工作负载需求的值。

您可以使用 kubelet 参数限制工作负载的 CPU 使用率​`--kubelet-reserve`​和​`/`​或​`--system-reserve`​考虑节点（容器外部）的 CPU 使用率。这减少了​`NodeAllocatable`​。然后，集群范围的调度程序在确定 pod 放置时会考虑此预留。

在 Windows 上，kubelet 支持命令行标志来设置 kubelet 进程的优先级：​`--windows-priorityclass`​. 与在 Windows 主机上运行的其他进程相比，此标志允许 kubelet 进程获得更多的 CPU 时间片。有关允许值及其含义的更多信息，请参阅 [Windows 优先级](https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities target=)。为确保正在运行的 Pod 不会饿死 kubelet 的 CPU 周期，请将此标志设置为​`ABOVE_NORMAL_PRIORITY_CLASS`​或更高。

#  12.  Kubernetes 安全

##  1.  Kubernetes 云原生安全概述
云原生安全概述
-------

本概述定义了一个模型，用于在 Cloud Native 安全性上下文中考虑 Kubernetes 安全性。

> Warning: 此容器安全模型只提供建议，而不是经过验证的信息安全策略。

云原生安全的 4 个 C
------------

你可以分层去考虑安全性，云原生安全的 4 个 C 分别是云（Cloud）、集群（Cluster）、容器（Container）和代码（Code）。

> Note: 这种分层方法增强了[深度防护方法](https://en.wikipedia.org/wiki/Defense_in_depth_(computing))在安全性方面的 防御能力，该方法被广泛认为是保护软件系统的最佳实践。

![](https://atts.w3cschool.cn/attachments/image/20220523/1653269290503915.png)  

### 云原生安全的 4C

云原生安全模型的每一层都是基于下一个最外层，代码层受益于强大的基础安全层（云、集群、容器）。 你无法通过在代码层解决安全问题来为基础层中糟糕的安全标准提供保护。

云
-

在许多方面，云（或者位于同一位置的服务器，或者是公司数据中心）是 Kubernetes 集群中的 [可信计算基](https://en.wikipedia.org/wiki/Trusted_computing_base)。 如果云层容易受到攻击（或者被配置成了易受攻击的方式），就不能保证在此基础之上构建的组件是安全的。 每个云提供商都会提出安全建议，以在其环境中安全地运行工作负载。

### 云提供商安全性

如果你是在你自己的硬件或者其他不同的云提供商上运行 Kubernetes 集群， 请查阅相关文档来获取最好的安全实践。

下面是一些比较流行的云提供商的安全性文档链接：

IaaS 提供商

链接

Alibaba Cloud

[https://www.alibabacloud.com/trust-center](https://www.alibabacloud.com/trust-center)

Amazon Web Services

[https://aws.amazon.com/security/](https://aws.amazon.com/security/)

Google Cloud Platform

[https://cloud.google.com/security/](https://cloud.google.com/security/)

IBM Cloud

[https://www.ibm.com/cloud/security](https://www.ibm.com/cloud/security)

Microsoft Azure

[https://docs.microsoft.com/en-us/azure/security/azure-security](https://docs.microsoft.com/en-us/azure/security/azure-security)

Oracle Cloud Infrastructure

[https://www.oracle.com/security/](https://www.oracle.com/security/)

VMWare VSphere

[https://www.vmware.com/security/hardening-guides.html](https://www.vmware.com/security/hardening-guides.html)

### 基础设施安全

关于在 Kubernetes 集群中保护你的基础设施的建议：

Kubernetes 基础架构关注领域

建议

通过网络访问 API 服务（控制平面）

所有对 Kubernetes 控制平面的访问不允许在 Internet 上公开，同时应由网络访问控制列表控制，该列表包含管理集群所需的 IP 地址集。

通过网络访问 Node（节点）

节点应配置为 _仅能_ 从控制平面上通过指定端口来接受（通过网络访问控制列表）连接，以及接受 NodePort 和 LoadBalancer 类型的 Kubernetes 服务连接。如果可能的话，这些节点不应完全暴露在公共互联网上。

Kubernetes 访问云提供商的 API

每个云提供商都需要向 Kubernetes 控制平面和节点授予不同的权限集。为集群提供云提供商访问权限时，最好遵循对需要管理的资源的[最小特权原则](https://en.wikipedia.org/wiki/Principle_of_least_privilege)。[Kops 文档](https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md target=)提供有关 IAM 策略和角色的信息。

访问 etcd

对 etcd（Kubernetes 的数据存储）的访问应仅限于控制平面。根据配置情况，你应该尝试通过 TLS 来使用 etcd。更多信息可以在 [etcd 文档](https://github.com/etcd-io/etcd/tree/master/Documentation)中找到。

etcd 加密

在所有可能的情况下，最好对所有存储进行静态数据加密，并且由于 etcd 拥有整个集群的状态（包括机密信息），因此其磁盘更应该进行静态数据加密。

集群
--

保护 Kubernetes 有两个方面需要注意：

*   保护可配置的集群组件
*   保护在集群中运行的应用程序

### 集群组件 

如果想要保护集群免受意外或恶意的访问，采取良好的信息管理实践，请阅读并遵循有关保护集群的建议。

### 集群中的组件（你的应用）

根据你的应用程序的受攻击面，你可能需要关注安全性的特定面，比如： 如果你正在运行中的一个服务（A 服务）在其他资源链中很重要，并且所运行的另一工作负载（服务 B） 容易受到资源枯竭的攻击，则如果你不限制服务 B 的资源的话，损害服务 A 的风险就会很高。 

容器
--

容器安全性不在本指南的探讨范围内。下面是一些探索此主题的建议和连接：

容器关注领域

建议

容器漏洞扫描和操作系统依赖安全性

作为镜像构建的一部分，你应该扫描你的容器里的已知漏洞。

镜像签名和执行

对容器镜像进行签名，以维护对容器内容的信任。

禁止特权用户

构建容器时，请查阅文档以了解如何在具有最低操作系统特权级别的容器内部创建用户，以实现容器的目标。

使用带有较强隔离能力的容器运行时

选择提供较强隔离能力的容器运行时类。

代码
--

应用程序代码是你最能够控制的主要攻击面之一，虽然保护应用程序代码不在 Kubernetes 安全主题范围内，但以下是保护应用程序代码的建议：

### 代码安全性

代码关注领域

建议

仅通过 TLS 访问

如果你的代码需要通过 TCP 通信，请提前与客户端执行 TLS 握手。除少数情况外，请加密传输中的所有内容。更进一步，加密服务之间的网络流量是一个好主意。这可以通过被称为双向 TLS 或 [mTLS](https://en.wikipedia.org/wiki/Mutual_authentication) 的过程来完成，该过程对两个证书持有服务之间的通信执行双向验证。

限制通信端口范围

此建议可能有点不言自明，但是在任何可能的情况下，你都只应公开服务上对于通信或度量收集绝对必要的端口。

第三方依赖性安全

最好定期扫描应用程序的第三方库以了解已知的安全漏洞。每种编程语言都有一个自动执行此检查的工具。

静态代码分析

大多数语言都提供给了一种方法，来分析代码段中是否存在潜在的不安全的编码实践。只要有可能，你都应该使用自动工具执行检查，该工具可以扫描代码库以查找常见的安全错误，一些工具可以在以下连接中找到：https://owasp.org/www-community/Source\_Code\_Analysis\_Tools

动态探测攻击

你可以对服务运行一些自动化工具，来尝试一些众所周知的服务攻击。这些攻击包括 SQL 注入、CSRF 和 XSS。[OWASP Zed Attack](https://owasp.org/www-project-zap/) 代理工具是最受欢迎的动态分析工具之一。

##  2.  Kubernetes Pod安全性标准
Pod 安全性标准
---------

Pod 安全性标准定义了三种不同的 策略（Policy），以广泛覆盖安全应用场景。 这些策略是 渐进式的（Cumulative），安全级别从高度宽松至高度受限。 本指南概述了每个策略的要求。

Profile

描述

**Privileged**

不受限制的策略，提供最大可能范围的权限许可。此策略允许已知的特权提升。

**Baseline**

限制性最弱的策略，禁止已知的策略提升。允许使用默认的（规定最少）Pod 配置。

**Restricted**

限制性非常强的策略，遵循当前的保护 Pod 的最佳实践。

Profile 细节 
-----------

### Privileged

Privileged 策略是有目的地开放且完全无限制的策略。 此类策略通常针对由特权较高、受信任的用户所管理的系统级或基础设施级负载。

Privileged 策略定义中限制较少。对于默认允许（Allow-by-default）实施机制（例如 gatekeeper）， Privileged 框架可能意味着不应用任何约束而不是实施某策略实例。 与此不同，对于默认拒绝（Deny-by-default）实施机制（如 Pod 安全策略）而言， Privileged 策略应该默认允许所有控制（即，禁止所有限制）。

### Baseline

Baseline 策略的目标是便于常见的容器化应用采用，同时禁止已知的特权提升。 此策略针对的是应用运维人员和非关键性应用的开发人员。 下面列举的控制应该被实施（禁止）：

> Note:  
> 在下述表格中，通配符（​`*`​）意味着一个列表中的所有元素。 例如 ​`spec.containers[*].securityContext`​ 表示 所定义的所有容器 的安全性上下文对象。 如果所列出的任一容器不能满足要求，整个 Pod 将无法通过校验。

控制（Control）

策略（Policy）

HostProcess

Windows Pod 提供了运行 HostProcess 容器 的能力， 这使得对 Windows 节点的特权访问成为可能。 基线策略中对宿主的特权访问是被禁止的。 HostProcess Pod 是 Kubernetes **v1.22** 版本的 **alpha** 特性。

**限制的字段**

*   `spec.securityContext.windowsOptions.hostProcess`
*   `spec.containers[*].securityContext.windowsOptions.hostProcess`
*   `spec.initContainers[*].securityContext.windowsOptions.hostProcess`
*   `spec.ephemeralContainers[*].securityContext.windowsOptions.hostProcess`

**允许的值**

*   未定义/nil
*   `false`

宿主名字空间

必须禁止共享宿主名字空间。

**限制的字段**

*   `spec.hostNetwork`
*   `spec.hostPID`
*   `spec.hostIPC`

**允许的值**

*   未定义/nil
*   `false`

特权容器

特权 Pod 关闭了大多数安全性机制，必须被禁止。

**限制的字段**

*   `spec.containers[*].securityContext.privileged`
*   `spec.initContainers[*].securityContext.privileged`
*   `spec.ephemeralContainers[*].securityContext.privileged`

**允许的值**

*   未定义/nil
*   `false`

权能

必须禁止添加除下列字段之外的权能。

**限制的字段**

*   `spec.containers[*].securityContext.capabilities.add`
*   `spec.initContainers[*].securityContext.capabilities.add`
*   `spec.ephemeralContainers[*].securityContext.capabilities.add`

**允许的值**

*   Undefined/nil
*   `AUDIT_WRITE`
*   `CHOWN`
*   `DAC_OVERRIDE`
*   `FOWNER`
*   `FSETID`
*   `KILL`
*   `MKNOD`
*   `NET_BIND_SERVICE`
*   `SETFCAP`
*   `SETGID`
*   `SETPCAP`
*   `SETUID`
*   `SYS_CHROOT`

HostPath 卷

必须禁止 HostPath 卷。

**限制的字段**

*   `spec.volumes[*].hostPath`

**允许的值**

*   未定义/nil

宿主端口

应禁止使用宿主端口，或者至少限定为已知列表。

**限制的字段**

*   `spec.containers[*].ports[*].hostPort`
*   `spec.initContainers[*].ports[*].hostPort`
*   `spec.ephemeralContainers[*].ports[*].hostPort`

**允许的值**

*   未定义/nil
*   已知列表
*   `0`

AppArmor

在受支持的主机上，默认使用 `runtime/default` AppArmor Profile。 基线策略应避免覆盖或者禁用默认策略，以及限制覆盖一些 Profile 集合的权限。

**限制的字段**

*   `metadata.annotations["container.apparmor.security.beta.kubernetes.io/*"]`

**允许的值**

*   未定义/nil
*   `runtime/default`
*   `localhost/*`

SELinux

设置 SELinux 类型的操作是被限制的，设置自定义的 SELinux 用户或角色选项是被禁止的。

**限制的字段**

*   `spec.securityContext.seLinuxOptions.type`
*   `spec.containers[*].securityContext.seLinuxOptions.type`
*   `spec.initContainers[*].securityContext.seLinuxOptions.type`
*   `spec.ephemeralContainers[*].securityContext.seLinuxOptions.type`

**允许的值**

*   未定义/""
*   `container_t`
*   `container_init_t`
*   `container_kvm_t`

* * *

**限制的字段**

*   `spec.securityContext.seLinuxOptions.user`
*   `spec.containers[*].securityContext.seLinuxOptions.user`
*   `spec.initContainers[*].securityContext.seLinuxOptions.user`
*   `spec.ephemeralContainers[*].securityContext.seLinuxOptions.user`
*   `spec.securityContext.seLinuxOptions.role`
*   `spec.containers[*].securityContext.seLinuxOptions.role`
*   `spec.initContainers[*].securityContext.seLinuxOptions.role`
*   `spec.ephemeralContainers[*].securityContext.seLinuxOptions.role`

**允许的值**

*   未定义/""

`/proc` 挂载类型

要求使用默认的 `/proc` 掩码以减小攻击面。

**限制的字段**

*   `spec.containers[*].securityContext.procMount`
*   `spec.initContainers[*].securityContext.procMount`
*   `spec.ephemeralContainers[*].securityContext.procMount`

**允许的值**

*   未定义/nil
*   `Default`

Seccomp

Seccomp Profile 禁止被显式设置为 `Unconfined`。

**限制的字段**

*   `spec.securityContext.seccompProfile.type`
*   `spec.containers[*].securityContext.seccompProfile.type`
*   `spec.initContainers[*].securityContext.seccompProfile.type`
*   `spec.ephemeralContainers[*].securityContext.seccompProfile.type`

**允许的值**

*   未定义/nil
*   `RuntimeDefault`
*   `Localhost`

Sysctls

Sysctls 可以禁用安全机制或影响宿主上所有容器，因此除了若干“安全”的子集之外，应该被禁止。 如果某 sysctl 是受容器或 Pod 的名字空间限制，且与节点上其他 Pod 或进程相隔离，可认为是安全的。

**限制的字段**

*   `spec.securityContext.sysctls[*].name`

**允许的值**

*   未定义/nil
*   `kernel.shm_rmid_forced`
*   `net.ipv4.ip_local_port_range`
*   `net.ipv4.ip_unprivileged_port_start`
*   `net.ipv4.tcp_syncookies`
*   `net.ipv4.ping_group_range`

### Restricted

Restricted 策略旨在实施当前保护 Pod 的最佳实践，尽管这样作可能会牺牲一些兼容性。 该类策略主要针对运维人员和安全性很重要的应用的开发人员，以及不太被信任的用户。 下面列举的控制需要被实施（禁止）：

> Note: 在下述表格中，通配符（​`*`​）意味着一个列表中的所有元素。 例如 ​`spec.containers[*].securityContext`​ 表示 所定义的所有容器 的安全性上下文对象。 如果所列出的任一容器不能满足要求，整个 Pod 将无法通过校验。

**控制（Control）**

**策略（Policy）**

_基线策略的所有要求。_

卷类型

除了限制 HostPath 卷之外，此类策略还限制可以通过 PersistentVolumes 定义的非核心卷类型。

**限制的字段**

*   `spec.volumes[*]`

**允许的值**

`spec.volumes[*]` 列表中的每个条目必须将下面字段之一设置为非空值：

*   `spec.volumes[*].configMap`
*   `spec.volumes[*].csi`
*   `spec.volumes[*].downwardAPI`
*   `spec.volumes[*].emptyDir`
*   `spec.volumes[*].ephemeral`
*   `spec.volumes[*].persistentVolumeClaim`
*   `spec.volumes[*].projected`
*   `spec.volumes[*].secret`

特权提升（v1.8+）

禁止（通过 SetUID 或 SetGID 文件模式）获得特权提升。

  

**限制的字段**

*   `spec.containers[*].securityContext.allowPrivilegeEscalation`
*   `spec.initContainers[*].securityContext.allowPrivilegeEscalation`
*   `spec.ephemeralContainers[*].securityContext.allowPrivilegeEscalation`

**允许的值**

*   `false`

以非 root 账号运行

必须要求容器以非 root 用户运行。

**限制的字段**

*   `spec.securityContext.runAsNonRoot`
*   `spec.containers[*].securityContext.runAsNonRoot`
*   `spec.initContainers[*].securityContext.runAsNonRoot`
*   `spec.ephemeralContainers[*].securityContext.runAsNonRoot`

**允许的值**

*   `true`

如果 Pod 级别 `spec.securityContext.runAsNonRoot` 设置为 `true`，则允许容器组的安全上下文字段设置为 未定义/`nil`。

非 root 用户（v1.23+）

Containers 不可以将 runAsUser 设置为 0

**限制的字段**

*   `spec.securityContext.runAsUser`
*   `spec.containers[*].securityContext.runAsUser`
*   `spec.initContainers[*].securityContext.runAsUser`
*   `spec.ephemeralContainers[*].securityContext.runAsUser`

**允许的字段**

*   any non-zero value
*   `未定义/空值`

Seccomp (v1.19+)

Seccomp Profile 必须被显式设置成一个允许的值。禁止使用 `Unconfined` Profile 或者指定 _不存在的_ Profile。

**限制的字段**

*   `spec.securityContext.seccompProfile.type`
*   `spec.containers[*].securityContext.seccompProfile.type`
*   `spec.initContainers[*].securityContext.seccompProfile.type`
*   `spec.ephemeralContainers[*].securityContext.seccompProfile.type`

**允许的值**

*   `RuntimeDefault`
*   `Localhost`

如果 Pod 级别的 `spec.securityContext.seccompProfile.type` 已设置得当，容器级别的安全上下文字段可以为 未定义/`nil`。 反过来说，如果 \_所有的\_ 容器级别的安全上下文字段已设置，则 Pod 级别的字段可为 未定义/`nil`。

权能（v1.22+）

容器组必须弃用 `ALL` 权能，并且只允许添加 `NET_BIND_SERVICE` 权能。

**限制的字段**

*   `spec.containers[*].securityContext.capabilities.drop`
*   `spec.initContainers[*].securityContext.capabilities.drop`
*   `spec.ephemeralContainers[*].securityContext.capabilities.drop`

**允许的值**

*   包含 `ALL` 的任何一种权能列表。

* * *

**限制的字段**

*   `spec.containers[*].securityContext.capabilities.add`
*   `spec.initContainers[*].securityContext.capabilities.add`
*   `spec.ephemeralContainers[*].securityContext.capabilities.add`

**允许的值**

*   未定义/nil
*   `NET_BIND_SERVICE`

策略实例化 
------

将策略定义从策略实例中解耦出来有助于形成跨集群的策略理解和语言陈述， 以免绑定到特定的下层实施机制。

随着相关机制的成熟，这些机制会按策略分别定义在下面。特定策略的实施方法不在这里定义。

Pod 安全性准入控制器

*   [Privileged 名字空间](https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/security/podsecurity-privileged.yaml)
*   [Baseline 名字空间](https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/security/podsecurity-baseline.yaml)
*   [Restricted 名字空间](https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/security/podsecurity-restricted.yaml)

PodSecurityPolicy （已弃用）

*   [Privileged](https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/privileged-psp.yaml)
*   [Baseline](https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/baseline-psp.yaml)
*   [Restricted](https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/restricted-psp.yaml)

常见问题 
-----

### 为什么不存在介于 Privileged 和 Baseline 之间的策略类型

这里定义的三种策略框架有一个明晰的线性递进关系，从最安全（Restricted）到最不安全， 并且覆盖了很大范围的工作负载。特权要求超出 Baseline 策略者通常是特定于应用的需求， 所以我们没有在这个范围内提供标准框架。 这并不意味着在这样的情形下仍然只能使用 Privileged 框架，只是说处于这个范围的 策略需要因地制宜地定义。

SIG Auth 可能会在将来考虑这个范围的框架，前提是有对其他框架的需求。

### 安全策略与安全上下文的区别是什么？

安全上下文在运行时配置 Pod 和容器。安全上下文是在 Pod 清单中作为 Pod 和容器规约的一部分来定义的，所代表的是 传递给容器运行时的参数。

安全策略则是控制面用来对安全上下文以及安全性上下文之外的参数实施某种设置的机制。 在 2020 年 7 月， Pod 安全性策略已被废弃， 取而代之的是内置的 Pod 安全性准入控制器。

Kubernetes 生态系统中还在开发一些其他的替代方案，例如

*   [OPA Gatekeeper](https://github.com/open-policy-agent/gatekeeper)
*   [Kubewarden](https://github.com/kubewarden)
*   [Kyverno](https://kyverno.io/policies/pod-security/)

### 我应该为我的 Windows Pod 实施哪种框架？ 

Kubernetes 中的 Windows 负载与标准的基于 Linux 的负载相比有一些局限性和区别。 尤其是 Pod SecurityContext 字段 对 Windows 不起作用。 因此，目前没有对应的标准 Pod 安全性框架。

如果你为一个 Windows Pod 应用了 Restricted 策略，可能会 对该 Pod 的运行时产生影响。 Restricted 策略需要强制执行 Linux 特有的限制（如 seccomp Profile，并且禁止特权提升）。 如果 kubelet 和/或其容器运行时忽略了 Linux 特有的值，那么应该不影响 Windows Pod 正常工作。 然而，对于使用 Windows 容器的 Pod 来说，缺乏强制执行意味着相比于 Restricted 策略，没有任何额外的限制。

你应该只在 Privileged 策略下使用 HostProcess 标志来创建 HostProcess Pod。 在 Baseline 和 Restricted 策略下，创建 Windows HostProcess Pod 是被禁止的， 因此任何 HostProcess Pod 都应该被认为是有特权的。

### 沙箱（Sandboxed） Pod 怎么处理？

现在还没有 API 标准来控制 Pod 是否被视作沙箱化 Pod。 沙箱 Pod 可以通过其是否使用沙箱化运行时（如 gVisor 或 Kata Container）来辨别，不过 目前还没有关于什么是沙箱化运行时的标准定义。

沙箱化负载所需要的保护可能彼此各不相同。例如，当负载与下层内核直接隔离开来时， 限制特权化操作的许可就不那么重要。这使得那些需要更多许可权限的负载仍能被有效隔离。

此外，沙箱化负载的保护高度依赖于沙箱化的实现方法。 因此，现在还没有针对所有沙箱化负载的建议策略。

##  3.  Kubernetes Pod安全性准入
Pod 安全性准入
---------

FEATURE STATE: Kubernetes v1.23 \[beta\]

Kubernetes Pod 安全性标准（Security Standards） 为 Pod 定义不同的隔离级别。这些标准能够让你以一种清晰、一致的方式定义如何限制 Pod 行为。

作为一项 Beta 功能特性，Kubernetes 提供一种内置的 Pod 安全性 准入控制器， 作为 PodSecurityPolicies 特性的后继演化版本。Pod 安全性限制是在 Pod 被创建时在 名字空间层面实施的。

> Note:  
> PodSecurityPolicy API 已经被废弃，会在 Kubernetes v1.25 发行版中 移除。

启用 PodSecurity 准入插件 
--------------------

在 v1.23 中，​`PodSecurity` ​特性门控 是一项 Beta 功能特性，默认被启用。

在 v1.22 中，​`PodSecurity` ​特性门控 是一项 Alpha 功能特性，必须在 ​`kube-apiserver`​ 上启用才能使用内置的准入插件。

`--feature-gates="...,PodSecurity=true"`

替代方案：安装 PodSecurity 准入 Webhook 
-------------------------------

对于无法应用内置 ​`PodSecurity` ​准入插件的环境，无论是因为集群版本低于 v1.22， 或者 ​`PodSecurity` ​特性无法被启用，都可以使用 Beta 版本的 [验证性准入 Webhook](https://github.com/kubernetes/pod-security-admission/tree/master/webhook)。 来使用 ​`PodSecurity` ​准入逻辑。

在 [https://git.k8s.io/pod-security-admission/webhook](https://github.com/kubernetes/pod-security-admission/tree/master/webhook) 上可以找到一个预先构建的容器镜像、证书生成脚本以及一些示例性质的清单。

`git clone git@github.com:kubernetes/pod-security-admission.git cd pod-security-admission/webhook make certs kubectl apply -k .`

> Note:  
> 所生成的证书合法期限为 2 年。在证书过期之前， 需要重新生成证书或者去掉 Webhook 以使用内置的准入查件。

Pod 安全性级别 
----------

Pod 安全性准入插件对 Pod 的安全性上下文 有一定的要求，并且依据 Pod 安全性标准 所定义的三个级别（​`privileged`​、​`baseline` ​和 ​`restricted`​）对其他字段也有要求。

为名字空间设置 Pod 安全性准入控制标签
---------------------

一旦特性被启用或者安装了 Webhook，你可以配置名字空间以定义每个名字空间中 Pod 安全性准入控制模式。 Kubernetes 定义了一组标签， 你可以设置这些标签来定义某个名字空间上要使用的预定义的 Pod 安全性标准级别。 你所选择的标签定义了检测到潜在违例时，控制面 要采取什么样的动作。

模式

描述

**enforce**

策略违例会导致 Pod 被拒绝

**audit**

策略违例会触发审计日志中记录新事件时添加审计注解；但是 Pod 仍是被接受的。

**warn**

策略违例会触发用户可见的警告信息，但是 Pod 仍是被接受的。

名字空间可以配置任何一种或者所有模式，或者甚至为不同的模式设置不同的级别。

对于每种模式，决定所使用策略的标签有两个：

``# 针对模式的级别标签用来标示针对该模式所应用的策略级别 # # MODE 必须是 `enforce`、`audit` 或 `warn` 之一 # LEVEL 必须是 `privileged`、baseline` 或 `restricted` 之一 pod-security.kubernetes.io/<MODE>: <LEVEL>  # 可选：针对每个模式版本的版本标签可以将策略锁定到 # 给定 Kubernetes 小版本号所附带的版本（例如 v1.24） # # MODE 必须是 `enforce`、`audit` 或 `warn` 之一 # VERSION 必须是一个合法的 Kubernetes 小版本号或者 `latest` pod-security.kubernetes.io/<MODE>-version: <VERSION>``

负载资源和 Pod 模板 
-------------

Pod 通常是通过创建 Deployment 或 Job 这类工作负载对象 来间接创建的。工作负载对象为工作负载资源定义一个 Pod 模板 和一个对应的 负责基于该模板来创建 Pod 的控制器。 为了尽早地捕获违例状况，​`audit` ​和 ​`warn` ​模式都应用到负载资源。 不过，​`enforce` ​模式并 不 应用到工作负载资源，仅应用到所生成的 Pod 对象上。

豁免 
---

你可以为 Pod 安全性的实施设置 豁免（Exemptions） 规则， 从而允许创建一些本来会被与给定名字空间相关的策略所禁止的 Pod。 豁免规则可以在准入控制器配置 中静态配置。

豁免规则可以显式枚举。满足豁免标准的请求会被准入控制器 忽略 （所有 ​`enforce`​、​`audit` ​和 ​`warn` ​行为都会被略过）。 豁免的维度包括：

*   ​`Username`​： 来自用户名已被豁免的、已认证的（或伪装的）的用户的请求会被忽略。
*   ​`RuntimeClassName`​： 指定了已豁免的运行时类名称的 Pod 和负载资源会被忽略。
*   ​`Namespace`​： 位于被豁免的名字空间中的 Pod 和负载资源 会被忽略。

> Caution:  
> 大多数 Pod 是作为对工作负载资源的响应， 由控制器所创建的，这意味着为某最终用户提供豁免时，只会当该用户直接创建 Pod 时对其实施安全策略的豁免。用户创建工作负载资源时不会被豁免。 控制器服务账号（例如：​`system:serviceaccount:kube-system:replicaset-controller`​） 通常不应该被豁免，因为豁免这类服务账号隐含着对所有能够创建对应工作负载资源的用户豁免。

策略检查时会对以下 Pod 字段的更新操作予以豁免，这意味着如果 Pod 更新请求仅改变这些字段时，即使 Pod 违反了当前的策略级别，请求也不会被拒绝。

*   除了对 seccomp 或 AppArmor 注解之外的所有 meatadata 更新操作：

*   ​`seccomp.security.alpha.kubernetes.io/pod`​ （已弃用）
*   ​`container.seccomp.security.alpha.kubernetes.io/*` ​（已弃用）
*   ​`container.apparmor.security.beta.kubernetes.io/*`​

*   对 ​`.spec.activeDeadlineSeconds`​ 的合法更新
*   对 ​`.spec.tolerations`​ 的合法更新

##  4.  Kubernetes Pod安全策略
Pod安全策略
-------

FEATURE STATE: Kubernetes v1.21 \[deprecated\]

> Caution: PodSecurityPolicy 自 Kubernetes v1.21 起已弃用，并将在 v1.25 中删除。 我们建议迁移到 Pod 安全准入或 3rd 方准入插件。

Pod 安全策略启用对 pod 创建和更新的细粒度授权。

什么是 Pod 安全策略？
-------------

Pod 安全策略是控制 pod 规范的安全敏感方面的集群级资源。 PodSecurityPolicy 对象定义了一组条件，Pod 必须满足这些条件才能被系统接受，以及相关字段的默认值。 它们允许管理员控制以下内容：

控制方面

字段名称

运行特权容器

privileged

主机命名空间的使用

hostPID, hostIPC

主机网络和端口的使用

hostNetwork, hostPorts

卷类型的使用

volumes

主机文件系统的使用

allowedHostPaths

允许特定的 FlexVolume 驱动程序

allowedFlexVolumes

分配拥有 pod 卷的 FSGroup

fsGroup

要求使用只读根文件系统

readOnlyRootFilesystem

容器的用户和组 ID

runAsUser, runAsGroup, supplementalGroups

限制升级到 root 权限

allowPrivilegeEscalation, defaultAllowPrivilegeEscalation

Linux 功能

defaultAddCapabilities, requiredDropCapabilities, allowedCapabilities

容器的 SELinux 上下文

seLinux

容器的 Allowed Proc Mount 类型

allowedProcMountTypes

容器使用的 AppArmor 配置文件

annotations

容器使用的 seccomp 配置文件

annotations

容器使用的 sysctl 配置文件

forbiddenSysctls,allowedUnsafeSysctls

启用 Pod 安全策略
-----------

Pod 安全策略控制被实现为可选的准入控制器。 PodSecurityPolicies 是通过启用准入控制器来实施的，但是在没有授权任何策略的情况下这样做会阻止在集群中创建任何 Pod。

由于 pod 安全策略 API (​`policy/v1beta1/podsecuritypolicy`​) 独立于准入控制器启用，因此对于现有集群，建议在启用准入控制器之前添加和授权策略。

授权政策
----

创建 PodSecurityPolicy 资源时，它什么也不做。 为了使用它，请求用户或目标 pod 的服务帐户必须被授权使用该策略，方法是允许策略上的 ​`use` ​verb。

大多数 Kubernetes pod 不是由用户直接创建的。 相反，它们通常作为 Deployment、ReplicaSet 或其他模板化控制器的一部分通过控制器管理器间接创建。 授予控制器对策略的访问权限将授予该控制器创建的所有 Pod 的访问权限，因此授权策略的首选方法是授予对 Pod 的服务帐户的访问权限

### 通过 RBAC

RBAC 是一种标准的 Kubernetes 授权模式，可以很容易地用于授权策略的使用。

首先，​`Role`​ 或 ​`ClusterRole` ​需要授予使用所需策略的访问权限。 授予访问权限的规则如下所示：

`apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata:   name: <role name> rules: - apiGroups: ['policy']   resources: ['podsecuritypolicies']   verbs:     ['use']   resourceNames:   - <list of policies to authorize>`

然后 ​`(Cluster)Role`​ 绑定到授权用户：

`apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata:   name: <binding name> roleRef:   kind: ClusterRole   name: <role name>   apiGroup: rbac.authorization.k8s.io subjects: # Authorize all service accounts in a namespace (recommended): - kind: Group   apiGroup: rbac.authorization.k8s.io   name: system:serviceaccounts:<authorized namespace> # Authorize specific service accounts (not recommended): - kind: ServiceAccount   name: <authorized service account name>   namespace: <authorized pod namespace> # Authorize specific users (not recommended): - kind: User   apiGroup: rbac.authorization.k8s.io   name: <authorized user name>`

如果使用 ​`RoleBinding`​（不是 ​`ClusterRoleBinding`​），它只会授予与绑定在同一命名空间中运行的 Pod 的使用权。 这可以与系统组配对以授予对命名空间中运行的所有 pod 的访问权限：

`# Authorize all service accounts in a namespace: - kind: Group   apiGroup: rbac.authorization.k8s.io   name: system:serviceaccounts # Or equivalently, all authenticated users in a namespace: - kind: Group   apiGroup: rbac.authorization.k8s.io   name: system:authenticated`

### 推荐做法

PodSecurityPolicy 正在被一个新的、简化的 ​`PodSecurity` ​准入控制器所取代。请遵循以下指南来简化从 PodSecurityPolicy 到新准入控制器的迁移：

1.  将您的 PodSecurityPolicies 限制为 Pod 安全标准定义的策略：

*   [Privileged](https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/privileged-psp.yaml)
*   [Baseline](https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/baseline-psp.yaml)
*   [Restricted](https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/restricted-psp.yaml)

3.  仅使用 ​`system:serviceaccounts:<namespace>`​ 组（其中 ​`<namespace>`​ 是目标命名空间）将 PSP 绑定到整个命名空间。 例如：

`apiVersion: rbac.authorization.k8s.io/v1 # This cluster role binding allows all pods in the "development" namespace to use the baseline PSP. kind: ClusterRoleBinding metadata:   name: psp-baseline-namespaces roleRef:   kind: ClusterRole   name: psp-baseline   apiGroup: rbac.authorization.k8s.io subjects: - kind: Group   name: system:serviceaccounts:development   apiGroup: rbac.authorization.k8s.io - kind: Group   name: system:serviceaccounts:canary   apiGroup: rbac.authorization.k8s.io`

### 故障排除

控制器管理器必须针对安全的 API 端口运行，并且不得具有超级用户权限。

如果控制器管理器通过受信任的 API 端口（也称为 ​`localhost` ​侦听器）连接，请求将绕过身份验证和授权模块； 所有 PodSecurityPolicy 对象都将被允许，并且用户将能够创建授予自己创建特权容器的能力。

Policy Order 
-------------

除了限制 pod 创建和更新之外，pod 安全策略还可用于为其控制的许多字段提供默认值。 当有多个策略可用时，Pod 安全策略控制器根据以下标准选择策略：

1.  PodSecurityPolicies 允许 pod 保持原样，而不更改默认值或改变 pod，是首选。 这些非变异 PodSecurityPolicies 的顺序无关紧要。
2.  如果 pod 必须是默认的或变异的，则选择第一个允许该 pod 的 PodSecurityPolicy（按名称排序）。

> Note: 在更新操作期间（在此期间不允许对 pod 规范进行更改），仅使用非变异 PodSecurityPolicies 来验证 pod。

例子
--

此示例假设您有一个正在运行的集群并启用了 PodSecurityPolicy 准入控制器，并且您拥有集群管理员权限。

### 设置

设置命名空间和服务帐户以作为本示例的行为。 我们将使用此服务帐户来模拟非管理员用户。

`kubectl create namespace psp-example kubectl create serviceaccount -n psp-example fake-user kubectl create rolebinding -n psp-example fake-editor --clusterrole=edit --serviceaccount=psp-example:fake-user`

为了明确我们所扮演的用户并保存一些输入，创建 2 个别名：

`alias kubectl-admin='kubectl -n psp-example' alias kubectl-user='kubectl --as=system:serviceaccount:psp-example:fake-user -n psp-example'`

### 创建策略和 pod

在文件中定义示例 PodSecurityPolicy 对象。 这是一项阻止创建特权 pod 的策略。 PodSecurityPolicy 对象的名称必须是有效的 DNS 子域名。

`apiVersion: policy/v1beta1 kind: PodSecurityPolicy metadata:   name: example spec:   privileged: false  # Don't allow privileged pods!   # The rest fills in some required fields.   seLinux:     rule: RunAsAny   supplementalGroups:     rule: RunAsAny   runAsUser:     rule: RunAsAny   fsGroup:     rule: RunAsAny   volumes:   - '*'`

并使用 kubectl 创建它：

`kubectl-admin create -f example-psp.yaml`

现在，作为非特权用户，尝试创建一个简单的 pod：

`kubectl-user create -f- <<EOF apiVersion: v1 kind: Pod metadata:   name: pause spec:   containers:     - name: pause       image: k8s.gcr.io/pause EOF`

输出类似于：

`Error from server (Forbidden): error when creating "STDIN": pods "pause" is forbidden: unable to validate against any pod security policy: []`

尽管创建了 PodSecurityPolicy，但 pod 的服务帐户和 ​`fake-user`​ 都无权使用新策略：

`kubectl-user auth can-i use podsecuritypolicy/example no`

创建角色绑定以授予 ​`fake-user`​ 示例策略上的 ​`use` ​verb：

> Note: 这不是推荐的方式！

`kubectl-admin create role psp:unprivileged \     --verb=use \     --resource=podsecuritypolicy \     --resource-name=example role "psp:unprivileged" created  kubectl-admin create rolebinding fake-user:psp:unprivileged \     --role=psp:unprivileged \     --serviceaccount=psp-example:fake-user rolebinding "fake-user:psp:unprivileged" created  kubectl-user auth can-i use podsecuritypolicy/example yes`

现在重试创建 pod：

`kubectl-user create -f- <<EOF apiVersion: v1 kind: Pod metadata:   name: pause spec:   containers:     - name: pause       image: k8s.gcr.io/pause EOF`

输出类似于此

`pod "pause" created`

它按预期工作！ 但仍应拒绝任何创建特权 pod 的尝试：

`kubectl-user create -f- <<EOF apiVersion: v1 kind: Pod metadata:   name: privileged spec:   containers:     - name: pause       image: k8s.gcr.io/pause       securityContext:         privileged: true EOF`

输出类似于：

`Error from server (Forbidden): error when creating "STDIN": pods "privileged" is forbidden: unable to validate against any pod security policy: [spec.containers[0].securityContext.privileged: Invalid value: true: Privileged containers are not allowed]`

在继续之前删除 pod：

`kubectl-user delete pod pause`

### 运行另一个 pod

让我们再试一次，稍有不同：

`kubectl-user create deployment pause --image=k8s.gcr.io/pause`

`deployment "pause" created`

`kubectl-user get pods`

`No resources found.`

`kubectl-user get events | head -n 2`

`LASTSEEN   FIRSTSEEN   COUNT     NAME              KIND         SUBOBJECT                TYPE      REASON                  SOURCE                                  MESSAGE 1m         2m          15        pause-7774d79b5   ReplicaSet                            Warning   FailedCreate            replicaset-controller                   Error creating: pods "pause-7774d79b5-" is forbidden: no providers available to validate pod request`

我们已经为我们的 ​`fake-user`​ 绑定了 ​`psp:unprivileged` ​角色，为什么我们会收到错误 ​`Error created: pods "pause-7774d79b5-" is disabled: no providers available to validate pod request`​？ 答案在于源——​`replicaset-controller`​。 Fake-user 成功创建了部署（成功创建了一个副本集），但是当副本集去创建 pod 时，它没有被授权使用示例 podsecuritypolicy。

为了解决这个问题，请将 ​`psp:unprivileged`​ 角色绑定到 pod 的服务帐户。 在这种情况下（因为我们没有指定它）服务帐户是默认的：

`kubectl-admin create rolebinding default:psp:unprivileged \     --role=psp:unprivileged \     --serviceaccount=psp-example:default`

`rolebinding "default:psp:unprivileged" created`

现在，如果你给它一分钟重试，replicas-controller 最终应该会成功创建 pod：

`kubectl-user get pods --watch`

`NAME                    READY     STATUS    RESTARTS   AGE pause-7774d79b5-qrgcb   0/1       Pending   0         1s pause-7774d79b5-qrgcb   0/1       Pending   0         1s pause-7774d79b5-qrgcb   0/1       ContainerCreating   0         1s pause-7774d79b5-qrgcb   1/1       Running   0         2s`

### 清理

删除命名空间以清理大部分示例资源：

`kubectl-admin delete ns psp-example`

`namespace "psp-example" deleted`

请注意，​`PodSecurityPolicy` ​资源没有命名空间，必须单独清理：

`kubectl-admin delete psp example`

`podsecuritypolicy "example" deleted`

### 示例策略

这是您可以创建的限制最少的策略，相当于不使用 pod 安全策略准入控制器：

`apiVersion: policy/v1beta1 kind: PodSecurityPolicy metadata:   name: privileged   annotations:     seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*' spec:   privileged: true   allowPrivilegeEscalation: true   allowedCapabilities:   - '*'   volumes:   - '*'   hostNetwork: true   hostPorts:   - min: 0     max: 65535   hostIPC: true   hostPID: true   runAsUser:     rule: 'RunAsAny'   seLinux:     rule: 'RunAsAny'   supplementalGroups:     rule: 'RunAsAny'   fsGroup:     rule: 'RunAsAny'`

这是一个限制性策略的示例，它要求用户以非特权用户身份运行，阻止可能升级到 root，并需要使用多种安全机制。

`apiVersion: policy/v1beta1 kind: PodSecurityPolicy metadata:   name: restricted   annotations:     # docker/default identifies a profile for seccomp, but it is not particularly tied to the Docker runtime     seccomp.security.alpha.kubernetes.io/allowedProfileNames: 'docker/default,runtime/default'     apparmor.security.beta.kubernetes.io/allowedProfileNames: 'runtime/default'     apparmor.security.beta.kubernetes.io/defaultProfileName:  'runtime/default' spec:   privileged: false   # Required to prevent escalations to root.   allowPrivilegeEscalation: false   requiredDropCapabilities:     - ALL   # Allow core volume types.   volumes:     - 'configMap'     - 'emptyDir'     - 'projected'     - 'secret'     - 'downwardAPI'     # Assume that ephemeral CSI drivers & persistentVolumes set up by the cluster admin are safe to use.     - 'csi'     - 'persistentVolumeClaim'     - 'ephemeral'   hostNetwork: false   hostIPC: false   hostPID: false   runAsUser:     # Require the container to run without root privileges.     rule: 'MustRunAsNonRoot'   seLinux:     # This policy assumes the nodes are using AppArmor rather than SELinux.     rule: 'RunAsAny'   supplementalGroups:     rule: 'MustRunAs'     ranges:       # Forbid adding the root group.       - min: 1         max: 65535   fsGroup:     rule: 'MustRunAs'     ranges:       # Forbid adding the root group.       - min: 1         max: 65535   readOnlyRootFilesystem: false`

策略参考
----

### 特权

Privileged - 确定 pod 中的任何容器是否可以启用特权模式。 默认情况下，不允许容器访问主机上的任何设备，但“特权”容器可以访问主机上的所有设备。 这允许容器几乎与主机上运行的进程具有相同的访问权限。 这对于想要使用 linux 功能（例如操作网络堆栈和访问设备）的容器很有用。

### 主机命名空间

*   ​`HostPID`​ - 控制 pod 容器是否可以共享主机进程 ID 命名空间。 请注意，当与 ptrace 配对时，这可用于提升容器外部的权限（默认情况下禁止使用 ptrace）。
*   ​`HostIPC` ​- 控制 pod 容器是否可以共享主机 IPC 命名空间。
*   ​`HostNetwork` ​- 控制 pod 是否可以使用节点网络命名空间。 这样做可以让 pod 访问环回设备、侦听 localhost 的服务，并可用于窥探同一节点上其他 pod 的网络活动。
*   ​`HostPorts` ​- 提供主机网络命名空间中允许的端口范围列表。 定义为 ​`HostPortRange` ​的列表，具有 ​`min`​(inclusive) 和 ​`max`​(inclusive)。 默认为不允许的主机端口。

### 卷和文件系统

卷 - 提供允许的卷类型列表。 允许的值对应于创建卷时定义的卷源。 此外，​`*`​ 可用于允许所有卷类型。

新 PSPs 的建议最小允许卷集是：

*   ​`configMap` ​
*   ​`downwardAPI` ​
*   ​`emptyDir` ​
*   ​`persistentVolumeClaim` ​
*   ​`secret` ​
*   ​`projected`​

> Warning: PodSecurityPolicy 不限制 ​`PersistentVolumeClaim` ​可以引用的 ​`PersistentVolume` ​对象的类型，hostPath 类型的 ​`PersistentVolume` ​不支持只读访问模式。 只有受信任的用户才应被授予创建 ​`PersistentVolume` ​对象的权限。

FSGroup - 控制应用于某些卷的补充组。

*   ​`MustRunAs` ​- 至少需要指定一个范围。 使用第一个范围的最小值作为默认值。 针对所有范围进行验证。
*   ​`MayRunAs` ​- 至少需要指定一个范围。 允许不设置 ​`FSGroups` ​而不提供默认值。 如果设置了 ​`FSGroups`​，则针对所有范围进行验证。
*   ​`RunAsAny` ​- 未提供默认值。 允许指定任何 ​`fsGroup` ​ID。

AllowedHostPaths - 这指定允许由 hostPath 卷使用的主机路径列表。 空列表意味着对使用的主机路径没有限制。 这被定义为具有单个 ​`pathPrefix` ​字段的对象列表，它允许 hostPath 卷安装以允许的前缀开头的路径，并且 ​`readOnly` ​字段指示它必须以只读方式安装。 例如：

  `allowedHostPaths:     # This allows "/foo", "/foo/", "/foo/bar" etc., but     # disallows "/fool", "/etc/foo" etc.     # "/foo/../" is never valid.     - pathPrefix: "/foo"       readOnly: true # only allow read-only mounts`

> Warning:  
> 对主机文件系统具有无限制访问权限的容器可以通过多种方式提升权限，包括从其他容器读取数据，以及滥用系统服务（如 Kubelet）的凭据。  
> 可写的 hostPath 目录卷允许容器以允许它们在 ​`pathPrefix` ​之外遍历主机文件系统的方式写入文件系统。 ​`readOnly: true`​，在 Kubernetes 1.11+ 中可用，必须在所有 ​`allowedHostPaths` ​上使用，以有效限制对指定 ​`pathPrefix` ​的访问。

ReadOnlyRootFilesystem - 要求容器必须使用只读根文件系统（即无可写层）运行。

### 弹性卷驱动程序

这指定了允许 flexvolume 使用的 FlexVolume 驱动程序列表。 空列表或 nil 表示对驱动程序没有限制。 请确保 ​`volumes` ​字段包含 ​`flexVolume` ​卷类型； 否则不允许使用任何 FlexVolume 驱动程序。

例如：

`apiVersion: policy/v1beta1 kind: PodSecurityPolicy metadata:   name: allow-flex-volumes spec:   # ... other spec fields   volumes:     - flexVolume   allowedFlexVolumes:     - driver: example/lvm     - driver: example/cifs`

### 用户和组

RunAsUser - 控制容器运行时使用的用户 ID。

*   ​`MustRunAs` ​- 至少需要指定一个范围。 使用第一个范围的最小值作为默认值。 针对所有范围进行验证。
*   ​`MustRunAsNonRoot` ​- 要求使用非零 ​`runAsUser` ​提交 pod 或在映像中定义 USER 指令（使用数字 UID）。 既没有指定 ​`runAsNonRoot` ​也没有指定 ​`runAsUser` ​设置的 Pod 将被更改为设置 ​`runAsNonRoot=true`​，因此需要在容器中定义一个非零数字 USER 指令。 没有提供默认值。 强烈建议使用此策略设置 ​`allowPrivilegeEscalation=false`​。
*   ​`RunAsAny` ​- 未提供默认值。 允许指定任何 ​`runAsUser`​。

RunAsGroup - 控制容器运行的主要组 ID。

*   ​`MustRunAs` ​- 至少需要指定一个范围。 使用第一个范围的最小值作为默认值。 针对所有范围进行验证。
*   ​`MayRunAs` ​- 不需要指定 RunAsGroup。 但是，当指定 RunAsGroup 时，它们必须落在定义的范围内。
*   ​`RunAsAny` ​- 未提供默认值。 允许指定任何 ​`runAsGroup`​

SupplementalGroups - 控制容器添加的组 ID。

*   ​`MustRunAs` ​- 至少需要指定一个范围。 使用第一个范围的最小值作为默认值。 针对所有范围进行验证。
*   ​`MayRunAs` ​- 至少需要指定一个范围。 允许在不提供默认值的情况下不设置​`supplementalGroups`​。 如果设置了补充组，则验证所有范围。
*   ​`RunAsAny` ​- 未提供默认值。 允许指定任何补充组。

### 权限提升

这些选项控制 ​`allowPrivilegeEscalation` ​容器选项。 此布尔值直接控制是否在容器进程上设置 ​`no_new_privs` ​标志。 此标志将阻止 ​`setuid` ​二进制文件更改有效用户 ID，并阻止文件启用额外功能（例如，它将阻止使用 ​`ping` ​工具）。 此行为是有效实施 ​`MustRunAsNonRoot` ​所必需的。

AllowPrivilegeEscalation - 决定是否允许用户将容器的安全上下文设置为 ​`allowPrivilegeEscalation=true`​。 这默认为允许，以免破坏 setuid 二进制文件。 将其设置为 ​`false` ​可确保容器的任何子进程都无法获得比其父进程更多的权限。

DefaultAllowPrivilegeEscalation - 设置 ​`allowPrivilegeEscalation` ​选项的默认值。 没有这个的默认行为是允许权限升级，以免破坏 setuid 二进制文件。 如果不需要该行为，则可以使用此字段默认为禁止，同时仍允许 pod 显式请求 ​`allowPrivilegeEscalation`​。

### 能力

Linux 功能提供了对传统上与超级用户相关的权限的更细粒度的细分。 其中一些功能可用于提升权限或用于容器突破，并且可能受 PodSecurityPolicy 限制。

以下字段采用功能列表，指定为 ALL\_CAPS 中不带 ​`CAP_` ​前缀的功能名称。

*   ​`AllowedCapabilities` ​- 提供允许添加到容器的功能列表。 默认功能集是隐式允许的。 空集意味着除了默认集之外不能添加其他功能。 ​`*`​ 可用于允许所有功能。
*   ​`RequiredDropCapabilities` ​- 必须从容器中删除的功能。 这些功能已从默认设置中删除，不得添加。 ​`RequiredDropCapabilities` ​中列出的功能不得包含在 ​`AllowedCapabilities` ​或 ​`DefaultAddCapabilities` ​中。
*   ​`DefaultAddCapabilities` ​- 除了运行时默认值之外，默认情况下添加到容器的功能。 

### SELinux

*   ​`MustRunAs` ​- 需要配置 ​`seLinuxOptions`​。 使用 ​`seLinuxOptions` ​作为默认值。 针对 ​`seLinuxOptions` ​进行验证。
*   ​`RunAsAny` ​- 未提供默认值。 允许指定任何 ​`seLinuxOptions`​。

### AllowedProcMountTypes

​`allowedProcMountTypes` ​是允许的 ProcMountTypes 的列表。 Empty 或 nil 表示只能使用 ​`DefaultProcMountType`​。

​`DefaultProcMount` ​对 /proc 的只读路径和掩码路径使用容器运行时默认值。 大多数容器运行时会屏蔽 /proc 中的某些路径，以避免特殊设备或信息的意外安全暴露。 这表示为字符串 ​`Default`​。

唯一的其他 ProcMountType 是 ​`UnmaskedProcMount`​，它绕过了容器运行时的默认屏蔽行为，并确保新创建的 /proc 容器保持不变而无需修改。 这表示为字符串 ​`Unmasked`​。

### AppArmor

通过 PodSecurityPolicy 上的注释进行控制。

### Seccomp

从 Kubernetes v1.19 开始，您可以使用 Pod 或容器的 ​`securityContext` ​中的 ​`seccompProfile` ​字段来控制 seccomp 配置文件的使用。 在之前的版本中，seccomp 是通过向 Pod 添加注释来控制的。 相同的 PodSecurityPolicies 可以与任一版本一起使用，以强制应用这些字段或注释。

seccomp.security.alpha.kubernetes.io/defaultProfileName - 指定要应用于容器的默认 seccomp 配置文件的注释。 可能的值为：

*   ​`unconfined` ​- 如果没有提供替代方案，则不将 Seccomp 应用于容器进程（这是 Kubernetes 中的默认设置）。
*   ​`runtime/default`​ - 使用默认容器运行时配置文件。
*   ​`docker/default`​ - 使用 Docker 默认的 seccomp 配置文件。 自 Kubernetes 1.11 起已弃用。 请改用runtime/default。
*   ​`localhost/<path>`​ - 将配置文件指定为位于 ​`<seccomp_root>/<path>`​ 的节点上的文件，其中 ​`<seccomp_root>`​ 是通过 Kubelet 上的 ​`--seccomp-profile-root`​ 标志定义的。 如果未定义 ​`--seccomp-profile-root`​ 标志，将使用默认路径，即 ​`<root-dir>/seccomp`​ 其中 ​`<root-dir>`​ 由 ​`--root-dir`​ 标志指定。

> Note: ​`--seccomp-profile-root`​ 标志自 Kubernetes v1.19 起已弃用。 鼓励用户使用默认路径。

​`seccomp.security.alpha.kubernetes.io/allowedProfileNames`​ - 指定 pod seccomp 注释允许哪些值的注释。 指定为允许值的逗号分隔列表。 可能的值是上面列出的值，加上 ​`*`​ 以允许所有配置文件。 缺少此注释意味着无法更改默认值。

### 

Sysctl

默认情况下，允许所有安全的 sysctl。

*   ​`forbiddenSysctls` ​- 不包括特定的 sysctl。 您可以在列表中禁止安全和不安全 sysctl 的组合。 要禁止设置任何 sysctls，请单独使用 ​`*`​。
*   ​`allowedUnsafeSysctls` ​- 允许被默认列表禁止的特定 sysctl，只要这些未在​`forbiddenSysctls`​中列出。

##  5.  Kubernetes Windows节点的安全性
Windows 节点的安全性
--------------

本页介绍特定于 Windows 操作系统的安全注意事项和最佳实践。

保护节点上的机密数据
----------

在 Windows 上，来自 Secrets 的数据以明文形式写入节点的本地存储（与在 Linux 上使用 tmpfs / in-memory 文件系统相比）。 作为集群运营商，您应该采取以下两项额外措施：

1.  使用文件 ACL 来保护 Secrets 的文件位置。
2.  使用 [BitLocker](https://docs.microsoft.com/zh-cn/windows/security/information-protection/bitlocker/bitlocker-how-to-deploy-on-windows-server) 应用卷级加密。

容器用户
----

可以为 Windows Pod 或容器指定 RunAsUsername 以作为特定用户执行容器进程。 这大致相当于 RunAsUser。

Windows 容器提供两个默认用户帐户，ContainerUser 和 ContainerAdministrator。 Microsoft 的安全 Windows 容器文档中的[何时使用 ContainerAdmin 和 ContainerUser 用户帐户](https://docs.microsoft.com/zh-cn/virtualization/windowscontainers/manage-containers/container-security target=)中介绍了这两个用户帐户之间的区别。

本地用户可以在容器构建过程中添加到容器镜像中。

> Note:  
> 
> *   基于 [Nano Server](https://hub.docker.com/_/microsoft-windows-nanoserver) 的图像默认以 ​`ContainerUser` ​身份运行
> *   基于 [Server Core](https://hub.docker.com/_/microsoft-windows-servercore) 的镜像默认作为 ​`ContainerAdministrator` ​运行

Windows 容器还可以通过使用组托管服务帐户作为 Active Directory 身份运行

Pod 级别的安全隔离
-----------

Windows 节点不支持 Linux 特定的 pod 安全上下文机制（例如 SELinux、AppArmor、Seccomp 或自定义 POSIX 功能）。

Windows 不支持特权容器。 相反，可以在 Windows 上使用 HostProcess 容器来执行许多由特权容器在 Linux 上执行的任务。

##  6.  Kubernetes API访问控制
用户使用 ​`kubectl`​、客户端库或通过发出 REST 请求来访问 Kubernetes API。 human用户和 Kubernetes 服务帐户都可以被授权访问 API。 当请求到达 API 时，它会经历几个阶段，如下图所示：

![](https://atts.w3cschool.cn/attachments/image/20220523/1653276221986343.svg)  

运输安全
----

在典型的 Kubernetes 集群中，API 服务于端口 443，受 TLS 保护。 API 服务器提供一个证书。 该证书可以使用私有证书颁发机构 (CA) 进行签名，也可以基于链接到公认 CA 的公钥基础设施进行签名。

如果您的集群使用私有证书颁发机构，您需要将该 CA 证书的副本配置到客户端的 ​`~/.kube/config`​ 中，以便您可以信任连接并确信它没有被拦截。

您的客户端可以在此阶段出示 TLS 客户端证书。

验证
--

建立 TLS 后，HTTP 请求将移至身份验证步骤。这在图中显示为步骤 1。集群创建脚本或集群管理员将 API 服务器配置为运行一个或多个 Authenticator 模块。

身份验证步骤的输入是整个 HTTP 请求；但是，它通常会检查标头和/或客户端证书。

身份验证模块包括客户端证书、密码和普通令牌、引导令牌和 JSON Web 令牌（用于服务帐户）。

可以指定多个认证模块，依次尝试每一个，直到其中一个成功。

如果请求无法通过身份验证，则会以 HTTP 状态代码 401 拒绝该请求。否则，用户将作为特定用户名进行身份验证，并且该用户名可供后续步骤在其决策中使用。一些身份验证器还提供用户的组成员身份，而其他身份验证器不提供。

虽然 Kubernetes 使用用户名进行访问控制决策和请求日志记录，但它没有用户对象，也没有在其 API 中存储用户名或其他有关用户的信息。

授权
--

在请求被验证为来自特定用户之后，该请求必须被授权。 这在图中显示为步骤 2。

请求必须包含请求者的用户名、请求的操作以及受该操作影响的对象。 如果现有策略声明用户有权完成所请求的操作，则该请求被授权。

例如，如果 Bob 具有以下策略，那么他只能读取命名空间 ​`projectCaribou` ​中的 pod：

`{     "apiVersion": "abac.authorization.kubernetes.io/v1beta1",     "kind": "Policy",     "spec": {         "user": "bob",         "namespace": "projectCaribou",         "resource": "pods",         "readonly": true     } }`

如果 Bob 发出以下请求，则该请求被授权，因为允许他读取 ​`projectCaribou` ​命名空间中的对象：

`{   "apiVersion": "authorization.k8s.io/v1beta1",   "kind": "SubjectAccessReview",   "spec": {     "resourceAttributes": {       "namespace": "projectCaribou",       "verb": "get",       "group": "unicorn.example.org",       "resource": "pods"     }   } }`

如果 Bob 请求写入（​`create`​或​`update`​）​`projectCaribou` ​命名空间中的对象，他的授权将被拒绝。如果 Bob 请求读取（​`get`​）不同命名空间（例如 ​`projectFish`​）中的对象，那么他的授权将被拒绝。

Kubernetes 授权要求您使用通用 REST 属性与现有的组织范围或云提供商范围的访问控制系统进行交互。使用 REST 格式很重要，因为这些控制系统可能会与 Kubernetes API 之外的其他 API 交互。

Kubernetes 支持 ABAC 模式、RBAC 模式、Webhook 模式等多种授权模块。当管理员创建集群时，他们配置应该在 API 服务器中使用的授权模块。如果配置了多个授权模块，Kubernetes 会检查每个模块，如果有任何模块授权请求，则请求可以继续。如果所有模块都拒绝该请求，则该请求被拒绝（HTTP 状态代码 403）。

准入控制
----

准入控制模块是可以修改或拒绝请求的软件模块。除了授权模块可用的属性外，准入控制模块还可以访问正在创建或修改的对象的内容。

准入控制器对创建、修改、删除或连接（代理）对象的请求进行操作。准入控制器不会对仅读取对象的请求进行操作。配置多个准入控制器时，按顺序调用。

这在图中显示为步骤 3。

与身份验证和授权模块不同，如果任何准入控制器模块拒绝，则请求会立即被拒绝。

除了拒绝对象，准入控制器还可以为字段设置复杂的默认值。

一旦请求通过了所有准入控制器，就会使用相应 API 对象的验证例程对其进行验证，然后将其写入对象存储（如步骤 4 所示）。

Auditing


------------

Kubernetes auditing提供了一组与安全相关的、按时间顺序排列的记录，记录了集群中的操作顺序。 集群审核用户、使用 Kubernetes API 的应用程序以及控制平面本身生成的活动。

API 服务器端口和 IP
-------------

前面的讨论适用于发送到 API 服务器安全端口的请求（典型情况）。 API 服务器实际上可以在 2 个端口上服务：

默认情况下，Kubernetes API 服务器在 2 个端口上提供 HTTP：

1.  本地主机端口:

*   用于测试和引导，以及主节点的其他组件（调度程序、控制器管理器）与 API 对话
*   没有 TLS
*   默认为 8080 端口
*   默认 IP 是 localhost，使用 ​`--insecure-bind-address`​ 标志进行更改。
*   请求绕过身份验证和授权模块。
*   由准入控制模块处理的请求。
*   受需要拥有主机访问权限的保护

3.  “安全端口”：

*   尽可能使用
*   使用 TLS。 使用 ​`--tls-cert-file`​ 设置证书，使用 ​`--tls-private-key-file`​ 标志设置密钥。
*   默认为端口 6443，使用 ​`--secure-port`​ 标志进行更改。
*   默认 IP 是第一个非本地主机网络接口，使用 ​`--bind-address`​ 标志进行更改。
*   由身份验证和授权模块处理的请求。
*   由准入控制模块处理的请求。
*   身份验证和授权模块运行。

##  7.  Kubernetes 基于角色的访问控制良好实践
基于角色的访问控制良好实践
-------------

Kubernetes RBAC 是一项关键的安全控制，可确保集群用户和工作负载只能访问执行其角色所需的资源。 重要的是确保在为集群用户设计权限时，集群管理员了解可能发生权限提升的区域，以降低过度访问导致安全事件的风险。

一般良好做法
------

### 最低权限

理想情况下，应将最少的 RBAC 权限分配给用户和服务帐户。 仅应使用其操作明确要求的权限。 虽然每个集群都会有所不同，但可以应用的一些一般规则是：

*   尽可能在命名空间级别分配权限。使用 RoleBindings 而不是 ClusterRoleBindings 仅在特定命名空间内授予用户权限。
*   尽可能避免提供通配符权限，尤其是对所有资源。由于 Kubernetes 是一个可扩展的系统，提供通配符访问不仅可以授予集群中当前所有对象类型的权限，还可以授予将来创建的所有未来对象类型的权限。
*   除非特别需要，否则管理员不应使用​`cluster-admin`​帐户。提供具有模拟权限的低权限帐户可以避免意外修改集群资源。

*   避免将用户添加到 ​`system:masters`​ 组。作为该组成员的任何用户都会绕过所有 RBAC 权限检查，并且将始终拥有不受限制的超级用户访问权限，这不能通过删除角色绑定或集群角色绑定来撤销。顺便说一句，如果集群正在使用授权 webhook，则该组的成员身份也会绕过该 webhook（来自该组成员的用户的请求永远不会发送到 webhook）

### 尽量减少特权代币的分配

理想情况下，不应为 pod 分配被授予强大权限的服务帐户。 如果工作负载需要强大的权限，请考虑以下做法：

*   限制运行强大 pod 的节点数量。 确保您运行的任何 DaemonSet 都是必需的，并且以最小权限运行以限制容器逃逸的爆炸半径。
*   避免与不受信任或公开的 Pod 一起运行强大的 Pod。 考虑使用 Taints and Toleration、NodeAffinity 或 PodAntiAffinity 来确保 Pod 不会与不受信任或不太受信任的 Pod 一起运行。 特别注意可信度较低的 Pod 不符合 Restricted Pod 安全标准的情况。

### Hardening

Kubernetes 默认提供并非每个集群都需要的访问权限。 查看默认提供的 RBAC 权限可以为安全加固提供机会。 通常，不应更改提供给系统的权限：帐户存在一些强化集群权限的选项：

*   查看 ​`system:unauthenticated`​ 组的绑定并在可能的情况下删除，因为这样可以访问可以在网络级别联系 API 服务器的任何人。
*   通过设置 ​`automountServiceAccountToken: false`​ 来避免默认自动挂载服务帐户令牌。为 Pod 设置此值将覆盖服务帐户设置，需要服务帐户令牌的工作负载仍然可以挂载它们。

### 定期审查

定期检查 Kubernetes RBAC 设置是否有冗余条目和可能的权限升级至关重要。 如果攻击者能够创建与已删除用户同名的用户帐户，他们可以自动继承已删除用户的所有权限，尤其是分配给该用户的权限。

Kubernetes RBAC - 提权风险
----------------------

在 Kubernetes RBAC 中有许多权限，如果授予这些权限，则可以允许用户或服务帐户提升其在集群中的权限或影响集群外的系统。

本节旨在提供集群操作员应注意的区域的可见性，以确保他们不会无意中允许对集群的访问超出预期。

### Listing secrets

通常很清楚，允许对 Secrets 的访问将允许用户阅读其内容。 同样重要的是要注意，​`list`​和​`watch`​访问也有效地允许用户透露秘密内容。 例如，当返回 List 响应时（例如，通过 ​`kubectl get secrets -A -o yaml`​），响应包括所有 Secrets 的内容。

### 工作负载创建

除非有基于 Kubernetes Pod 安全标准的限制，否则能够创建工作负载（Pod 或管理 Pod 的工作负载资源）的用户将能够访问底层节点。

可以运行特权 Pod 的用户可以使用该访问权限来获得节点访问权限，并可能进一步提升他们的权限。如果您不完全信任具有创建适当安全和隔离 Pod 的能力的用户或​​其他主体，则应强制执行基线或受限 Pod 安全标准。您可以使用 Pod 安全准入或其他（第三方）机制来实施该强制。

您还可以使用已弃用的 PodSecurityPolicy 机制来限制用户创建特权 Pod 的能力（注意，PodSecurityPolicy 计划在版本 1.25 中删除）。

在命名空间中创建工作负载还会授予对该命名空间中 Secret 的间接访问权限。在 kube-system 或类似特权的命名空间中创建一个 pod 可以授予用户对他们直接通过 RBAC 没有的 Secret 的访问权限

### 持久卷创建

对创建 PersistentVolume 的访问可以允许升级对底层主机的访问。 在需要访问持久存储的地方，受信任的管理员应该创建 PersistentVolume，并且受限用户应该使用 PersistentVolumeClaims 来访问该存储。

### 访问节点的代理子资源

有权访问节点对象的代理子资源的用户有权访问 Kubelet API，该 API 允许在他们有权访问的节点上的每个 pod 上执行命令。 此访问绕过审核日志记录和准入控制，因此在授予此资源权限之前应小心。

### Escalate verb

通常，RBAC 系统会阻止用户创建比他们拥有的权限更多的集群角色。 一个例外是​`escalate` ​verb，拥有此权限的用户可以有效地提升他们的权限。

### Bind verb

与​`escalate` ​verb类似，授予用户此权限允许绕过 Kubernetes 内置的针对权限升级的保护，允许用户创建与具有他们不具有的权限的角色的绑定。

### Impersonate verb

此verb允许用户模拟并获得集群中其他用户的权限。 授予它时应小心，以确保不能通过模拟帐户之一获得过多的权限。

### CSRs 和证书颁发

CSR API 允许具有 CSR 创建权限和更新​`certificatesigningrequests/approval`​权限的用户，其中签名者是 ​`kubernetes.io/kube-apiserver-client`​，以创建新的客户端证书，允许用户对集群进行身份验证。 这些客户端证书可以具有任意名称，包括 Kubernetes 系统组件的副本。 这将有效地允许特权升级。

### Token请求

对 ​`serviceaccounts/token`​ 具有​`create`​权限的用户可以创建 TokenRequests 来为现有的服务帐户颁发令牌。

### 控制准入 webhook

控制验证​`webhookconfigurations`​或​`mutatingwebhookconfigurations`​的用户可以控制可以读取集群允许的任何对象的webhook，并且在改变webhook的情况下，也可以改变允许的对象。

Kubernetes RBAC - 拒绝服务风险
------------------------

### 对象创建拒绝服务

有权在集群中创建对象的用户可能能够根据对象的大小或数量创建足够大的对象来创建拒绝服务条件，正如 Kubernetes 使用的 [etcd 中所讨论的那样容易受到 OOM 攻击](https://github.com/kubernetes/kubernetes/issues/107325)。 如果允许半受信任或不受信任的用户对系统进行有限访问，这可能与多租户集群特别相关。

缓解此问题的一种选择是使用资源配额来限制可以创建的对象数量。

#  13.  Kubernetes 策略

##  1.  Kubernetes 限制范围
限制范围
----

默认情况下， Kubernetes 集群上的容器运行使用的计算资源没有限制。 使用资源配额，集群管理员可以以名字空间为单位，限制其资源的使用与创建。 在命名空间中，一个 Pod 或 Container 最多能够使用命名空间的资源配额所定义的 CPU 和内存用量。 有人担心，一个 Pod 或 Container 会垄断所有可用的资源。 LimitRange 是在命名空间内限制资源分配（给多个 Pod 或 Container）的策略对象。

一个 LimitRange（限制范围） 对象提供的限制能够做到：

*   在一个命名空间中实施对每个 Pod 或 Container 最小和最大的资源使用量的限制。
*   在一个命名空间中实施对每个 PersistentVolumeClaim 能申请的最小和最大的存储空间大小的限制。
*   在一个命名空间中实施对一种资源的申请值和限制值的比值的控制。
*   设置一个命名空间中对计算资源的默认申请/限制值，并且自动的在运行时注入到多个 Container 中。

启用 LimitRange 
--------------

对 LimitRange 的支持自 Kubernetes 1.10 版本默认启用。

LimitRange 支持在很多 Kubernetes 发行版本中也是默认启用的。

LimitRange 的名称必须是合法的 DNS 子域名。

### 限制范围总览

*   管理员在一个命名空间内创建一个 ​`LimitRange` ​对象。
*   用户在命名空间内创建 Pod ，Container 和 PersistentVolumeClaim 等资源。
*   ​`LimitRanger` ​准入控制器对所有没有设置计算资源需求的 Pod 和 Container 设置默认值与限制值， 并跟踪其使用量以保证没有超出命名空间中存在的任意 LimitRange 对象中的最小、最大资源使用量以及使用量比值。
*   若创建或更新资源（Pod、 Container、PersistentVolumeClaim）违反了 LimitRange 的约束， 向 API 服务器的请求会失败，并返回 HTTP 状态码 ​`403 FORBIDDEN`​ 与描述哪一项约束被违反的消息。
*   若命名空间中的 LimitRange 启用了对 ​`cpu` ​和 ​`memory` ​的限制， 用户必须指定这些值的需求使用量与限制使用量。否则，系统将会拒绝创建 Pod。
*   LimitRange 的验证仅在 Pod 准入阶段进行，不对正在运行的 Pod 进行验证。

能够使用限制范围创建的策略示例有：

*   在一个有两个节点，8 GiB 内存与16个核的集群中，限制一个命名空间的 Pod 申请 100m 单位，最大 500m 单位的 CPU，以及申请 200Mi，最大 600Mi 的内存。
*   为 spec 中没有 cpu 和内存需求值的 Container 定义默认 CPU 限制值与需求值 150m，内存默认需求值 300Mi。

在命名空间的总限制值小于 Pod 或 Container 的限制值的总和的情况下，可能会产生资源竞争。 在这种情况下，将不会创建 Container 或 Pod。

竞争和对 LimitRange 的改变都不会影响任何已经创建了的资源。

##  2.  Kubernetes 资源配额
资源配额
----

当多个用户或团队共享具有固定节点数目的集群时，人们会担心有人使用超过其基于公平原则所分配到的资源量。

资源配额是帮助管理员解决这一问题的工具。

资源配额，通过 ​`ResourceQuota` ​对象来定义，对每个命名空间的资源消耗总量提供限制。 它可以限制命名空间中某种类型的对象的总数目上限，也可以限制命令空间中的 Pod 可以使用的计算资源的总上限。

资源配额的工作方式如下：

*   不同的团队可以在不同的命名空间下工作，目前这是非约束性的，在未来的版本中可能会通过 ACL (Access Control List 访问控制列表) 来实现强制性约束。
*   集群管理员可以为每个命名空间创建一个或多个 ResourceQuota 对象。
*   当用户在命名空间下创建资源（如 Pod、Service 等）时，Kubernetes 的配额系统会 跟踪集群的资源使用情况，以确保使用的资源用量不超过 ResourceQuota 中定义的硬性资源限额。
*   如果资源创建或者更新请求违反了配额约束，那么该请求会报错（HTTP 403 FORBIDDEN）， 并在消息中给出有可能违反的约束。
*   如果命名空间下的计算资源 （如 ​`cpu` ​和 ​`memory`​）的配额被启用，则用户必须为 这些资源设定请求值（request）和约束值（limit），否则配额系统将拒绝 Pod 的创建。 提示: 可使用 ​`LimitRanger` ​准入控制器来为没有设置计算资源需求的 Pod 设置默认值。

ResourceQuota 对象的名称必须是合法的 DNS 子域名。

下面是使用命名空间和配额构建策略的示例：

*   在具有 32 GiB 内存和 16 核 CPU 资源的集群中，允许 A 团队使用 20 GiB 内存 和 10 核的 CPU 资源， 允许 B 团队使用 10 GiB 内存和 4 核的 CPU 资源，并且预留 2 GiB 内存和 2 核的 CPU 资源供将来分配。
*   限制 "testing" 命名空间使用 1 核 CPU 资源和 1GiB 内存。允许 "production" 命名空间使用任意数量。

在集群容量小于各命名空间配额总和的情况下，可能存在资源竞争。资源竞争时，Kubernetes 系统会遵循先到先得的原则。

不管是资源竞争还是配额的修改，都不会影响已经创建的资源使用对象。

启用资源配额
------

资源配额的支持在很多 Kubernetes 版本中是默认启用的。 当 API 服务器 的命令行标志 ​`--enable-admission-plugins=`​ 中包含 ​`ResourceQuota` ​时， 资源配额会被启用。

当命名空间中存在一个 ResourceQuota 对象时，对于该命名空间而言，资源配额就是开启的。

计算资源配额
------

用户可以对给定命名空间下的可被请求的 计算资源 总量进行限制。

配额机制所支持的资源类型：

资源名称

描述

`limits.cpu`

所有非终止状态的 Pod，其 CPU 限额总量不能超过该值。

`limits.memory`

所有非终止状态的 Pod，其内存限额总量不能超过该值。

`requests.cpu`

所有非终止状态的 Pod，其 CPU 需求总量不能超过该值。

`requests.memory`

所有非终止状态的 Pod，其内存需求总量不能超过该值。

`hugepages-<size>`

对于所有非终止状态的 Pod，针对指定尺寸的巨页请求总数不能超过此值。

`cpu`

与 `requests.cpu` 相同。

`memory`

与 `requests.memory` 相同。

### 扩展资源的资源配额

除上述资源外，在 Kubernetes 1.10 版本中，还添加了对 扩展资源 的支持。

由于扩展资源不可超量分配，因此没有必要在配额中为同一扩展资源同时指定 ​`requests` ​和 ​`limits`​。 对于扩展资源而言，目前仅允许使用前缀为 ​`requests.`​ 的配额项。

以 GPU 拓展资源为例，如果资源名称为 ​`nvidia.com/gpu`​，并且要将命名空间中请求的 GPU 资源总数限制为 4，则可以如下定义配额：

*   ​`requests.nvidia.com/gpu: 4` ​

存储资源配额
------

用户可以对给定命名空间下的存储资源 总量进行限制。

此外，还可以根据相关的存储类（Storage Class）来限制存储资源的消耗。

资源名称

描述

`requests.storage`

所有 PVC，存储资源的需求总量不能超过该值。

`persistentvolumeclaims`

在该命名空间中所允许的 PVC 总量。

`<storage-class-name>.storageclass.storage.k8s.io/requests.storage`

在所有与 `<storage-class-name>` 相关的持久卷申领中，存储请求的总和不能超过该值。

`<storage-class-name>.storageclass.storage.k8s.io/persistentvolumeclaims`

在与 storage-class-name 相关的所有持久卷申领中，命名空间中可以存在的持久卷申领总数。

例如，如果一个操作人员针对 ​`gold` ​存储类型与 ​`bronze` ​存储类型设置配额， 操作人员可以定义如下配额：

*   ​`gold.storageclass.storage.k8s.io/requests.storage: 500Gi` ​
*   ​`bronze.storageclass.storage.k8s.io/requests.storage: 100Gi`​

在 Kubernetes 1.8 版本中，本地临时存储的配额支持已经是 Alpha 功能：

资源名称

描述

`requests.ephemeral-storage`

在命名空间的所有 Pod 中，本地临时存储请求的总和不能超过此值。

`limits.ephemeral-storage`

在命名空间的所有 Pod 中，本地临时存储限制值的总和不能超过此值。

`ephemeral-storage`

与 `requests.ephemeral-storage` 相同。

> Note:  
> 如果所使用的是 CRI 容器运行时，容器日志会被计入临时存储配额。 这可能会导致存储配额耗尽的 Pods 被意外地驱逐出节点。

对象数量配额
------

你可以使用以下语法对所有标准的、命名空间域的资源类型进行配额设置：

*   ​`count/<resource>.<group>`​：用于非核心（core）组的资源
*   ​`count/<resource>`​：用于核心组的资源

这是用户可能希望利用对象计数配额来管理的一组资源示例。

*   ​`count/persistentvolumeclaims` ​
*   ​`count/services` ​
*   ​`count/secrets` ​
*   ​`count/configmaps` ​
*   ​`count/replicationcontrollers` ​
*   ​`count/deployments.apps` ​
*   ​`count/replicasets.apps` ​
*   ​`count/statefulsets.apps` ​
*   ​`count/jobs.batch` ​
*   ​`count/cronjobs.batch`​

相同语法也可用于自定义资源。 例如，要对 ​`example.com`​ API 组中的自定义资源 ​`widgets` ​设置配额，请使用 ​`count/widgets.example.com`​。

当使用 ​`count/*`​ 资源配额时，如果对象存在于服务器存储中，则会根据配额管理资源。 这些类型的配额有助于防止存储资源耗尽。例如，用户可能想根据服务器的存储能力来对服务器中 Secret 的数量进行配额限制。 集群中存在过多的 Secret 实际上会导致服务器和控制器无法启动。 用户可以选择对 Job 进行配额管理，以防止配置不当的 CronJob 在某命名空间中创建太多 Job 而导致集群拒绝服务。

对有限的一组资源上实施一般性的对象数量配额也是可能的。 此外，还可以进一步按资源的类型设置其配额。

支持以下类型：

资源名称

描述

`configmaps`

在该命名空间中允许存在的 ConfigMap 总数上限。

`persistentvolumeclaims`

在该命名空间中允许存在的 PVC 的总数上限。

`pods`

在该命名空间中允许存在的非终止状态的 Pod 总数上限。Pod 终止状态等价于 Pod 的 `.status.phase in (Failed, Succeeded)` 为真。

`replicationcontrollers`

在该命名空间中允许存在的 ReplicationController 总数上限。

`resourcequotas`

在该命名空间中允许存在的 ResourceQuota 总数上限。

`services`

在该命名空间中允许存在的 Service 总数上限。

`services.loadbalancers`

在该命名空间中允许存在的 LoadBalancer 类型的 Service 总数上限。

`services.nodeports`

在该命名空间中允许存在的 NodePort 类型的 Service 总数上限。

`secrets`

在该命名空间中允许存在的 Secret 总数上限。

例如，​`pods` ​配额统计某个命名空间中所创建的、非终止状态的 ​`Pod` ​个数并确保其不超过某上限值。 用户可能希望在某命名空间中设置 ​`pods` ​配额，以避免有用户创建很多小的 Pod， 从而耗尽集群所能提供的 Pod IP 地址。

配额作用域 
------

每个配额都有一组相关的 ​`scope`​（作用域），配额只会对作用域内的资源生效。 配额机制仅统计所列举的作用域的交集中的资源用量。

当一个作用域被添加到配额中后，它会对作用域相关的资源数量作限制。 如配额中指定了允许（作用域）集合之外的资源，会导致验证错误。

作用域

描述

`Terminating`

匹配所有 `spec.activeDeadlineSeconds` 不小于 0 的 Pod。

`NotTerminating`

匹配所有 `spec.activeDeadlineSeconds` 是 nil 的 Pod。

`BestEffort`

匹配所有 Qos 是 BestEffort 的 Pod。

`NotBestEffort`

匹配所有 Qos 不是 BestEffort 的 Pod。

`PriorityClass`

匹配所有引用了所指定的优先级类的 Pods。

`CrossNamespacePodAffinity`

匹配那些设置了跨名字空间 （反）亲和性条件的 Pod。

​`BestEffort` ​作用域限制配额跟踪以下资源：

*   ​`pods` ​

​`Terminating`​、​`NotTerminating`​、​`NotBestEffort` ​和 ​`PriorityClass` ​这些作用域限制配额跟踪以下资源：

*   ​`pods` ​
*   ​`cpu` ​
*   ​`memory` ​
*   ​`requests.cpu` ​
*   ​`requests.memory` ​
*   ​`limits.cpu` ​
*   ​`limits.memory`​

需要注意的是，你不可以在同一个配额对象中同时设置 ​`Terminating` ​和 ​`NotTerminating` ​作用域，你也不可以在同一个配额中同时设置 ​`BestEffort` ​和 ​`NotBestEffort` ​作用域。

​`scopeSelector` ​支持在 ​`operator` ​字段中使用以下值：

*   ​`In` ​
*   ​`NotIn` ​
*   ​`Exists` ​
*   ​`DoesNotExist`​

定义 ​`scopeSelector` ​时，如果使用以下值之一作为 ​`scopeName` ​的值，则对应的 ​`operator` ​只能是 ​`Exists`​。

*   ​`Terminating` ​
*   ​`NotTerminating` ​
*   ​`BestEffort` ​
*   ​`NotBestEffort`​

如果 ​`operator` ​是 ​`In` ​或 ​`NotIn` ​之一，则 ​`values` ​字段必须至少包含一个值。 例如：

  `scopeSelector:     matchExpressions:       - scopeName: PriorityClass         operator: In         values:           - middle`

如果 ​`operator` ​为 ​`Exists` ​或 ​`DoesNotExist`​，则不可以设置 ​`values` ​字段。

### 基于优先级类（PriorityClass）来设置资源配额

FEATURE STATE: Kubernetes v1.17 \[stable\]

Pod 可以创建为特定的优先级。 通过使用配额规约中的 ​`scopeSelector` ​字段，用户可以根据 Pod 的优先级控制其系统资源消耗。

仅当配额规范中的 ​`scopeSelector` ​字段选择到某 Pod 时，配额机制才会匹配和计量 Pod 的资源消耗。

如果配额对象通过 ​`scopeSelector` ​字段设置其作用域为优先级类，则配额对象只能 跟踪以下资源：

*   ​`pods` ​
*   ​`cpu` ​
*   ​`memory` ​
*   ​`ephemeral-storage` ​
*   ​`limits.cpu` ​
*   ​`limits.memory` ​
*   ​`limits.ephemeral-storage` ​
*   ​`requests.cpu` ​
*   ​`requests.memory` ​
*   ​`requests.ephemeral-storage`​

本示例创建一个配额对象，并将其与具有特定优先级的 Pod 进行匹配。 该示例的工作方式如下：

*   集群中的 Pod 可取三个优先级类之一，即 "low"、"medium"、"high"。
*   为每个优先级创建一个配额对象。

将以下 YAML 保存到文件 ​`quota.yml`​ 中。

`apiVersion: v1 kind: List items: - apiVersion: v1   kind: ResourceQuota   metadata:     name: pods-high   spec:     hard:       cpu: "1000"       memory: 200Gi       pods: "10"     scopeSelector:       matchExpressions:       - operator : In         scopeName: PriorityClass         values: ["high"] - apiVersion: v1   kind: ResourceQuota   metadata:     name: pods-medium   spec:     hard:       cpu: "10"       memory: 20Gi       pods: "10"     scopeSelector:       matchExpressions:       - operator : In         scopeName: PriorityClass         values: ["medium"] - apiVersion: v1   kind: ResourceQuota   metadata:     name: pods-low   spec:     hard:       cpu: "5"       memory: 10Gi       pods: "10"     scopeSelector:       matchExpressions:       - operator : In         scopeName: PriorityClass         values: ["low"]`

使用 ​`kubectl create`​ 命令运行以下操作。

`kubectl create -f ./quota.yml`

`resourcequota/pods-high created resourcequota/pods-medium created resourcequota/pods-low created`

使用 ​`kubectl describe quota`​ 操作验证配额的 ​`Used` ​值为 ​`0`​。

`kubectl describe quota`

`Name:       pods-high Namespace:  default Resource    Used  Hard --------    ----  ---- cpu         0     1k memory      0     200Gi pods        0     10   Name:       pods-low Namespace:  default Resource    Used  Hard --------    ----  ---- cpu         0     5 memory      0     10Gi pods        0     10   Name:       pods-medium Namespace:  default Resource    Used  Hard --------    ----  ---- cpu         0     10 memory      0     20Gi pods        0     10`

创建优先级为 "high" 的 Pod。 将以下 YAML 保存到文件 ​`high-priority-pod.yml`​ 中。

`apiVersion: v1 kind: Pod metadata:   name: high-priority spec:   containers:   - name: high-priority     image: ubuntu     command: ["/bin/sh"]     args: ["-c", "while true; do echo hello; sleep 10;done"]     resources:       requests:         memory: "10Gi"         cpu: "500m"       limits:         memory: "10Gi"         cpu: "500m"   priorityClassName: high`

使用 ​`kubectl create`​ 运行以下操作。

`kubectl create -f ./high-priority-pod.yml`

确认 "high" 优先级配额 ​`pods-high`​ 的 "Used" 统计信息已更改，并且其他两个配额未更改。

`kubectl describe quota`

`Name:       pods-high Namespace:  default Resource    Used  Hard --------    ----  ---- cpu         500m  1k memory      10Gi  200Gi pods        1     10   Name:       pods-low Namespace:  default Resource    Used  Hard --------    ----  ---- cpu         0     5 memory      0     10Gi pods        0     10   Name:       pods-medium Namespace:  default Resource    Used  Hard --------    ----  ---- cpu         0     10 memory      0     20Gi pods        0     10`

### 跨名字空间的 Pod 亲和性配额 

FEATURE STATE: Kubernetes v1.24 \[stable\]

集群运维人员可以使用 ​`CrossNamespacePodAffinity` ​配额作用域来 限制哪个名字空间中可以存在包含跨名字空间亲和性规则的 Pod。 更为具体一点，此作用域用来配置哪些 Pod 可以在其 Pod 亲和性规则 中设置 ​`namespaces` ​或 ​`namespaceSelector` ​字段。

禁止用户使用跨名字空间的亲和性规则可能是一种被需要的能力，因为带有 反亲和性约束的 Pod 可能会阻止所有其他名字空间的 Pod 被调度到某失效域中。

使用此作用域操作符可以避免某些名字空间（例如下面例子中的 ​`foo-ns`​）运行 特别的 Pod，这类 Pod 使用跨名字空间的 Pod 亲和性约束，在该名字空间中创建 了作用域为 ​`CrossNamespaceAffinity` ​的、硬性约束为 0 的资源配额对象。

`apiVersion: v1 kind: ResourceQuota metadata:   name: disable-cross-namespace-affinity   namespace: foo-ns spec:   hard:     pods: "0"   scopeSelector:     matchExpressions:     - scopeName: CrossNamespaceAffinity`

如果集群运维人员希望默认禁止使用 ​`namespaces` ​和 ​`namespaceSelector`​，而 仅仅允许在特定名字空间中这样做，他们可以将 ​`CrossNamespaceAffinity` ​作为一个 被约束的资源。方法是为 ​`kube-apiserver`​ 设置标志 ​`--admission-control-config-file`​，使之指向如下的配置文件：

`apiVersion: apiserver.config.k8s.io/v1 kind: AdmissionConfiguration plugins: - name: "ResourceQuota"   configuration:     apiVersion: apiserver.config.k8s.io/v1     kind: ResourceQuotaConfiguration     limitedResources:     - resource: pods       matchScopes:       - scopeName: CrossNamespaceAffinity`

基于上面的配置，只有名字空间中包含作用域为 ​`CrossNamespaceAffinity` ​且 硬性约束大于或等于使用 ​`namespaces` ​和 ​`namespaceSelector` ​字段的 Pods 个数时，才可以在该名字空间中继续创建在其 Pod 亲和性规则中设置 ​`namespaces` ​或 ​`namespaceSelector` ​的新 Pod。

请求与限制的比较 
---------

分配计算资源时，每个容器可以为 CPU 或内存指定请求和约束。 配额可以针对二者之一进行设置。

如果配额中指定了 ​`requests.cpu`​ 或 ​`requests.memory`​ 的值，则它要求每个容器都显式给出对这些资源的请求。 同理，如果配额中指定了 ​`limits.cpu`​ 或 ​`limits.memory`​ 的值，那么它要求每个容器都显式设定对应资源的限制。

查看和设置配额
-------

Kubectl 支持创建、更新和查看配额：

`kubectl create namespace myspace`

`cat <<EOF > compute-resources.yaml apiVersion: v1 kind: ResourceQuota metadata:   name: compute-resources spec:   hard:     requests.cpu: "1"     requests.memory: 1Gi     limits.cpu: "2"     limits.memory: 2Gi     requests.nvidia.com/gpu: 4 EOF`

`kubectl create -f ./compute-resources.yaml --namespace=myspace`

`cat <<EOF > object-counts.yaml apiVersion: v1 kind: ResourceQuota metadata:   name: object-counts spec:   hard:     configmaps: "10"     persistentvolumeclaims: "4"     pods: "4"     replicationcontrollers: "20"     secrets: "10"     services: "10"     services.loadbalancers: "2" EOF`

`kubectl create -f ./object-counts.yaml --namespace=myspace`

`kubectl get quota --namespace=myspace`

`NAME                    AGE compute-resources       30s object-counts           32s`

`kubectl describe quota compute-resources --namespace=myspace`

`Name:                    compute-resources Namespace:               myspace Resource                 Used  Hard --------                 ----  ---- limits.cpu               0     2 limits.memory            0     2Gi requests.cpu             0     1 requests.memory          0     1Gi requests.nvidia.com/gpu  0     4`

`kubectl describe quota object-counts --namespace=myspace`

`Name:                   object-counts Namespace:              myspace Resource                Used    Hard --------                ----    ---- configmaps              0       10 persistentvolumeclaims  0       4 pods                    0       4 replicationcontrollers  0       20 secrets                 1       10 services                0       10 services.loadbalancers  0       2`

kubectl 还使用语法 ​`count/<resource>.<group>`​ 支持所有标准的、命名空间域的资源的对象计数配额：

`kubectl create namespace myspace`

`kubectl create quota test --hard=count/deployments.apps=2,count/replicasets.apps=4,count/pods=3,count/secrets=4 --namespace=myspace`

`kubectl create deployment nginx --image=nginx --namespace=myspace --replicas=2`

`kubectl describe quota --namespace=myspace`

`Name:                         test Namespace:                    myspace Resource                      Used  Hard --------                      ----  ---- count/deployments.apps        1     2 count/pods                    2     3 count/replicasets.apps        1     4 count/secrets                 1     4`

配额和集群容量 
--------

ResourceQuota 与集群资源总量是完全独立的。它们通过绝对的单位来配置。 所以，为集群添加节点时，资源配额不会自动赋予每个命名空间消耗更多资源的能力。

有时可能需要资源配额支持更复杂的策略，比如：

*   在几个团队中按比例划分总的集群资源。
*   允许每个租户根据需要增加资源使用量，但要有足够的限制以防止资源意外耗尽。
*   探测某个命名空间的需求，添加物理节点并扩大资源配额值。

这些策略可以通过将资源配额作为一个组成模块、手动编写一个控制器来监控资源使用情况， 并结合其他信号调整命名空间上的硬性资源配额来实现。

注意：资源配额对集群资源总体进行划分，但它对节点没有限制：来自不同命名空间的 Pod 可能在同一节点上运行。

默认情况下限制特定优先级的资源消耗
-----------------

有时候可能希望当且仅当某名字空间中存在匹配的配额对象时，才可以创建特定优先级 （例如 "cluster-services"）的 Pod。

通过这种机制，操作人员能够将限制某些高优先级类仅出现在有限数量的命名空间中， 而并非每个命名空间默认情况下都能够使用这些优先级类。

要实现此目的，应设置 kube-apiserver 的标志 ​`--admission-control-config-file`​ 指向如下配置文件：

`apiVersion: apiserver.config.k8s.io/v1 kind: AdmissionConfiguration plugins: - name: "ResourceQuota"   configuration:     apiVersion: apiserver.config.k8s.io/v1     kind: ResourceQuotaConfiguration     limitedResources:     - resource: pods       matchScopes:       - scopeName: PriorityClass         operator: In         values: ["cluster-services"]`

现在在 ​`kube-system`​ 名字空间中创建一个资源配额对象：

`apiVersion: v1 kind: ResourceQuota metadata:   name: pods-cluster-services spec:   scopeSelector:     matchExpressions:       - operator : In         scopeName: PriorityClass         values: ["cluster-services"]`

`kubectl apply -f https://k8s.io/examples/policy/priority-class-resourcequota.yaml -n kube-system`

`resourcequota/pods-cluster-services created`

在这里，当以下条件满足时可以创建 Pod：

1.  Pod 未设置 ​`priorityClassName` ​
2.  Pod 的 ​`priorityClassName` ​设置值不是 ​`cluster-services` ​
3.  Pod 的 ​`priorityClassName` ​设置值为 ​`cluster-services`​，它将被创建于 ​`kube-system`​ 名字空间中，并且它已经通过了资源配额检查。

如果 Pod 的 ​`priorityClassName` ​设置为 ​`cluster-services`​，但要被创建到 ​`kube-system`​ 之外的别的名字空间，则 Pod 创建请求也被拒绝。

##  3.  Kubernetes 进程ID约束与预留
进程 ID 约束与预留
-----------

FEATURE STATE: Kubernetes v1.20 \[stable\]

Kubernetes 允许你限制一个 Pod 中可以使用的 进程 ID（PID）数目。你也可以为每个 节点 预留一定数量的可分配的 PID，供操作系统和守护进程（而非 Pod）使用。

进程 ID（PID）是节点上的一种基础资源。很容易就会在尚未超出其它资源约束的时候就 已经触及任务个数上限，进而导致宿主机器不稳定。

集群管理员需要一定的机制来确保集群中运行的 Pod 不会导致 PID 资源枯竭，甚而 造成宿主机上的守护进程（例如 kubelet 或者 kube-proxy 乃至包括容器运行时本身）无法正常运行。 此外，确保 Pod 中 PID 的个数受限对于保证其不会影响到同一节点上其它负载也很重要。

> Note:  
> 在某些 Linux 安装环境中，操作系统会将 PID 约束设置为一个较低的默认值，例如 ​`32768`​。这时可以考虑提升 ​`/proc/sys/kernel/pid_max`​ 的设置值。

你可以配置 kubelet 限制给定 Pod 能够使用的 PID 个数。 例如，如果你的节点上的宿主操作系统被设置为最多可使用 ​`262144` ​个 PID，同时预期 节点上会运行的 Pod 个数不会超过 ​`250`​，那么你可以为每个 Pod 设置 ​`1000` ​个 PID 的预算，避免耗尽该节点上可用 PID 的总量。 如果管理员系统像 CPU 或内存那样允许对 PID 进行过量分配（Overcommit），他们也可以 这样做，只是会有一些额外的风险。不管怎样，任何一个 Pod 都不可以将整个机器的运行 状态破坏。这类资源限制有助于避免简单的派生炸弹（Fork Bomb）影响到整个集群的运行。

在 Pod 级别设置 PID 限制使得管理员能够保护 Pod 之间不会互相伤害，不过无法 确保所有调度到该宿主机器上的所有 Pod 都不会影响到节点整体。 Pod 级别的限制也无法保护节点代理任务自身不会受到 PID 耗尽的影响。

你也可以预留一定量的 PID，作为节点的额外开销，与分配给 Pod 的 PID 集合独立。 这有点类似于在给操作系统和其它设施预留 CPU、内存或其它资源时所做的操作， 这些任务都在 Pod 及其所包含的容器之外运行。

PID 限制是与计算资源 请求和限制相辅相成的一种机制。不过，你需要用一种不同的方式来设置这一限制： 你需要将其设置到 kubelet 上而不是在 Pod 的 ​`.spec`​ 中为 Pod 设置资源限制。 目前还不支持在 Pod 级别设置 PID 限制。

> Caution:  
> 这意味着，施加在 Pod 之上的限制值可能因为 Pod 运行所在的节点不同而有差别。 为了简化系统，最简单的方法是为所有节点设置相同的 PID 资源限制和预留值。

节点级别 PID 限制 
------------

Kubernetes 允许你为系统预留一定量的进程 ID。为了配置预留数量，你可以使用 kubelet 的 ​`--system-reserved`​ 和 ​`--kube-reserved`​ 命令行选项中的参数 ​`pid=<number>`​。你所设置的参数值分别用来声明为整个系统和 Kubernetes 系统 守护进程所保留的进程 ID 数目。

> Note:  
> 在 Kubernetes 1.20 版本之前，在节点级别通过 PID 资源限制预留 PID 的能力 需要启用特性门控 ​`SupportNodePidsLimit` ​才行。

Pod 级别 PID 限制 
--------------

Kubernetes 允许你限制 Pod 中运行的进程个数。你可以在节点级别设置这一限制， 而不是为特定的 Pod 来将其设置为资源限制。 每个节点都可以有不同的 PID 限制设置。 要设置限制值，你可以设置 kubelet 的命令行参数 ​`--pod-max-pids`​，或者 在 kubelet 的配置文件 中设置 ​`PodPidsLimit`​。

> Note:  
> 在 Kubernetes 1.20 版本之前，为 Pod 设置 PID 资源限制的能力需要启用 特性门控 ​`SupportNodePidsLimit` ​才行。

基于 PID 的驱逐 
-----------

你可以配置 kubelet 使之在 Pod 行为不正常或者消耗不正常数量资源的时候将其终止。 这一特性称作驱逐。你可以针对不同的驱逐信号 配置资源不足的处理。 使用 ​`pid.available`​ 驱逐信号来配置 Pod 使用的 PID 个数的阈值。 你可以设置硬性的和软性的驱逐策略。不过，即使使用硬性的驱逐策略， 如果 PID 个数增长过快，节点仍然可能因为触及节点 PID 限制而进入一种不稳定状态。 驱逐信号的取值是周期性计算的，而不是一直能够强制实施约束。

Pod 级别和节点级别的 PID 限制会设置硬性限制。 一旦触及限制值，工作负载会在尝试获得新的 PID 时开始遇到问题。 这可能会也可能不会导致 Pod 被重新调度，取决于工作负载如何应对这类失败 以及 Pod 的存活性和就绪态探测是如何配置的。 可是，如果限制值被正确设置，你可以确保其它 Pod 负载和系统进程不会因为某个 Pod 行为不正常而没有 PID 可用。

##  4.  Kubernetes 节点资源管理器
节点资源管理器
-------

Kubernetes 提供了一组资源管理器，用于支持延迟敏感的、高吞吐量的工作负载。 资源管理器的目标是协调和优化节点资源，以支持对 CPU、设备和内存（巨页）等资源有特殊需求的 Pod。

主管理器，也叫拓扑管理器（Topology Manager），是一个 Kubelet 组件， 它通过策略， 协调全局的资源管理过程。

#  14.  Kubernetes 调度，抢占和驱逐

##  1.  Kubernetes 调度器
Kubernetes 调度器
--------------

在 Kubernetes 中，调度 是指将 Pod 放置到合适的 Node 上，然后对应 Node 上的 Kubelet 才能够运行这些 pod。

调度概览
----

调度器通过 kubernetes 的监测（Watch）机制来发现集群中新创建且尚未被调度到 Node 上的 Pod。 调度器会将发现的每一个未调度的 Pod 调度到一个合适的 Node 上来运行。 调度器会依据下文的调度原则来做出调度选择。

如果你想要理解 Pod 为什么会被调度到特定的 Node 上，或者你想要尝试实现 一个自定义的调度器，这篇文章将帮助你了解调度。

kube-scheduler
--------------

kube-scheduler 是 Kubernetes 集群的默认调度器，并且是集群 控制面 的一部分。 如果你真的希望或者有这方面的需求，kube-scheduler 在设计上是允许 你自己写一个调度组件并替换原有的 kube-scheduler。

对每一个新创建的 Pod 或者是未被调度的 Pod，kube-scheduler 会选择一个最优的 Node 去运行这个 Pod。然而，Pod 内的每一个容器对资源都有不同的需求，而且 Pod 本身也有不同的资源需求。因此，Pod 在被调度到 Node 上之前， 根据这些特定的资源调度需求，需要对集群中的 Node 进行一次过滤。

在一个集群中，满足一个 Pod 调度请求的所有 Node 称之为 可调度节点。 如果没有任何一个 Node 能满足 Pod 的资源请求，那么这个 Pod 将一直停留在 未调度状态直到调度器能够找到合适的 Node。

调度器先在集群中找到一个 Pod 的所有可调度节点，然后根据一系列函数对这些可调度节点打分， 选出其中得分最高的 Node 来运行 Pod。之后，调度器将这个调度决定通知给 kube-apiserver，这个过程叫做 绑定。

在做调度决定时需要考虑的因素包括：单独和整体的资源请求、硬件/软件/策略限制、 亲和以及反亲和要求、数据局域性、负载间的干扰等等。

kube-scheduler 调度流程 
--------------------

kube-scheduler 给一个 pod 做调度选择包含两个步骤：

1.  过滤
2.  打分

过滤阶段会将所有满足 Pod 调度需求的 Node 选出来。 例如，PodFitsResources 过滤函数会检查候选 Node 的可用资源能否满足 Pod 的资源请求。 在过滤之后，得出一个 Node 列表，里面包含了所有可调度节点；通常情况下， 这个 Node 列表包含不止一个 Node。如果这个列表是空的，代表这个 Pod 不可调度。

在打分阶段，调度器会为 Pod 从所有可调度节点中选取一个最合适的 Node。 根据当前启用的打分规则，调度器会给每一个可调度节点进行打分。

最后，kube-scheduler 会将 Pod 调度到得分最高的 Node 上。 如果存在多个得分最高的 Node，kube-scheduler 会从中随机选取一个。

支持以下两种方式配置调度器的过滤和打分行为：

1.  调度策略 允许你配置过滤的 断言(Predicates) 和打分的 优先级(Priorities) 。
2.  调度配置 允许你配置实现不同调度阶段的插件， 包括：​`QueueSort`​, ​`Filter`​, ​`Score`​, ​`Bind`​, ​`Reserve`​, ​`Permit` ​等等。 你也可以配置 kube-scheduler 运行不同的配置文件。

##  2.  Kubernetes 将Pod指派给节点
将 Pod 指派给节点
-----------

你可以约束一个 Pod 只能在特定的节点上运行。 有几种方法可以实现这点，推荐的方法都是用 标签选择算符来进行选择。 通常这样的约束不是必须的，因为调度器将自动进行合理的放置（比如，将 Pod 分散到节点上， 而不是将 Pod 放置在可用资源不足的节点上等等）。但在某些情况下，你可能需要进一步控制 Pod 被部署到的节点。例如，确保 Pod 最终落在连接了 SSD 的机器上， 或者将来自两个不同的服务且有大量通信的 Pods 被放置在同一个可用区。

你可以使用下列方法中的任何一种来选择 Kubernetes 对特定 Pod 的调度：

*   与节点标签匹配的 nodeSelector
*   亲和性与反亲和性
*   nodeName 字段

节点标签 
-----

与很多其他 Kubernetes 对象类似，节点也有标签。 你可以手动地添加标签。 Kubernetes 也会为集群中所有节点添加一些标准的标签。 参见常用的标签、注解和污点以了解常见的节点标签。

> Note:  
> 这些标签的取值是取决于云提供商的，并且是无法在可靠性上给出承诺的。 例如，​`kubernetes.io/hostname`​ 的取值在某些环境中可能与节点名称相同， 而在其他环境中会取不同的值。

节点隔离/限制 
--------

通过为节点添加标签，你可以准备让 Pod 调度到特定节点或节点组上。 你可以使用这个功能来确保特定的 Pod 只能运行在具有一定隔离性，安全性或监管属性的节点上。

如果使用标签来实现节点隔离，建议选择节点上的 kubelet 无法修改的标签键。 这可以防止受感染的节点在自身上设置这些标签，进而影响调度器将工作负载调度到受感染的节点。

​`NodeRestriction` ​准入插件防止 kubelet 使用 ​`node-restriction.kubernetes.io/`​ 前缀设置或修改标签。

要使用该标签前缀进行节点隔离：

1.  确保你在使用节点鉴权机制并且已经启用了 NodeRestriction 准入插件。
2.  将带有 ​`node-restriction.kubernetes.io/`​ 前缀的标签添加到 Node 对象， 然后在节点选择器中使用这些标签。 例如，​`example.com.node-restriction.kubernetes.io/fips=true`​ 或 ​`example.com.node-restriction.kubernetes.io/pci-dss=true`​。

nodeSelector
------------

​`nodeSelector` ​是节点选择约束的最简单推荐形式。你可以将 ​`nodeSelector` ​字段添加到 Pod 的规约中设置你希望目标节点所具有的节点标签。 Kubernetes 只会将 Pod 调度到拥有你所指定的每个标签的节点上。

亲和性与反亲和性 
---------

​`nodeSelector` ​提供了一种最简单的方法来将 Pod 约束到具有特定标签的节点上。 亲和性和反亲和性扩展了你可以定义的约束类型。使用亲和性与反亲和性的一些好处有：

*   亲和性、反亲和性语言的表达能力更强。​`nodeSelector` ​只能选择拥有所有指定标签的节点。 亲和性、反亲和性为你提供对选择逻辑的更强控制能力。
*   你可以标明某规则是“软需求”或者“偏好”，这样调度器在无法找到匹配节点时仍然调度该 Pod。
*   你可以使用节点上（或其他拓扑域中）运行的其他 Pod 的标签来实施调度约束， 而不是只能使用节点本身的标签。这个能力让你能够定义规则允许哪些 Pod 可以被放置在一起。

### 节点亲和性 

节点亲和性概念上类似于 ​`nodeSelector`​， 它使你可以根据节点上的标签来约束 Pod 可以调度到哪些节点上。 节点亲和性有两种：

*   ​`requiredDuringSchedulingIgnoredDuringExecution`​： 调度器只有在规则被满足的时候才能执行调度。此功能类似于 ​`nodeSelector`​， 但其语法表达能力更强。
*   ​`preferredDuringSchedulingIgnoredDuringExecution`​： 调度器会尝试寻找满足对应规则的节点。如果找不到匹配的节点，调度器仍然会调度该 Pod。

> Note:  
> 在上述类型中，​`IgnoredDuringExecution` ​意味着如果节点标签在 Kubernetes 调度 Pod 时发生了变更，Pod 仍将继续运行。

你可以使用 Pod 规约中的 ​`.spec.affinity.nodeAffinity`​ 字段来设置节点亲和性。 例如，考虑下面的 Pod 规约：

`apiVersion: v1 kind: Pod metadata:   name: with-node-affinity spec:   affinity:     nodeAffinity:       requiredDuringSchedulingIgnoredDuringExecution:         nodeSelectorTerms:         - matchExpressions:           - key: kubernetes.io/os             operator: In             values:             - linux       preferredDuringSchedulingIgnoredDuringExecution:       - weight: 1         preference:           matchExpressions:           - key: another-node-label-key             operator: In             values:             - another-node-label-value   containers:   - name: with-node-affinity     image: k8s.gcr.io/pause:2.0`

在这一示例中，所应用的规则如下：

*   节点必须包含键名为 ​`kubernetes.io/os`​ 的标签，并且其取值为 ​`linux`​。
*   节点 最好 具有键名为 ​`another-node-label-key`​ 且取值为 ​`another-node-label-value`​ 的标签。

你可以使用 ​`operator` ​字段来为 Kubernetes 设置在解释规则时要使用的逻辑操作符。 你可以使用 ​`In`​、​`NotIn`​、​`Exists`​、​`DoesNotExist`​、​`Gt` ​和 ​`Lt` ​之一作为操作符。

​`NotIn` ​和 ​`DoesNotExist` ​可用来实现节点反亲和性行为。 你也可以使用节点污点 将 Pod 从特定节点上驱逐。

> Note:  
> 如果你同时指定了 ​`nodeSelector` ​和 ​`nodeAffinity`​，两者 必须都要满足， 才能将 Pod 调度到候选节点上。  
> 如果你指定了多个与 ​`nodeAffinity` ​类型关联的 ​`nodeSelectorTerms`​， 只要其中一个 ​`nodeSelectorTerms` ​满足的话，Pod 就可以被调度到节点上。  
> 如果你指定了多个与同一 ​`nodeSelectorTerms` ​关联的 ​`matchExpressions`​， 则只有当所有 ​`matchExpressions` ​都满足时 Pod 才可以被调度到节点上。

#### 节点亲和性权重 

你可以为 ​`preferredDuringSchedulingIgnoredDuringExecution` ​亲和性类型的每个实例设置 ​`weight` ​字段，其取值范围是 1 到 100。 当调度器找到能够满足 Pod 的其他调度请求的节点时，调度器会遍历节点满足的所有的偏好性规则， 并将对应表达式的 ​`weight` ​值加和。

最终的加和值会添加到该节点的其他优先级函数的评分之上。 在调度器为 Pod 作出调度决定时，总分最高的节点的优先级也最高。

例如，考虑下面的 Pod 规约：

`apiVersion: v1 kind: Pod metadata:   name: with-affinity-anti-affinity spec:   affinity:     nodeAffinity:       requiredDuringSchedulingIgnoredDuringExecution:         nodeSelectorTerms:         - matchExpressions:           - key: kubernetes.io/os             operator: In             values:             - linux       preferredDuringSchedulingIgnoredDuringExecution:       - weight: 1         preference:           matchExpressions:           - key: label-1             operator: In             values:             - key-1       - weight: 50         preference:           matchExpressions:           - key: label-2             operator: In             values:             - key-2   containers:   - name: with-node-affinity     image: k8s.gcr.io/pause:2.0`

如果存在两个候选节点，都满足 ​`requiredDuringSchedulingIgnoredDuringExecution` ​规则， 其中一个节点具有标签 ​`label-1:key-1`​，另一个节点具有标签 ​`label-2:key-2`​， 调度器会考察各个节点的 ​`weight` ​取值，并将该权重值添加到节点的其他得分值之上。

> Note:  
> 如果你希望 Kubernetes 能够成功地调度此例中的 Pod，你必须拥有打了 ​`kubernetes.io/os=linux`​ 标签的节点。

#### 逐个调度方案中设置节点亲和性 

FEATURE STATE: Kubernetes v1.20 \[beta\]

在配置多个调度方案时， 你可以将某个方案与节点亲和性关联起来，如果某个调度方案仅适用于某组特殊的节点时， 这样做是很有用的。 要实现这点，可以在调度器配置中为 ​`NodeAffinity` ​插件的 ​`args` ​字段添加 ​`addedAffinity`​。例如：

`apiVersion: kubescheduler.config.k8s.io/v1beta3 kind: KubeSchedulerConfiguration  profiles:   - schedulerName: default-scheduler   - schedulerName: foo-scheduler     pluginConfig:       - name: NodeAffinity         args:           addedAffinity:             requiredDuringSchedulingIgnoredDuringExecution:               nodeSelectorTerms:               - matchExpressions:                 - key: scheduler-profile                   operator: In                   values:                   - foo`

这里的 ​`addedAffinity` ​除遵从 Pod 规约中设置的节点亲和性之外，还 适用于将 ​`.spec.schedulerName`​ 设置为 ​`foo-scheduler`​。 换言之，为了匹配 Pod，节点需要满足 ​`addedAffinity` ​和 Pod 的 ​`.spec.NodeAffinity`​。

由于 ​`addedAffinity` ​对最终用户不可见，其行为可能对用户而言是出乎意料的。 应该使用与调度方案名称有明确关联的节点标签。

> Note:  
> DaemonSet 控制器为 DaemonSet 创建 Pods， 但该控制器不理会调度方案。 DaemonSet 控制器创建 Pod 时，默认的 Kubernetes 调度器负责放置 Pod， 并遵从 DaemonSet 控制器中奢侈的 ​`nodeAffinity` ​规则。

### pod 间亲和性与反亲和性 

Pod 间亲和性与反亲和性使你可以基于已经在节点上运行的 Pod 的标签来约束 Pod 可以调度到的节点，而不是基于节点上的标签。

Pod 间亲和性与反亲和性的规则格式为“如果 X 上已经运行了一个或多个满足规则 Y 的 Pod， 则这个 Pod 应该（或者在反亲和性的情况下不应该）运行在 X 上”。 这里的 X 可以是节点、机架、云提供商可用区或地理区域或类似的拓扑域， Y 则是 Kubernetes 尝试满足的规则。

你通过标签选择算符 的形式来表达规则（Y），并可根据需要指定选关联的名字空间列表。 Pod 在 Kubernetes 中是名字空间作用域的对象，因此 Pod 的标签也隐式地具有名字空间属性。 针对 Pod 标签的所有标签选择算符都要指定名字空间，Kubernetes 会在指定的名字空间内寻找标签。

你会通过 ​`topologyKey` ​来表达拓扑域（X）的概念，其取值是系统用来标示域的节点标签键。

> Note:  
> Pod 间亲和性和反亲和性都需要相当的计算量，因此会在大规模集群中显著降低调度速度。 我们不建议在包含数百个节点的集群中使用这类设置。

> Note:  
> Pod 反亲和性需要节点上存在一致性的标签。换言之， 集群中每个节点都必须拥有与 ​`topologyKey` ​匹配的标签。 如果某些或者所有节点上不存在所指定的 ​`topologyKey` ​标签，调度行为可能与预期的不同。

#### Pod 间亲和性与反亲和性的类型

与节点亲和性类似，Pod 的亲和性与反亲和性也有两种类型：

*   ​`requiredDuringSchedulingIgnoredDuringExecution` ​
*   ​`preferredDuringSchedulingIgnoredDuringExecution` ​

例如，你可以使用 ​`requiredDuringSchedulingIgnoredDuringExecution` ​亲和性来告诉调度器， 将两个服务的 Pod 放到同一个云提供商可用区内，因为它们彼此之间通信非常频繁。 类似地，你可以使用 ​`preferredDuringSchedulingIgnoredDuringExecution` ​反亲和性来将同一服务的多个 Pod 分布到多个云提供商可用区中。

要使用 Pod 间亲和性，可以使用 Pod 规约中的 ​`.affinity.podAffinity`​ 字段。 对于 Pod 间反亲和性，可以使用 Pod 规约中的 ​`.affinity.podAntiAffinity`​ 字段。

#### Pod 亲和性示例 

考虑下面的 Pod 规约：

`apiVersion: v1 kind: Pod metadata:   name: with-pod-affinity spec:   affinity:     podAffinity:       requiredDuringSchedulingIgnoredDuringExecution:       - labelSelector:           matchExpressions:           - key: security             operator: In             values:             - S1         topologyKey: topology.kubernetes.io/zone     podAntiAffinity:       preferredDuringSchedulingIgnoredDuringExecution:       - weight: 100         podAffinityTerm:           labelSelector:             matchExpressions:             - key: security               operator: In               values:               - S2           topologyKey: topology.kubernetes.io/zone   containers:   - name: with-pod-affinity     image: k8s.gcr.io/pause:2.0`

本示例定义了一条 Pod 亲和性规则和一条 Pod 反亲和性规则。Pod 亲和性规则配置为 ​`requiredDuringSchedulingIgnoredDuringExecution`​，而 Pod 反亲和性配置为 ​`preferredDuringSchedulingIgnoredDuringExecution`​。

亲和性规则表示，仅当节点和至少一个已运行且有 ​`security=S1`​ 的标签的 Pod 处于同一区域时，才可以将该 Pod 调度到节点上。 更确切的说，调度器必须将 Pod 调度到具有 ​`topology.kubernetes.io/zone=V`​ 标签的节点上，并且集群中至少有一个位于该可用区的节点上运行着带有 ​`security=S1`​ 标签的 Pod。

反亲和性规则表示，如果节点处于 Pod 所在的同一可用区且至少一个 Pod 具有 ​`security=S2`​ 标签，则该 Pod 不应被调度到该节点上。 更确切地说， 如果同一可用区中存在其他运行着带有 ​`security=S2`​ 标签的 Pod 节点， 并且节点具有标签 ​`topology.kubernetes.io/zone=R`​，Pod 不能被调度到该节点上。

查阅设计文档 以了解 Pod 亲和性与反亲和性的更多示例。

你可以针对 Pod 间亲和性与反亲和性为其 ​`operator` ​字段使用 ​`In`​、​`NotIn`​、​`Exists`​、 ​`DoesNotExist` ​等值。

原则上，​`topologyKey` ​可以是任何合法的标签键。出于性能和安全原因，​`topologyKey` ​有一些限制：

*   对于 Pod 亲和性而言，在 ​`requiredDuringSchedulingIgnoredDuringExecution` ​和 ​`preferredDuringSchedulingIgnoredDuringExecution` ​中，​`topologyKey` ​不允许为空。
*   对于 ​`requiredDuringSchedulingIgnoredDuringExecution` ​要求的 Pod 反亲和性， 准入控制器 ​`LimitPodHardAntiAffinityTopology` ​要求 ​`topologyKey` ​只能是 ​`kubernetes.io/hostname`​。如果你希望使用其他定制拓扑逻辑， 你可以更改准入控制器或者禁用之。

除了 ​`labelSelector` ​和 ​`topologyKey`​，你也可以指定 ​`labelSelector` ​要匹配的命名空间列表，方法是在 ​`labelSelector` ​和 ​`topologyKey` ​所在层同一层次上设置 ​`namespaces`​。 如果 ​`namespaces` ​被忽略或者为空，则默认为 Pod 亲和性/反亲和性的定义所在的命名空间。

#### 名字空间选择算符 

FEATURE STATE: Kubernetes v1.24 \[stable\]

用户也可以使用 ​`namespaceSelector` ​选择匹配的名字空间，​`namespaceSelector` ​是对名字空间集合进行标签查询的机制。 亲和性条件会应用到 ​`namespaceSelector` ​所选择的名字空间和 ​`namespaces` ​字段中 所列举的名字空间之上。 注意，空的 ​`namespaceSelector`​（​`{}`​）会匹配所有名字空间，而 null 或者空的 ​`namespaces` ​列表以及 null 值 ​`namespaceSelector` ​意味着“当前 Pod 的名字空间”。

#### 更实际的用例

Pod 间亲和性与反亲和性在与更高级别的集合（例如 ReplicaSet、StatefulSet、 Deployment 等）一起使用时，它们可能更加有用。 这些规则使得你可以配置一组工作负载，使其位于相同定义拓扑（例如，节点）中。

在下面的 Redis 缓存 Deployment 示例中，副本上设置了标签 ​`app=store`​。 ​`podAntiAffinity` ​规则告诉调度器避免将多个带有 ​`app=store`​ 标签的副本部署到同一节点上。 因此，每个独立节点上会创建一个缓存实例。

`apiVersion: apps/v1 kind: Deployment metadata:   name: redis-cache spec:   selector:     matchLabels:       app: store   replicas: 3   template:     metadata:       labels:         app: store     spec:       affinity:         podAntiAffinity:           requiredDuringSchedulingIgnoredDuringExecution:           - labelSelector:               matchExpressions:               - key: app                 operator: In                 values:                 - store             topologyKey: "kubernetes.io/hostname"       containers:       - name: redis-server         image: redis:3.2-alpine`

下面的 Deployment 用来提供 Web 服务器服务，会创建带有标签 ​`app=web-store`​ 的副本。 Pod 亲和性规则告诉调度器将副本放到运行有标签包含 ​`app=store`​ Pod 的节点上。 Pod 反亲和性规则告诉调度器不要在同一节点上放置多个 ​`app=web-store`​ 的服务器。

`apiVersion: apps/v1 kind: Deployment metadata:   name: web-server spec:   selector:     matchLabels:       app: web-store   replicas: 3   template:     metadata:       labels:         app: web-store     spec:       affinity:         podAntiAffinity:           requiredDuringSchedulingIgnoredDuringExecution:           - labelSelector:               matchExpressions:               - key: app                 operator: In                 values:                 - web-store             topologyKey: "kubernetes.io/hostname"         podAffinity:           requiredDuringSchedulingIgnoredDuringExecution:           - labelSelector:               matchExpressions:               - key: app                 operator: In                 values:                 - store             topologyKey: "kubernetes.io/hostname"       containers:       - name: web-app         image: nginx:1.16-alpine`
    

创建前面两个 Deployment 会产生如下的集群布局，每个 Web 服务器与一个缓存实例并置， 并分别运行在三个独立的节点上。

node-1

node-2

node-3

_webserver-1_

_webserver-2_

_webserver-3_

_cache-1_

_cache-2_

_cache-3_

nodeName
--------

​`nodeName` ​是比亲和性或者 ​`nodeSelector` ​更为直接的形式。​`nodeName` ​是 Pod 规约中的一个字段。如果 ​`nodeName` ​字段不为空，调度器会忽略该 Pod， 而指定节点上的 kubelet 会尝试将 Pod 放到该节点上。 使用 ​`nodeName` ​规则的优先级会高于使用 ​`nodeSelector` ​或亲和性与非亲和性的规则。

使用 ​`nodeName` ​来选择节点的方式有一些局限性：

*   如果所指代的节点不存在，则 Pod 无法运行，而且在某些情况下可能会被自动删除。
*   如果所指代的节点无法提供用来运行 Pod 所需的资源，Pod 会失败， 而其失败原因中会给出是否因为内存或 CPU 不足而造成无法运行。
*   在云环境中的节点名称并不总是可预测的，也不总是稳定的。

下面是一个使用 ​`nodeName` ​字段的 Pod 规约示例：

`apiVersion: v1 kind: Pod metadata:   name: nginx spec:   containers:   - name: nginx     image: nginx   nodeName: kube-01`

上面的 Pod 只能运行在节点 ​`kube-01`​ 之上。

##  3.  Kubernetes Pod开销
Pod 开销
------

FEATURE STATE: Kubernetes v1.24 \[stable\]

在节点上运行 Pod 时，Pod 本身占用大量系统资源。这些是运行 Pod 内容器所需资源之外的资源。 在 Kubernetes 中，POD 开销 是一种方法，用于计算 Pod 基础设施在容器请求和限制之上消耗的资源。

在 Kubernetes 中，Pod 的开销是根据与 Pod 的 RuntimeClass 相关联的开销在准入时设置的。

如果启用了 Pod Overhead，在调度 Pod 时，除了考虑容器资源请求的总和外，还要考虑 Pod 开销。 类似地，kubelet 将在确定 Pod cgroups 的大小和执行 Pod 驱逐排序时也会考虑 Pod 开销。

配置 Pod 开销 
----------

你需要确保使用一个定义了 ​`overhead` ​字段的 ​`RuntimeClass`​。

使用示例
----

要使用 Pod 开销，你需要一个定义了 ​`overhead` ​字段的 RuntimeClass。 作为例子，下面的 RuntimeClass 定义中包含一个虚拟化所用的容器运行时， RuntimeClass 如下，其中每个 Pod 大约使用 120MiB 用来运行虚拟机和寄宿操作系统：

`apiVersion: node.k8s.io/v1 kind: RuntimeClass metadata:   name: kata-fc handler: kata-fc overhead:   podFixed:     memory: "120Mi"     cpu: "250m"`

通过指定 ​`kata-fc`​ RuntimeClass 处理程序创建的工作负载会将内存和 CPU 开销计入资源配额计算、节点调度以及 Pod cgroup 尺寸确定。

假设我们运行下面给出的工作负载示例 test-pod:

`apiVersion: v1 kind: Pod metadata:   name: test-pod spec:   runtimeClassName: kata-fc   containers:   - name: busybox-ctr     image: busybox:1.28     stdin: true     tty: true     resources:       limits:         cpu: 500m         memory: 100Mi   - name: nginx-ctr     image: nginx     resources:       limits:         cpu: 1500m         memory: 100Mi`

在准入阶段 RuntimeClass 准入控制器 更新工作负载的 PodSpec 以包含 RuntimeClass 中定义的 ​`overhead`​。如果 PodSpec 中已定义该字段，该 Pod 将会被拒绝。 在这个例子中，由于只指定了 RuntimeClass 名称，所以准入控制器更新了 Pod，使之包含 ​`overhead`​。

在 RuntimeClass 准入控制器进行修改后，你可以查看更新后的 PodSpec：

`kubectl get pod test-pod -o jsonpath='{.spec.overhead}'`

输出：

`map[cpu:250m memory:120Mi]`

如果定义了 ResourceQuata, 则容器请求的总量以及 ​`overhead` ​字段都将计算在内。

当 kube-scheduler 决定在哪一个节点调度运行新的 Pod 时，调度器会兼顾该 Pod 的 ​`overhead` ​以及该 Pod 的容器请求总量。在这个示例中，调度器将资源请求和开销相加， 然后寻找具备 2.25 CPU 和 320 MiB 内存可用的节点。

一旦 Pod 被调度到了某个节点， 该节点上的 kubelet 将为该 Pod 新建一个 cgroup。 底层容器运行时将在这个 Pod 中创建容器。

如果该资源对每一个容器都定义了一个限制（定义了限制值的 Guaranteed QoS 或者 Burstable QoS），kubelet 会为与该资源（CPU 的 ​`cpu.cfs_quota_us`​ 以及内存的 ​`memory.limit_in_bytes`​） 相关的 Pod cgroup 设定一个上限。该上限基于 PodSpec 中定义的容器限制总量与 ​`overhead` ​之和。

对于 CPU，如果 Pod 的 QoS 是 Guaranteed 或者 Burstable，kubelet 会基于容器请求总量与 PodSpec 中定义的 ​`overhead` ​之和设置 ​`cpu.shares`​。

请看这个例子，验证工作负载的容器请求：

`kubectl get pod test-pod -o jsonpath='{.spec.containers[*].resources.limits}'`

容器请求总计 2000m CPU 和 200MiB 内存：

`map[cpu: 500m memory:100Mi] map[cpu:1500m memory:100Mi]`

对照从节点观察到的情况来检查一下：

`kubectl describe node | grep test-pod -B2`

该输出显示请求了 2250m CPU 以及 320MiB 内存。请求包含了 Pod 开销在内：

  `Namespace    Name       CPU Requests  CPU Limits   Memory Requests  Memory Limits  AGE   ---------    ----       ------------  ----------   ---------------  -------------  ---   default      test-pod   2250m (56%)   2250m (56%)  320Mi (1%)       320Mi (1%)     36m`

验证 Pod cgroup 限制
----------------

在工作负载所运行的节点上检查 Pod 的内存 cgroups。在接下来的例子中， 将在该节点上使用具备 CRI 兼容的容器运行时命令行工具 ​`[crictl](https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md)`​。 这是一个显示 Pod 开销行为的高级示例， 预计用户不需要直接在节点上检查 cgroups。 首先在特定的节点上确定该 Pod 的标识符：

`# 在该 Pod 被调度到的节点上执行如下命令： POD_ID="$(sudo crictl pods --name test-pod -q)"`

可以依此判断该 Pod 的 cgroup 路径：

`# 在该 Pod 被调度到的节点上执行如下命令： sudo crictl inspectp -o=json $POD_ID | grep cgroupsPath`

执行结果的 cgroup 路径中包含了该 Pod 的 ​`pause` ​容器。Pod 级别的 cgroup 在即上一层目录。

  `"cgroupsPath": "/kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2/7ccf55aee35dd16aca4189c952d83487297f3cd760f1bbf09620e206e7d0c27a"`

在这个例子中，该 Pod 的 cgroup 路径是 ​`kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2`​。 验证内存的 Pod 级别 cgroup 设置：

`# 在该 Pod 被调度到的节点上执行这个命令。 # 另外，修改 cgroup 的名称以匹配为该 Pod 分配的 cgroup。  cat /sys/fs/cgroup/memory/kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2/memory.limit_in_bytes`

和预期的一样，这一数值为 320 MiB。

`335544320`

### 可观察性 

在 [kube-state-metrics](https://github.com/kubernetes/kube-state-metrics) 中可以通过 ​`kube_pod_overhead_*`​ 指标来协助确定何时使用 Pod 开销， 以及协助观察以一个既定开销运行的工作负载的稳定性。 该特性在 kube-state-metrics 的 1.9 发行版本中不可用，不过预计将在后续版本中发布。 在此之前，用户需要从源代码构建 kube-state-metrics。

##  4.  Kubernetes 污点和容忍度
污点和容忍度
------

节点亲和性 是 Pod 的一种属性，它使 Pod 被吸引到一类特定的节点 （这可能出于一种偏好，也可能是硬性要求）。 污点（Taint）则相反——它使节点能够排斥一类特定的 Pod。

容忍度（Toleration）是应用于 Pod 上的，允许（但并不要求）Pod 调度到带有与之匹配的污点的节点上。

污点和容忍度（Toleration）相互配合，可以用来避免 Pod 被分配到不合适的节点上。 每个节点上都可以应用一个或多个污点，这表示对于那些不能容忍这些污点的 Pod，是不会被该节点接受的。

概念
--

你可以使用命令 [kubectl taint](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=) 给节点增加一个污点。比如，

`kubectl taint nodes node1 key1=value1:NoSchedule`

给节点 ​`node1` ​增加一个污点，它的键名是 ​`key1`​，键值是 ​`value1`​，效果是 ​`NoSchedule`​。 这表示只有拥有和这个污点相匹配的容忍度的 Pod 才能够被分配到 ​`node1` ​这个节点。

若要移除上述命令所添加的污点，你可以执行：

`kubectl taint nodes node1 key1=value1:NoSchedule-`

你可以在 PodSpec 中定义 Pod 的容忍度。 下面两个容忍度均与上面例子中使用 ​`kubectl taint`​ 命令创建的污点相匹配， 因此如果一个 Pod 拥有其中的任何一个容忍度都能够被分配到 ​`node1`​ ：

`tolerations: - key: "key1"   operator: "Equal"   value: "value1"   effect: "NoSchedule"`

`tolerations: - key: "key1"   operator: "Exists"   effect: "NoSchedule"`

这里是一个使用了容忍度的 Pod：

`apiVersion: v1 kind: Pod metadata:   name: nginx   labels:     env: test spec:   containers:   - name: nginx     image: nginx     imagePullPolicy: IfNotPresent   tolerations:   - key: "example-key"     operator: "Exists"     effect: "NoSchedule"`

​`operator` ​的默认值是 ​`Equal`​。

一个容忍度和一个污点相“匹配”是指它们有一样的键名和效果，并且：

*   如果 ​`operator` ​是 ​`Exists` ​（此时容忍度不能指定 ​`value`​），或者
*   如果 ​`operator` ​是 ​`Equal` ​，则它们的 ​`value` ​应该相等

> Note:  
> 存在两种特殊情况：  
> 如果一个容忍度的 ​`key` ​为空且 operator 为 ​`Exists`​， 表示这个容忍度与任意的 key 、value 和 effect 都匹配，即这个容忍度能容忍任意 taint。  
> 如果 ​`effect` ​为空，则可以与所有键名 ​`key1` ​的效果相匹配。

上述例子中 ​`effect` ​使用的值为 ​`NoSchedule`​，你也可以使用另外一个值 ​`PreferNoSchedule`​。 这是“优化”或“软”版本的 ​`NoSchedule` ​—— 系统会 尽量 避免将 Pod 调度到存在其不能容忍污点的节点上， 但这不是强制的。​`effect` ​的值还可以设置为 ​`NoExecute`​，下文会详细描述这个值。

你可以给一个节点添加多个污点，也可以给一个 Pod 添加多个容忍度设置。 Kubernetes 处理多个污点和容忍度的过程就像一个过滤器：从一个节点的所有污点开始遍历， 过滤掉那些 Pod 中存在与之相匹配的容忍度的污点。余下未被过滤的污点的 effect 值决定了 Pod 是否会被分配到该节点，特别是以下情况：

*   如果未被过滤的污点中存在至少一个 effect 值为 ​`NoSchedule` ​的污点， 则 Kubernetes 不会将 Pod 分配到该节点。
*   如果未被过滤的污点中不存在 effect 值为 ​`NoSchedule` ​的污点， 但是存在 effect 值为 ​`PreferNoSchedule` ​的污点， 则 Kubernetes 会 尝试 不将 Pod 分配到该节点。
*   如果未被过滤的污点中存在至少一个 effect 值为 ​`NoExecute` ​的污点， 则 Kubernetes 不会将 Pod 分配到该节点（如果 Pod 还未在节点上运行）， 或者将 Pod 从该节点驱逐（如果 Pod 已经在节点上运行）。

例如，假设你给一个节点添加了如下污点

`kubectl taint nodes node1 key1=value1:NoSchedule kubectl taint nodes node1 key1=value1:NoExecute kubectl taint nodes node1 key2=value2:NoSchedule`

假定有一个 Pod，它有两个容忍度：

`tolerations: - key: "key1"   operator: "Equal"   value: "value1"   effect: "NoSchedule" - key: "key1"   operator: "Equal"   value: "value1"   effect: "NoExecute"`

在这种情况下，上述 Pod 不会被分配到上述节点，因为其没有容忍度和第三个污点相匹配。 但是如果在给节点添加上述污点之前，该 Pod 已经在上述节点运行， 那么它还可以继续运行在该节点上，因为第三个污点是三个污点中唯一不能被这个 Pod 容忍的。

通常情况下，如果给一个节点添加了一个 effect 值为 ​`NoExecute` ​的污点， 则任何不能忍受这个污点的 Pod 都会马上被驱逐， 任何可以忍受这个污点的 Pod 都不会被驱逐。 但是，如果 Pod 存在一个 effect 值为 ​`NoExecute` ​的容忍度指定了可选属性 ​`tolerationSeconds` ​的值，则表示在给节点添加了上述污点之后， Pod 还能继续在节点上运行的时间。例如，

`tolerations: - key: "key1"   operator: "Equal"   value: "value1"   effect: "NoExecute"   tolerationSeconds: 3600`

这表示如果这个 Pod 正在运行，同时一个匹配的污点被添加到其所在的节点， 那么 Pod 还将继续在节点上运行 3600 秒，然后被驱逐。 如果在此之前上述污点被删除了，则 Pod 不会被驱逐。

使用例子
----

通过污点和容忍度，可以灵活地让 Pod 避开 某些节点或者将 Pod 从某些节点驱逐。下面是几个使用例子：

*   专用节点：如果你想将某些节点专门分配给特定的一组用户使用，你可以给这些节点添加一个污点（即， ​`kubectl taint nodes nodename dedicated=groupName:NoSchedule`​）， 然后给这组用户的 Pod 添加一个相对应的 toleration（通过编写一个自定义的 准入控制器，很容易就能做到）。 拥有上述容忍度的 Pod 就能够被分配到上述专用节点，同时也能够被分配到集群中的其它节点。 如果你希望这些 Pod 只能被分配到上述专用节点，那么你还需要给这些专用节点另外添加一个和上述 污点类似的 label （例如：​`dedicated=groupName`​），同时 还要在上述准入控制器中给 Pod 增加节点亲和性要求上述 Pod 只能被分配到添加了 ​`dedicated=groupName`​ 标签的节点上。
*   配备了特殊硬件的节点：在部分节点配备了特殊硬件（比如 GPU）的集群中， 我们希望不需要这类硬件的 Pod 不要被分配到这些特殊节点，以便为后继需要这类硬件的 Pod 保留资源。 要达到这个目的，可以先给配备了特殊硬件的节点添加 taint （例如 ​`kubectl taint nodes nodename special=true:NoSchedule`​ 或 ​`kubectl taint nodes nodename special=true:PreferNoSchedule`​)， 然后给使用了这类特殊硬件的 Pod 添加一个相匹配的 toleration。 和专用节点的例子类似，添加这个容忍度的最简单的方法是使用自定义 准入控制器。 比如，我们推荐使用扩展资源 来表示特殊硬件，给配置了特殊硬件的节点添加污点时包含扩展资源名称， 然后运行一个 ​`ExtendedResourceToleration` ​准入控制器。此时，因为节点已经被设置污点了，没有对应容忍度的 Pod 不会被调度到这些节点。但当你创建一个使用了扩展资源的 Pod 时， ExtendedResourceToleration 准入控制器会自动给 Pod 加上正确的容忍度， 这样 Pod 就会被自动调度到这些配置了特殊硬件件的节点上。 这样就能够确保这些配置了特殊硬件的节点专门用于运行需要使用这些硬件的 Pod， 并且你无需手动给这些 Pod 添加容忍度。
*   基于污点的驱逐: 这是在每个 Pod 中配置的在节点出现问题时的驱逐行为，接下来的章节会描述这个特性。

基于污点的驱逐 
--------

FEATURE STATE: Kubernetes v1.18 \[stable\]

前文提到过污点的 effect 值 ​`NoExecute` ​会影响已经在节点上运行的 Pod

*   如果 Pod 不能忍受 effect 值为 ​`NoExecute` ​的污点，那么 Pod 将马上被驱逐
*   如果 Pod 能够忍受 effect 值为 ​`NoExecute` ​的污点，但是在容忍度定义中没有指定 ​`tolerationSeconds`​，则 Pod 还会一直在这个节点上运行。
*   如果 Pod 能够忍受 effect 值为 ​`NoExecute` ​的污点，而且指定了 ​`tolerationSeconds`​， 则 Pod 还能在这个节点上继续运行这个指定的时间长度。

当某种条件为真时，节点控制器会自动给节点添加一个污点。当前内置的污点包括：

*   ​`node.kubernetes.io/not-ready`​：节点未准备好。这相当于节点状态 ​`Ready` ​的值为 "​`False`​"。
*   ​`node.kubernetes.io/unreachable`​：节点控制器访问不到节点. 这相当于节点状态 ​`Ready` ​的值为 "​`Unknown`​"。
*   ​`node.kubernetes.io/memory-pressure`​：节点存在内存压力。
*   ​`node.kubernetes.io/disk-pressure`​：节点存在磁盘压力。
*   ​`node.kubernetes.io/pid-pressure`​: 节点的 PID 压力。
*   ​`node.kubernetes.io/network-unavailable`​：节点网络不可用。
*   ​`node.kubernetes.io/unschedulable`​: 节点不可调度。
*   ​`node.cloudprovider.kubernetes.io/uninitialized`​：如果 kubelet 启动时指定了一个 "外部" 云平台驱动， 它将给当前节点添加一个污点将其标志为不可用。在 cloud-controller-manager 的一个控制器初始化这个节点后，kubelet 将删除这个污点。

在节点被驱逐时，节点控制器或者 kubelet 会添加带有 ​`NoExecute` ​效应的相关污点。 如果异常状态恢复正常，kubelet 或节点控制器能够移除相关的污点。

> Note: 为了保证由于节点问题引起的 Pod 驱逐 速率限制行为正常， 系统实际上会以限定速率的方式添加污点。在像主控节点与工作节点间通信中断等场景下， 这样做可以避免 Pod 被大量驱逐。

使用这个功能特性，结合 ​`tolerationSeconds`​，Pod 就可以指定当节点出现一个 或全部上述问题时还将在这个节点上运行多长的时间。

比如，一个使用了很多本地状态的应用程序在网络断开时，仍然希望停留在当前节点上运行一段较长的时间， 愿意等待网络恢复以避免被驱逐。在这种情况下，Pod 的容忍度可能是下面这样的：

`tolerations: - key: "node.kubernetes.io/unreachable"   operator: "Exists"   effect: "NoExecute"   tolerationSeconds: 6000`

> Note:  
> Kubernetes 会自动给 Pod 添加一个 key 为 ​`node.kubernetes.io/not-ready`​ 的容忍度 并配置 ​`tolerationSeconds=300`​，除非用户提供的 Pod 配置中已经已存在了 key 为 ​`node.kubernetes.io/not-ready`​ 的容忍度。  
> 同样，Kubernetes 会给 Pod 添加一个 key 为 ​`node.kubernetes.io/unreachable`​ 的容忍度 并配置 ​`tolerationSeconds=300`​，除非用户提供的 Pod 配置中已经已存在了 key 为 ​`node.kubernetes.io/unreachable`​ 的容忍度。

这种自动添加的容忍度意味着在其中一种问题被检测到时 Pod 默认能够继续停留在当前节点运行 5 分钟。

DaemonSet 中的 Pod 被创建时， 针对以下污点自动添加的 ​`NoExecute` ​的容忍度将不会指定 ​`tolerationSeconds`​：

*   ​`node.kubernetes.io/unreachable` ​
*   ​`node.kubernetes.io/not-ready`​

这保证了出现上述问题时 DaemonSet 中的 Pod 永远不会被驱逐。

基于节点状态添加污点 
-----------

控制平面使用节点控制器自动创建 与节点状况对应的带有 ​`NoSchedule` ​效应的污点。

调度器在进行调度时检查污点，而不是检查节点状况。这确保节点状况不会直接影响调度。 例如，如果 ​`DiskPressure` ​节点状况处于活跃状态，则控制平面 添加 ​`node.kubernetes.io/disk-pressure`​ 污点并且不会调度新的 pod 到受影响的节点。如果 ​`MemoryPressure` ​节点状况处于活跃状态，则 控制平面添加 ​`node.kubernetes.io/memory-pressure`​ 污点。

对于新创建的 Pod，可以通过添加相应的 Pod 容忍度来忽略节点状况。 控制平面还在具有除 ​`BestEffort` ​之外的 QoS 类的 Pod 上 添加 ​`node.kubernetes.io/memory-pressure`​ 容忍度。 这是因为 Kubernetes 将 ​`Guaranteed` ​或 ​`Burstable` ​QoS 类中的 Pod（甚至没有设置内存请求的 Pod） 视为能够应对内存压力，而新创建的 ​`BestEffort` ​Pod 不会被调度到受影响的节点上。

DaemonSet 控制器自动为所有守护进程添加如下 ​`NoSchedule`​ 容忍度以防 DaemonSet 崩溃：

*   ​`node.kubernetes.io/memory-pressure` ​
*   ​`node.kubernetes.io/disk-pressure` ​
*   ​`node.kubernetes.io/pid-pressure`​ (1.14 或更高版本)
*   ​`node.kubernetes.io/unschedulable`​ (1.10 或更高版本)
*   ​`node.kubernetes.io/network-unavailable`​ (只适合主机网络配置)

添加上述容忍度确保了向后兼容，你也可以选择自由向 DaemonSet 添加容忍度。

##  5.  Kubernetes Pod优先级和抢占
Pod 优先级和抢占
----------

FEATURE STATE: Kubernetes v1.14 \[stable\]

Pod 可以有 优先级。 优先级表示一个 Pod 相对于其他 Pod 的重要性。 如果一个 Pod 无法被调度，调度程序会尝试抢占（驱逐）较低优先级的 Pod， 以使悬决 Pod 可以被调度。

> Warning:  
> 在一个并非所有用户都是可信的集群中，恶意用户可能以最高优先级创建 Pod， 导致其他 Pod 被驱逐或者无法被调度。 管理员可以使用 ResourceQuota 来阻止用户创建高优先级的 Pod。

如何使用优先级和抢占
----------

要使用优先级和抢占：

1.  新增一个或多个 PriorityClass。
2.  创建 Pod，并将其 ​`priorityClassName` ​设置为新增的 PriorityClass。 当然你不需要直接创建 Pod；通常，你将会添加 ​`priorityClassName` ​到集合对象（如 Deployment） 的 Pod 模板中。

> Note:  
> Kubernetes 已经提供了 2 个 PriorityClass： ​`system-cluster-critical`​ 和 ​`system-node-critical`​。 这些是常见的类，用于确保始终优先调度关键组件。

PriorityClass
-------------

PriorityClass 是一个无名称空间对象，它定义了从优先级类名称到优先级整数值的映射。 名称在 PriorityClass 对象元数据的 ​`name` ​字段中指定。 值在必填的 ​`value` ​字段中指定。值越大，优先级越高。 PriorityClass 对象的名称必须是有效的 DNS 子域名， 并且它不能以 ​`system-`​ 为前缀。

PriorityClass 对象可以设置任何小于或等于 10 亿的 32 位整数值。 较大的数字是为通常不应被抢占或驱逐的关键的系统 Pod 所保留的。 集群管理员应该为这类映射分别创建独立的 PriorityClass 对象。

PriorityClass 还有两个可选字段：​`globalDefault` ​和 ​`description`​。 ​`globalDefault` ​字段表示这个 PriorityClass 的值应该用于没有 ​`priorityClassName` ​的 Pod。 系统中只能存在一个 ​`globalDefault` ​设置为 true 的 PriorityClass。 如果不存在设置了 ​`globalDefault` ​的 PriorityClass， 则没有 ​`priorityClassName` ​的 Pod 的优先级为零。

​`description` ​字段是一个任意字符串。 它用来告诉集群用户何时应该使用此 PriorityClass。

### 关于 PodPriority 和现有集群的注意事项

*   如果你升级一个已经存在的但尚未使用此特性的集群，该集群中已经存在的 Pod 的优先级等效于零。
*   添加一个将 ​`globalDefault` ​设置为 ​`true` ​的 PriorityClass 不会改变现有 Pod 的优先级。 此类 PriorityClass 的值仅用于添加 PriorityClass 后创建的 Pod。
*   如果你删除了某个 PriorityClass 对象，则使用被删除的 PriorityClass 名称的现有 Pod 保持不变， 但是你不能再创建使用已删除的 PriorityClass 名称的 Pod。

### PriorityClass 示例

`apiVersion: scheduling.k8s.io/v1 kind: PriorityClass metadata:   name: high-priority value: 1000000 globalDefault: false description: "此优先级类应仅用于 XYZ 服务 Pod。"`

非抢占式 PriorityClass 
-------------------

FEATURE STATE: Kubernetes v1.24 \[stable\]

配置了 ​`preemptionPolicy: Never`​ 的 Pod 将被放置在调度队列中较低优先级 Pod 之前， 但它们不能抢占其他 Pod。等待调度的非抢占式 Pod 将留在调度队列中，直到有足够的可用资源， 它才可以被调度。非抢占式 Pod，像其他 Pod 一样，受调度程序回退的影响。 这意味着如果调度程序尝试这些 Pod 并且无法调度它们，它们将以更低的频率被重试， 从而允许其他优先级较低的 Pod 排在它们之前。

非抢占式 Pod 仍可能被其他高优先级 Pod 抢占。

​`preemptionPolicy` ​默认为 ​`PreemptLowerPriority`​， 这将允许该 PriorityClass 的 Pod 抢占较低优先级的 Pod（现有默认行为也是如此）。 如果 ​`preemptionPolicy` ​设置为 ​`Never`​，则该 PriorityClass 中的 Pod 将是非抢占式的。

数据科学工作负载是一个示例用例。用户可以提交他们希望优先于其他工作负载的作业， 但不希望因为抢占运行中的 Pod 而导致现有工作被丢弃。 设置为 ​`preemptionPolicy: Never`​ 的高优先级作业将在其他排队的 Pod 之前被调度， 只要足够的集群资源“自然地”变得可用。

### 非抢占式 PriorityClass 示例

`apiVersion: scheduling.k8s.io/v1 kind: PriorityClass metadata:   name: high-priority-nonpreempting value: 1000000 preemptionPolicy: Never globalDefault: false description: "This priority class will not cause other pods to be preempted."`

Pod 优先级
-------

在你拥有一个或多个 PriorityClass 对象之后， 你可以创建在其规约中指定这些 PriorityClass 名称之一的 Pod。 优先级准入控制器使用 ​`priorityClassName` ​字段并填充优先级的整数值。 如果未找到所指定的优先级类，则拒绝 Pod。

以下 YAML 是 Pod 配置的示例，它使用在前面的示例中创建的 PriorityClass。 优先级准入控制器检查 Pod 规约并将其优先级解析为 1000000。

`apiVersion: v1 kind: Pod metadata:   name: nginx   labels:     env: test spec:   containers:   - name: nginx     image: nginx     imagePullPolicy: IfNotPresent   priorityClassName: high-priority`

### Pod 优先级对调度顺序的影响 

当启用 Pod 优先级时，调度程序会按优先级对悬决 Pod 进行排序， 并且每个悬决的 Pod 会被放置在调度队列中其他优先级较低的悬决 Pod 之前。 因此，如果满足调度要求，较高优先级的 Pod 可能会比具有较低优先级的 Pod 更早调度。 如果无法调度此类 Pod，调度程序将继续并尝试调度其他较低优先级的 Pod。

抢占 
---

Pod 被创建后会进入队列等待调度。 调度器从队列中挑选一个 Pod 并尝试将它调度到某个节点上。 如果没有找到满足 Pod 的所指定的所有要求的节点，则触发对悬决 Pod 的抢占逻辑。 让我们将悬决 Pod 称为 P。抢占逻辑试图找到一个节点， 在该节点中删除一个或多个优先级低于 P 的 Pod，则可以将 P 调度到该节点上。 如果找到这样的节点，一个或多个优先级较低的 Pod 会被从节点中驱逐。 被驱逐的 Pod 消失后，P 可以被调度到该节点上。

### 用户暴露的信息

当 Pod P 抢占节点 N 上的一个或多个 Pod 时， Pod P 状态的 ​`nominatedNodeName` ​字段被设置为节点 N 的名称。 该字段帮助调度程序跟踪为 Pod P 保留的资源，并为用户提供有关其集群中抢占的信息。

请注意，Pod P 不一定会调度到“被提名的节点（Nominated Node）”。 调度程序总是在迭代任何其他节点之前尝试“指定节点”。 在 Pod 因抢占而牺牲时，它们将获得体面终止期。 如果调度程序正在等待牺牲者 Pod 终止时另一个节点变得可用， 则调度程序可以使用另一个节点来调度 Pod P。 因此，Pod 规约中的 ​`nominatedNodeName` ​和 ​`nodeName` ​并不总是相同。 此外，如果调度程序抢占节点 N 上的 Pod，但随后比 Pod P 更高优先级的 Pod 到达， 则调度程序可能会将节点 N 分配给新的更高优先级的 Pod。 在这种情况下，调度程序会清除 Pod P 的 ​`nominatedNodeName`​。 通过这样做，调度程序使 Pod P 有资格抢占另一个节点上的 Pod。

### 抢占的限制 

#### 被抢占牺牲者的体面终止

当 Pod 被抢占时，牺牲者会得到他们的 体面终止期。 它们可以在体面终止期内完成工作并退出。如果它们不这样做就会被杀死。 这个体面终止期在调度程序抢占 Pod 的时间点和待处理的 Pod (P) 可以在节点 (N) 上调度的时间点之间划分出了一个时间跨度。 同时，调度器会继续调度其他待处理的 Pod。当牺牲者退出或被终止时， 调度程序会尝试在待处理队列中调度 Pod。 因此，调度器抢占牺牲者的时间点与 Pod P 被调度的时间点之间通常存在时间间隔。 为了最小化这个差距，可以将低优先级 Pod 的体面终止时间设置为零或一个小数字。

#### 支持 PodDisruptionBudget，但不保证

PodDisruptionBudget (PDB) 允许多副本应用程序的所有者限制因自愿性质的干扰而同时终止的 Pod 数量。 Kubernetes 在抢占 Pod 时支持 PDB，但对 PDB 的支持是基于尽力而为原则的。 调度器会尝试寻找不会因被抢占而违反 PDB 的牺牲者，但如果没有找到这样的牺牲者， 抢占仍然会发生，并且即使违反了 PDB 约束也会删除优先级较低的 Pod。

#### 与低优先级 Pod 之间的 Pod 间亲和性

只有当这个问题的答案是肯定的时，才考虑在一个节点上执行抢占操作： “如果从此节点上删除优先级低于悬决 Pod 的所有 Pod，悬决 Pod 是否可以在该节点上调度？”

> Note: 抢占并不一定会删除所有较低优先级的 Pod。 如果悬决 Pod 可以通过删除少于所有较低优先级的 Pod 来调度， 那么只有一部分较低优先级的 Pod 会被删除。 即便如此，上述问题的答案必须是肯定的。 如果答案是否定的，则不考虑在该节点上执行抢占。

如果悬决 Pod 与节点上的一个或多个较低优先级 Pod 具有 Pod 间亲和性， 则在没有这些较低优先级 Pod 的情况下，无法满足 Pod 间亲和性规则。 在这种情况下，调度程序不会抢占节点上的任何 Pod。 相反，它寻找另一个节点。调度程序可能会找到合适的节点， 也可能不会。无法保证悬决 Pod 可以被调度。

我们针对此问题推荐的解决方案是仅针对同等或更高优先级的 Pod 设置 Pod 间亲和性。

#### 跨节点抢占

假设正在考虑在一个节点 N 上执行抢占，以便可以在 N 上调度待处理的 Pod P。 只有当另一个节点上的 Pod 被抢占时，P 才可能在 N 上变得可行。 下面是一个例子：

*   正在考虑将 Pod P 调度到节点 N 上。
*   Pod Q 正在与节点 N 位于同一区域的另一个节点上运行。
*   Pod P 与 Pod Q 具有 Zone 维度的反亲和（​`topologyKey:topology.kubernetes.io/zone`​）。
*   Pod P 与 Zone 中的其他 Pod 之间没有其他反亲和性设置。
*   为了在节点 N 上调度 Pod P，可以抢占 Pod Q，但调度器不会进行跨节点抢占。 因此，Pod P 将被视为在节点 N 上不可调度。

如果将 Pod Q 从所在节点中移除，则不会违反 Pod 间反亲和性约束， 并且 Pod P 可能会被调度到节点 N 上。

如果有足够的需求，并且如果我们找到性能合理的算法， 我们可能会考虑在未来版本中添加跨节点抢占。

故障排除
----

Pod 优先级和抢占可能会产生不必要的副作用。以下是一些潜在问题的示例以及处理这些问题的方法。

### Pod 被不必要地抢占

抢占在资源压​​力较大时从集群中删除现有 Pod，为更高优先级的悬决 Pod 腾出空间。 如果你错误地为某些 Pod 设置了高优先级，这些无意的高优先级 Pod 可能会导致集群中出现抢占行为。 Pod 优先级是通过设置 Pod 规约中的 ​`priorityClassName` ​字段来指定的。 优先级的整数值然后被解析并填充到 ​`podSpec` ​的 ​`priority` ​字段。

为了解决这个问题，你可以将这些 Pod 的 ​`priorityClassName` ​更改为使用较低优先级的类， 或者将该字段留空。默认情况下，空的 ​`priorityClassName` ​解析为零。

当 Pod 被抢占时，集群会为被抢占的 Pod 记录事件。只有当集群没有足够的资源用于 Pod 时， 才会发生抢占。在这种情况下，只有当悬决 Pod（抢占者）的优先级高于受害 Pod 时才会发生抢占。 当没有悬决 Pod，或者悬决 Pod 的优先级等于或低于牺牲者时，不得发生抢占。 如果在这种情况下发生抢占，请提出问题。

### 有 Pod 被抢占，但抢占者并没有被调度

当 Pod 被抢占时，它们会收到请求的体面终止期，默认为 30 秒。 如果受害 Pod 在此期限内没有终止，它们将被强制终止。 一旦所有牺牲者都离开，就可以调度抢占者 Pod。

在抢占者 Pod 等待牺牲者离开的同时，可能某个适合同一个节点的更高优先级的 Pod 被创建。 在这种情况下，调度器将调度优先级更高的 Pod 而不是抢占者。

这是预期的行为：具有较高优先级的 Pod 应该取代具有较低优先级的 Pod。

### 优先级较高的 Pod 在优先级较低的 Pod 之前被抢占

调度程序尝试查找可以运行悬决 Pod 的节点。如果没有找到这样的节点， 调度程序会尝试从任意节点中删除优先级较低的 Pod，以便为悬决 Pod 腾出空间。 如果具有低优先级 Pod 的节点无法运行悬决 Pod， 调度器可能会选择另一个具有更高优先级 Pod 的节点（与其他节点上的 Pod 相比）进行抢占。 牺牲者的优先级必须仍然低于抢占者 Pod。

当有多个节点可供执行抢占操作时，调度器会尝试选择具有一组优先级最低的 Pod 的节点。 但是，如果此类 Pod 具有 PodDisruptionBudget，当它们被抢占时， 则会违反 PodDisruptionBudget，那么调度程序可能会选择另一个具有更高优先级 Pod 的节点。

当存在多个节点抢占且上述场景均不适用时，调度器会选择优先级最低的节点。

Pod 优先级和服务质量之间的相互作用
-------------------

Pod 优先级和 QoS 类 是两个正交特征，交互很少，并且对基于 QoS 类设置 Pod 的优先级没有默认限制。 调度器的抢占逻辑在选择抢占目标时不考虑 QoS。 抢占会考虑 Pod 优先级并尝试选择一组优先级最低的目标。 仅当移除优先级最低的 Pod 不足以让调度程序调度抢占式 Pod， 或者最低优先级的 Pod 受 PodDisruptionBudget 保护时，才会考虑优先级较高的 Pod。

kubelet 使用优先级来确定 节点压力驱逐 Pod 的顺序。 你可以使用 QoS 类来估计 Pod 最有可能被驱逐的顺序。kubelet 根据以下因素对 Pod 进行驱逐排名：

1.  对紧俏资源的使用是否超过请求值
2.  Pod 优先级
3.  相对于请求的资源使用量

当某 Pod 的资源用量未超过其请求时，kubelet 节点压力驱逐不会驱逐该 Pod。 如果优先级较低的 Pod 没有超过其请求，则不会被驱逐。 另一个优先级高于其请求的 Pod 可能会被驱逐。

##  6.  Kubernetes 节点压力驱逐
节点压力驱逐
------

节点压力驱逐是 kubelet 主动终止 Pod 以回收节点上资源的过程。

kubelet 监控集群节点的 CPU、内存、磁盘空间和文件系统的 inode 等资源。 当这些资源中的一个或者多个达到特定的消耗水平， kubelet 可以主动地使节点上一个或者多个 Pod 失效，以回收资源防止饥饿。

在节点压力驱逐期间，kubelet 将所选 Pod 的 ​`PodPhase` ​设置为 ​`Failed`​。这将终止 Pod。

节点压力驱逐不同于 API 发起的驱逐。

kubelet 并不理会你配置的 ​`PodDisruptionBudget` ​或者是 Pod 的 ​`terminationGracePeriodSeconds`​。 如果你使用了软驱逐条件，kubelet 会考虑你所配置的 ​`eviction-max-pod-grace-period`​。 如果你使用了硬驱逐条件，它使用 0s 宽限期来终止 Pod。

如果 Pod 是由替换失败 Pod 的工作负载资源 （例如 StatefulSet 或者 Deployment）管理， 则控制平面或 ​`kube-controller-manager`​ 会创建新的 Pod 来代替被驱逐的 Pod。

> Note:  
> kubelet 在终止最终用户 Pod 之前会尝试回收节点级资源。 例如，它会在磁盘资源不足时删除未使用的容器镜像。

kubelet 使用各种参数来做出驱逐决定，如下所示：

*   驱逐信号
*   驱逐条件
*   监控间隔

驱逐信号
----

驱逐信号是特定资源在特定时间点的当前状态。 kubelet 使用驱逐信号，通过将信号与驱逐条件进行比较来做出驱逐决定， 驱逐条件是节点上应该可用资源的最小量。

kubelet 使用以下驱逐信号：

驱逐信号

描述

`memory.available`

`memory.available` := `node.status.capacity[memory]` - `node.stats.memory.workingSet`

`nodefs.available`

`nodefs.available` := `node.stats.fs.available`

`nodefs.inodesFree`

`nodefs.inodesFree` := `node.stats.fs.inodesFree`

`imagefs.available`

`imagefs.available` := `node.stats.runtime.imagefs.available`

`imagefs.inodesFree`

`imagefs.inodesFree` := `node.stats.runtime.imagefs.inodesFree`

`pid.available`

`pid.available` := `node.stats.rlimit.maxpid` - `node.stats.rlimit.curproc`

在上表中，描述列显示了 kubelet 如何获取信号的值。每个信号支持百分比值或者是字面值。 kubelet 计算相对于与信号有关的总量的百分比值。

​`memory.available`​ 的值来自 cgroupfs，而不是像 ​`free -m`​ 这样的工具。 这很重要，因为 ​`free -m`​ 在容器中不起作用，如果用户使用 节点可分配资源 这一功能特性，资源不足的判定是基于 CGroup 层次结构中的用户 Pod 所处的局部及 CGroup 根节点作出的。 这个 [脚本](https://atts.tedschool.cn/k8s%2Fmemory-available.sh) 重现了 kubelet 为计算 ​`memory.available`​ 而执行的相同步骤。 kubelet 在其计算中排除了 inactive\_file（即非活动 LRU 列表上基于文件来虚拟的内存的字节数）， 因为它假定在压力下内存是可回收的。

kubelet 支持以下文件系统分区：

1.  ​`nodefs`​：节点的主要文件系统，用于本地磁盘卷、emptyDir、日志存储等。 例如，​`nodefs` ​包含 ​`/var/lib/kubelet/`​。
2.  ​`imagefs`​：可选文件系统，供容器运行时存储容器镜像和容器可写层。

kubelet 会自动发现这些文件系统并忽略其他文件系统。kubelet 不支持其他配置。

> Note:  
> 一些 kubelet 垃圾收集功能已被弃用，以支持驱逐。

驱逐条件
----

你可以为 kubelet 指定自定义驱逐条件，以便在作出驱逐决定时使用。

驱逐条件的形式为 ​`[eviction-signal][operator][quantity]`​，其中：

*   ​`eviction-signal`​ 是要使用的驱逐信号。
*   ​`operator` ​是你想要的[关系运算符](https://en.wikipedia.org/wiki/Relational_operator target=)， 比如 ​`<`​（小于）。
*   ​`quantity` ​是驱逐条件数量，例如 ​`1Gi`​。 ​`quantity` ​的值必须与 Kubernetes 使用的数量表示相匹配。 你可以使用文字值或百分比（​`%`​）。

例如，如果一个节点的总内存为 10Gi 并且你希望在可用内存低于 1Gi 时触发驱逐， 则可以将驱逐条件定义为 ​`memory.available<10%`​ 或 ​`memory.available< 1G`​。 你不能同时使用二者。

你可以配置软和硬驱逐条件。

### 软驱逐条件

软驱逐条件将驱逐条件与管理员所必须指定的宽限期配对。 在超过宽限期之前，kubelet 不会驱逐 Pod。 如果没有指定的宽限期，kubelet 会在启动时返回错误。

你可以既指定软驱逐条件宽限期，又指定 Pod 终止宽限期的上限，，给 kubelet 在驱逐期间使用。 如果你指定了宽限期的上限并且 Pod 满足软驱逐阈条件，则 kubelet 将使用两个宽限期中的较小者。 如果你没有指定宽限期上限，kubelet 会立即杀死被驱逐的 Pod，不允许其体面终止。

你可以使用以下标志来配置软驱逐条件：

*   ​`eviction-soft`​：一组驱逐条件，如 ​`memory.available<1.5Gi`​， 如果驱逐条件持续时长超过指定的宽限期，可以触发 Pod 驱逐。
*   ​`eviction-soft-grace-period`​：一组驱逐宽限期， 如 ​`memory.available=1m30s`​，定义软驱逐条件在触发 Pod 驱逐之前必须保持多长时间。
*   ​`eviction-max-pod-grace-period`​：在满足软驱逐条件而终止 Pod 时使用的最大允许宽限期（以秒为单位）。

### 硬驱逐条件

硬驱逐条件没有宽限期。当达到硬驱逐条件时， kubelet 会立即杀死 pod，而不会正常终止以回收紧缺的资源。

你可以使用 ​`eviction-hard`​ 标志来配置一组硬驱逐条件， 例如 ​`memory.available<1Gi`​。

kubelet 具有以下默认硬驱逐条件：

*   ​`memory.available<100Mi` ​
*   ​`nodefs.available<10%` ​
*   ​`imagefs.available<15%` ​
*   ​`nodefs.inodesFree<5%`​（Linux 节点）

驱逐监测间隔
------

kubelet 根据其配置的 ​`housekeeping-interval`​（默认为 ​`10s`​）评估驱逐条件。

节点条件
----

kubelet 报告节点状况以反映节点处于压力之下，因为满足硬或软驱逐条件，与配置的宽限期无关。

kubelet 根据下表将驱逐信号映射为节点状况：

节点条件

驱逐信号

描述

`MemoryPressure`

`memory.available`

节点上的可用内存已满足驱逐条件

`DiskPressure`

`nodefs.available`、`nodefs.inodesFree`、`imagefs.available` 或 `imagefs.inodesFree`

节点的根文件系统或映像文件系统上的可用磁盘空间和 inode 已满足驱逐条件

`PIDPressure`

`pid.available`

(Linux) 节点上的可用进程标识符已低于驱逐条件

kubelet 根据配置的 ​`--node-status-update-frequency`​ 更新节点条件，默认为 ​`10s`​。

### 节点条件振荡

在某些情况下，节点在软驱逐条件上下振荡，而没有保持定义的宽限期。 这会导致报告的节点条件在 ​`true` ​和 ​`false` ​之间不断切换，从而导致错误的驱逐决策。

为了防止振荡，你可以使用 ​`eviction-pressure-transition-period`​ 标志， 该标志控制 kubelet 在将节点条件转换为不同状态之前必须等待的时间。 过渡期的默认值为 ​`5m`​。

回收节点级资源
-------

kubelet 在驱逐最终用户 Pod 之前会先尝试回收节点级资源。

当报告 ​`DiskPressure` ​节点状况时，kubelet 会根据节点上的文件系统回收节点级资源。

### 有 imagefs

如果节点有一个专用的 ​`imagefs` ​文件系统供容器运行时使用，kubelet 会执行以下操作：

*   如果 ​`nodefs` ​文件系统满足驱逐条件，kubelet 垃圾收集死亡 Pod 和容器。
*   如果 ​`imagefs` ​文件系统满足驱逐条件，kubelet 将删除所有未使用的镜像。

### 没有 imagefs

如果节点只有一个满足驱逐条件的 ​`nodefs` ​文件系统， kubelet 按以下顺序释放磁盘空间：

1.  对死亡的 Pod 和容器进行垃圾收集
2.  删除未使用的镜像

kubelet 驱逐时 Pod 的选择
-------------------

如果 kubelet 回收节点级资源的尝试没有使驱逐信号低于条件， 则 kubelet 开始驱逐最终用户 Pod。

kubelet 使用以下参数来确定 Pod 驱逐顺序：

1.  Pod 的资源使用是否超过其请求
2.  Pod 优先级
3.  Pod 相对于请求的资源使用情况

因此，kubelet 按以下顺序排列和驱逐 Pod：

1.  首先考虑资源使用量超过其请求的 ​`BestEffort` ​或 ​`Burstable` ​Pod。 这些 Pod 会根据它们的优先级以及它们的资源使用级别超过其请求的程度被逐出。
2.  资源使用量少于请求量的 ​`Guaranteed` ​Pod 和 ​`Burstable` ​Pod 根据其优先级被最后驱逐。

> Note:  
> kubelet 不使用 Pod 的 QoS 类来确定驱逐顺序。 在回收内存等资源时，你可以使用 QoS 类来估计最可能的 Pod 驱逐顺序。 QoS 不适用于临时存储（EphemeralStorage）请求， 因此如果节点在 ​`DiskPressure` ​下，则上述场景将不适用。

仅当 ​`Guaranteed` ​Pod 中所有容器都被指定了请求和限制并且二者相等时，才保证 Pod 不被驱逐。 这些 Pod 永远不会因为另一个 Pod 的资源消耗而被驱逐。 如果系统守护进程（例如 ​`kubelet` ​和 ​`journald`​） 消耗的资源比通过 ​`system-reserved`​ 或 ​`kube-reserved`​ 分配保留的资源多， 并且该节点只有 ​`Guaranteed` ​或 ​`Burstable` ​Pod 使用的资源少于其上剩余的请求， 那么 kubelet 必须选择驱逐这些 Pod 中的一个以保持节点稳定性并减少资源匮乏对其他 Pod 的影响。 在这种情况下，它会选择首先驱逐最低优先级的 Pod。

当 kubelet 因 inode 或 PID 不足而驱逐 pod 时， 它使用优先级来确定驱逐顺序，因为 inode 和 PID 没有请求。

kubelet 根据节点是否具有专用的 ​`imagefs` ​文件系统对 Pod 进行不同的排序：

### 有 imagefs

如果 ​`nodefs` ​触发驱逐， kubelet 会根据 ​`nodefs` ​使用情况（本地卷 + 所有容器的日志）对 Pod 进行排序。

如果 ​`imagefs` ​触发驱逐，kubelet 会根据所有容器的可写层使用情况对 Pod 进行排序。

### 没有 imagefs

如果 ​`nodefs` ​触发驱逐， kubelet 会根据磁盘总用量（本地卷 + 日志和所有容器的可写层）对 Pod 进行排序。

最小驱逐回收 
-------

在某些情况下，驱逐 Pod 只会回收少量的紧俏资源。 这可能导致 kubelet 反复达到配置的驱逐条件并触发多次驱逐。

你可以使用 ​`--eviction-minimum-reclaim`​ 标志或 kubelet 配置文件 为每个资源配置最小回收量。 当 kubelet 注意到某个资源耗尽时，它会继续回收该资源，直到回收到你所指定的数量为止。

例如，以下配置设置最小回收量：

`apiVersion: kubelet.config.k8s.io/v1beta1 kind: KubeletConfiguration evictionHard:   memory.available: "500Mi"   nodefs.available: "1Gi"   imagefs.available: "100Gi" evictionMinimumReclaim:   memory.available: "0Mi"   nodefs.available: "500Mi"   imagefs.available: "2Gi"`

在这个例子中，如果 ​`nodefs.available`​ 信号满足驱逐条件， kubelet 会回收资源，直到信号达到 ​`1Gi` ​的条件， 然后继续回收至少 ​`500Mi`​ 直到信号达到 ​`1.5Gi`​。

类似地，kubelet 会回收 ​`imagefs` ​资源，直到 ​`imagefs.available`​ 信号达到 ​`102Gi`​。

对于所有资源，默认的 ​`eviction-minimum-reclaim`​ 为 ​`0`​。

节点内存不足行为
--------

如果节点在 kubelet 能够回收内存之前遇到内存不足（OOM）事件， 则节点依赖 [oom\_killer](https://lwn.net/Articles/391222/) 来响应。

kubelet 根据 Pod 的服务质量（QoS）为每个容器设置一个 ​`oom_score_adj`​ 值。

服务质量

oom\_score\_adj

`Guaranteed`

\-997

`BestEffort`

1000

`Burstable`

min(max(2, 1000 - (1000 \* memoryRequestBytes) / machineMemoryCapacityBytes), 999)

> Note:  
> kubelet 还将具有 ​`system-node-critical`​ 优先级 的 Pod 中的容器 ​`oom_score_adj`​ 值设为 ​`-997`​。

如果 kubelet 在节点遇到 OOM 之前无法回收内存， 则 ​`oom_killer` ​根据它在节点上使用的内存百分比计算 ​`oom_score`​， 然后加上 ​`oom_score_adj` ​得到每个容器有效的 ​`oom_score`​。 然后它会杀死得分最高的容器。

这意味着低 QoS Pod 中相对于其调度请求消耗内存较多的容器，将首先被杀死。

与 Pod 驱逐不同，如果容器被 OOM 杀死， ​`kubelet` ​可以根据其 ​`RestartPolicy` ​重新启动它。

最佳实践
----

以下部分描述了驱逐配置的最佳实践。

### 可调度的资源和驱逐策略

当你为 kubelet 配置驱逐策略时， 你应该确保调度程序不会在 Pod 触发驱逐时对其进行调度，因为这类 Pod 会立即引起内存压力。

考虑以下场景：

*   节点内存容量：​`10Gi` ​
*   操作员希望为系统守护进程（内核、​`kubelet` ​等）保留 10% 的内存容量
*   操作员希望驱逐内存利用率为 95% 的Pod，以减少系统 OOM 的概率。

为此，kubelet 启动设置如下：

`--eviction-hard=memory.available<500Mi --system-reserved=memory=1.5Gi`

在此配置中，​`--system-reserved`​ 标志为系统预留了 ​`1.5Gi`​ 的内存， 即 总内存的 10% + 驱逐条件量。

如果 Pod 使用的内存超过其请求值或者系统使用的内存超过 ​`1Gi`​， 则节点可以达到驱逐条件，这使得 ​`memory.available`​ 信号低于 ​`500Mi`​ 并触发条件。

DaemonSet
---------

Pod 优先级是做出驱逐决定的主要因素。 如果你不希望 kubelet 驱逐属于 ​`DaemonSet` ​的 Pod， 请在 Pod 规约中为这些 Pod 提供足够高的 ​`priorityClass`​。 你还可以使用优先级较低的 ​`priorityClass` ​或默认配置， 仅在有足够资源时才运行 ​`DaemonSet` ​Pod。

已知问题 
-----

以下部分描述了与资源不足处理相关的已知问题。

### kubelet 可能不会立即观察到内存压力

默认情况下，kubelet 轮询 ​`cAdvisor` ​以定期收集内存使用情况统计信息。 如果该轮询时间窗口内内存使用量迅速增加，kubelet 可能无法足够快地观察到 ​`MemoryPressure`​， 但是 ​`OOMKiller` ​仍将被调用。

你可以使用 ​`--kernel-memcg-notification`​ 标志在 kubelet 上启用 ​`memcg` ​通知 API，以便在超过条件时立即收到通知。

如果你不是追求极端利用率，而是要采取合理的过量使用措施， 则解决此问题的可行方法是使用 ​`--kube-reserved`​ 和 ​`--system-reserved`​ 标志为系统分配内存。

### active\_file 内存未被视为可用内存 

在 Linux 上，内核跟踪活动 LRU 列表上的基于文件所虚拟的内存字节数作为 ​`active_file` ​统计信息。 kubelet 将 ​`active_file` ​内存区域视为不可回收。 对于大量使用块设备形式的本地存储（包括临时本地存储）的工作负载， 文件和块数据的内核级缓存意味着许多最近访问的缓存页面可能被计为 ​`active_file`​。 如果这些内核块缓冲区中在活动 LRU 列表上有足够多， kubelet 很容易将其视为资源用量过量并为节点设置内存压力污点，从而触发 Pod 驱逐。

更多细节请参见 [https://github.com/kubernetes/kubernetes/issues/43916](https://github.com/kubernetes/kubernetes/issues/43916)

你可以通过为可能执行 I/O 密集型活动的容器设置相同的内存限制和内存请求来应对该行为。 你将需要估计或测量该容器的最佳内存限制值。

##  7.  Kubernetes API发起的驱逐
API 发起的驱逐
---------

API 发起的驱逐是一个先调用 [Eviction API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/ target=) 创建 ​`Eviction` ​对象，再由该对象体面地中止 Pod 的过程。

你可以通过直接调用 Eviction API 发起驱逐，也可以通过编程的方式使用 API 服务器的客户端来发起驱逐， 比如 ​`kubectl drain`​ 命令。 此操作创建一个 ​`Eviction` ​对象，该对象再驱动 API 服务器终止选定的 Pod。

API 发起的驱逐将遵从你的 PodDisruptionBudgets 和 terminationGracePeriodSeconds 配置。

使用 API 创建 Eviction 对象，就像对 Pod 执行策略控制的 DELETE 操作

调用 Eviction API
---------------

你可以使用 Kubernetes 语言客户端 来访问 Kubernetes API 并创建 ​`Eviction` ​对象。 要执行此操作，你应该用 POST 发出要尝试的请求，类似于下面的示例：

*   ​`policy/v1`​

> Note:  
> ​`policy/v1`​ 版本的 Eviction 在 v1.22 以及更高的版本中可用，之前的发行版本使用 ​`policy/v1beta1`​ 版本。

`{   "apiVersion": "policy/v1",   "kind": "Eviction",   "metadata": {     "name": "quux",     "namespace": "default"   } }`

*   ​`policy/v1beta1`​

> Note:  
> 在 v1.22 版本废弃以支持 ​`policy/v1`​

`{   "apiVersion": "policy/v1beta1",   "kind": "Eviction",   "metadata": {     "name": "quux",     "namespace": "default"   } }`

或者，你可以通过使用 ​`curl` ​或者 ​`wget` ​来访问 API 以尝试驱逐操作，类似于以下示例：

`curl -v -H 'Content-type: application/json' https://your-cluster-api-endpoint.example/api/v1/namespaces/default/pods/quux/eviction -d @eviction.json`

API 发起驱逐的工作原理
-------------

当你使用 API 来请求驱逐时，API 服务器将执行准入检查，并通过以下方式之一做出响应：

*   ​`200 OK`​：允许驱逐，子资源 ​`Eviction` ​被创建，并且 Pod 被删除， 类似于发送一个 ​`DELETE` ​请求到 Pod 地址。
*   ​`429 Too Many Requests`​：当前不允许驱逐，因为配置了 PodDisruptionBudget。 你可以稍后再尝试驱逐。你也可能因为 API 速率限制而看到这种响应。
*   ​`500 Internal Server Error`​：不允许驱逐，因为存在配置错误， 例如存在多个 PodDisruptionBudgets 引用同一个 Pod。

如果你想驱逐的 Pod 不属于有 PodDisruptionBudget 的工作负载， API 服务器总是返回 ​`200 OK`​ 并且允许驱逐。

如果 API 服务器允许驱逐，Pod 按照如下方式删除：

1.  API 服务器中的 ​`Pod` ​资源会更新上删除时间戳，之后 API 服务器会认为此 ​`Pod` ​资源将被终止。 此 ​`Pod` ​资源还会标记上配置的宽限期。
2.  本地运行状态的 Pod 所处的节点上的 kubelet 注意到 ​`Pod` ​资源被标记为终止，并开始优雅停止本地 Pod。
3.  当 kubelet 停止 Pod 时，控制面从 Endpoint 和 EndpointSlice 对象中移除该 Pod。因此，控制器不再将此 Pod 视为有用对象。
4.  Pod 的宽限期到期后，kubelet 强制终止本地 Pod。
5.  kubelet 告诉 API 服务器删除 ​`Pod` ​资源。
6.  API 服务器删除 ​`Pod` ​资源。

解决驱逐被卡住的问题
----------

在某些情况下，你的应用可能进入中断状态， 在你干预之前，驱逐 API 总是返回 ​`429` ​或 ​`500`​。 例如，如果 ReplicaSet 为你的应用程序创建了 Pod， 但新的 Pod 没有进入 ​`Ready` ​状态，就会发生这种情况。 在最后一个被驱逐的 Pod 有很长的终止宽限期的情况下，你可能也会注意到这种行为。

如果你注意到驱逐被卡住，请尝试以下解决方案之一：

*   终止或暂停导致问题的自动化操作，重新启动操作之前，请检查被卡住的应用程序。
*   等待一段时间后，直接从集群控制平面删除 Pod，而不是使用 Eviction API。

##  8.  Kubernetes 扩展资源的资源装箱
扩展资源的资源装箱
---------

FEATURE STATE: Kubernetes 1.16 \[alpha\]

使用 ​`RequestedToCapacityRatioResourceAllocation` ​优先级函数，可以将 kube-scheduler 配置为支持包含扩展资源在内的资源装箱操作。 优先级函数可用于根据自定义需求微调 kube-scheduler 。

使用 RequestedToCapacityRatioResourceAllocation 启用装箱
--------------------------------------------------

Kubernetes 允许用户指定资源以及每类资源的权重， 以便根据请求数量与可用容量之比率为节点评分。 这就使得用户可以通过使用适当的参数来对扩展资源执行装箱操作，从而提高了大型集群中稀缺资源的利用率。 ​`RequestedToCapacityRatioResourceAllocation` ​优先级函数的行为可以通过名为 ​`RequestedToCapacityRatioArgs` ​的配置选项进行控制。 该标志由两个参数 ​`shape` ​和 ​`resources` ​组成。 ​`shape` ​允许用户根据 ​`utilization` ​和 ​`score` ​值将函数调整为 最少请求（least requested）或最多请求（most requested）计算。 ​`resources` ​包含由 ​`name` ​和 ​`weight` ​组成，​`name` ​指定评分时要考虑的资源， ​`weight` ​指定每种资源的权重。

以下是一个配置示例，该配置将 ​`requestedToCapacityRatioArguments` ​设置为对扩展资源 ​`intel.com/foo`​ 和 ​`intel.com/bar`​ 的装箱行为

`apiVersion: kubescheduler.config.k8s.io/v1beta3 kind: KubeSchedulerConfiguration profiles: # ...   pluginConfig:   - name: RequestedToCapacityRatio     args:        shape:       - utilization: 0         score: 10       - utilization: 100         score: 0       resources:       - name: intel.com/foo         weight: 3       - name: intel.com/bar         weight: 5`

使用 kube-scheduler 标志 ​`--config=/path/to/config/file`​ 引用 ​`KubeSchedulerConfiguration` ​文件将配置传递给调度器。

默认情况下此功能处于被禁用状态

### 调整 RequestedToCapacityRatioResourceAllocation 优先级函数 

​`shape` ​用于指定 ​`RequestedToCapacityRatioPriority` ​函数的行为。

`shape:  - utilization: 0    score: 0  - utilization: 100    score: 10`

上面的参数在 ​`utilization` ​为 0% 时给节点评分为 0，在 ​`utilization` ​为 100% 时给节点评分为 10，因此启用了装箱行为。 要启用最少请求（least requested）模式，必须按如下方式反转得分值。

 `shape:   - utilization: 0     score: 10   - utilization: 100     score: 0`

​`resources` ​是一个可选参数，默认情况下设置为：

`resources:   - name: cpu     weight: 1   - name: memory     weight: 1`

它可以用来添加扩展资源，如下所示：

`resources:   - name: intel.com/foo     weight: 5   - name: cpu     weight: 3   - name: memory     weight: 1`

weight 参数是可选的，如果未指定，则设置为 1。 同时，weight 不能设置为负值。

### 节点容量分配的评分 

本节适用于希望了解此功能的内部细节的人员。 以下是如何针对给定的一组值来计算节点得分的示例。

`请求的资源  intel.com/foo : 2 memory: 256MB cpu: 2  资源权重  intel.com/foo : 5 memory: 1 cpu: 3  FunctionShapePoint {{0, 0}, {100, 10}}  节点 Node 1 配置  可用：   intel.com/foo : 4   memory : 1 GB   cpu: 8  已用：   intel.com/foo: 1   memory: 256MB   cpu: 1  节点得分：  intel.com/foo  = resourceScoringFunction((2+1),4)                = (100 - ((4-3)*100/4)                = (100 - 25)                = 75                = rawScoringFunction(75)                = 7  memory         = resourceScoringFunction((256+256),1024)                = (100 -((1024-512)*100/1024))                = 50                = rawScoringFunction(50)                = 5  cpu            = resourceScoringFunction((2+1),8)                = (100 -((8-3)*100/8))                = 37.5                = rawScoringFunction(37.5)                = 3  NodeScore   =  (7 * 5) + (5 * 1) + (3 * 3) / (5 + 1 + 3)             =  5   节点 Node 2 配置  可用：   intel.com/foo: 8   memory: 1GB   cpu: 8  已用：   intel.com/foo: 2   memory: 512MB   cpu: 6  节点得分：  intel.com/foo  = resourceScoringFunction((2+2),8)                = (100 - ((8-4)*100/8)                = (100 - 50)                = 50                = rawScoringFunction(50)                = 5  memory         = resourceScoringFunction((256+512),1024)                = (100 -((1024-768)*100/1024))                = 75                = rawScoringFunction(75)                = 7  cpu            = resourceScoringFunction((2+6),8)                = (100 -((8-8)*100/8))                = 100                = rawScoringFunction(100)                = 10  NodeScore   =  (5 * 5) + (7 * 1) + (10 * 3) / (5 + 1 + 3)             =  7`

##  9.  Kubernetes 调度框架
调度框架
----

FEATURE STATE: Kubernetes 1.19 \[stable\]

调度框架是面向 Kubernetes 调度器的一种插件架构， 它为现有的调度器添加了一组新的“插件” API。插件会被编译到调度器之中。 这些 API 允许大多数调度功能以插件的形式实现，同时使调度“核心”保持简单且可维护。

框架工作流程
------

调度框架定义了一些扩展点。调度器插件注册后在一个或多个扩展点处被调用。 这些插件中的一些可以改变调度决策，而另一些仅用于提供信息。

每次调度一个 Pod 的尝试都分为两个阶段，即 调度周期 和 绑定周期。

调度周期和绑定周期
---------

调度周期为 Pod 选择一个节点，绑定周期将该决策应用于集群。 调度周期和绑定周期一起被称为“调度上下文”。

调度周期是串行运行的，而绑定周期可能是同时运行的。

如果确定 Pod 不可调度或者存在内部错误，则可以终止调度周期或绑定周期。 Pod 将返回队列并重试。

扩展点 
----

下图显示了一个 Pod 的调度上下文以及调度框架公开的扩展点。 在此图片中，“过滤器”等同于“断言”，“评分”相当于“优先级函数”。

一个插件可以在多个扩展点处注册，以执行更复杂或有状态的任务。

![](https://atts.w3cschool.cn/attachments/image/20220526/1653535012689507.png)  

### 队列排序

这些插件用于对调度队列中的 Pod 进行排序。 队列排序插件本质上提供 ​`less(Pod1, Pod2)`​ 函数。 一次只能启动一个队列插件。

### PreFilter

这些插件用于预处理 Pod 的相关信息，或者检查集群或 Pod 必须满足的某些条件。 如果 PreFilter 插件返回错误，则调度周期将终止。

### Filter

这些插件用于过滤出不能运行该 Pod 的节点。对于每个节点， 调度器将按照其配置顺序调用这些过滤插件。如果任何过滤插件将节点标记为不可行， 则不会为该节点调用剩下的过滤插件。节点可以被同时进行评估。

### PostFilter 

这些插件在 Filter 阶段后调用，但仅在该 Pod 没有可行的节点时调用。 插件按其配置的顺序调用。如果任何 PostFilter 插件标记节点为“Schedulable”， 则其余的插件不会调用。典型的 PostFilter 实现是抢占，试图通过抢占其他 Pod 的资源使该 Pod 可以调度。

### PreScore

这些插件用于执行 “前置评分（pre-scoring）” 工作，即生成一个可共享状态供 Score 插件使用。 如果 PreScore 插件返回错误，则调度周期将终止。

### Score 

这些插件用于对通过过滤阶段的节点进行排序。调度器将为每个节点调用每个评分插件。 将有一个定义明确的整数范围，代表最小和最大分数。 在标准化评分阶段之后，调度器将根据配置的插件权重 合并所有插件的节点分数。

### NormalizeScore 

这些插件用于在调度器计算 Node 排名之前修改分数。 在此扩展点注册的插件被调用时会使用同一插件的 Score 结果。 每个插件在每个调度周期调用一次。

例如，假设一个 ​`BlinkingLightScorer` ​插件基于具有的闪烁指示灯数量来对节点进行排名。

`func ScoreNode(_ *v1.pod, n *v1.Node) (int, error) {    return getBlinkingLightCount(n) }`

然而，最大的闪烁灯个数值可能比 ​`NodeScoreMax` ​小。要解决这个问题， ​`BlinkingLightScorer` ​插件还应该注册该扩展点。

`func NormalizeScores(scores map[string]int) {    highest := 0    for _, score := range scores {       highest = max(highest, score)    }    for node, score := range scores {       scores[node] = score*NodeScoreMax/highest    } }`

如果任何 NormalizeScore 插件返回错误，则调度阶段将终止。

> Note: 希望执行“预保留”工作的插件应该使用 NormalizeScore 扩展点。

### Reserve

Reserve 是一个信息性的扩展点。 管理运行时状态的插件（也成为“有状态插件”）应该使用此扩展点，以便 调度器在节点给指定 Pod 预留了资源时能够通知该插件。 这是在调度器真正将 Pod 绑定到节点之前发生的，并且它存在是为了防止 在调度器等待绑定成功时发生竞争情况。

这个是调度周期的最后一步。 一旦 Pod 处于保留状态，它将在绑定周期结束时触发 ​`Unreserve` ​插件 （失败时）或 ​`PostBind` ​插件（成功时）。

### Permit

Permit 插件在每个 Pod 调度周期的最后调用，用于防止或延迟 Pod 的绑定。 一个允许插件可以做以下三件事之一：

1.  批准

一旦所有 Permit 插件批准 Pod 后，该 Pod 将被发送以进行绑定。

3.  拒绝

如果任何 Permit 插件拒绝 Pod，则该 Pod 将被返回到调度队列。 这将触发​`Unreserve` ​插件。

5.  等待（带有超时）

如果一个 Permit 插件返回 “等待” 结果，则 Pod 将保持在一个内部的 “等待中” 的 Pod 列表，同时该 Pod 的绑定周期启动时即直接阻塞直到得到 批准。如果超时发生，等待 变成 拒绝，并且 Pod 将返回调度队列，从而触发 ​`Unreserve` ​插件。

> Note: 尽管任何插件可以访问 “等待中” 状态的 Pod 列表并批准它们 (查看 [FrameworkHandle](https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework target=))。 我们期望只有允许插件可以批准处于 “等待中” 状态的预留 Pod 的绑定。 一旦 Pod 被批准了，它将发送到 ​`PreBind` ​阶段。

### PreBind 

这些插件用于执行 Pod 绑定前所需的所有工作。 例如，一个 PreBind 插件可能需要制备网络卷并且在允许 Pod 运行在该节点之前 将其挂载到目标节点上。

如果任何 PreBind 插件返回错误，则 Pod 将被 拒绝 并且 退回到调度队列中。

### Bind

Bind 插件用于将 Pod 绑定到节点上。直到所有的 PreBind 插件都完成，Bind 插件才会被调用。 各 Bind 插件按照配置顺序被调用。Bind 插件可以选择是否处理指定的 Pod。 如果某 Bind 插件选择处理某 Pod，剩余的 Bind 插件将被跳过。

### PostBind 

这是个信息性的扩展点。 PostBind 插件在 Pod 成功绑定后被调用。这是绑定周期的结尾，可用于清理相关的资源。

### Unreserve

这是个信息性的扩展点。 如果 Pod 被保留，然后在后面的阶段中被拒绝，则 Unreserve 插件将被通知。 Unreserve 插件应该清楚保留 Pod 的相关状态。

使用此扩展点的插件通常也使用 Reserve。

插件 API 
-------

插件 API 分为两个步骤。首先，插件必须完成注册并配置，然后才能使用扩展点接口。 扩展点接口具有以下形式。

`type Plugin interface {    Name() string }  type QueueSortPlugin interface {    Plugin    Less(*v1.pod, *v1.pod) bool }  type PreFilterPlugin interface {    Plugin    PreFilter(context.Context, *framework.CycleState, *v1.pod) error }  // ...`

插件配置
----

你可以在调度器配置中启用或禁用插件。 如果你在使用 Kubernetes v1.18 或更高版本，大部分调度 插件 都在使用中且默认启用。

除了默认的插件，你还可以实现自己的调度插件并且将它们与默认插件一起配置。 你可以访问 [scheduler-plugins](https://github.com/kubernetes-sigs/scheduler-plugins) 了解更多信息。

如果你正在使用 Kubernetes v1.18 或更高版本，你可以将一组插件设置为 一个调度器配置文件，然后定义不同的配置文件来满足各类工作负载。

##  10.  Kubernetes 调度器性能调优
调度器性能调优
-------

FEATURE STATE: Kubernetes 1.14 \[beta\]

作为 kubernetes 集群的默认调度器， ​`kube-scheduler`​ 主要负责将 Pod 调度到集群的 Node 上。

在一个集群中，满足一个 Pod 调度请求的所有 Node 称之为 可调度 Node。 调度器先在集群中找到一个 Pod 的可调度 Node，然后根据一系列函数对这些可调度 Node 打分， 之后选出其中得分最高的 Node 来运行 Pod。 最后，调度器将这个调度决定告知 kube-apiserver，这个过程叫做 绑定（Binding）。

这篇文章将会介绍一些在大规模 Kubernetes 集群下调度器性能优化的方式。

在大规模集群中，你可以调节调度器的表现来平衡调度的延迟（新 Pod 快速就位） 和精度（调度器很少做出糟糕的放置决策）。

你可以通过设置 kube-scheduler 的 ​`percentageOfNodesToScore` ​来配置这个调优设置。 这个 KubeSchedulerConfiguration 设置决定了调度集群中节点的阈值。

### 设置阈值

​`percentageOfNodesToScore` ​选项接受从 0 到 100 之间的整数值。 0 值比较特殊，表示 kube-scheduler 应该使用其编译后的默认值。 如果你设置 ​`percentageOfNodesToScore` ​的值超过了 100， kube-scheduler 的表现等价于设置值为 100。

要修改这个值，先编辑 kube-scheduler 的配置文件 然后重启调度器。 大多数情况下，这个配置文件是 ​`/etc/kubernetes/config/kube-scheduler.yaml`​。

修改完成后，你可以执行

`kubectl get pods -n kube-system | grep kube-scheduler`

来检查该 kube-scheduler 组件是否健康。

节点打分阈值
------

要提升调度性能，kube-scheduler 可以在找到足够的可调度节点之后停止查找。 在大规模集群中，比起考虑每个节点的简单方法相比可以节省时间。

你可以使用整个集群节点总数的百分比作为阈值来指定需要多少节点就足够。 kube-scheduler 会将它转换为节点数的整数值。在调度期间，如果 kube-scheduler 已确认的可调度节点数足以超过了配置的百分比数量， kube-scheduler 将停止继续查找可调度节点并继续进行 打分阶段。

### 默认阈值

如果你不指定阈值，Kubernetes 使用线性公式计算出一个比例，在 100-节点集群 下取 50%，在 5000-节点的集群下取 10%。这个自动设置的参数的最低值是 5%。

这意味着，调度器至少会对集群中 5% 的节点进行打分，除非用户将该参数设置的低于 5。

如果你想让调度器对集群内所有节点进行打分，则将 ​`percentageOfNodesToScore` ​设置为 100。

示例
--

下面就是一个将 ​`percentageOfNodesToScore` ​参数设置为 50% 的例子。

`apiVersion: kubescheduler.config.k8s.io/v1alpha1 kind: KubeSchedulerConfiguration algorithmSource:   provider: DefaultProvider  ...  percentageOfNodesToScore: 50`

### 调节 percentageOfNodesToScore 参数 

​`percentageOfNodesToScore` ​的值必须在 1 到 100 之间，而且其默认值是通过集群的规模计算得来的。 另外，还有一个 50 个 Node 的最小值是硬编码在程序中。

值得注意的是，该参数设置后可能会导致只有集群中少数节点被选为可调度节点， 很多节点都没有进入到打分阶段。这样就会造成一种后果， 一个本来可以在打分阶段得分很高的节点甚至都不能进入打分阶段。

由于这个原因，这个参数不应该被设置成一个很低的值。 通常的做法是不会将这个参数的值设置的低于 10。 很低的参数值一般在调度器的吞吐量很高且对节点的打分不重要的情况下才使用。 换句话说，只有当你更倾向于在可调度节点中任意选择一个节点来运行这个 Pod 时， 才使用很低的参数设置。

### 调度器做调度选择的时候如何覆盖所有的 Node

如果你想要理解这一个特性的内部细节，那么请仔细阅读这一章节。

在将 Pod 调度到节点上时，为了让集群中所有节点都有公平的机会去运行这些 Pod， 调度器将会以轮询的方式覆盖全部的 Node。 你可以将 Node 列表想象成一个数组。调度器从数组的头部开始筛选可调度节点， 依次向后直到可调度节点的数量达到 ​`percentageOfNodesToScore` ​参数的要求。 在对下一个 Pod 进行调度的时候，前一个 Pod 调度筛选停止的 Node 列表的位置， 将会来作为这次调度筛选 Node 开始的位置。

如果集群中的 Node 在多个区域，那么调度器将从不同的区域中轮询 Node， 来确保不同区域的 Node 接受可调度性检查。如下例，考虑两个区域中的六个节点：

`Zone 1: Node 1, Node 2, Node 3, Node 4 Zone 2: Node 5, Node 6`

调度器将会按照如下的顺序去评估 Node 的可调度性：

`Node 1, Node 5, Node 2, Node 6, Node 3, Node 4`

在评估完所有 Node 后，将会返回到 Node 1，从头开始。

#  15.  Kubernetes 集群管理

##  1.  Kubernetes 管理资源
管理资源
----

你已经部署了应用并通过服务暴露它。然后呢？ Kubernetes 提供了一些工具来帮助管理你的应用部署，包括扩缩容和更新。 我们将更深入讨论的特性包括 配置文件和 标签。

组织资源配置 
-------

许多应用需要创建多个资源，例如 Deployment 和 Service。 可以通过将多个资源组合在同一个文件中（在 YAML 中以 ​`---`​ 分隔） 来简化对它们的管理。例如：

`apiVersion: v1 kind: Service metadata:   name: my-nginx-svc   labels:     app: nginx spec:   type: LoadBalancer   ports:   - port: 80   selector:     app: nginx --- apiVersion: apps/v1 kind: Deployment metadata:   name: my-nginx   labels:     app: nginx spec:   replicas: 3   selector:     matchLabels:       app: nginx   template:     metadata:       labels:         app: nginx     spec:       containers:       - name: nginx         image: nginx:1.14.2         ports:         - containerPort: 80`

可以用创建单个资源相同的方式来创建多个资源：

`kubectl apply -f https://k8s.io/examples/application/nginx-app.yaml`

`service/my-nginx-svc created deployment.apps/my-nginx created`

资源将按照它们在文件中的顺序创建。 因此，最好先指定服务，这样在控制器（例如 Deployment）创建 Pod 时能够 确保调度器可以将与服务关联的多个 Pod 分散到不同节点。

​`kubectl create`​ 也接受多个 ​`-f`​ 参数:

`kubectl apply -f https://k8s.io/examples/application/nginx/nginx-svc.yaml -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml`

还可以指定目录路径，而不用添加多个单独的文件：

`kubectl apply -f https://k8s.io/examples/application/nginx/`

​`kubectl` ​将读取任何后缀为 ​`.yaml`​、​`.yml`​ 或者 ​`.json`​ 的文件。

建议的做法是，将同一个微服务或同一应用层相关的资源放到同一个文件中， 将同一个应用相关的所有文件按组存放到同一个目录中。 如果应用的各层使用 DNS 相互绑定，那么你可以将堆栈的所有组件一起部署。

还可以使用 URL 作为配置源，便于直接使用已经提交到 Github 上的配置文件进行部署：

`kubectl apply -f https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/nginx/nginx-deployment.yaml`

`deployment.apps/my-nginx created`

kubectl 中的批量操作
--------------

资源创建并不是 ​`kubectl` ​可以批量执行的唯一操作。 ​`kubectl` ​还可以从配置文件中提取资源名，以便执行其他操作， 特别是删除你之前创建的资源：

`kubectl delete -f https://k8s.io/examples/application/nginx-app.yaml`

`deployment.apps "my-nginx" deleted service "my-nginx-svc" deleted`

在仅有两种资源的情况下，可以使用"资源类型/资源名"的语法在命令行中 同时指定这两个资源：

`kubectl delete deployments/my-nginx services/my-nginx-svc`

对于资源数目较大的情况，你会发现使用 ​`-l`​ 或 ​`--selector`​ 指定筛选器（标签查询）能很容易根据标签筛选资源：

`kubectl delete deployment,services -l app=nginx`

`deployment.apps "my-nginx" deleted service "my-nginx-svc" deleted`

由于 ​`kubectl` ​用来输出资源名称的语法与其所接受的资源名称语法相同， 你可以使用 ​`$()`​ 或 ​`xargs` ​进行链式操作：

`kubectl get $(kubectl create -f docs/concepts/cluster-administration/nginx/ -o name | grep service) kubectl create -f docs/concepts/cluster-administration/nginx/ -o name | grep service | xargs -i kubectl get {}`

`NAME           TYPE           CLUSTER-IP   EXTERNAL-IP   PORT(S)      AGE my-nginx-svc   LoadBalancer   10.0.0.208   <pending>     80/TCP       0s`

上面的命令中，我们首先使用 ​`examples/application/nginx/`​ 下的配置文件创建资源， 并使用 ​`-o name`​ 的输出格式（以"资源/名称"的形式打印每个资源）打印所创建的资源。 然后，我们通过 ​`grep` ​来过滤 "service"，最后再打印 ​`kubectl get`​ 的内容。

如果你碰巧在某个路径下的多个子路径中组织资源，那么也可以递归地在所有子路径上 执行操作，方法是在 ​`--filename,-f`​ 后面指定 ​`--recursive`​ 或者 ​`-R`​。

例如，假设有一个目录路径为 ​`project/k8s/development`​，它保存开发环境所需的 所有清单，并按资源类型组织：

`project/k8s/development ├── configmap │   └── my-configmap.yaml ├── deployment │   └── my-deployment.yaml └── pvc     └── my-pvc.yaml`

默认情况下，对 ​`project/k8s/development`​ 执行的批量操作将停止在目录的第一级， 而不是处理所有子目录。 如果我们试图使用以下命令在此目录中创建资源，则会遇到一个错误：

`kubectl apply -f project/k8s/development`

`error: you must provide one or more resources by argument or filename (.json|.yaml|.yml|stdin)`

正确的做法是，在 ​`--filename,-f`​ 后面标明 ​`--recursive`​ 或者 ​`-R`​ 之后：

`kubectl apply -f project/k8s/development --recursive`

`configmap/my-config created deployment.apps/my-deployment created persistentvolumeclaim/my-pvc created`

​`--recursive`​ 可以用于接受 ​`--filename,-f`​ 参数的任何操作，例如： ​`kubectl {create,get,delete,describe,rollout}`​ 等。

有多个 ​`-f`​ 参数出现的时候，​`--recursive`​ 参数也能正常工作：

`kubectl apply -f project/k8s/namespaces -f project/k8s/development --recursive`

`namespace/development created namespace/staging created configmap/my-config created deployment.apps/my-deployment created persistentvolumeclaim/my-pvc created`

有效地使用标签
-------

到目前为止我们使用的示例中的资源最多使用了一个标签。 在许多情况下，应使用多个标签来区分集合。

例如，不同的应用可能会为 ​`app` ​标签设置不同的值。 但是，类似 [guestbook 示例](https://github.com/kubernetes/examples/tree/master/guestbook/) 这样的多层应用，还需要区分每一层。前端可以带以下标签：

     `labels:         app: guestbook         tier: frontend`

Redis 的主节点和从节点会有不同的 ​`tier` ​标签，甚至还有一个额外的 ​`role` ​标签：

     `labels:         app: guestbook         tier: backend         role: master`

以及

     `labels:         app: guestbook         tier: backend         role: slave`

标签允许我们按照标签指定的任何维度对我们的资源进行切片和切块：

`kubectl apply -f examples/guestbook/all-in-one/guestbook-all-in-one.yaml kubectl get pods -Lapp -Ltier -Lrole`

`NAME                           READY     STATUS    RESTARTS   AGE       APP         TIER       ROLE guestbook-fe-4nlpb             1/1       Running   0          1m        guestbook   frontend   <none> guestbook-fe-ght6d             1/1       Running   0          1m        guestbook   frontend   <none> guestbook-fe-jpy62             1/1       Running   0          1m        guestbook   frontend   <none> guestbook-redis-master-5pg3b   1/1       Running   0          1m        guestbook   backend    master guestbook-redis-slave-2q2yf    1/1       Running   0          1m        guestbook   backend    slave guestbook-redis-slave-qgazl    1/1       Running   0          1m        guestbook   backend    slave my-nginx-divi2                 1/1       Running   0          29m       nginx       <none>     <none> my-nginx-o0ef1                 1/1       Running   0          29m       nginx       <none>     <none>`

`kubectl get pods -lapp=guestbook,role=slave`

`NAME                          READY     STATUS    RESTARTS   AGE guestbook-redis-slave-2q2yf   1/1       Running   0          3m guestbook-redis-slave-qgazl   1/1       Running   0          3m`

金丝雀部署（Canary Deployments） 
--------------------------

另一个需要多标签的场景是用来区分同一组件的不同版本或者不同配置的多个部署。 常见的做法是部署一个使用金丝雀发布来部署新应用版本 （在 Pod 模板中通过镜像标签指定），保持新旧版本应用同时运行。 这样，新版本在完全发布之前也可以接收实时的生产流量。

例如，你可以使用 ​`track` ​标签来区分不同的版本。

主要稳定的发行版将有一个 ​`track` ​标签，其值为 ​`stable`​：

     `name: frontend      replicas: 3      ...      labels:         app: guestbook         tier: frontend         track: stable      ...      image: gb-frontend:v3`

然后，你可以创建 guestbook 前端的新版本，让这些版本的 ​`track` ​标签带有不同的值 （即 ​`canary`​），以便两组 Pod 不会重叠：

     `name: frontend-canary      replicas: 1      ...      labels:         app: guestbook         tier: frontend         track: canary      ...      image: gb-frontend:v4`

前端服务通过选择标签的公共子集（即忽略 ​`track` ​标签）来覆盖两组副本， 以便流量可以转发到两个应用：

  `selector:      app: guestbook      tier: frontend`

你可以调整 ​`stable` ​和 ​`canary` ​版本的副本数量，以确定每个版本将接收 实时生产流量的比例（在本例中为 3:1）。 一旦有信心，你就可以将新版本应用的 ​`track` ​标签的值从 ​`canary` ​替换为 ​`stable`​，并且将老版本应用删除。

想要了解更具体的示例，请查看 [Ghost 部署教程](https://github.com/kelseyhightower/talks/tree/master/kubecon-eu-2016/demo target=)。

更新标签 
-----

有时，现有的 pod 和其它资源需要在创建新资源之前重新标记。 这可以用 ​`kubectl label`​ 完成。 例如，如果想要将所有 nginx pod 标记为前端层，运行：

`kubectl label pods -l app=nginx tier=fe`

`pod/my-nginx-2035384211-j5fhi labeled pod/my-nginx-2035384211-u2c7e labeled pod/my-nginx-2035384211-u3t6x labeled`

首先用标签 "app=nginx" 过滤所有的 Pod，然后用 "tier=fe" 标记它们。 想要查看你刚才标记的 Pod，请运行：

`kubectl get pods -l app=nginx -L tier`

`NAME                        READY     STATUS    RESTARTS   AGE       TIER my-nginx-2035384211-j5fhi   1/1       Running   0          23m       fe my-nginx-2035384211-u2c7e   1/1       Running   0          23m       fe my-nginx-2035384211-u3t6x   1/1       Running   0          23m       fe`

这将输出所有 "app=nginx" 的 Pod，并有一个额外的描述 Pod 的 tier 的标签列 （用参数 ​`-L`​ 或者 ​`--label-columns`​ 标明）。

更新注解 
-----

有时，你可能希望将注解附加到资源中。注解是 API 客户端（如工具、库等） 用于检索的任意非标识元数据。这可以通过 ​`kubectl annotate`​ 来完成。例如：

`kubectl annotate pods my-nginx-v4-9gw19 description='my frontend running nginx' kubectl get pods my-nginx-v4-9gw19 -o yaml`

`apiVersion: v1 kind: pod metadata:   annotations:     description: my frontend running nginx ...`

扩缩你的应用
------

当应用上的负载增长或收缩时，使用 ​`kubectl` ​能够实现应用规模的扩缩。 例如，要将 nginx 副本的数量从 3 减少到 1，请执行以下操作：

`kubectl scale deployment/my-nginx --replicas=1`

`deployment.extensions/my-nginx scaled`

现在，你的 Deployment 管理的 Pod 只有一个了。

`kubectl get pods -l app=nginx`

`NAME                        READY     STATUS    RESTARTS   AGE my-nginx-2035384211-j5fhi   1/1       Running   0          30m`

想要让系统自动选择需要 nginx 副本的数量，范围从 1 到 3，请执行以下操作：

`kubectl autoscale deployment/my-nginx --min=1 --max=3`

`horizontalpodautoscaler.autoscaling/my-nginx autoscaled`

就地更新资源 
-------

有时，有必要对你所创建的资源进行小范围、无干扰地更新。

### kubectl apply

建议在源代码管理中维护一组配置文件 （参见[配置即代码](https://martinfowler.com/bliki/InfrastructureAsCode.html)）， 这样，它们就可以和应用代码一样进行维护和版本管理。 然后，你可以用 ​`[kubectl apply](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=)`​ 将配置变更应用到集群中。

这个命令将会把推送的版本与以前的版本进行比较，并应用你所做的更改， 但是不会自动覆盖任何你没有指定更改的属性。

`kubectl apply -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml deployment.apps/my-nginx configured`

注意，​`kubectl apply`​ 将为资源增加一个额外的注解，以确定自上次调用以来对配置的更改。 执行时，​`kubectl apply`​ 会在以前的配置、提供的输入和资源的当前配置之间 找出三方差异，以确定如何修改资源。

目前，新创建的资源是没有这个注解的，所以，第一次调用 ​`kubectl apply`​ 时 将使用提供的输入和资源的当前配置双方之间差异进行比较。 在第一次调用期间，它无法检测资源创建时属性集的删除情况。 因此，kubectl 不会删除它们。

所有后续的 ​`kubectl apply`​ 操作以及其他修改配置的命令，如 ​`kubectl replace`​ 和 ​`kubectl edit`​，都将更新注解，并允许随后调用的 ​`kubectl apply`​ 使用三方差异进行检查和执行删除。

> Note: 想要使用 apply，请始终使用 ​`kubectl apply`​ 或 ​`kubectl create --save-config`​ 创建资源。

### kubectl edit

或者，你也可以使用 ​`kubectl edit`​ 更新资源：

`kubectl edit deployment/my-nginx`

这相当于首先 ​`get` ​资源，在文本编辑器中编辑它，然后用更新的版本 ​`apply` ​资源：

`kubectl get deployment my-nginx -o yaml > /tmp/nginx.yaml vi /tmp/nginx.yaml # do some edit, and then save the file  kubectl apply -f /tmp/nginx.yaml deployment.apps/my-nginx configured  rm /tmp/nginx.yaml`

这使你可以更加容易地进行更重大的更改。 请注意，可以使用 ​`EDITOR` ​或 ​`KUBE_EDITOR` ​环境变量来指定编辑器。

想要了解更多信息，请参考 [kubectl edit](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=) 文档。

### kubectl patch

你可以使用 ​`kubectl patch`​ 来更新 API 对象。此命令支持 JSON patch、 JSON merge patch、以及 strategic merge patch。

破坏性的更新 
-------

在某些情况下，你可能需要更新某些初始化后无法更新的资源字段，或者你可能只想立即进行递归更改， 例如修复 Deployment 创建的不正常的 Pod。若要更改这些字段，请使用 ​`replace --force`​， 它将删除并重新创建资源。在这种情况下，你可以修改原始配置文件：

`kubectl replace -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml --force`

`deployment.apps/my-nginx deleted deployment.apps/my-nginx replaced`

在不中断服务的情况下更新应用
--------------

在某些时候，你最终需要更新已部署的应用，通常都是通过指定新的镜像或镜像标签， 如上面的金丝雀发布的场景中所示。​`kubectl` ​支持几种更新操作， 每种更新操作都适用于不同的场景。

我们将指导你通过 Deployment 如何创建和更新应用。

假设你正运行的是 1.14.2 版本的 nginx：

`kubectl create deployment my-nginx --image=nginx:1.14.2`

`deployment.apps/my-nginx created`

要更新到 1.16.1 版本，只需使用我们前面学到的 kubectl 命令将 ​`.spec.template.spec.containers[0].image`​ 从 ​`nginx:1.14.2`​ 修改为 ​`nginx:1.16.1`​。

`kubectl edit deployment/my-nginx`

没错，就是这样！Deployment 将在后台逐步更新已经部署的 nginx 应用。 它确保在更新过程中，只有一定数量的旧副本被开闭，并且只有一定基于所需 Pod 数量的新副本被创建。

##  2.  Kubernetes 集群网络系统
集群网络系统
------

集群网络系统是 Kubernetes 的核心部分，但是想要准确了解它的工作原理可是个不小的挑战。 下面列出的是网络系统的的四个主要问题：

1.  高度耦合的容器间通信：这个已经被 Pods 和 ​`localhost` ​通信解决了。
2.  Pod 间通信：这个是本文档的重点要讲述的。
3.  Pod 和服务间通信：这个已经在[服务](https://www.w3cschool.cn/kubernetes/kubernetes-oek63nwj.html?RECACHE=1)里讲述过了。
4.  外部和服务间通信：这也已经在[服务](https://www.w3cschool.cn/kubernetes/kubernetes-oek63nwj.html?RECACHE=1)讲述过了。

Kubernetes 的宗旨就是在应用之间共享机器。 通常来说，共享机器需要两个应用之间不能使用相同的端口，但是在多个应用开发者之间 去大规模地协调端口是件很困难的事情，尤其是还要让用户暴露在他们控制范围之外的集群级别的问题上。

动态分配端口也会给系统带来很多复杂度 - 每个应用都需要设置一个端口的参数， 而 API 服务器还需要知道如何将动态端口数值插入到配置模块中，服务也需要知道如何找到对方等等。 与其去解决这些问题，Kubernetes 选择了其他不同的方法。

如何实现 Kubernetes 的网络模型 
----------------------

有很多种方式可以实现这种网络模型，本文档并不是对各种实现技术的详细研究， 但是希望可以作为对各种技术的详细介绍，并且成为你研究的起点。

接下来的网络技术是按照首字母排序，顺序本身并无其他意义。

### ACI

[Cisco Application Centric Infrastructure](https://www.cisco.com/c/en/us/solutions/data-center-virtualization/application-centric-infrastructure/index.html) 提供了一个集成覆盖网络和底层 SDN 的解决方案来支持容器、虚拟机和其他裸机服务器。 [ACI](https://github.com/noironetworks/aci-containers) 为 ACI 提供了容器网络集成。 点击[这里](https://www.cisco.com/c/dam/en/us/solutions/collateral/data-center-virtualization/application-centric-infrastructure/solution-overview-c22-739493.pdf)查看概述。

### Antrea

[Antrea](https://github.com/antrea-io/antrea) 项目是一个开源的联网解决方案，旨在成为 Kubernetes 原生的网络解决方案。它利用 Open vSwitch 作为网络数据平面。 Open vSwitch 是一个高性能可编程的虚拟交换机，支持 Linux 和 Windows 平台。 Open vSwitch 使 Antrea 能够以高性能和高效的方式实现 Kubernetes 的网络策略。 借助 Open vSwitch 可编程的特性，Antrea 能够在 Open vSwitch 之上实现广泛的联网、安全功能和服务。

### Kubernetes 的 AWS VPC CNI

[AWS VPC CNI](https://github.com/aws/amazon-vpc-cni-k8s) 为 Kubernetes 集群提供了集成的 AWS 虚拟私有云（VPC）网络。该 CNI 插件提供了高吞吐量和可用性，低延迟以及最小的网络抖动。 此外，用户可以使用现有的 AWS VPC 网络和安全最佳实践来构建 Kubernetes 集群。 这包括使用 VPC 流日志、VPC 路由策略和安全组进行网络流量隔离的功能。

使用该 CNI 插件，可使 Kubernetes Pod 拥有与在 VPC 网络上相同的 IP 地址。 CNI 将 AWS 弹性网络接口（ENI）分配给每个 Kubernetes 节点，并将每个 ENI 的辅助 IP 范围用于该节点上的 Pod 。 CNI 包含用于 ENI 和 IP 地址的预分配的控件，以便加快 Pod 的启动时间，并且能够支持多达 2000 个节点的大型集群。

此外，CNI 可以与 [用于执行网络策略的 Calico](https://docs.aws.amazon.com/eks/latest/userguide/calico.html) 一起运行。 AWS VPC CNI 项目是开源的，请查看 [GitHub 上的文档](https://github.com/aws/amazon-vpc-cni-k8s)。

### Kubernetes 的 Azure CNI

[Azure CNI](https://docs.microsoft.com/en-us/azure/virtual-network/container-networking-overview) 是一个[开源插件](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md)， 将 Kubernetes Pods 和 Azure 虚拟网络（也称为 VNet）集成在一起，可提供与 VM 相当的网络性能。 Pod 可以通过 Express Route 或者 站点到站点的 VPN 来连接到对等的 VNet ， 也可以从这些网络来直接访问 Pod。Pod 可以访问受服务端点或者受保护链接的 Azure 服务，比如存储和 SQL。 你可以使用 VNet 安全策略和路由来筛选 Pod 流量。 该插件通过利用在 Kubernetes 节点的网络接口上预分配的辅助 IP 池将 VNet 分配给 Pod 。

Azure CNI 可以在 [Azure Kubernetes Service (AKS)](https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni) 中获得。

### Calico

[Calico](https://projectcalico.docs.tigera.io/about/about-calico) 是一个开源的联网及网络安全方案， 用于基于容器、虚拟机和本地主机的工作负载。 Calico 支持多个数据面，包括：纯 Linux eBPF 的数据面、标准的 Linux 联网数据面 以及 Windows HNS 数据面。Calico 在提供完整的联网堆栈的同时，还可与 [云驱动 CNIs](https://docs.projectcalico.org/networking/determine-best-networking target=) 联合使用，以保证网络策略实施。

### Cilium 

[Cilium](https://github.com/cilium/cilium) 是一个开源软件，用于提供并透明保护应用容器间的网络连接。 Cilium 支持 L7/HTTP，可以在 L3-L7 上通过使用与网络分离的基于身份的安全模型寻址来实施网络策略， 并且可以与其他 CNI 插件结合使用。

### 华为的 CNI-Genie

[CNI-Genie](https://github.com/cni-genie/CNI-Genie) 是一个 CNI 插件， 可以让 Kubernetes 在运行时使用不同的网络模型的 [实现同时被访问](https://github.com/cni-genie/CNI-Genie/blob/master/docs/multiple-cni-plugins/README.md target=)。 这包括以 [CNI 插件](https://github.com/containernetworking/cni target=)运行的任何实现，比如 [Flannel](https://github.com/flannel-io/flannel target=)、 [Calico](https://projectcalico.docs.tigera.io/about/about-calico)、 [Weave-net](https://www.weave.works/oss/net/)。

CNI-Genie 还支持[将多个 IP 地址分配给 Pod](https://github.com/cni-genie/CNI-Genie/blob/master/docs/multiple-ips/README.md target=)， 每个都来自不同的 CNI 插件。

### cni-ipvlan-vpc-k8s

[cni-ipvlan-vpc-k8s](https://github.com/lyft/cni-ipvlan-vpc-k8s) 包含了一组 CNI 和 IPAM 插件来提供一个简单的、本地主机、低延迟、高吞吐量 以及通过使用 Amazon 弹性网络接口（ENI）并使用 Linux 内核的 IPv2 驱动程序 以 L2 模式将 AWS 管理的 IP 绑定到 Pod 中， 在 Amazon Virtual Private Cloud（VPC）环境中为 Kubernetes 兼容的网络堆栈。

这些插件旨在直接在 VPC 中进行配置和部署，Kubelets 先启动， 然后根据需要进行自我配置和扩展它们的 IP 使用率，而无需经常建议复杂的管理 覆盖网络、BGP、禁用源/目标检查或调整 VPC 路由表以向每个主机提供每个实例子网的 复杂性（每个 VPC 限制为50-100个条目）。 简而言之，cni-ipvlan-vpc-k8s 大大降低了在 AWS 中大规模部署 Kubernetes 所需的网络复杂性。

### Coil

[Coil](https://github.com/cybozu-go/coil) 是一个为易于集成、提供灵活的出站流量网络而设计的 CNI 插件。 与裸机相比，Coil 的额外操作开销低，并允许针对外部网络的出站流量任意定义 NAT 网关。

### Contiv-VPP

[Contiv-VPP](https://contivpp.io/) 是用于 Kubernetes 的用户空间、面向性能的网络插件，使用 [fd.io](https://fd.io/) 数据平面。

### Contrail/Tungsten Fabric

[Contrail](https://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/) 是基于 [Tungsten Fabric](https://tungsten.io/) 的，真正开放的多云网络虚拟化和策略管理平台。 Contrail 和 Tungsten Fabric 与各种编排系统集成在一起，例如 Kubernetes、OpenShift、OpenStack 和 Mesos， 并为虚拟机、容器或 Pods 以及裸机工作负载提供了不同的隔离模式。

### DANM

[DANM](https://github.com/nokia/danm) 是一个针对在 Kubernetes 集群中运行的电信工作负载的网络解决方案。 它由以下几个组件构成：

*   能够配置具有高级功能的 IPVLAN 接口的 CNI 插件
*   一个内置的 IPAM 模块，能够管理多个、集群内的、不连续的 L3 网络，并按请求提供动态、静态或无 IP 分配方案
*   CNI 元插件能够通过自己的 CNI 或通过将任务授权给其他任何流行的 CNI 解决方案（例如 SRI-OV 或 Flannel）来实现将多个网络接口连接到容器
*   Kubernetes 控制器能够集中管理所有 Kubernetes 主机的 VxLAN 和 VLAN 接口
*   另一个 Kubernetes 控制器扩展了 Kubernetes 的基于服务的服务发现概念，以在 Pod 的所有网络接口上工作

通过这个工具集，DANM 可以提供多个分离的网络接口，可以为 Pod 使用不同的网络后端和高级 IPAM 功能。

### Flannel

[Flannel](https://github.com/flannel-io/flannel target=) 是一个非常简单的能够满足 Kubernetes 所需要的覆盖网络。已经有许多人报告了使用 Flannel 和 Kubernetes 的成功案例。

### Hybridnet 

[Hybridnet](https://github.com/alibaba/hybridnet) 是一个为混合云设计的开源 CNI 插件， 它为一个或多个集群中的容器提供覆盖和底层网络。 Overlay 和 underlay 容器可以在同一个节点上运行， 并具有集群范围的双向网络连接。

### Jaguar

[Jaguar](https://gitlab.com/sdnlab/jaguar) 是一个基于 OpenDaylight 的 Kubernetes 网络开源解决方案。 Jaguar 使用 vxlan 提供覆盖网络，而 Jaguar CNIPlugin 为每个 Pod 提供一个 IP 地址。

### k-vswitch 

[k-vswitch](https://github.com/k-vswitch/k-vswitch) 是一个基于 [Open vSwitch](https://www.openvswitch.org/) 的简易 Kubernetes 网络插件。 它利用 Open vSwitch 中现有的功能来提供强大的网络插件，该插件易于操作，高效且安全。

### Knitter

[Knitter](https://github.com/ZTE/Knitter/) 是一个支持 Kubernetes 中实现多个网络系统的解决方案。 它提供了租户管理和网络管理的功能。除了多个网络平面外，Knitter 还包括一组端到端的 NFV 容器网络解决方案， 例如为应用程序保留 IP 地址、IP 地址迁移等。

### Kube-OVN

[Kube-OVN](https://github.com/kubeovn/kube-ovn) 是一个基于 OVN 的用于企业的 Kubernetes 网络架构。 借助于 OVN/OVS ，它提供了一些高级覆盖网络功能，例如子网、QoS、静态 IP 分配、流量镜像、网关、 基于 openflow 的网络策略和服务代理。

### Kube-router 

[Kube-router](https://github.com/cloudnativelabs/kube-router) 是 Kubernetes 的专用网络解决方案， 旨在提供高性能和易操作性。 Kube-router 提供了一个基于 Linux LVS/IPVS 的服务代理、一个基于 Linux 内核转发的无覆盖 Pod-to-Pod 网络解决方案和基于 iptables/ipset 的网络策略执行器。

### L2 networks and linux bridging

如果你具有一个“哑”的L2网络，例如“裸机”环境中的简单交换机，则应该能够执行与上述 GCE 设置类似的操作。 请注意，这些说明仅是非常简单的尝试过-似乎可行，但尚未经过全面测试。 如果你使用此技术并完善了流程，请告诉我们。

根据 Lars Kellogg-Stedman 的这份非常不错的“Linux 网桥设备” [使用说明](https://blog.oddbit.com/post/2014-08-11-four-ways-to-connect-a-docker/)来进行操作。

### Multus (a Multi Network plugin)

Multus 是一个多 CNI 插件， 使用 Kubernetes 中基于 CRD 的网络对象来支持实现 Kubernetes 多网络系统。

Multus 支持所有[参考插件](https://github.com/containernetworking/plugins)（比如： [Flannel](https://github.com/containernetworking/cni.dev/blob/main/content/plugins/v0.9/meta/flannel.md)、 [DHCP](https://github.com/containernetworking/plugins/tree/main/plugins/ipam/dhcp)、 [Macvlan](https://github.com/containernetworking/plugins/tree/main/plugins/main/macvlan) ） 来实现 CNI 规范和第三方插件（比如： [Calico](https://github.com/projectcalico/cni-plugin)、 [Weave](https://github.com/weaveworks/weave)、 [Cilium](https://github.com/cilium/cilium)、 [Contiv](https://github.com/contiv/netplugin)）。 除此之外， Multus 还支持 [SRIOV](https://github.com/hustcat/sriov-cni)、 [DPDK](https://github.com/k8snetworkplumbingwg/sriov-cni)、 [OVS-DPDK & VPP](https://github.com/intel/userspace-cni-network-plugin) 的工作负载， 以及 Kubernetes 中基于云的本机应用程序和基于 NFV 的应用程序。

### NSX-T

[VMware NSX-T](https://docs.vmware.com/cn/VMware-NSX-T-Data-Center/index.html) 是一个网络虚拟化和安全平台。 NSX-T 可以为多云及多系统管理程序环境提供网络虚拟化，并专注于具有异构端点和技术堆栈的新兴应用程序框架和体系结构。 除了 vSphere 管理程序之外，这些环境还包括其他虚拟机管理程序，例如 KVM、容器和裸机。

[NSX-T Container Plug-in (NCP)](https://docs.vmware.com/en/VMware-NSX-T/2.0/nsxt_20_ncp_kubernetes.pdf) 提供了 NSX-T 与容器协调器（例如 Kubernetes）之间的结合， 以及 NSX-T 与基于容器的 CaaS/PaaS 平台（例如 Pivotal Container Service（PKS）和 OpenShift）之间的集成。

### OVN (开放式虚拟网络)

OVN 是一个由 Open vSwitch 社区开发的开源的网络虚拟化解决方案。 它允许创建逻辑交换器、逻辑路由、状态 ACL、负载均衡等等来建立不同的虚拟网络拓扑。 该项目有一个特定的Kubernetes插件和文档 [ovn-kubernetes](https://github.com/openvswitch/ovn-kubernetes)。

### Weaveworks 的 Weave Net

[Weave Net](https://www.weave.works/oss/net/) 是 Kubernetes 及其 托管应用程序的弹性且易于使用的网络系统。 Weave Net 可以作为 [CNI 插件](https://www.weave.works/docs/net/latest/kubernetes/) 运行或者独立运行。 在这两种运行方式里，都不需要任何配置或额外的代码即可运行，并且在两种情况下， 网络都为每个 Pod 提供一个 IP 地址 -- 这是 Kubernetes 的标准配置。

##  3.  Kubernetes 系统组件指标
Kubernetes 系统组件指标
-----------------

通过系统组件指标可以更好地了解系统组个内部发生的情况。系统组件指标对于构建仪表板和告警特别有用。

Kubernetes 组件以 [Prometheus 格式](https://prometheus.io/docs/instrumenting/exposition_formats/) 生成度量值。 这种格式是结构化的纯文本，旨在使人和机器都可以阅读。

Kubernetes 中组件的指标
-----------------

在大多数情况下，可以通过 HTTP 访问组件的 ​`/metrics`​ 端点来获取组件的度量值。 对于那些默认情况下不暴露端点的组件，可以使用 ​`--bind-address`​ 标志启用。

在生产环境中，你可能需要配置 [Prometheus 服务器](https://prometheus.io/) 或 某些其他指标搜集器以定期收集这些指标，并使它们在某种时间序列数据库中可用。

请注意，kubelet 还会在 ​`/metrics/cadvisor`​， ​`/metrics/resource`​ 和 ​`/metrics/probes`​ 端点中公开度量值。这些度量值的生命周期各不相同。

如果你的集群使用了 RBAC， 则读取指标需要通过基于用户、组或 ServiceAccount 的鉴权，要求具有允许访问 ​`/metrics`​ 的 ClusterRole。 例如：

`apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata:   name: prometheus rules:   - nonResourceURLs:       - "/metrics"     verbs:       - get`

指标生命周期
------

Alpha 指标 → 稳定的指标 → 弃用的指标 → 隐藏的指标 → 删除的指标

Alpha 指标没有稳定性保证。这些指标可以随时被修改或者删除。

稳定的指标可以保证不会改变。这意味着：

*   稳定的、不包含已弃用（deprecated）签名的指标不会被删除（或重命名）
*   稳定的指标的类型不会被更改

已弃用的指标最终将被删除，不过仍然可用。 这类指标包含注解，标明其被废弃的版本。

例如：

*   被弃用之前：

`# HELP some_counter this counts things # TYPE some_counter counter some_counter 0`

*   被弃用之后：

`# HELP some_counter (Deprecated since 1.15.0) this counts things # TYPE some_counter counter some_counter 0`

隐藏的指标不会再被发布以供抓取，但仍然可用。删除的指标不再被发布，亦无法使用。

显示隐藏指标 
-------

如上所述，管理员可以通过设置可执行文件的命令行参数来启用隐藏指标， 如果管理员错过了上一版本中已经弃用的指标的迁移，则可以把这个用作管理员的逃生门。

​`show-hidden-metrics-for-version`​ 标志接受版本号作为取值，版本号给出 你希望显示该发行版本中已弃用的指标。 版本表示为 x.y，其中 x 是主要版本，y 是次要版本。补丁程序版本不是必须的， 即使指标可能会在补丁程序发行版中弃用，原因是指标弃用策略规定仅针对次要版本。

该参数只能使用前一个次要版本。如果管理员将先前版本设置为 ​`show-hidden-metrics-for-version`​， 则先前版本中隐藏的度量值会再度生成。不允许使用过旧的版本，因为那样会违反指标弃用策略。

以指标 ​`A` ​为例，此处假设 ​`A` ​在 1.n 中已弃用。根据指标弃用策略，我们可以得出以下结论：

*   在版本 ​`1.n`​ 中，这个指标已经弃用，且默认情况下可以生成。
*   在版本 ​`1.n+1`​ 中，这个指标默认隐藏，可以通过命令行参数 ​`show-hidden-metrics-for-version=1.n`​ 来再度生成。
*   在版本 ​`1.n+2`​ 中，这个指标就将被从代码中移除，不会再有任何逃生窗口。

如果你要从版本 ​`1.12`​ 升级到 ​`1.13`​，但仍依赖于 ​`1.12`​ 中弃用的指标 ​`A`​，则应通过命令行设置隐藏指标： ​`--show-hidden-metrics=1.12`​，并记住在升级到 ​`1.14`​ 版本之前删除此指标依赖项。

禁用加速器指标
-------

kubelet 通过 cAdvisor 收集加速器指标。为了收集这些指标，对于 NVIDIA GPU 之类的加速器， kubelet 在驱动程序上保持打开状态。这意味着为了执行基础结构更改（例如更新驱动程序）， 集群管理员需要停止 kubelet 代理。

现在，收集加速器指标的责任属于供应商，而不是 kubelet。供应商必须提供一个收集指标的容器， 并将其公开给指标服务（例如 Prometheus）。

​`DisableAcceleratorUsageMetrics` ​特性门控 禁止由 kubelet 收集的指标。 关于[何时会在默认情况下启用此功能也有一定规划](https://github.com/kubernetes/enhancements/tree/411e51027db842355bd489691af897afc1a41a5e/keps/sig-node/1867-disable-accelerator-usage-metrics target=)。

组件指标
----

### kube-controller-manager 指标

控制器管理器指标可提供有关控制器管理器性能和运行状况的重要洞察。 这些指标包括通用的 Go 语言运行时指标（例如 go\_routine 数量）和控制器特定的度量指标， 例如可用于评估集群运行状况的 etcd 请求延迟或云提供商（AWS、GCE、OpenStack）的 API 延迟等。

从 Kubernetes 1.7 版本开始，详细的云提供商指标可用于 GCE、AWS、Vsphere 和 OpenStack 的存储操作。 这些指标可用于监控持久卷操作的运行状况。

比如，对于 GCE，这些指标称为：

`cloudprovider_gce_api_request_duration_seconds { request = "instance_list"} cloudprovider_gce_api_request_duration_seconds { request = "disk_insert"} cloudprovider_gce_api_request_duration_seconds { request = "disk_delete"} cloudprovider_gce_api_request_duration_seconds { request = "attach_disk"} cloudprovider_gce_api_request_duration_seconds { request = "detach_disk"} cloudprovider_gce_api_request_duration_seconds { request = "list_disk"}`

### kube-scheduler 指标 

FEATURE STATE: Kubernetes v1.21 \[beta\]

调度器会暴露一些可选的指标，报告所有运行中 Pods 所请求的资源和期望的约束值。 这些指标可用来构造容量规划监控面板、访问调度约束的当前或历史数据、 快速发现因为缺少资源而无法被调度的负载，或者将 Pod 的实际资源用量 与其请求值进行比较。

kube-scheduler 组件能够辩识各个 Pod 所配置的资源 请求和约束。 在 Pod 的资源请求值或者约束值非零时，kube-scheduler 会以度量值时间序列的形式 生成报告。该时间序列值包含以下标签：

*   名字空间
*   Pod 名称
*   Pod 调度所处节点，或者当 Pod 未被调度时用空字符串表示
*   优先级
*   为 Pod 所指派的调度器
*   资源的名称（例如，​`cpu`​）
*   资源的单位，如果知道的话（例如，​`cores`​）

一旦 Pod 进入完成状态（其 ​`restartPolicy` ​为 ​`Never` ​或 ​`OnFailure`​，且 其处于 ​`Succeeded` ​或 ​`Failed` ​Pod 阶段，或者已经被删除且所有容器都具有 终止状态），该时间序列停止报告，因为调度器现在可以调度其它 Pod 来执行。 这两个指标称作 ​`kube_pod_resource_request` ​和 ​`kube_pod_resource_limit`​。

指标暴露在 HTTP 端点 ​`/metrics/resources`​，与调度器上的 ​`/metrics`​ 端点 一样要求相同的访问授权。你必须使用 ​`--show-hidden-metrics-for-version=1.20`​ 标志才能暴露那些稳定性为 Alpha 的指标。

禁用指标
----

你可以通过命令行标志 ​`--disabled-metrics`​ 来关闭某指标。 在例如某指标会带来性能问题的情况下，这一操作可能是有用的。 标志的参数值是一组被禁止的指标（例如：​`--disabled-metrics=metric1,metric2`​）。

指标顺序性保证 
--------

在 Alpha 阶段，标志只能接受一组映射值作为可以使用的指标标签。 每个映射值的格式为<指标名称>,<标签名称>=<可用标签列表>，其中 <可用标签列表> 是一个用逗号分隔的、可接受的标签名的列表。

最终的格式看起来会是这样： --allow-label-value <指标名称>,<标签名称>='<可用值1>,<可用值2>...', <指标名称2>,<标签名称>='<可用值1>, <可用值2>...', ....

下面是一个例子：

​`--allow-label-value number_count_metric,odd_number='1,3,5', number_count_metric,even_number='2,4,6', date_gauge_metric,weekend='Saturday,Sunday'`​

##  4.  Kubernetes 日志架构
日志架构
----

应用日志可以让你了解应用内部的运行状况。日志对调试问题和监控集群活动非常有用。 大部分现代化应用都有某种日志记录机制。同样地，容器引擎也被设计成支持日志记录。 针对容器化应用，最简单且最广泛采用的日志记录方式就是写入标准输出和标准错误流。

但是，由容器引擎或运行时提供的原生功能通常不足以构成完整的日志记录方案。 例如，如果发生容器崩溃、Pod 被逐出或节点宕机等情况，你可能想访问应用日志。 在集群中，日志应该具有独立的存储和生命周期，与节点、Pod 或容器的生命周期相独立。 这个概念叫 集群级的日志 。

集群级日志架构需要一个独立的后端用来存储、分析和查询日志。 Kubernetes 并不为日志数据提供原生的存储解决方案。 相反，有很多现成的日志方案可以集成到 Kubernetes 中。 下面各节描述如何在节点上处理和存储日志。

Kubernetes 中的基本日志记录
-------------------

这里的示例使用包含一个容器的 Pod 规约，每秒钟向标准输出写入数据。

`apiVersion: v1 kind: Pod metadata:   name: counter spec:   containers:   - name: count     image: busybox:1.28     args: [/bin/sh, -c,             'i=0; while true; do echo "$i: $(date)"; i=$((i+1)); sleep 1; done']`

用下面的命令运行 Pod：

`kubectl apply -f https://k8s.io/examples/debug/counter-pod.yaml`

输出结果为：

`pod/counter created`

像下面这样，使用 ​`kubectl logs`​ 命令获取日志:

`kubectl logs counter`

输出结果为：

`0: Mon Jan  1 00:00:00 UTC 2001 1: Mon Jan  1 00:00:01 UTC 2001 2: Mon Jan  1 00:00:02 UTC 2001 ...`

你可以使用命令 ​`kubectl logs --previous`​ 检索之前容器实例的日志。 如果 Pod 中有多个容器，你应该为该命令附加容器名以访问对应容器的日志。 详见 ​[`kubectl logs`​ 文档](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=)。 如果 Pod 有多个容器，你应该为该命令附加容器名以访问对应容器的日志， 使用 ​`-c`​ 标志来指定要访问的容器的日志，如下所示：

`kubectl logs counter -c count`

详见 ​[`kubectl logs`​ 文档](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=)。

节点级日志记录
-------

![](https://atts.w3cschool.cn/attachments/image/20220526/1653545623746679.png)  

容器化应用写入 ​`stdout` ​和 ​`stderr` ​的任何数据，都会被容器引擎捕获并被重定向到某个位置。 例如，Docker 容器引擎将这两个输出流重定向到某个 [日志驱动（Logging Driver）](https://docs.docker.com/config/containers/logging/configure/) ， 该日志驱动在 Kubernetes 中配置为以 JSON 格式写入文件。

> Note: Docker JSON 日志驱动将日志的每一行当作一条独立的消息。 该日志驱动不直接支持多行消息。你需要在日志代理级别或更高级别处理多行消息。

默认情况下，如果容器重启，kubelet 会保留被终止的容器日志。 如果 Pod 在工作节点被驱逐，该 Pod 中所有的容器也会被驱逐，包括容器日志。

节点级日志记录中，需要重点考虑实现日志的轮转，以此来保证日志不会消耗节点上全部可用空间。 Kubernetes 并不负责轮转日志，而是通过部署工具建立一个解决问题的方案。 例如，在用 ​`kube-up.sh`​ 部署的 Kubernetes 集群中，存在一个 ​[`logrotate`​](https://linux.die.net/man/8/logrotate)，每小时运行一次。 你也可以设置容器运行时来自动地轮转应用日志。

例如，你可以找到关于 ​`kube-up.sh`​ 为 GCP 环境的 COS 镜像设置日志的详细信息， 脚本为 ​[`configure-helper`​ 脚本](https://github.com/kubernetes/kubernetes/blob/master/cluster/gce/gci/configure-helper.sh)。

当使用某 CRI 容器运行时 时，kubelet 要负责对日志进行轮换，并 管理日志目录的结构。kubelet 将此信息发送给 CRI 容器运行时，后者 将容器日志写入到指定的位置。在 kubelet 配置文件 中的两个 kubelet 参数 ​`containerLogMaxSize` ​和 ​`containerLogMaxFiles` ​可以用来配置每个日志文件的最大长度和每个容器可以生成的日志文件个数上限。

当运行 [kubectl logs](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=) 时， 节点上的 kubelet 处理该请求并直接读取日志文件，同时在响应中返回日志文件内容。

> Note: 如果有外部系统执行日志轮转或者使用了 CRI 容器运行时，那么 ​`kubectl logs`​ 仅可查询到最新的日志内容。 比如，对于一个 10MB 大小的文件，通过 ​`logrotate` ​执行轮转后生成两个文件， 一个 10MB 大小，一个为空，​`kubectl logs`​ 返回最新的日志文件，而该日志文件 在这个例子中为空。

### 系统组件日志

系统组件有两种类型：在容器中运行的和不在容器中运行的。例如：

*   在容器中运行的 kube-scheduler 和 kube-proxy。
*   不在容器中运行的 kubelet 和容器运行时。

在使用 systemd 机制的服务器上，kubelet 和容器容器运行时将日志写入到 journald 中。 如果没有 systemd，它们将日志写入到 ​`/var/log`​ 目录下的 ​`.log`​ 文件中。 容器中的系统组件通常将日志写到 ​`/var/log`​ 目录，绕过了默认的日志机制。 他们使用 [klog](https://github.com/kubernetes/klog) 日志库。 你可以在[日志开发文档](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md) 找到这些组件的日志告警级别约定。

和容器日志类似，​`/var/log`​ 目录中的系统组件日志也应该被轮转。 通过脚本 ​`kube-up.sh`​ 启动的 Kubernetes 集群中，日志被工具 ​`logrotate` ​执行每日轮转，或者日志大小超过 100MB 时触发轮转。

集群级日志架构 
--------

虽然Kubernetes没有为集群级日志记录提供原生的解决方案，但你可以考虑几种常见的方法。 以下是一些选项：

*   使用在每个节点上运行的节点级日志记录代理。
*   在应用程序的 Pod 中，包含专门记录日志的边车（Sidecar）容器。
*   将日志直接从应用程序中推送到日志记录后端。

### 使用节点级日志代理

![](https://atts.w3cschool.cn/attachments/image/20220526/1653545939430176.png)  

你可以通过在每个节点上使用 节点级的日志记录代理 来实现集群级日志记录。 日志记录代理是一种用于暴露日志或将日志推送到后端的专用工具。 通常，日志记录代理程序是一个容器，它可以访问包含该节点上所有应用程序容器的日志文件的目录。

由于日志记录代理必须在每个节点上运行，通常可以用 ​`DaemonSet` ​的形式运行该代理。 节点级日志在每个节点上仅创建一个代理，不需要对节点上的应用做修改。

容器向标准输出和标准错误输出写出数据，但在格式上并不统一。 节点级代理 收集这些日志并将其进行转发以完成汇总。

### 使用 sidecar 容器运行日志代理 

你可以通过以下方式之一使用边车（Sidecar）容器：

*   边车容器将应用程序日志传送到自己的标准输出。
*   边车容器运行一个日志代理，配置该日志代理以便从应用容器收集日志。

#### 传输数据流的 sidecar 容器

![](https://atts.w3cschool.cn/attachments/image/20220526/1653545981833281.png)  

利用边车容器向自己的 ​`stdout` ​和 ​`stderr` ​传输流的方式， 你就可以利用每个节点上的 kubelet 和日志代理来处理日志。 边车容器从文件、套接字或 journald 读取日志。 每个边车容器向自己的 ​`stdout` ​和 ​`stderr` ​流中输出日志。

这种方法允许你将日志流从应用程序的不同部分分离开，其中一些可能缺乏对写入 ​`stdout` ​或 ​`stderr` ​的支持。重定向日志背后的逻辑是最小的，因此它的开销几乎可以忽略不计。 另外，因为 ​`stdout`​、​`stderr` ​由 kubelet 处理，你可以使用内置的工具 ​`kubectl logs`​。

例如，某 Pod 中运行一个容器，该容器向两个文件写不同格式的日志。 下面是这个 pod 的配置文件:

`apiVersion: v1 kind: Pod metadata:   name: counter spec:   containers:   - name: count     image: busybox:1.28     args:     - /bin/sh     - -c     - >       i=0;       while true;       do         echo "$i: $(date)" >> /var/log/1.log;         echo "$(date) INFO $i" >> /var/log/2.log;         i=$((i+1));         sleep 1;       done           volumeMounts:     - name: varlog       mountPath: /var/log   volumes:   - name: varlog     emptyDir: {}`

不建议在同一个日志流中写入不同格式的日志条目，即使你成功地将其重定向到容器的 ​`stdout` ​流。相反，你可以创建两个边车容器。每个边车容器可以从共享卷 跟踪特定的日志文件，并将文件内容重定向到各自的 ​`stdout` ​流。

下面是运行两个边车容器的 Pod 的配置文件：

`apiVersion: v1 kind: Pod metadata:   name: counter spec:   containers:   - name: count     image: busybox:1.28     args:     - /bin/sh     - -c     - >       i=0;       while true;       do         echo "$i: $(date)" >> /var/log/1.log;         echo "$(date) INFO $i" >> /var/log/2.log;         i=$((i+1));         sleep 1;       done           volumeMounts:     - name: varlog       mountPath: /var/log   - name: count-log-1     image: busybox:1.28     args: [/bin/sh, -c, 'tail -n+1 -F /var/log/1.log']     volumeMounts:     - name: varlog       mountPath: /var/log   - name: count-log-2     image: busybox:1.28     args: [/bin/sh, -c, 'tail -n+1 -F /var/log/2.log']     volumeMounts:     - name: varlog       mountPath: /var/log   volumes:   - name: varlog     emptyDir: {}`

现在当你运行这个 Pod 时，你可以运行如下命令分别访问每个日志流：

`kubectl logs counter count-log-1`

输出为：

`0: Mon Jan  1 00:00:00 UTC 2001 1: Mon Jan  1 00:00:01 UTC 2001 2: Mon Jan  1 00:00:02 UTC 2001 ...`

`kubectl logs counter count-log-2`

输出为：

`Mon Jan  1 00:00:00 UTC 2001 INFO 0 Mon Jan  1 00:00:01 UTC 2001 INFO 1 Mon Jan  1 00:00:02 UTC 2001 INFO 2 ...`

集群中安装的节点级代理会自动获取这些日志流，而无需进一步配置。 如果你愿意，你也可以配置代理程序来解析源容器的日志行。

注意，尽管 CPU 和内存使用率都很低（以多个 CPU 毫核指标排序或者按内存的兆字节排序）， 向文件写日志然后输出到 ​`stdout` ​流仍然会成倍地增加磁盘使用率。 如果你的应用向单一文件写日志，通常最好设置 ​`/dev/stdout`​ 作为目标路径， 而不是使用流式的边车容器方式。

应用本身如果不具备轮转日志文件的功能，可以通过边车容器实现。 该方式的一个例子是运行一个小的、定期轮转日志的容器。 然而，还是推荐直接使用 ​`stdout` ​和 ​`stderr`​，将日志的轮转和保留策略 交给 kubelet。

### 具有日志代理功能的边车容器

![](https://atts.w3cschool.cn/attachments/image/20220526/1653546156127488.png)  

如果节点级日志记录代理程序对于你的场景来说不够灵活，你可以创建一个 带有单独日志记录代理的边车容器，将代理程序专门配置为与你的应用程序一起运行。

> Note:  
> 在边车容器中使用日志代理会带来严重的资源损耗。 此外，你不能使用 ​`kubectl logs`​ 命令访问日志，因为日志并没有被 kubelet 管理。

下面是两个配置文件，可以用来实现一个带日志代理的边车容器。 第一个文件包含用来配置 fluentd 的 ConfigMap。

`apiVersion: v1 kind: ConfigMap metadata:   name: fluentd-config data:   fluentd.conf: |     <source>       type tail       format none       path /var/log/1.log       pos_file /var/log/1.log.pos       tag count.format1     </source>      <source>       type tail       format none       path /var/log/2.log       pos_file /var/log/2.log.pos       tag count.format2     </source>      <match **>       type google_cloud     </match>`    

> Note:  
> 要进一步了解如何配置 fluentd，请参考 [fluentd 官方文档](https://docs.fluentd.org/)。

第二个文件描述了运行 fluentd 边车容器的 Pod 。 flutend 通过 Pod 的挂载卷获取它的配置数据。

`apiVersion: v1 kind: Pod metadata:   name: counter spec:   containers:   - name: count     image: busybox:1.28     args:     - /bin/sh     - -c     - >       i=0;       while true;       do         echo "$i: $(date)" >> /var/log/1.log;         echo "$(date) INFO $i" >> /var/log/2.log;         i=$((i+1));         sleep 1;       done           volumeMounts:     - name: varlog       mountPath: /var/log   - name: count-agent     image: k8s.gcr.io/fluentd-gcp:1.30     env:     - name: FLUENTD_ARGS       value: -c /etc/fluentd-config/fluentd.conf     volumeMounts:     - name: varlog       mountPath: /var/log     - name: config-volume       mountPath: /etc/fluentd-config   volumes:   - name: varlog     emptyDir: {}   - name: config-volume     configMap:       name: fluentd-config`

在示例配置中，你可以将 fluentd 替换为任何日志代理，从应用容器内 的任何来源读取数据。

### 从应用中直接暴露日志目录

![](https://atts.w3cschool.cn/attachments/image/20220526/1653546250792190.png)  

从各个应用中直接暴露和推送日志数据的集群日志机制 已超出 Kubernetes 的范围。

##  5.  Kubernetes 系统日志
系统日志
----

系统组件的日志记录集群中发生的事件，这对于调试非常有用。 你可以配置日志的精细度，以展示更多或更少的细节。 日志可以是粗粒度的，如只显示组件内的错误， 也可以是细粒度的，如显示事件的每一个跟踪步骤（比如 HTTP 访问日志、pod 状态更新、控制器动作或调度器决策）。

Klog
----

klog 是 Kubernetes 的日志库。 [klog](https://github.com/kubernetes/klog) 为 Kubernetes 系统组件生成日志消息。

Kubernetes 正在进行简化其组件日志的努力。下面的 klog 命令行参数从 Kubernetes 1.23 开始[已被废弃](https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/2845-deprecate-klog-specific-flags-in-k8s-components)， 会在未来版本中移除：

*   ​`--add-dir-header` ​
*   ​`--alsologtostderr` ​
*   ​`--log-backtrace-at` ​
*   ​`--log-dir` ​
*   ​`--log-file` ​
*   ​`--log-file-max-size` ​
*   ​`--logtostderr` ​
*   ​`--one-output` ​
*   ​`--skip-headers` ​
*   ​`--skip-log-headers` ​
*   ​`--stderrthreshold`​

输出总会被写到标准错误输出（stderr）之上，无论输出格式如何。 对输出的重定向将由调用 Kubernetes 组件的软件来处理。 这一软件可以是 POSIX Shell 或者类似 systemd 这样的工具。

在某些场合下，例如对于无发行主体的（distroless）容器或者 Windows 系统服务， 这些替代方案都是不存在的。那么你可以使用 [kube-log-runner](https://github.com/kubernetes/kubernetes/blob/d2a8a81639fcff8d1221b900f66d28361a170654/staging/src/k8s.io/component-base/logs/kube-log-runner/README.md) 可执行文件来作为 Kubernetes 的封装层，完成对输出的重定向。 在很多 Kubernetes 基础镜像中，都包含一个预先构建的可执行程序。 这个程序原来称作 ​`/go-runner`​，而在服务器和节点的发行版本库中，称作 ​`kube-log-runner`​。

下表展示的是 ​`kube-log-runner`​ 调用与 Shell 重定向之间的对应关系：

用法

POSIX Shell（例如 Bash）

`kube-log-runner <options> <cmd>`

合并 stderr 与 stdout，写出到 stdout

`2>&1`

`kube-log-runner`（默认行为 ）

将 stderr 与 stdout 重定向到日志文件

`1>>/tmp/log 2>&1`

`kube-log-runner -log-file=/tmp/log`

输出到 stdout 并复制到日志文件中

`2>&1 | tee -a /tmp/log`

`kube-log-runner -log-file=/tmp/log -also-stdout`

仅将 stdout 重定向到日志

`>/tmp/log`

`kube-log-runner -log-file=/tmp/log -redirect-stderr=false`

### klog 输出

传统的 klog 原生格式示例：

`I1025 00:15:15.525108       1 httplog.go:79] GET /api/v1/namespaces/kube-system/pods/metrics-server-v0.3.1-57c75779f-9p8wg: (1.512ms) 200 [pod_nanny/v0.0.0 (linux/amd64) kubernetes/$Format 10.56.1.19:51756]`

消息字符串可能包含换行符：

`I1025 00:15:15.525108       1 example.go:79] This is a message which has a line break.`

### 结构化日志

FEATURE STATE: Kubernetes v1.23 \[beta\]

> Warning:  
> 迁移到结构化日志消息是一个正在进行的过程。在此版本中，并非所有日志消息都是结构化的。 解析日志文件时，你也必须要处理非结构化日志消息。  
> 日志格式和值的序列化可能会发生变化。

结构化日志记录旨在日志消息中引入统一结构，以便以编程方式提取信息。 你可以方便地用更小的开销来处理结构化日志。 生成日志消息的代码决定其使用传统的非结构化的 klog 还是结构化的日志。

默认的结构化日志消息是以文本形式呈现的，其格式与传统的 klog 保持向后兼容：

`<klog header> "<message>" <key1>="<value1>" <key2>="<value2>" ...`

示例：

`I1025 00:15:15.525108       1 controller_utils.go:116] "Pod status updated" pod="kube-system/kubedns" status="ready"`

字符串在输出时会被添加引号。其他数值类型都使用 [%+v](https://pkg.go.dev/fmt target=) 来格式化，因此可能导致日志消息会延续到下一行， [具体取决于数据本身](https://github.com/kubernetes/kubernetes/issues/106428)。

`I1025 00:15:15.525108       1 example.go:116] "Example" data="This is text with a line break\nand \"quotation marks\"." someInt=1 someFloat=0.1 someStruct={StringField: First line, second line.}`

### 上下文日志

FEATURE STATE: Kubernetes v1.24 \[alpha\]

上下文日志建立在结构化日志之上。 它主要是关于开发人员如何使用日志记录调用：基于该概念的代码将更加灵活， 并且支持在[结构化日志 KEP](https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/3077-contextual-logging) 中描述的额外用例。

如果开发人员在他们的组件中使用额外的函数，比如 ​`WithValues` ​或 ​`WithName`​， 那么日志条目将会包含额外的信息，这些信息会被调用者传递给函数。

目前这一特性是由 ​`StructuredLogging` ​特性门控所控制的，默认关闭。 这个基础设施是在 1.24 中被添加的，并不需要修改组件。 该 ​[`component-base/logs/example`​](https://github.com/kubernetes/kubernetes/blob/v1.24.0-beta.0/staging/src/k8s.io/component-base/logs/example/cmd/logger.go) 命令演示了如何使用新的日志记录调用以及组件如何支持上下文日志记录。

`$ cd $GOPATH/src/k8s.io/kubernetes/staging/src/k8s.io/component-base/logs/example/cmd/ $ go run . --help ...       --feature-gates mapStringBool  A set of key=value pairs that describe feature gates for alpha/experimental features. Options are:                                      AllAlpha=true|false (ALPHA - default=false)                                      AllBeta=true|false (BETA - default=false)                                      ContextualLogging=true|false (ALPHA - default=false) $ go run . --feature-gates ContextualLogging=true ... I0404 18:00:02.916429  451895 logger.go:94] "example/myname: runtime" foo="bar" duration="1m0s" I0404 18:00:02.916447  451895 logger.go:95] "example: another runtime" foo="bar" duration="1m0s"`

​`example` ​前缀和 ​`foo="bar"`​ 会被函数的调用者添加上， 不需修改该函数，它就会记录 ​`runtime` ​消息和 ​`duration="1m0s"`​ 值。

禁用上下文日志后，​`WithValues` ​和 ​`WithName` ​什么都不会做， 并且会通过调用全局的 klog 日志记录器记录日志。 因此，这些附加信息不再出现在日志输出中：

`$ go run . --feature-gates ContextualLogging=false ... I0404 18:03:31.171945  452150 logger.go:94] "runtime" duration="1m0s" I0404 18:03:31.171962  452150 logger.go:95] "another runtime" duration="1m0s"`

### JSON 日志格式

FEATURE STATE: Kubernetes v1.19 \[alpha\]

> Warning:  
> JSON 输出并不支持太多标准 klog 参数。  
> 并不是所有日志都保证写成 JSON 格式（例如，在进程启动期间）。 如果你打算解析日志，请确保可以处理非 JSON 格式的日志行。  
> 字段名和 JSON 序列化可能会发生变化。

​`--logging-format=json`​ 参数将日志格式从 klog 原生格式改为 JSON 格式。 JSON 日志格式示例（美化输出）：

`{    "ts": 1580306777.04728,    "v": 4,    "msg": "Pod status updated",    "pod":{       "name": "nginx-1",       "namespace": "default"    },    "status": "ready" }`

具有特殊意义的 key：

*   ​`ts` ​- Unix 时间风格的时间戳（必选项，浮点值）
*   ​`v` ​- 精细度（仅用于 info 级别，不能用于错误信息，整数）
*   ​`err` ​- 错误字符串（可选项，字符串）
*   ​`msg` ​- 消息（必选项，字符串）

当前支持JSON格式的组件列表：

*   kube-controller-manager
*   kube-apiserver
*   kube-scheduler
*   kubelet

### 日志精细度级别

参数 ​`-v`​ 控制日志的精细度。增大该值会增大日志事件的数量。 减小该值可以减小日志事件的数量。增大精细度会记录更多的不太严重的事件。 精细度设置为 0 时只记录关键（critical）事件。

### 日志位置

有两种类型的系统组件：运行在容器中的组件和不运行在容器中的组件。例如：

*   Kubernetes 调度器和 kube-proxy 在容器中运行。
*   kubelet 和容器运行时不在容器中运行。

在使用 systemd 的系统中，kubelet 和容器运行时写入 journald。 在别的系统中，日志写入 ​`/var/log`​ 目录下的 ​`.log`​ 文件中。 容器中的系统组件总是绕过默认的日志记录机制，写入 ​`/var/log`​ 目录下的 ​`.log`​ 文件。 与容器日志类似，你应该轮转 ​`/var/log`​ 目录下系统组件日志。 在 ​`kube-up.sh`​ 脚本创建的 Kubernetes 集群中，日志轮转由 ​`logrotate` ​工具配置。 ​`logrotate`​ 工具，每天或者当日志大于 100MB 时，轮转日志。

##  6.  Kubernetes 追踪系统组件
追踪 Kubernetes 系统组件
------------------

FEATURE STATE: Kubernetes v1.22 \[alpha\]

系统组件追踪功能记录各个集群操作的时延信息和这些操作之间的关系。

Kubernetes 组件基于 gRPC 导出器的 [OpenTelemetry 协议](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md target=) 发送追踪信息，并用 [OpenTelemetry Collector](https://github.com/open-telemetry/opentelemetry-collector target=) 收集追踪信息，再将其转交给追踪系统的后台。

追踪信息的收集
-------

关于收集追踪信息、以及使用收集器的完整指南，可参见 [Getting Started with the OpenTelemetry Collector](https://opentelemetry.io/docs/collector/getting-started/)。 不过，还有一些特定于 Kubernetes 组件的事项值得注意。

默认情况下，Kubernetes 组件使用 gRPC 的 OTLP 导出器来导出追踪信息，将信息写到 [IANA OpenTelemetry 端口](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=opentelemetry)。 举例来说，如果收集器以 Kubernetes 组件的边车模式运行，以下接收器配置会收集 spans 信息，并将它们写入到标准输出。

`receivers:   otlp:     protocols:       grpc: exporters:   # 用适合你后端环境的导出器替换此处的导出器   logging:     logLevel: debug service:   pipelines:     traces:       receivers: [otlp]       exporters: [logging]`

组件追踪
----

### kube-apiserver 追踪

kube-apiserver 为传入的 HTTP 请求、传出到 webhook 和 etcd 的请求以及重入的请求生成 spans。 由于 kube-apiserver 通常是一个公开的端点，所以它通过出站的请求传播 [W3C 追踪上下文](https://www.w3.org/TR/trace-context/)， 但不使用入站请求的追踪上下文。

#### 在 kube-apiserver 中启用追踪 

要启用追踪特性，需要启用 kube-apiserver 上的 ​`APIServerTracing` ​特性门控。 然后，使用 ​`--tracing-config-file=<<配置文件路径>`​ 为 kube-apiserver 提供追踪配置文件。 下面是一个示例配置，它为万分之一的请求记录 spans，并使用了默认的 OpenTelemetry 端口。

`apiVersion: apiserver.config.k8s.io/v1alpha1 kind: TracingConfiguration # default value #endpoint: localhost:4317 samplingRatePerMillion: 100`

稳定性 
----

追踪工具仍在积极开发中，未来它会以多种方式发生变化。 这些变化包括：span 名称、附加属性、检测端点等等。 此类特性在达到稳定版本之前，不能保证追踪工具的向后兼容性。

##  7.  Kubernetes 代理
代理 
---

用户在使用 Kubernetes 的过程中可能遇到几种不同的代理（proxy）：

1.  kubectl proxy：

*   运行在用户的桌面或 pod 中
*   从本机地址到 Kubernetes apiserver 的代理
*   客户端到代理使用 HTTP 协议
*   代理到 apiserver 使用 HTTPS 协议
*   指向 apiserver
*   添加认证头信息

3.  apiserver proxy：

*   是一个建立在 apiserver 内部的“堡垒”
*   将集群外部的用户与集群 IP 相连接，这些IP是无法通过其他方式访问的
*   运行在 apiserver 进程内
*   客户端到代理使用 HTTPS 协议 (如果配置 apiserver 使用 HTTP 协议，则使用 HTTP 协议)
*   通过可用信息进行选择，代理到目的地可能使用 HTTP 或 HTTPS 协议
*   可以用来访问 Node、 Pod 或 Service
*   当用来访问 Service 时，会进行负载均衡

5.  kube proxy：

*   在每个节点上运行
*   代理 UDP、TCP 和 SCTP
*   不支持 HTTP
*   提供负载均衡能力
*   只用来访问 Service

7.  apiserver 之前的代理/负载均衡器：

*   在不同集群中的存在形式和实现不同 (如 nginx)
*   位于所有客户端和一个或多个 API 服务器之间
*   存在多个 API 服务器时，扮演负载均衡器的角色

9.  外部服务的云负载均衡器：

*   由一些云供应商提供 (如 AWS ELB、Google Cloud Load Balancer)
*   Kubernetes 服务类型为 ​`LoadBalancer` ​时自动创建
*   通常仅支持 UDP/TCP 协议
*   SCTP 支持取决于云供应商的负载均衡器实现
*   不同云供应商的云负载均衡器实现不同

Kubernetes 用户通常只需要关心前两种类型的代理，集群管理员通常需要确保后面几种类型的代理设置正确。

请求重定向
-----

代理已经取代重定向功能，重定向功能已被弃用。

##  8.  Kubernetes API优先级和公平性
API 优先级和公平性
-----------

FEATURE STATE: Kubernetes v1.20 \[beta\]

对于集群管理员来说，控制 Kubernetes API 服务器在过载情况下的行为是一项关键任务。 kube-apiserver 有一些控件（例如：命令行标志 ​`--max-requests-inflight`​ 和 ​`--max-mutating-requests-inflight`​ ）, 可以限制将要接受的未处理的请求，从而防止过量请求入站，潜在导致 API 服务器崩溃。 但是这些标志不足以保证在高流量期间，最重要的请求仍能被服务器接受。

API 优先级和公平性（APF）是一种替代方案，可提升上述最大并发限制。 APF 以更细粒度的方式对请求进行分类和隔离。 它还引入了空间有限的排队机制，因此在非常短暂的突发情况下，API 服务器不会拒绝任何请求。 通过使用公平排队技术从队列中分发请求，这样， 一个行为不佳的 控制器 就不会饿死其他控制器（即使优先级相同）。

本功能特性在设计上期望其能与标准控制器一起工作得很好； 这类控制器使用通知组件（Informers）获得信息并对 API 请求的失效作出反应， 在处理失效时能够执行指数型回退。其他客户端也以类似方式工作。

> Caution: 属于“长时间运行”类型的请求（主要是 watch）不受 API 优先级和公平性过滤器的约束。 如果未启用 APF 特性，即便设置 ​`--max-requests-inflight`​ 标志，该类请求也不受约束。

启用/禁用 API 优先级和公平性 
------------------

API 优先级与公平性（APF）特性由特性门控控制，默认情况下启用。 有关特性门控的一般性描述以及如何启用和禁用特性门控， 请参见特性门控。 APF 的特性门控称为 ​`APIPriorityAndFairness`​。 此特性也与某个 API 组 相关： (a) ​`v1alpha1` ​版本，默认被禁用； (b) ​`v1beta1` ​和 ​`v1beta2` ​版本，默认被启用。 你可以在启动 ​`kube-apiserver`​ 时，添加以下命令行标志来禁用此功能门控及 API Beta 组：

`kube-apiserver \ --feature-gates=APIPriorityAndFairness=false \ --runtime-config=flowcontrol.apiserver.k8s.io/v1beta1=false,flowcontrol.apiserver.k8s.io/v1beta2=false \   # ...其他配置不变` 

或者，你也可以通过 ​`--runtime-config=flowcontrol.apiserver.k8s.io/v1alpha1=true`​ 启用 API 组的 v1alpha1 版本。

命令行标志 ​`--enable-priority-fairness=false`​ 将彻底禁用 APF 特性，即使其他标志启用它也是无效。

概念 
---

APF 特性包含几个不同的功能。 传入的请求通过 FlowSchema 按照其属性分类，并分配优先级。 每个优先级维护自定义的并发限制，加强了隔离度，这样不同优先级的请求，就不会相互饿死。 在同一个优先级内，公平排队算法可以防止来自不同 flow 的请求相互饿死。 该算法将请求排队，通过排队机制，防止在平均负载较低时，通信量突增而导致请求失败。

### 优先级 

如果未启用 APF，API 服务器中的整体并发量将受到 ​`kube-apiserver`​ 的参数 ​`--max-requests-inflight`​ 和 ​`--max-mutating-requests-inflight`​ 的限制。 启用 APF 后，将对这些参数定义的并发限制进行求和，然后将总和分配到一组可配置的 优先级 中。 每个传入的请求都会分配一个优先级；每个优先级都有各自的配置，设定允许分发的并发请求数。

例如，默认配置包括针对领导者选举请求、内置控制器请求和 Pod 请求都单独设置优先级。 这表示即使异常的 Pod 向 API 服务器发送大量请求，也无法阻止领导者选举或内置控制器的操作执行成功。

### 排队 

即使在同一优先级内，也可能存在大量不同的流量源。 在过载情况下，防止一个请求流饿死其他流是非常有价值的 （尤其是在一个较为常见的场景中，一个有故障的客户端会疯狂地向 kube-apiserver 发送请求， 理想情况下，这个有故障的客户端不应对其他客户端产生太大的影响）。 公平排队算法在处理具有相同优先级的请求时，实现了上述场景。 每个请求都被分配到某个 流 中，该 流 由对应的 FlowSchema 的名字加上一个 流区分项（Flow Distinguisher） 来标识。 这里的流区分项可以是发出请求的用户、目标资源的名称空间或什么都不是。 系统尝试为不同流中具有相同优先级的请求赋予近似相等的权重。 要启用对不同实例的不同处理方式，多实例的控制器要分别用不同的用户名来执行身份认证。

将请求划分到流中之后，APF 功能将请求分配到队列中。 分配时使用一种称为 混洗分片（Shuffle-Sharding） 的技术。 该技术可以相对有效地利用队列隔离低强度流与高强度流。

排队算法的细节可针对每个优先等级进行调整，并允许管理员在内存占用、 公平性（当总流量超标时，各个独立的流将都会取得进展）、 突发流量的容忍度以及排队引发的额外延迟之间进行权衡。

### 豁免请求 

某些特别重要的请求不受制于此特性施加的任何限制。这些豁免可防止不当的流控配置完全禁用 API 服务器。

资源 
---

流控 API 涉及两种资源。 [PriorityLevelConfigurations](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/ target=) 定义隔离类型和可处理的并发预算量，还可以微调排队行为。  [FlowSchemas](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/ target=) 用于对每个入站请求进行分类，并与一个 PriorityLevelConfigurations 相匹配。 此外同一 API 组还有一个 ​`v1alpha1` ​版本，其中包含语法和语义都相同的资源类别。

### PriorityLevelConfiguration 

一个 PriorityLevelConfiguration 表示单个隔离类型。每个 PriorityLevelConfigurations 对未完成的请求数有各自的限制，对排队中的请求数也有限制。

PriorityLevelConfigurations 的并发限制不是指定请求绝对数量，而是在“并发份额”中指定。 API 服务器的总并发量限制通过这些份额按例分配到现有 PriorityLevelConfigurations 中。 集群管理员可以更改 ​`--max-requests-inflight`​ （或 ​`--max-mutating-requests-inflight`​ ）的值， 再重新启动 ​`kube-apiserver`​ 来增加或减小服务器的总流量， 然后所有的 PriorityLevelConfigurations 将看到其最大并发增加（或减少）了相同的比例。

> Caution: 启用 APF 功能后，服务器的总并发量限制将设置为 ​`--max-requests-inflight`​ 和 ​`--max-mutating-requests-inflight`​ 之和。 可变请求和不可变请求之间不再有任何区别； 如果对于某种资源，你需要区别对待不同请求，请创建不同的 FlowSchema 分别匹配可变请求和不可变请求。

当入站请求的数量大于分配的 PriorityLevelConfigurations 中允许的并发级别时， ​`type` ​字段将确定对额外请求的处理方式。 ​`Reject` ​类型，表示多余的流量将立即被 HTTP 429（请求过多）错误所拒绝。 ​`Queue` ​类型，表示对超过阈值的请求进行排队，将使用阈值分片和公平排队技术来平衡请求流之间的进度。

公平排队算法支持通过排队配置对优先级微调：

*   ​`queues` ​递增能减少不同流之间的冲突概率，但代价是增加了内存使用量。 值为 1 时，会禁用公平排队逻辑，但仍允许请求排队。
*   ​`queueLengthLimit` ​递增可以在不丢弃任何请求的情况下支撑更大的突发流量， 但代价是增加了等待时间和内存使用量。
*   修改 ​`handSize` ​允许你调整过载情况下不同流之间的冲突概率以及单个流可用的整体并发性。

> Note: 较大的 ​`handSize` ​使两个单独的流程发生碰撞的可能性较小（因此，一个流可以饿死另一个流）， 但是更有可能的是少数流可以控制 apiserver。 较大的 ​`handSize` ​还可能增加单个高并发流的延迟量。 单个流中可能排队的请求的最大数量为 ​`handSize * queueLengthLimit`​ 。

下表显示了有趣的随机分片配置集合， 每行显示给定的老鼠（低强度流）被不同数量的大象挤压（高强度流）的概率。 表来源请参阅： [https://play.golang.org/p/Gi0PLgVHiUg](https://go.dev/play/p/Gi0PLgVHiUg)

随机分片

队列数

1 个大象

4 个大象

16 个大象

12

32

4.428838398950118e-09

0.11431348830099144

0.9935089607656024

10

32

1.550093439632541e-08

0.0626479840223545

0.9753101519027554

10

64

6.601827268370426e-12

0.00045571320990370776

0.49999929150089345

9

64

3.6310049976037345e-11

0.00045501212304112273

0.4282314876454858

8

64

2.25929199850899e-10

0.0004886697053040446

0.35935114681123076

8

128

6.994461389026097e-13

3.4055790161620863e-06

0.02746173137155063

7

128

1.0579122850901972e-11

6.960839379258192e-06

0.02406157386340147

7

256

7.597695465552631e-14

6.728547142019406e-08

0.0006709661542533682

6

256

2.7134626662687968e-12

2.9516464018476436e-07

0.0008895654642000348

6

512

4.116062922897309e-14

4.982983350480894e-09

2.26025764343413e-05

6

1024

6.337324016514285e-16

8.09060164312957e-11

4.517408062903668e-07

### FlowSchema 

FlowSchema 匹配一些入站请求，并将它们分配给优先级。 每个入站请求都会对所有 FlowSchema 测试是否匹配， 首先从 ​`matchingPrecedence` ​数值最低的匹配开始（我们认为这是逻辑上匹配度最高）， 然后依次进行，直到首个匹配出现。

> Caution: 对一个请求来说，只有首个匹配的 FlowSchema 才有意义。 如果一个入站请求与多个 FlowSchema 匹配，则将基于 ​`matchingPrecedence` ​值最高的请求进行筛选。 如果一个请求匹配多个 FlowSchema 且 ​`matchingPrecedence` ​的值相同，则按 ​`name` ​的字典序选择最小， 但是最好不要依赖它，而是确保不存在两个 FlowSchema 具有相同的 ​`matchingPrecedence` ​值。

当给定的请求与某个 FlowSchema 的 ​`rules` ​的其中一条匹配，那么就认为该请求与该 FlowSchema 匹配。 判断规则与该请求是否匹配，不仅要求该条规则的 ​`subjects` ​字段至少存在一个与该请求相匹配， 而且要求该条规则的 ​`resourceRules` ​或 ​`nonResourceRules` ​（取决于传入请求是针对资源URL还是非资源URL）字段至少存在一个与该请求相匹配。

对于 ​`subjects` ​中的 ​`name` ​字段和资源和非资源规则的 ​`verbs`​，​`apiGroups`​，​`resources`​，​`namespaces` ​和 ​`nonResourceURLs` ​字段， 可以指定通配符 ​`*`​ 来匹配任意值，从而有效地忽略该字段。

FlowSchema 的 ​`distinguisherMethod.type`​ 字段决定了如何把与该模式匹配的请求分散到各个流中。 可能是 ​`ByUser` ​，在这种情况下，一个请求用户将无法饿死其他容量的用户； 或者是 ​`ByNamespace` ​，在这种情况下，一个名称空间中的资源请求将无法饿死其它名称空间的资源请求； 或者它可以为空（或者可以完全省略 ​`distinguisherMethod`​）， 在这种情况下，与此 FlowSchema 匹配的请求将被视为单个流的一部分。 资源和你的特定环境决定了如何选择正确一个 FlowSchema。

默认值 
----

每个 kube-apiserver 会维护两种类型的 APF 配置对象：强制的（Mandatory）和建议的（Suggested）。

### 强制的配置对象

有四种强制的配置对象对应内置的守护行为。这里的行为是服务器在还未创建对象之前就具备的行为， 而当这些对象存在时，其规约反映了这类行为。四种强制的对象如下：

*   强制的 ​`exempt` ​优先级用于完全不受流控限制的请求：它们总是立刻被分发。 强制的 ​`exempt` ​FlowSchema 把 ​`system:masters`​ 组的所有请求都归入该优先级。 如果合适，你可以定义新的 FlowSchema，将其他请求定向到该优先级。
*   强制的 ​`catch-all`​ 优先级与强制的 ​`catch-all`​ FlowSchema 结合使用， 以确保每个请求都分类。一般而言，你不应该依赖于 ​`catch-all`​ 的配置， 而应适当地创建自己的 ​`catch-all`​ FlowSchema 和 PriorityLevelConfiguration （或使用默认安装的 ​`global-default`​ 配置）。 因为这一优先级不是正常场景下要使用的，​`catch-all`​ 优先级的并发度份额很小， 并且不会对请求进行排队。

### 建议的配置对象

建议的 FlowSchema 和 PriorityLevelConfiguration 包含合理的默认配置。 你可以修改这些对象或者根据需要创建新的配置对象。如果你的集群可能承受较重负载， 那么你就要考虑哪种配置最合适。

建议的配置把请求分为六个优先级：

*   ​`node-high`​ 优先级用于来自节点的健康状态更新。
*   ​`system` ​优先级用于 ​`system:nodes`​ 组（即 kubelet）的与健康状态更新无关的请求； kubelets 必须能连上 API 服务器，以便工作负载能够调度到其上。
*   ​`leader-election`​ 优先级用于内置控制器的领导选举的请求 （特别是来自 ​`kube-system`​ 名称空间中 ​`system:kube-controller-manager`​ 和 ​`system:kube-scheduler`​ 用户和服务账号，针对 ​`endpoints`​、​`configmaps` ​或 ​`leases` ​的请求）。 将这些请求与其他流量相隔离非常重要，因为领导者选举失败会导致控制器发生故障并重新启动， 这反过来会导致新启动的控制器在同步信息时，流量开销更大。
*   ​`workload-high`​ 优先级用于内置控制器的其他请求。
*   ​`workload-low`​ 优先级用于来自所有其他服务帐户的请求，通常包括来自 Pod 中运行的控制器的所有请求。
*   ​`global-default`​ 优先级可处理所有其他流量，例如：非特权用户运行的交互式 ​`kubectl` ​命令。

建议的 FlowSchema 用来将请求导向上述的优先级内，这里不再一一列举。

### 强制的与建议的配置对象的维护

每个 ​`kube-apiserver`​ 都独立地维护其强制的与建议的配置对象， 这一维护操作既是服务器的初始行为，也是其周期性操作的一部分。 因此，当存在不同版本的服务器时，如果各个服务器对于配置对象中的合适内容有不同意见， 就可能出现抖动。

每个 ​`kube-apiserver`​ 都会对强制的与建议的配置对象执行初始的维护操作， 之后（每分钟）对这些对象执行周期性的维护。

对于强制的配置对象，维护操作包括确保对象存在并且包含合适的规约（如果存在的话）。 服务器会拒绝创建或更新与其守护行为不一致的规约。

对建议的配置对象的维护操作被设计为允许其规约被重载。删除操作是不允许的， 维护操作期间会重建这类配置对象。如果你不需要某个建议的配置对象， 你需要将它放在一边，并让其规约所产生的影响最小化。 对建议的配置对象而言，其维护方面的设计也支持在上线新的 ​`kube-apiserver`​ 时完成自动的迁移动作，即便可能因为当前的服务器集合存在不同的版本而可能造成抖动仍是如此。

对建议的配置对象的维护操作包括基于服务器建议的规约创建对象 （如果对象不存在的话）。反之，如果对象已经存在，维护操作的行为取决于是否 ​`kube-apiserver`​ 或者用户在控制对象。如果 ​`kube-apiserver`​ 在控制对象， 则服务器确保对象的规约与服务器所给的建议匹配，如果用户在控制对象， 对象的规约保持不变。

关于谁在控制对象这个问题，首先要看对象上的 ​`apf.kubernetes.io/autoupdate-spec`​ 注解。如果对象上存在这个注解，并且其取值为​`true`​，则 kube-apiserver 在控制该对象。如果存在这个注解，并且其取值为​`false`​，则用户在控制对象。 如果这两个条件都不满足，则需要进一步查看对象的 ​`metadata.generation`​。 如果该值为 1，则 kube-apiserver 控制对象，否则用户控制对象。 这些规则是在 1.22 发行版中引入的，而对 ​`metadata.generation`​ 的考量是为了便于从之前较简单的行为迁移过来。希望控制建议的配置对象的用户应该将对象的 ​`apf.kubernetes.io/autoupdate-spec`​ 注解设置为 ​`false`​。

对强制的或建议的配置对象的维护操作也包括确保对象上存在 ​`apf.kubernetes.io/autoupdate-spec`​ 这一注解，并且其取值准确地反映了是否 kube-apiserver 在控制着对象。

维护操作还包括删除那些既非强制又非建议的配置，同时注解配置为 ​`apf.kubernetes.io/autoupdate-spec=true`​ 的对象。

健康检查并发豁免 
---------

推荐配置没有为本地 kubelet 对 kube-apiserver 执行健康检查的请求进行任何特殊处理 ——它们倾向于使用安全端口，但不提供凭据。 在推荐配置中，这些请求将分配 ​`global-default`​ FlowSchema 和 ​`global-default`​ 优先级， 这样其他流量可以排除健康检查。

如果添加以下 FlowSchema，健康检查请求不受速率限制。

> Caution: 进行此更改后，任何敌对方都可以发送与此 FlowSchema 匹配的任意数量的健康检查请求。 如果你有 Web 流量过滤器或类似的外部安全机制保护集群的 API 服务器免受常规网络流量的侵扰， 则可以配置规则，阻止所有来自集群外部的健康检查请求。

`apiVersion: flowcontrol.apiserver.k8s.io/v1beta2 kind: FlowSchema metadata:   name: health-for-strangers spec:   matchingPrecedence: 1000   priorityLevelConfiguration:     name: exempt   rules:   - nonResourceRules:     - nonResourceURLs:       - "/healthz"       - "/livez"       - "/readyz"       verbs:       - "*"     subjects:     - kind: Group       group:         name: system:unauthenticated`

问题诊断 
-----

启用了 APF 的 API 服务器，它每个 HTTP 响应都有两个额外的 HTTP 头： ​`X-Kubernetes-PF-FlowSchema-UID`​ 和 ​`X-Kubernetes-PF-PriorityLevel-UID`​， 注意与请求匹配的 FlowSchema 和已分配的优先级。 如果请求用户没有查看这些对象的权限，则这些 HTTP 头中将不包含 API 对象的名称， 因此在调试时，你可以使用类似如下的命令：

`kubectl get flowschemas -o custom-columns="uid:{metadata.uid},name:{metadata.name}" kubectl get prioritylevelconfigurations -o custom-columns="uid:{metadata.uid},name:{metadata.name}"`             

来获取 UID 到 FlowSchema 的名称和 UID 到 PriorityLevelConfigurations 的名称的映射。

可观察性 
-----

### 指标

> Note: 在 Kubernetes v1.20 之前的版本中，标签 ​`flow_schema` ​和 ​`priority_level`​ 的名称有时被写作 ​`flowSchema` ​和 ​`priorityLevel`​，即存在不一致的情况。 如果你在运行 Kubernetes v1.19 或者更早版本，你需要参考你所使用的集群 版本对应的文档。

当你开启了 APF 后，kube-apiserver 会暴露额外指标。 监视这些指标有助于判断你的配置是否不当地限制了重要流量， 或者发现可能会损害系统健康的，行为不良的工作负载。

*   ​`apiserver_flowcontrol_rejected_requests_total` ​是一个计数器向量， 记录被拒绝的请求数量（自服务器启动以来累计值）， 由标签 ​`flow_chema`​（表示与请求匹配的 FlowSchema），​`priority_evel` ​（表示分配给请该求的优先级）和 ​`reason` ​来区分。 ​`reason` ​标签将具有以下值之一：

*   ​`queue-full`​ ，表明已经有太多请求排队，
*   ​`concurrency-limit`​，表示将 PriorityLevelConfiguration 配置为 ​`Reject` ​而不是 ​`Queue` ​，或者
*   ​`time-out`​, 表示在其排队时间超期的请求仍在队列中。

*   ​`apiserver_flowcontrol_dispatched_requests_total`​ 是一个计数器向量， 记录开始执行的请求数量（自服务器启动以来的累积值）， 由标签 ​`flow_schema`​（表示与请求匹配的 FlowSchema）和 ​`priority_level`​（表示分配给该请求的优先级）来区分。
*   ​`apiserver_current_inqueue_requests` ​是一个表向量， 记录最近排队请求数量的高水位线， 由标签 ​`request_kind` ​分组，标签的值为 ​`mutating` ​或 ​`readOnly`​。 这些高水位线表示在最近一秒钟内看到的最大数字。 它们补充说明了老的表向量 ​`apiserver_current_inflight_requests` ​（该量保存了最后一个窗口中，正在处理的请求数量的高水位线）。
*   ​`apiserver_flowcontrol_read_vs_write_request_count_samples` ​是一个直方图向量， 记录当前请求数量的观察值， 由标签 ​`phase`​（取值为 ​`waiting` ​和 ​`executing`​）和 ​`request_kind` ​（取值 ​`mutating` ​和 ​`readOnly`​）拆分。定期以高速率观察该值。
*   ​`apiserver_flowcontrol_read_vs_write_request_count_watermarks` ​是一个直方图向量， 记录请求数量的高/低水位线， 由标签 ​`phase`​（取值为 ​`waiting` ​和 ​`executing`​）和 ​`request_kind` ​（取值为 ​`mutating` ​和 ​`readOnly`​）拆分；标签 ​`mark` ​取值为 ​`high` ​和 ​`low` ​。 ​`apiserver_flowcontrol_read_vs_write_request_count_samples` ​向量观察到有值新增， 则该向量累积。这些水位线显示了样本值的范围。
*   ​`apiserver_flowcontrol_current_inqueue_requests` ​是一个表向量， 记录包含排队中的（未执行）请求的瞬时数量， 由标签 ​`priorityLevel` ​和 ​`flowSchema` ​拆分。
*   ​`apiserver_flowcontrol_current_executing_requests` ​是一个表向量， 记录包含执行中（不在队列中等待）请求的瞬时数量， 由标签 ​`priority_level` ​和 ​`flow_schema` ​进一步区分。
*   ​`apiserver_flowcontrol_request_concurrency_in_use` ​是一个规范向量， 包含占用座位的瞬时数量，由标签 ​`priority_level` ​和 ​`flow_schema` ​进一步区分。
*   ​`apiserver_flowcontrol_priority_level_request_count_samples` ​是一个直方图向量， 记录当前请求的观测值，由标签 ​`phase`​（取值为​`waiting` ​和 ​`executing`​）和 ​`priority_level` ​进一步区分。 每个直方图都会定期进行观察，直到相关类别的最后活动为止。观察频率高。
*   ​`apiserver_flowcontrol_priority_level_request_count_watermarks` ​是一个直方图向量， 记录请求数的高/低水位线，由标签 ​`phase`​（取值为 ​`waiting` ​和 ​`executing`​）和 ​`priority_level` ​拆分； 标签 ​`mark` ​取值为 ​`high` ​和 ​`low` ​。 ​`apiserver_flowcontrol_priority_level_request_count_samples` ​向量观察到有值新增， 则该向量累积。这些水位线显示了样本值的范围。
*   ​`apiserver_flowcontrol_request_queue_length_after_enqueue` ​是一个直方图向量， 记录请求队列的长度，由标签 ​`priority_level` ​和 ​`flow_schema` ​进一步区分。 每个排队中的请求都会为其直方图贡献一个样本，并在添加请求后立即上报队列的长度。 请注意，这样产生的统计数据与无偏调查不同。

> Note: 直方图中的离群值在这里表示单个流（即，一个用户或一个名称空间的请求， 具体取决于配置）正在疯狂地向 API 服务器发请求，并受到限制。 相反，如果一个优先级的直方图显示该优先级的所有队列都比其他优先级的队列长， 则增加 PriorityLevelConfigurations 的并发份额是比较合适的。

*   ​`apiserver_flowcontrol_request_concurrency_limit` ​是一个表向量， 记录并发限制的计算值（基于 API 服务器的总并发限制和 PriorityLevelConfigurations 的并发份额），并按标签 ​`priority_level` ​进一步区分。
*   ​`apiserver_flowcontrol_request_wait_duration_seconds` ​是一个直方图向量， 记录请求排队的时间， 由标签 ​`flow_schema`​（表示与请求匹配的 FlowSchema ）， ​`priority_level`​（表示分配该请求的优先级） 和 ​`execute`​（表示请求是否开始执行）进一步区分。

> Note: 由于每个 FlowSchema 总会给请求分配 PriorityLevelConfigurations， 因此你可以为一个优先级添加所有 FlowSchema 的直方图，以获取分配给 该优先级的请求的有效直方图。

*   ​`apiserver_flowcontrol_request_execution_seconds` ​是一个直方图向量， 记录请求实际执行需要花费的时间， 由标签 ​`flow_schema`​（表示与请求匹配的 FlowSchema ）和 ​`priority_level`​（表示分配给该请求的优先级）进一步区分。

### 调试端点 

启用 APF 特性后， kube-apiserver 会在其 HTTP/HTTPS 端口提供以下路径：

*   ​`/debug/api_priority_and_fairness/dump_priority_levels`​ —— 所有优先级及其当前状态的列表。你可以这样获取：

`kubectl get --raw /debug/api_priority_and_fairness/dump_priority_levels`

输出类似于：

`PriorityLevelName, ActiveQueues, IsIdle, IsQuiescing, WaitingRequests, ExecutingRequests, workload-low,      0,            true,   false,       0,               0, global-default,    0,            true,   false,       0,               0, exempt,            <none>,       <none>, <none>,      <none>,          <none>, catch-all,         0,            true,   false,       0,               0, system,            0,            true,   false,       0,               0, leader-election,   0,            true,   false,       0,               0, workload-high,     0,            true,   false,       0,               0,`

*   ​`/debug/api_priority_and_fairness/dump_queues`​ —— 所有队列及其当前状态的列表。 你可以这样获取：

`kubectl get --raw /debug/api_priority_and_fairness/dump_queues`

输出类似于：

`PriorityLevelName, Index,  PendingRequests, ExecutingRequests, VirtualStart, workload-high,     0,      0,               0,                 0.0000, workload-high,     1,      0,               0,                 0.0000, workload-high,     2,      0,               0,                 0.0000, ... leader-election,   14,     0,               0,                 0.0000, leader-election,   15,     0,               0,                 0.0000,`

*   ​`/debug/api_priority_and_fairness/dump_requests`​ ——当前正在队列中等待的所有请求的列表。 你可以这样获取：

`kubectl get --raw /debug/api_priority_and_fairness/dump_requests`

输出类似于：

`PriorityLevelName, FlowSchemaName, QueueIndex, RequestIndexInQueue, FlowDistingsher,       ArriveTime, exempt,            <none>,         <none>,     <none>,              <none>,                <none>, system,            system-nodes,   12,         0,                   system:node:127.0.0.1, 2020-07-23T15:26:57.179170694Z,`

针对每个优先级别，输出中还包含一条虚拟记录，对应豁免限制。

你可以使用以下命令获得更详细的清单：

`kubectl get --raw '/debug/api_priority_and_fairness/dump_requests?includeRequestDetails=1'`

输出类似于：

`PriorityLevelName, FlowSchemaName, QueueIndex, RequestIndexInQueue, FlowDistingsher,       ArriveTime,                     UserName,              Verb,   APIPath,                                                     Namespace, Name,   APIVersion, Resource, SubResource, system,            system-nodes,   12,         0,                   system:node:127.0.0.1, 2020-07-23T15:31:03.583823404Z, system:node:127.0.0.1, create, /api/v1/namespaces/scaletest/configmaps, system,            system-nodes,   12,         1,                   system:node:127.0.0.1, 2020-07-23T15:31:03.594555947Z, system:node:127.0.0.1, create, /api/v1/namespaces/scaletest/configmaps,`

##  9.  Kubernetes 安装扩展（Addons）
安装扩展（Addons）
------------

Add-ons 扩展了 Kubernetes 的功能。

本文列举了一些可用的 add-ons 以及到它们各自安装说明的链接。

每个 Add-ons 按字母顺序排序 - 顺序不代表任何优先地位。

网络和网络策略
-------

*   [ACI](https://www.github.com/noironetworks/aci-containers) 通过 Cisco ACI 提供集成的容器网络和安全网络。
*   [Antrea](https://antrea.io/) 在第 3/4 层执行操作，为 Kubernetes 提供网络连接和安全服务。Antrea 利用 Open vSwitch 作为网络的数据面。
*   [Calico](https://docs.projectcalico.org/v3.11/getting-started/kubernetes/installation/calico) 是一个安全的 L3 网络和网络策略驱动。
*   [Canal](https://github.com/tigera/canal/tree/master/k8s-install) 结合 Flannel 和 Calico，提供网络和网络策略。
*   [Cilium](https://github.com/cilium/cilium) 是一个 L3 网络和网络策略插件，能够透明的实施 HTTP/API/L7 策略。 同时支持路由（routing）和覆盖/封装（overlay/encapsulation）模式。
*   [CNI-Genie](https://github.com/Huawei-PaaS/CNI-Genie) 使 Kubernetes 无缝连接到一种 CNI 插件， 例如：Flannel、Calico、Canal、Romana 或者 Weave。
*   [Contiv](https://contivpp.io/) 为各种用例和丰富的策略框架提供可配置的网络 （使用 BGP 的本机 L3、使用 vxlan 的覆盖、标准 L2 和 Cisco-SDN/ACI）。 Contiv 项目完全[开源](https://github.com/contiv)。 [安装程序](https://github.com/contiv/install) 提供了基于 kubeadm 和非 kubeadm 的安装选项。
*   基于 [Tungsten Fabric](https://tungsten.io/) 的 [Contrail](https://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/) 是一个开源的多云网络虚拟化和策略管理平台，Contrail 和 Tungsten Fabric 与业务流程系统 （例如 Kubernetes、OpenShift、OpenStack和Mesos）集成在一起， 为虚拟机、容器或 Pod 以及裸机工作负载提供了隔离模式。
*   [Flannel](https://github.com/flannel-io/flannel target=) 是一个可以用于 Kubernetes 的 overlay 网络提供者。
*   [Knitter](https://github.com/ZTE/Knitter/) 是为 kubernetes 提供复合网络解决方案的网络组件。
*   Multus 是一个多插件，可在 Kubernetes 中提供多种网络支持， 以支持所有 CNI 插件（例如 Calico，Cilium，Contiv，Flannel）， 而且包含了在 Kubernetes 中基于 SRIOV、DPDK、OVS-DPDK 和 VPP 的工作负载。
*   [OVN-Kubernetes](https://github.com/ovn-org/ovn-kubernetes/) 是一个 Kubernetes 网络驱动， 基于 [OVN（Open Virtual Network）](https://github.com/ovn-org/ovn/)实现，是从 Open vSwitch (OVS) 项目衍生出来的虚拟网络实现。 OVN-Kubernetes 为 Kubernetes 提供基于覆盖网络的网络实现，包括一个基于 OVS 实现的负载均衡器 和网络策略。
*   [OVN4NFV-K8S-Plugin](https://github.com/opnfv/ovn4nfv-k8s-plugin) 是一个基于 OVN 的 CNI 控制器插件，提供基于云原生的服务功能链条（Service Function Chaining，SFC）、多种 OVN 覆盖 网络、动态子网创建、动态虚拟网络创建、VLAN 驱动网络、直接驱动网络，并且可以 驳接其他的多网络插件，适用于基于边缘的、多集群联网的云原生工作负载。
*   [NSX-T](https://docs.vmware.com/en/VMware-NSX-T/2.0/nsxt_20_ncp_kubernetes.pdf) 容器插件（NCP） 提供了 VMware NSX-T 与容器协调器（例如 Kubernetes）之间的集成，以及 NSX-T 与基于容器的 CaaS / PaaS 平台（例如关键容器服务（PKS）和 OpenShift）之间的集成。
*   [Nuage](https://github.com/nuagenetworks/nuage-kubernetes/blob/v5.1.1-1/docs/kubernetes-1-installation.rst) 是一个 SDN 平台，可在 Kubernetes Pods 和非 Kubernetes 环境之间提供基于策略的联网，并具有可视化和安全监控。
*   Romana 是一个 pod 网络的第三层解决方案，并支持 NetworkPolicy API。 Kubeadm add-on 安装细节可以在[这里](https://github.com/romana/romana/tree/master/containerize)找到。
*   [Weave Net](https://www.weave.works/docs/net/latest/kubernetes/kube-addon/) 提供在网络分组两端参与工作的网络和网络策略，并且不需要额外的数据库。

服务发现 
-----

[CoreDNS](https://coredns.io/) 是一种灵活的，可扩展的 DNS 服务器，可以 [安装](https://github.com/coredns/deployment/tree/master/kubernetes)为集群内的 Pod 提供 DNS 服务。

可视化管理
-----

[Dashboard](https://github.com/kubernetes/dashboard target=) 是一个 Kubernetes 的 Web 控制台界面。

[Weave Scope](https://www.weave.works/docs/scope/latest/installing/ target=) 是一个图形化工具， 用于查看你的容器、Pod、服务等。请和一个 [Weave Cloud 账号](https://cloud.weave.works/) 一起使用， 或者自己运行 UI。

基础设施
----

[KubeVirt](https://kubevirt.io/user-guide/ target=) 是可以让 Kubernetes 运行虚拟机的 add-ons。通常运行在裸机集群上。

[节点问题检测器](https://github.com/kubernetes/node-problem-detector) 在 Linux 节点上运行， 并将系统问题报告为事件 或节点状况。

遗留 Add-ons
----------

还有一些其它 add-ons 归档在已废弃的 [cluster/addons](https://github.com/kubernetes/kubernetes/tree/master/cluster/addons) 路径中。

维护完善的 add-ons 应该被链接到这里。欢迎提出 PRs！

#  16.  Kubernetes 扩展

##  1.  Kubernetes 扩展API

###  1.  Kubernetes 定制资源
定制资源
----

资源（Resource） 是 Kubernetes API 中的一个端点， 其中存储的是某个类别的 API 对象 的一个集合。 例如内置的 pods 资源包含一组 Pod 对象。

定制资源（Custom Resource） 是对 Kubernetes API 的扩展，不一定在默认的 Kubernetes 安装中就可用。定制资源所代表的是对特定 Kubernetes 安装的一种定制。 不过，很多 Kubernetes 核心功能现在都用定制资源来实现，这使得 Kubernetes 更加模块化。

定制资源可以通过动态注册的方式在运行中的集群内或出现或消失，集群管理员可以独立于集群 更新定制资源。一旦某定制资源被安装，用户可以使用 kubectl 来创建和访问其中的对象，就像他们为 pods 这种内置资源所做的一样。

定制控制器 
------

就定制资源本身而言，它只能用来存取结构化的数据。 当你将定制资源与 定制控制器（Custom Controller） 相结合时，定制资源就能够 提供真正的 声明式 API（Declarative API）。

使用声明式 API， 你可以 声明 或者设定你的资源的期望状态，并尝试让 Kubernetes 对象的当前状态 同步到其期望状态。控制器负责将结构化的数据解释为用户所期望状态的记录，并 持续地维护该状态。

你可以在一个运行中的集群上部署和更新定制控制器，这类操作与集群的生命周期无关。 定制控制器可以用于任何类别的资源，不过它们与定制资源结合起来时最为有效。 Operator 模式就是将定制资源 与定制控制器相结合的。你可以使用定制控制器来将特定于某应用的领域知识组织 起来，以编码的形式构造对 Kubernetes API 的扩展。

我是否应该向我的 Kubernetes 集群添加定制资源？
-----------------------------

在创建新的 API 时，请考虑是 将你的 API 与 Kubernetes 集群 API 聚合起来 还是让你的 API 独立运行。

考虑 API 聚合的情况

优选独立 API 的情况

你的 API 是声明式的。

你的 API 不符合声明式模型。

你希望可以是使用 `kubectl` 来读写你的新资源类别。

不要求 `kubectl` 支持。

你希望在 Kubernetes UI （如仪表板）中和其他内置类别一起查看你的新资源类别。

不需要 Kubernetes UI 支持。

你在开发新的 API。

你已经有一个提供 API 服务的程序并且工作良好。

你有意愿取接受 Kubernetes 对 REST 资源路径所作的格式限制，例如 API 组和名字空间。（参阅 API 概述）

你需要使用一些特殊的 REST 路径以便与已经定义的 REST API 保持兼容。

你的资源可以自然地界定为集群作用域或集群中某个名字空间作用域。

集群作用域或名字空间作用域这种二分法很不合适；你需要对资源路径的细节进行控制。

你希望复用 Kubernetes API 支持特性。

你不需要这类特性。

#### 声明式 APIs

典型地，在声明式 API 中：

*   你的 API 包含相对而言为数不多的、尺寸较小的对象（资源）。
*   对象定义了应用或者基础设施的配置信息。
*   对象更新操作频率较低。
*   通常需要人来读取或写入对象。
*   对象的主要操作是 CRUD 风格的（创建、读取、更新和删除）。
*   不需要跨对象的事务支持：API 对象代表的是期望状态而非确切实际状态。

命令式 API（Imperative API）与声明式有所不同。 以下迹象表明你的 API 可能不是声明式的：

*   客户端发出“做这个操作”的指令，之后在该操作结束时获得同步响应。
*   客户端发出“做这个操作”的指令，并获得一个操作 ID，之后需要检查一个 Operation（操作） 对象来判断请求是否成功完成。
*   你会将你的 API 类比为远程过程调用（Remote Procedure Call，RPCs）。
*   直接存储大量数据；例如每个对象几 kB，或者存储上千个对象。
*   需要较高的访问带宽（长期保持每秒数十个请求）。
*   存储有应用来处理的最终用户数据（如图片、个人标识信息（PII）等）或者其他大规模数据。
*   在对象上执行的常规操作并非 CRUD 风格。
*   API 不太容易用对象来建模。
*   你决定使用操作 ID 或者操作对象来表现悬决的操作。

我应该使用一个 ConfigMap 还是一个定制资源？
---------------------------

如果满足以下条件之一，应该使用 ConfigMap：

*   存在一个已有的、文档完备的配置文件格式约定，例如 ​`mysql.cnf`​ 或 ​`pom.xml`​。
*   你希望将整个配置文件放到某 configMap 中的一个主键下面。
*   配置文件的主要用途是针对运行在集群中 Pod 内的程序，供后者依据文件数据配置自身行为。
*   文件的使用者期望以 Pod 内文件或者 Pod 内环境变量的形式来使用文件数据， 而不是通过 Kubernetes API。
*   你希望当文件被更新时通过类似 Deployment 之类的资源完成滚动更新操作。

> Note: 请使用 Secret 来保存敏感数据。 Secret 类似于 configMap，但更为安全。

如果以下条件中大多数都被满足，你应该使用定制资源（CRD 或者 聚合 API）：

*   你希望使用 Kubernetes 客户端库和 CLI 来创建和更改新的资源。
*   你希望 ​`kubectl` ​能够直接支持你的资源；例如，​`kubectl get my-object object-name`​。
*   你希望构造新的自动化机制，监测新对象上的更新事件，并对其他对象执行 CRUD 操作，或者监测后者更新前者。
*   你希望编写自动化组件来处理对对象的更新。
*   你希望使用 Kubernetes API 对诸如 ​`.spec`​、​`.status`​ 和 ​`.metadata`​ 等字段的约定。
*   你希望对象是对一组受控资源的抽象，或者对其他资源的归纳提炼。

添加定制资源 
-------

Kubernetes 提供了两种方式供你向集群中添加定制资源：

*   CRD 相对简单，创建 CRD 可以不必编程。
*   API 聚合 需要编程，但支持对 API 行为进行更多的控制，例如数据如何存储以及在不同 API 版本间如何转换等。

Kubernetes 提供这两种选项以满足不同用户的需求，这样就既不会牺牲易用性也不会牺牲灵活性。

聚合 API 指的是一些下位的 API 服务器，运行在主 API 服务器后面；主 API 服务器以代理的方式工作。这种组织形式称作 API 聚合（API Aggregation，AA） 。 对用户而言，看起来仅仅是 Kubernetes API 被扩展了。

CRD 允许用户创建新的资源类别同时又不必添加新的 API 服务器。 使用 CRD 时，你并不需要理解 API 聚合。

无论以哪种方式安装定制资源，新的资源都会被当做定制资源，以便与内置的 Kubernetes 资源（如 Pods）相区分。

CustomResourceDefinitions
-------------------------

CustomResourceDefinition API 资源允许你定义定制资源。 定义 CRD 对象的操作会使用你所设定的名字和模式定义（Schema）创建一个新的定制资源， Kubernetes API 负责为你的定制资源提供存储和访问服务。 CRD 对象的名称必须是合法的 DNS 子域名。

CRD 使得你不必编写自己的 API 服务器来处理定制资源，不过其背后实现的通用性也意味着 你所获得的灵活性要比 API 服务器聚合少很多。

关于如何注册新的定制资源、使用新资源类别的实例以及如何使用控制器来处理事件， 相关的例子可参见[定制控制器示例](https://github.com/kubernetes/sample-controller)。

API 服务器聚合 
----------

通常，Kubernetes API 中的每个资源都需要处理 REST 请求和管理对象持久性存储的代码。 Kubernetes API 主服务器能够处理诸如 pods 和 services 这些内置资源，也可以 按通用的方式通过 CRD 来处理定制资源。

聚合层（Aggregation Layer） 使得你可以通过编写和部署你自己的 API 服务器来为定制资源提供特殊的实现。 主 API 服务器将针对你要处理的定制资源的请求全部委托给你自己的 API 服务器来处理，同时将这些资源 提供给其所有客户端。

选择添加定制资源的方法 
------------

CRD 更为易用；聚合 API 则更为灵活。请选择最符合你的需要的方法。

通常，如何存在以下情况，CRD 可能更合适：

*   定制资源的字段不多；
*   你在组织内部使用该资源或者在一个小规模的开源项目中使用该资源，而不是 在商业产品中使用。

#### 比较易用性 

CRD 比聚合 API 更容易创建

CRDs

聚合 API

无需编程。用户可选择任何语言来实现 CRD 控制器。

需要使用 Go 来编程，并构建可执行文件和镜像。

无需额外运行服务；CRD 由 API 服务器处理。

需要额外创建服务，且该服务可能失效。

一旦 CRD 被创建，不需要持续提供支持。Kubernetes 主控节点升级过程中自动会带入缺陷修复。

可能需要周期性地从上游提取缺陷修复并更新聚合 API 服务器。

无需处理 API 的多个版本；例如，当你控制资源的客户端时，你可以更新它使之与 API 同步。

你需要处理 API 的多个版本；例如，在开发打算与很多人共享的扩展时。

#### 高级特性与灵活性 

聚合 API 可提供更多的高级 API 特性，也可对其他特性实行定制；例如，对存储层进行定制。

特性

描述

CRDs

聚合 API

合法性检查

帮助用户避免错误，允许你独立于客户端版本演化 API。这些特性对于由很多无法同时更新的客户端的场合。

可以。大多数验证可以使用 OpenAPI v3.0 合法性检查 来设定。其他合法性检查操作可以通过添加合法性检查 Webhook来实现。

可以，可执行任何合法性检查。

默认值设置

同上

可以。可通过 OpenAPI v3.0 合法性检查的 `default` 关键词（自 1.17 正式发布）或更改性（Mutating）Webhook来实现（不过从 etcd 中读取老的对象时不会执行这些 Webhook）。

可以。

多版本支持

允许通过两个 API 版本同时提供同一对象。可帮助简化类似字段更名这类 API 操作。如果你能控制客户端版本，这一特性将不再重要。

可以。

可以。

定制存储

支持使用具有不同性能模式的存储（例如，要使用时间序列数据库而不是键值存储），或者因安全性原因对存储进行隔离（例如对敏感信息执行加密）。

不可以。

可以。

定制业务逻辑

在创建、读取、更新或删除对象时，执行任意的检查或操作。

可以。要使用 Webhook。

可以。

支持 scale 子资源

允许 HorizontalPodAutoscaler 和 PodDisruptionBudget 这类子系统与你的新资源交互。

可以。

可以。

支持 status 子资源

允许在用户写入 spec 部分而控制器写入 status 部分时执行细粒度的访问控制。允许在对定制资源的数据进行更改时增加对象的代际（Generation）；这需要资源对 spec 和 status 部分有明确划分。

可以。

可以。

其他子资源

添加 CRUD 之外的操作，例如 "logs" 或 "exec"。

不可以。

可以。

strategic-merge-patch

新的端点要支持标记了 `Content-Type: application/strategic-merge-patch+json` 的 PATCH 操作。对于更新既可在本地更改也可在服务器端更改的对象而言是有用的。要了解更多信息，可参见使用 kubectl patch 来更新 API 对象。

不可以。

可以。

支持协议缓冲区

新的资源要支持想要使用协议缓冲区（Protocol Buffer）的客户端。

不可以。

可以。

OpenAPI Schema

是否存在新资源类别的 OpenAPI（Swagger）Schema 可供动态从服务器上读取？是否存在机制确保只能设置被允许的字段以避免用户犯字段拼写错误？是否实施了字段类型检查（换言之，不允许在 `string` 字段设置 `int` 值）？

可以，依据 OpenAPI v3.0 合法性检查 模式（1.16 中进入正式发布状态）。

可以。

#### 公共特性 

与在 Kubernetes 平台之外实现定制资源相比， 无论是通过 CRD 还是通过聚合 API 来创建定制资源，你都会获得很多 API 特性：

功能特性

具体含义

CRUD

新的端点支持通过 HTTP 和 `kubectl` 发起的 CRUD 基本操作

监测（Watch）

新的端点支持通过 HTTP 发起的 Kubernetes Watch 操作

发现（Discovery）

类似 `kubectl` 和仪表盘（Dashboard）这类客户端能够自动提供列举、显示、在字段级编辑你的资源的操作

json-patch

新的端点支持带 `Content-Type: application/json-patch+json` 的 PATCH 操作

merge-patch

新的端点支持带 `Content-Type: application/merge-patch+json` 的 PATCH 操作

HTTPS

新的端点使用 HTTPS

内置身份认证

对扩展的访问会使用核心 API 服务器（聚合层）来执行身份认证操作

内置鉴权授权

对扩展的访问可以复用核心 API 服务器所使用的鉴权授权机制；例如，RBAC

Finalizers

在外部清除工作结束之前阻止扩展资源被删除

准入 Webhooks

在创建、更新和删除操作中对扩展资源设置默认值和执行合法性检查

UI/CLI 展示

`kubectl` 和仪表盘（Dashboard）可以显示扩展资源

区分未设置值和空值

客户端能够区分哪些字段是未设置的，哪些字段的值是被显式设置为零值的。

生成客户端库

Kubernetes 提供通用的客户端库，以及用来生成特定类别客户端库的工具

标签和注解

提供涵盖所有对象的公共元数据结构，且工具知晓如何编辑核心资源和定制资源的这些元数据

准备安装定制资源
--------

在向你的集群添加定制资源之前，有些事情需要搞清楚。

#### 第三方代码和新的失效点的问题

尽管添加新的 CRD 不会自动带来新的失效点（Point of Failure），例如导致第三方代码被在 API 服务器上运行， 类似 Helm Charts 这种软件包或者其他安装包通常在提供 CRD 的同时还包含带有第三方 代码的 Deployment，负责实现新的定制资源的业务逻辑。

安装聚合 API 服务器时，也总会牵涉到运行一个新的 Deployment。

#### 存储 

定制资源和 ConfigMap 一样也会消耗存储空间。创建过多的定制资源可能会导致 API 服务器上的存储空间超载。

聚合 API 服务器可以使用主 API 服务器的同一存储。如果是这样，你也要注意 此警告。

#### 身份认证、鉴权授权以及审计

CRD 通常与 API 服务器上的内置资源一样使用相同的身份认证、鉴权授权 和审计日志机制。

如果你使用 RBAC 来执行鉴权授权，大多数 RBAC 角色都会授权对新资源的访问 （除了 cluster-admin 角色以及使用通配符规则创建的其他角色）。 你要显式地为新资源的访问授权。CRD 和聚合 API 通常在交付时会包含 针对所添加的类别的新的角色定义。

聚合 API 服务器可能会使用主 API 服务器相同的身份认证、鉴权授权和审计 机制，也可能不会。

访问定制资源
------

Kubernetes 客户端库可用来访问定制资源。 并非所有客户端库都支持定制资源。Go 和 Python 客户端库是支持的。

当你添加了新的定制资源后，可以用如下方式之一访问它们：

*   ​`kubectl` ​
*   Kubernetes 动态客户端
*   你所编写的 REST 客户端
*   使用 [Kubernetes 客户端生成工具](https://github.com/kubernetes/code-generator) 所生成的客户端。生成客户端的工作有些难度，不过某些项目可能会随着 CRD 或 聚合 API 一起提供一个客户端

###  2.  Kubernetes 通过聚合层扩展API
通过聚合层扩展 Kubernetes API
----------------------

使用聚合层（Aggregation Layer），用户可以通过额外的 API 扩展 Kubernetes， 而不局限于 Kubernetes 核心 API 提供的功能。

这里的附加 API 可以是现成的解决方案比如 [metrics server](https://github.com/kubernetes-sigs/metrics-server), 或者你自己开发的 API。

聚合层不同于 定制资源（Custom Resources）。 后者的目的是让 kube-apiserver 能够认识新的对象类别（Kind）。

聚合层 
----

聚合层在 kube-apiserver 进程内运行。在扩展资源注册之前，聚合层不做任何事情。 要注册 API，用户必须添加一个 APIService 对象，用它来“申领” Kubernetes API 中的 URL 路径。 自此以后，聚合层将会把发给该 API 路径的所有内容（例如 ​`/apis/myextension.mycompany.io/v1/…`​） 转发到已注册的 APIService。

APIService 的最常见实现方式是在集群中某 Pod 内运行 扩展 API 服务器。 如果你在使用扩展 API 服务器来管理集群中的资源，该扩展 API 服务器（也被写成“extension-apiserver”） 一般需要和一个或多个控制器一起使用。 apiserver-builder 库同时提供构造扩展 API 服务器和控制器框架代码。

#### 反应延迟 

扩展 API 服务器与 kube-apiserver 之间需要存在低延迟的网络连接。 发现请求需要在五秒钟或更短的时间内完成到 kube-apiserver 的往返。

如果你的扩展 API 服务器无法满足这一延迟要求，应考虑如何更改配置以满足需要。

##  2.  Kubernetes Operator模式
Operator 模式
-----------

Operator 是 Kubernetes 的扩展软件，它利用 定制资源 管理应用及其组件。 Operator 遵循 Kubernetes 的理念，特别是在控制器 方面。

初衷
--

Operator 模式旨在捕获（正在管理一个或一组服务的）运维人员的关键目标。 负责特定应用和 service 的运维人员，在系统应该如何运行、如何部署以及出现问题时如何处理等方面有深入的了解。

在 Kubernetes 上运行工作负载的人们都喜欢通过自动化来处理重复的任务。 Operator 模式会封装你编写的（Kubernetes 本身提供功能以外的）任务自动化代码。

Kubernetes 上的 Operator
----------------------

Kubernetes 为自动化而生。无需任何修改，你即可以从 Kubernetes 核心中获得许多内置的自动化功能。 你可以使用 Kubernetes 自动化部署和运行工作负载， 甚至 可以自动化 Kubernetes 自身。

Kubernetes 的 Operator 模式概念允许你在不修改 Kubernetes 自身代码的情况下，通过为一个或多个自定义资源关联控制器 来扩展集群的能力。 Operator 是 Kubernetes API 的客户端，充当 自定义资源 的控制器。

Operator 示例
-----------

使用 Operator 可以自动化的事情包括：

*   按需部署应用
*   获取/还原应用状态的备份
*   处理应用代码的升级以及相关改动。例如，数据库 schema 或额外的配置设置
*   发布一个 service，要求不支持 Kubernetes API 的应用也能发现它
*   模拟整个或部分集群中的故障以测试其稳定性
*   在没有内部成员选举程序的情况下，为分布式应用选择首领角色

想要更详细的了解 Operator？下面是一个示例：

1.  有一个名为 SampleDB 的自定义资源，你可以将其配置到集群中。
2.  一个包含 Operator 控制器部分的 Deployment，用来确保 Pod 处于运行状态。
3.  Operator 代码的容器镜像。
4.  控制器代码，负责查询控制平面以找出已配置的 SampleDB 资源。
5.  Operator 的核心是告诉 API 服务器，如何使现实与代码里配置的资源匹配。

*   如果添加新的 SampleDB，Operator 将设置 PersistentVolumeClaims 以提供 持久化的数据库存储，设置 StatefulSet 以运行 SampleDB，并设置 Job 来处理初始配置。
*   如果你删除它，Operator 将建立快照，然后确保 StatefulSet 和 Volume 已被删除。

7.  Operator 也可以管理常规数据库的备份。对于每个 SampleDB 资源，Operator 会确定何时创建（可以连接到数据库并进行备份的）Pod。这些 Pod 将依赖于 ConfigMap 和/或具有数据库连接详细信息和凭据的 Secret。
8.  由于 Operator 旨在为其管理的资源提供强大的自动化功能，因此它还需要一些 额外的支持性代码。在这个示例中，代码将检查数据库是否正运行在旧版本上， 如果是，则创建 Job 对象为你升级数据库。

部署 Operator 
------------

部署 Operator 最常见的方法是将自定义资源及其关联的控制器添加到你的集群中。 跟运行容器化应用一样，控制器通常会运行在 控制平面 之外。 例如，你可以在集群中将控制器作为 Deployment 运行。

使用 Operator
-----------

部署 Operator 后，你可以对 Operator 所使用的资源执行添加、修改或删除操作。 按照上面的示例，你将为 Operator 本身建立一个 Deployment，然后：

`kubectl get SampleDB                   # 查找所配置的数据库  kubectl edit SampleDB/example-database # 手动修改某些配置`

可以了！Operator 会负责应用所作的更改并保持现有服务处于良好的状态。

编写你自己的 Operator
---------------

如果生态系统中没可以实现你目标的 Operator，你可以自己编写代码。

你还可以使用任何支持 Kubernetes API 客户端 的语言或运行时来实现 Operator（即控制器）。

以下是一些库和工具，你可用于编写自己的云原生 Operator。

*   [Charmed Operator Framework](https://juju.is/)
*   [Kopf](https://github.com/nolar/kopf) (Kubernetes Operator Pythonic Framework)
*   [kubebuilder](https://book.kubebuilder.io/)
*   [KubeOps](https://buehler.github.io/dotnet-operator-sdk/) (dotnet operator SDK)
*   [KUDO](https://kudo.dev/) (Kubernetes 通用声明式 Operator)
*   [Metacontroller](https://metacontroller.github.io/metacontroller/intro.html)，可与 Webhooks 结合使用，以实现自己的功能。
*   [Operator Framework](https://operatorframework.io/)
*   [shell-operator](https://github.com/flant/shell-operator)

##  3.  Kubernetes 计算、存储和网络扩展

###  1.  Kubernetes 网络插件
网络插件
----

Kubernetes 1.24 支持[容器网络接口](https://github.com/containernetworking/cni) (CNI) 集群网络插件。 你必须使用和你的集群相兼容并且满足你的需求的 CNI 插件。 在更广泛的 Kubernetes 生态系统中你可以使用不同的插件（开源和闭源）。

你必须使用与 [v0.4.0](https://github.com/containernetworking/cni/blob/spec-v0.4.0/SPEC.md) 或更高版本的 CNI 规范相符合的 CNI 插件。 Kubernetes 推荐使用一个兼容 [v1.0.0](https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md) CNI 规范的插件（插件可以兼容多个规范版本）。

安装
--

CNI 插件需要实现 Kubernetes 网络模型。 CRI 管理它自己的 CNI 插件。 在使用插件时，需要记住两个 kubelet 命令行参数：

*   ​`cni-bin-dir`​： kubelet 在启动时探测这个目录中的插件
*   ​`network-plugin`​： 要使用的网络插件来自 ​`cni-bin-dir`​。 它必须与从插件目录探测到的插件报告的名称匹配。 对于 CNI 插件，其值为 "cni"。

网络插件要求
------

除了提供 NetworkPlugin 接口 来配置和清理 Pod 网络之外，该插件还可能需要对 kube-proxy 的特定支持。 iptables 代理显然依赖于 iptables，插件可能需要确保 iptables 能够监控容器的网络通信。 例如，如果插件将容器连接到 Linux 网桥，插件必须将 ​`net/bridge/bridge-nf-call-iptables`​ 系统参数设置为​`1`​，以确保 iptables 代理正常工作。 如果插件不使用 Linux 网桥（而是类似于 Open vSwitch 或者其它一些机制）， 它应该确保为代理对容器通信执行正确的路由。

默认情况下，如果未指定 kubelet 网络插件，则使用 ​`noop` ​插件， 该插件设置 ​`net/bridge/bridge-nf-call-iptables=1`​，以确保简单的配置 （如带网桥的 Docker ）与 iptables 代理正常工作。

#### CNI

通过给 Kubelet 传递 ​`--network-plugin=cni`​ 命令行选项可以选择 CNI 插件。 Kubelet 从 ​`--cni-conf-dir`​ （默认是 ​`/etc/cni/net.d`​） 读取文件并使用 该文件中的 CNI 配置来设置各个 Pod 的网络。 CNI 配置文件必须与 [CNI 规约](https://github.com/containernetworking/cni/blob/main/SPEC.md target=) 匹配，并且配置所引用的所有所需的 CNI 插件都应存在于 ​`--cni-bin-dir`​（默认是 ​`/opt/cni/bin`​）下。

如果这个目录中有多个 CNI 配置文件，kubelet 将会使用按文件名的字典顺序排列 的第一个作为配置文件。

除了配置文件指定的 CNI 插件外，Kubernetes 还需要标准的 CNI ​`[lo](https://github.com/containernetworking/plugins/blob/main/plugins/main/loopback/loopback.go)`​ 插件，最低版本是0.2.0。

#### 支持 hostPort

CNI 网络插件支持 ​`hostPort`​。 你可以使用官方 [portmap](https://github.com/containernetworking/plugins/tree/main/plugins/meta/portmap) 插件，它由 CNI 插件团队提供，或者使用你自己的带有 portMapping 功能的插件。

如果你想要启动 ​`hostPort` ​支持，则必须在 ​`cni-conf-dir`​ 指定 ​`portMappings capability`​。 例如：

`{   "name": "k8s-pod-network",   "cniVersion": "0.3.0",   "plugins": [     {       "type": "calico",       "log_level": "info",       "datastore_type": "kubernetes",       "nodename": "127.0.0.1",       "ipam": {         "type": "host-local",         "subnet": "usePodCidr"       },       "policy": {         "type": "k8s"       },       "kubernetes": {         "kubeconfig": "/etc/cni/net.d/calico-kubeconfig"       }     },     {       "type": "portmap",       "capabilities": {"portMappings": true}     }   ] }`

#### 支持流量整形

##### 实验功能

CNI 网络插件还支持 pod 入口和出口流量整形。 你可以使用 CNI 插件团队提供的 [bandwidth](https://github.com/containernetworking/plugins/tree/main/plugins/meta/bandwidth) 插件，也可以使用你自己的具有带宽控制功能的插件。

如果你想要启用流量整形支持，你必须将 ​`bandwidth` ​插件添加到 CNI 配置文件 （默认是 ​`/etc/cni/net.d`​）并保证该可执行文件包含在你的 CNI 的 bin 文件夹内 (默认为 ​`/opt/cni/bin`​)。

`{   "name": "k8s-pod-network",   "cniVersion": "0.3.0",   "plugins": [     {       "type": "calico",       "log_level": "info",       "datastore_type": "kubernetes",       "nodename": "127.0.0.1",       "ipam": {         "type": "host-local",         "subnet": "usePodCidr"       },       "policy": {         "type": "k8s"       },       "kubernetes": {         "kubeconfig": "/etc/cni/net.d/calico-kubeconfig"       }     },     {       "type": "bandwidth",       "capabilities": {"bandwidth": true}     }   ] }`

现在，你可以将 ​`kubernetes.io/ingress-bandwidth`​ 和 ​`kubernetes.io/egress-bandwidth`​ 注解添加到 pod 中。例如：

`apiVersion: v1 kind: Pod metadata:   annotations:     kubernetes.io/ingress-bandwidth: 1M     kubernetes.io/egress-bandwidth: 1M ...`

用法总结
----

*   ​`--network-plugin=cni`​ 用来表明我们要使用 ​`cni` ​网络插件，实际的 CNI 插件 可执行文件位于 ​`--cni-bin-dir`​（默认是 ​`/opt/cni/bin`​）下， CNI 插件配置位于 ​`--cni-conf-dir`​（默认是 ​`/etc/cni/net.d`​）下。

###  2.  Kubernetes 设备插件
设备插件
----

FEATURE STATE: Kubernetes v1.10 \[beta\]

Kubernetes 提供了一个 [设备插件框架](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/device-plugin.md)，你可以用它来将系统硬件资源发布到 Kubelet。

供应商可以实现设备插件，由你手动部署或作为 DaemonSet 来部署，而不必定制 Kubernetes 本身的代码。目标设备包括 GPU、高性能 NIC、FPGA、 InfiniBand 适配器以及其他类似的、可能需要特定于供应商的初始化和设置的计算资源。

注册设备插件 
-------

​`kubelet` ​提供了一个 ​`Registration` ​的 gRPC 服务：

`service Registration { 	rpc Register(RegisterRequest) returns (Empty) {} }`

设备插件可以通过此 gRPC 服务在 kubelet 进行注册。在注册期间，设备插件需要发送下面几样内容：

*   设备插件的 Unix 套接字。
*   设备插件的 API 版本。
*   ​`ResourceName` ​是需要公布的。这里 ​`ResourceName` ​需要遵循 扩展资源命名方案， 类似于 ​`vendor-domain/resourcetype`​。（比如 NVIDIA GPU 就被公布为 ​`nvidia.com/gpu`​。）

成功注册后，设备插件就向 kubelet 发送它所管理的设备列表，然后 kubelet 负责将这些资源发布到 API 服务器，作为 kubelet 节点状态更新的一部分。

比如，设备插件在 kubelet 中注册了 ​`hardware-vendor.example/foo`​ 并报告了 节点上的两个运行状况良好的设备后，节点状态将更新以通告该节点已安装 2 个 "Foo" 设备并且是可用的。

然后，用户可以请求设备作为 Pod 规范的一部分。请求扩展资源类似于管理请求和限制的方式， 其他资源，有以下区别：

*   扩展资源仅可作为整数资源使用，并且不能被过量使用
*   设备不能在容器之间共享

#### 示例

假设 Kubernetes 集群正在运行一个设备插件，该插件在一些节点上公布的资源为 ​`hardware-vendor.example/foo`​。 下面就是一个 Pod 示例，请求此资源以运行一个工作负载的示例：

`--- apiVersion: v1 kind: Pod metadata:   name: demo-pod spec:   containers:     - name: demo-container-1       image: k8s.gcr.io/pause:2.0       resources:         limits:           hardware-vendor.example/foo: 2 # # 这个 pod 需要两个 hardware-vendor.example/foo 设备 # 而且只能够调度到满足需求的节点上 # # 如果该节点中有 2 个以上的设备可用，其余的可供其他 Pod 使用`

设备插件的实现 
--------

设备插件的常规工作流程包括以下几个步骤：

*   初始化。在这个阶段，设备插件将执行供应商特定的初始化和设置， 以确保设备处于就绪状态。
*   插件使用主机路径 ​`/var/lib/kubelet/device-plugins/`​ 下的 Unix 套接字启动 一个 gRPC 服务，该服务实现以下接口：

`service DevicePlugin {       // GetDevicePluginOptions 返回与设备管理器沟通的选项。       rpc GetDevicePluginOptions(Empty) returns (DevicePluginOptions) {}        // ListAndWatch 返回 Device 列表构成的数据流。       // 当 Device 状态发生变化或者 Device 消失时，ListAndWatch       // 会返回新的列表。       rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) {}        // Allocate 在容器创建期间调用，这样设备插件可以运行一些特定于设备的操作，       // 并告诉 kubelet 如何令 Device 可在容器中访问的所需执行的具体步骤       rpc Allocate(AllocateRequest) returns (AllocateResponse) {}        // GetPreferredAllocation 从一组可用的设备中返回一些优选的设备用来分配，       // 所返回的优选分配结果不一定会是设备管理器的最终分配方案。       // 此接口的设计仅是为了让设备管理器能够在可能的情况下做出更有意义的决定。       rpc GetPreferredAllocation(PreferredAllocationRequest) returns (PreferredAllocationResponse) {}        // PreStartContainer 在设备插件注册阶段根据需要被调用，调用发生在容器启动之前。       // 在将设备提供给容器使用之前，设备插件可以运行一些诸如重置设备之类的特定于       // 具体设备的操作，       rpc PreStartContainer(PreStartContainerRequest) returns (PreStartContainerResponse) {} }`

> Note:  
> 插件并非必须为 ​`GetPreferredAllocation()`​ 或 ​`PreStartContainer()`​ 提供有用 的实现逻辑，调用 ​`GetDevicePluginOptions()`​ 时所返回的 ​`DevicePluginOptions`​ 消息中应该设置这些调用是否可用。​`kubelet` ​在真正调用这些函数之前，总会调用 ​`GetDevicePluginOptions()`​ 来查看是否存在这些可选的函数。

*   插件通过 Unix socket 在主机路径 ​`/var/lib/kubelet/device-plugins/kubelet.sock`​ 处向 kubelet 注册自身。
*   成功注册自身后，设备插件将以服务模式运行，在此期间，它将持续监控设备运行状况， 并在设备状态发生任何变化时向 kubelet 报告。它还负责响应 ​`Allocate` ​gRPC 请求。 在 ​`Allocate` ​期间，设备插件可能还会做一些设备特定的准备；例如 GPU 清理或 QRNG 初始化。 如果操作成功，则设备插件将返回 ​`AllocateResponse`​，其中包含用于访问被分配的设备容器运行时的配置。 kubelet 将此信息传递到容器运行时。

#### 处理 kubelet 重启

设备插件应能监测到 kubelet 重启，并且向新的 kubelet 实例来重新注册自己。 在当前实现中，当 kubelet 重启的时候，新的 kubelet 实例会删除 ​`/var/lib/kubelet/device-plugins`​ 下所有已经存在的 Unix 套接字。 设备插件需要能够监控到它的 Unix 套接字被删除，并且当发生此类事件时重新注册自己。

设备插件部署
------

你可以将你的设备插件作为节点操作系统的软件包来部署、作为 DaemonSet 来部署或者手动部署。

规范目录 ​`/var/lib/kubelet/device-plugins`​ 是需要特权访问的，所以设备插件 必须要在被授权的安全的上下文中运行。 如果你将设备插件部署为 DaemonSet，​`/var/lib/kubelet/device-plugins`​ 目录必须要在插件的 [PodSpec](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/ target=) 中声明作为 卷（Volume） 被挂载到插件中。

如果你选择 DaemonSet 方法，你可以通过 Kubernetes 进行以下操作： 将设备插件的 Pod 放置在节点上，在出现故障后重新启动守护进程 Pod，来进行自动升级。

API 兼容性
-------

Kubernetes 设备插件支持还处于 beta 版本。所以在稳定版本出来之前 API 会以不兼容的方式进行更改。 作为一个项目，Kubernetes 建议设备插件开发者：

*   注意未来版本的更改
*   支持多个版本的设备插件 API，以实现向后/向前兼容性。

如果你启用 DevicePlugins 功能，并在需要升级到 Kubernetes 版本来获得较新的设备插件 API 版本的节点上运行设备插件，请在升级这些节点之前先升级设备插件以支持这两个版本。 采用该方法将确保升级期间设备分配的连续运行。

监控设备插件资源
--------

FEATURE STATE: Kubernetes v1.15 \[beta\]

为了监控设备插件提供的资源，监控代理程序需要能够发现节点上正在使用的设备， 并获取元数据来描述哪个指标与容器相关联。 设备监控代理暴露给 [Prometheus](https://prometheus.io/) 的指标应该遵循 [Kubernetes Instrumentation Guidelines](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/instrumentation.md)， 使用 ​`pod`​、​`namespace` ​和 ​`container` ​标签来标识容器。

kubelet 提供了 gRPC 服务来使得正在使用中的设备被发现，并且还未这些设备提供了元数据：

`// PodResourcesLister 是一个由 kubelet 提供的服务，用来提供供节点上  // Pods 和容器使用的节点资源的信息 service PodResourcesLister {     rpc List(ListPodResourcesRequest) returns (ListPodResourcesResponse) {}     rpc GetAllocatableResources(AllocatableResourcesRequest) returns (AllocatableResourcesResponse) {} }`

#### List gRPC 端点

这一 ​`List` ​端点提供运行中 Pods 的资源信息，包括类似独占式分配的 CPU ID、设备插件所报告的设备 ID 以及这些设备分配所处的 NUMA 节点 ID。 此外，对于基于 NUMA 的机器，它还会包含为容器保留的内存和大页的信息。

`// ListPodResourcesResponse 是 List 函数的响应 message ListPodResourcesResponse {     repeated PodResources pod_resources = 1; }  // PodResources 包含关于分配给 Pod 的节点资源的信息 message PodResources {     string name = 1;     string namespace = 2;     repeated ContainerResources containers = 3; }  // ContainerResources 包含分配给容器的资源的信息 message ContainerResources {     string name = 1;     repeated ContainerDevices devices = 2;     repeated int64 cpu_ids = 3;     repeated ContainerMemory memory = 4; }  // ContainerMemory 包含分配给容器的内存和大页信息 message ContainerMemory {     string memory_type = 1;     uint64 size = 2;     TopologyInfo topology = 3; }  // Topology 描述资源的硬件拓扑结构 message TopologyInfo {         repeated NUMANode nodes = 1; }  // NUMA 代表的是 NUMA 节点 message NUMANode {         int64 ID = 1; }  // ContainerDevices 包含分配给容器的设备信息 message ContainerDevices {     string resource_name = 1;     repeated string device_ids = 2;     TopologyInfo topology = 3; }`

> Note:  
> ​`List` ​端点中的 ​`ContainerResources` ​中的 cpu\_ids 对应于分配给某个容器的专属 CPU。 如果要统计共享池中的 CPU，​`List` ​端点需要与 ​`GetAllocatableResources` ​端点一起使用，如下所述:  
> 
> 1.  调用 ​`GetAllocatableResources` ​获取所有可用的 CPUs。
> 2.  在系统中所有的 ​`ContainerResources` ​上调用 ​`GetCpuIds`​。
> 3.  用 ​`GetAllocatableResources` ​获取的 CPU 数减去 ​`GetCpuIds` ​获取的 CPU 数。

#### GetAllocatableResources gRPC 端点

FEATURE STATE: Kubernetes v1.23 \[beta\]

端点 ​`GetAllocatableResources` ​提供工作节点上原始可用的资源信息。 此端点所提供的信息比导出给 API 服务器的信息更丰富。

> Note:  
> ​`GetAllocatableResources` ​应该仅被用于评估一个节点上的可分配的 资源。如果目标是评估空闲/未分配的资源，此调用应该与 List() 端点一起使用。 除非暴露给 kubelet 的底层资源发生变化 否则 ​`GetAllocatableResources` ​得到的结果将保持不变。 这种情况很少发生，但当发生时（例如：热插拔，设备健康状况改变），客户端应该调用 ​`GetAlloctableResources` ​端点。 然而，调用 ​`GetAllocatableResources` ​端点在 cpu、内存被更新的情况下是不够的， Kubelet 需要重新启动以获取正确的资源容量和可分配的资源。

`// AllocatableResourcesResponses 包含 kubelet 所了解到的所有设备的信息 message AllocatableResourcesResponse {     repeated ContainerDevices devices = 1;     repeated int64 cpu_ids = 2;     repeated ContainerMemory memory = 3; }`

从 Kubernetes v1.23 开始，​`GetAllocatableResources` ​被默认启用。 你可以通过关闭 ​`KubeletPodResourcesGetAllocatable` ​特性门控 来禁用。

在 Kubernetes v1.23 之前，要启用这一功能，​`kubelet` ​必须用以下标志启动：

​`--feature-gates=KubeletPodResourcesGetAllocatable=true` ​

​`ContainerDevices` ​会向外提供各个设备所隶属的 NUMA 单元这类拓扑信息。 NUMA 单元通过一个整数 ID 来标识，其取值与设备插件所报告的一致。 设备插件注册到 kubelet 时 会报告这类信息。

gRPC 服务通过 ​`/var/lib/kubelet/pod-resources/kubelet.sock`​ 的 UNIX 套接字来提供服务。 设备插件资源的监控代理程序可以部署为守护进程或者 DaemonSet。 规范的路径 ​`/var/lib/kubelet/pod-resources`​ 需要特权来进入， 所以监控代理程序必须要在获得授权的安全的上下文中运行。 如果设备监控代理以 DaemonSet 形式运行，必须要在插件的 [PodSpec](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/ target=) 中声明将 ​`/var/lib/kubelet/pod-resources`​ 目录以 卷的形式被挂载到设备监控代理中。

对“PodResourcesLister 服务”的支持要求启用 ​`KubeletPodResources` ​特性门控。 从 Kubernetes 1.15 开始默认启用，自从 Kubernetes 1.20 开始为 v1。

设备插件与拓扑管理器的集成
-------------

FEATURE STATE: Kubernetes v1.18 \[beta\]

拓扑管理器是 Kubelet 的一个组件，它允许以拓扑对齐方式来调度资源。 为了做到这一点，设备插件 API 进行了扩展来包括一个 ​`TopologyInfo` ​结构体。

`message TopologyInfo {  repeated NUMANode nodes = 1; }  message NUMANode {     int64 ID = 1; }`

设备插件希望拓扑管理器可以将填充的 TopologyInfo 结构体作为设备注册的一部分以及设备 ID 和设备的运行状况发送回去。然后设备管理器将使用此信息来咨询拓扑管理器并做出资源分配决策。

​`TopologyInfo` ​支持定义 ​`nodes` ​字段，允许为 ​`nil`​（默认）或者是一个 NUMA 节点的列表。 这样就可以使设备插件可以跨越 NUMA 节点去发布。

下面是一个由设备插件为设备填充 ​`TopologyInfo` ​结构体的示例：

`pluginapi.Device{ID: "25102017", Health: pluginapi.Healthy, Topology:&pluginapi.TopologyInfo{Nodes: []*pluginapi.NUMANode{&pluginapi.NUMANode{ID: 0,},}}}`

设备插件示例
------

下面是一些设备插件实现的示例：

*   [AMD GPU 设备插件](https://github.com/RadeonOpenCompute/k8s-device-plugin)
*   [Intel 设备插件](https://github.com/intel/intel-device-plugins-for-kubernetes) 支持 Intel GPU、FPGA 和 QuickAssist 设备
*   [KubeVirt](https://github.com/kubevirt/kubernetes-device-plugins) 设备插件 用于硬件辅助的虚拟化
*   [为 Container-Optimized OS 所提供的 NVIDIA GPU 设备插件](https://github.com/GoogleCloudPlatform/container-engine-accelerators/tree/master/cmd/nvidia_gpu)
*   [RDMA 设备插件](https://github.com/hustcat/k8s-rdma-device-plugin)
*   [SocketCAN 设备插件](https://github.com/collabora/k8s-socketcan)
*   [Solarflare 设备插件](https://github.com/vikaschoudhary16/sfc-device-plugin)
*   [SR-IOV 网络设备插件](https://github.com/k8snetworkplumbingwg/sriov-network-device-plugin)
*   [Xilinx FPGA 设备插件](https://github.com/Xilinx/FPGA_as_a_Service/tree/master/k8s-fpga-device-plugin)

##  4.  Kubernetes 服务目录
服务目录
----

服务目录（Service Catalog）是 服务目录是一种扩展 API，它能让 Kubernetes 集群中运行的应用易于使用外部托管的的软件服务，例如云供应商提供的数据仓库服务。

服务目录可以检索、供应、和绑定由 服务代理人（Service Brokers） 提供的外部托管服务（Managed Services）， 而无需知道那些服务具体是怎样创建和托管的。

服务代理（Service Broker）是由[Open Service Broker API 规范](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md)定义的一组托管服务的端点，这些服务由第三方提供并维护，其中的第三方可以是 AWS、GCP 或 Azure 等云服务提供商。 托管服务的一些示例是 Microsoft Azure Cloud Queue、Amazon Simple Queue Service 和 Google Cloud Pub/Sub，但它们可以是应用程序能够使用的任何软件交付物。

使用服务目录，集群操作员 可以浏览某服务代理所提供的托管服务列表，供应托管服务实例并与之绑定， 以使其可以被 Kubernetes 集群中的应用程序使用。

示例用例
----

应用开发人员， 希望使用消息队列，作为其在 Kubernetes 集群中运行的应用程序的一部分。 但是，他们不想承受构造这种服务的开销，也不想自行管理。 幸运的是，有一家云服务提供商通过其服务代理以托管服务的形式提供消息队列服务。

集群操作员可以设置服务目录并使用它与云服务提供商的服务代理通信，进而部署消息队列服务的实例 并使其对 Kubernetes 中的应用程序可用。 应用开发者于是可以不关心消息队列的实现细节，也不用对其进行管理。 他们的应用程序可以简单的将其作为服务使用。

架构 
---

服务目录使用[Open Service Broker API](https://github.com/openservicebrokerapi/servicebroker) 与服务代理进行通信，并作为 Kubernetes API 服务器的中介，以便协商启动部署和获取 应用程序使用托管服务时必须的凭据。

它是基于 CRDs 架构实现的。

![](https://atts.w3cschool.cn/attachments/image/20220527/1653617690940644.svg)  

API 资源
------

服务目录安装 ​`servicecatalog.k8s.io`​ API 并提供以下 Kubernetes 资源：

*   ​`ClusterServiceBroker`​：服务目录的集群内表现形式，封装了其服务连接细节。集群运维人员创建和管理这些资源，并希望使用该代理服务在集群中提供新类型的托管服务。
*   ​`ClusterServiceClass`​：由特定服务代理提供的托管服务。当新的 ​`ClusterServiceBroker` ​资源被添加到集群时，服务目录控制器将连接到服务代理以获取可用的托管服务列表。然后为每个托管服务创建对应的新 ​`ClusterServiceClass`​ 资源。
*   ​`ClusterServicePlan`​：托管服务的特定产品。例如托管服务可能有不同的计划可用，如免费版本和付费版本，或者可能有不同的配置选项，例如使用 SSD 存储或拥有更多资源。与 ​`ClusterServiceClass` ​类似，当一个新的 ​`ClusterServiceBroker` ​被添加到集群时，服务目录会为每个托管服务的每个可用服务计划创建对应的新 ​`ClusterServicePlan` ​资源。
*   ​`ServiceInstance`​：​`ClusterServiceClass`​ 提供的示例。由集群运维人员创建，以使托管服务的特定实例可供一个或多个集群内应用程序使用。当创建一个新的 ​`ServiceInstance` ​资源时，服务目录控制器将连接到相应的服务代理并指示它调配服务实例。
*   ​`ServiceBinding`​：​`ServiceInstance`​ 的访问凭据。由希望其应用程序使用服务 ​`ServiceInstance` ​的集群运维人员创建。创建之后，服务目录控制器将创建一个 Kubernetes ​`Secret`​，其中包含服务实例的连接细节和凭据，可以挂载到 Pod 中。

### 认证 

服务目录支持这些认证方法：

*   基本认证（用户名/密码）
*   [OAuth 2.0 不记名令牌](https://datatracker.ietf.org/doc/html/rfc6750)

使用方式
----

集群运维人员可以使用服务目录 API 资源来供应托管服务并使其在 Kubernetes 集群内可用。涉及的步骤有：

1.  列出服务代理提供的托管服务和服务计划。
2.  配置托管服务的新实例。
3.  绑定到托管服务，它将返回连接凭证。
4.  将连接凭证映射到应用程序中。

### 列出托管服务和服务计划

首先，集群运维人员在 ​`servicecatalog.k8s.io`​ 组内创建一个 ​`ClusterServiceBroker` ​资源。此资源包含访问服务代理终结点所需的 URL 和连接详细信息。

这是一个 ​`ClusterServiceBroker` ​资源的例子：

`apiVersion: servicecatalog.k8s.io/v1beta1 kind: ClusterServiceBroker metadata:   name: cloud-broker spec:   # 指向服务代理的末端。(这里的 URL 是无法使用的。)   url:  https://servicebroker.somecloudprovider.com/v1alpha1/projects/service-catalog/brokers/default   #####   # 这里可以添加额外的用来与服务代理通信的属性值,   # 例如持有者令牌信息或者 TLS 的 CA 包。   #####`

下面的时序图展示了从服务代理列出可用托管服务和计划所涉及的各个步骤：

![](https://atts.w3cschool.cn/attachments/image/20220527/1653617907817456.svg)  

1.  一旦 ​`ClusterServiceBroker` ​资源被添加到了服务目录之后，将会触发一个到外部服务代理的 调用，以列举所有可用服务；
2.  服务代理返回可用的托管服务和服务计划列表，这些列表将本地缓存在 ​`ClusterServiceClass` ​和 ​`ClusterServicePlan` ​资源中。
3.  集群运维人员接下来可以使用以下命令获取可用托管服务的列表：

`kubectl get clusterserviceclasses \   -o=custom-columns=SERVICE\ NAME:.metadata.name,EXTERNAL\ NAME:.spec.externalName`

它应该输出一个和以下格式类似的服务名称列表：

`SERVICE NAME                           EXTERNAL NAME 4f6e6cf6-ffdd-425f-a2c7-3c9258ad2468   cloud-provider-service ...                                    ...`

他们还可以使用以下命令查看可用的服务计划：

`kubectl get clusterserviceplans \    -o=custom-columns=PLAN\ NAME:.metadata.name,EXTERNAL\ NAME:.spec.externalName`

它应该输出一个和以下格式类似的服务计划列表：

`PLAN NAME                              EXTERNAL NAME 86064792-7ea2-467b-af93-ac9694d96d52   service-plan-name ...                                    ...`

### 供应一个新实例

集群运维人员 可以通过创建一个 ​`ServiceInstance` ​资源来启动一个新实例的配置。

下面是一个 ​`ServiceInstance` ​资源的例子：

`apiVersion: servicecatalog.k8s.io/v1beta1 kind: ServiceInstance metadata:   name: cloud-queue-instance   namespace: cloud-apps spec:   # 引用之前返回的服务之一   clusterServiceClassExternalName: cloud-provider-service   clusterServicePlanExternalName: service-plan-name   #####   # 这里可添加额外的参数，供服务代理使用   #####`

以下时序图展示了配置托管服务新实例所涉及的步骤：

![](https://atts.w3cschool.cn/attachments/image/20220527/1653618020477997.svg)  

1.  创建 ​`ServiceInstance` ​资源时，服务目录将启动一个到外部服务代理的调用， 请求供应一个实例。
2.  服务代理创建一个托管服务的新实例并返回 HTTP 响应。
3.  接下来，集群运维人员可以检查实例的状态是否就绪。

### 绑定到托管服务

在设置新实例之后，集群运维人员必须绑定到托管服务才能获取应用程序使用服务所需的连接凭据和服务账户的详细信息。该操作通过创建一个 ​`ServiceBinding` ​资源完成。

以下是 ​`ServiceBinding` ​资源的示例：

`apiVersion: servicecatalog.k8s.io/v1beta1 kind: ServiceBinding metadata:   name: cloud-queue-binding   namespace: cloud-apps spec:   instanceRef:     name: cloud-queue-instance   #####   # 这里可以添加供服务代理使用的额外信息，例如 Secret 名称或者服务账号参数，   #####`

以下顺序图展示了绑定到托管服务实例的步骤：

![](https://atts.w3cschool.cn/attachments/image/20220527/1653618074280915.svg)  

1.  在创建 ​`ServiceBinding` ​之后，服务目录调用外部服务代理，请求绑定服务实例所需的信息。
2.  服务代理为相应服务账户启用应用权限/角色。
3.  服务代理返回连接和访问托管服务示例所需的信息。这是由提供商和服务特定的，故返回的信息可能因服务提供商和其托管服务而有所不同。

### 映射连接凭据

完成绑定之后的最后一步就是将连接凭据和服务特定的信息映射到应用程序中。这些信息存储在 secret 中，集群中的应用程序可以访问并使用它们直接与托管服务进行连接。

![](https://atts.w3cschool.cn/attachments/image/20220527/1653618106992075.svg)  

#### Pod 配置文件

执行此映射的一种方法是使用声明式 Pod 配置。

以下示例描述了如何将服务账户凭据映射到应用程序中。名为 ​`sa-key`​ 的密钥保存在一个名为 ​`provider-cloud-key`​ 的卷中，应用程序会将该卷挂载在 ​`/var/secrets/provider/key.json`​ 路径下。环境变量 ​`PROVIDER_APPLICATION_CREDENTIALS` ​将映射为挂载文件的路径。

`...     spec:       volumes:         - name: provider-cloud-key           secret:             secretName: sa-key       containers: ...           volumeMounts:           - name: provider-cloud-key             mountPath: /var/secrets/provider           env:           - name: PROVIDER_APPLICATION_CREDENTIALS             value: "/var/secrets/provider/key.json"`

以下示例描述了如何将 Secret 值映射为应用程序的环境变量。 在这个示例中，消息队列的主题名从 Secret ​`provider-queue-credentials`​ 中名为 ​`topic` ​的主键映射到环境变量 ​`TOPIC` ​中。

`...           env:           - name: "TOPIC"             valueFrom:                 secretKeyRef:                    name: provider-queue-credentials                    key: topic`

#  17.  Kubernetes 应用故障排除

##  1.  Kubernetes 调试Pod
调试 Pod 
-------

调试 Pod 的第一步是查看 Pod 信息。用如下命令查看 Pod 的当前状态和最近的事件：

`kubectl describe pods ${POD_NAME}`

查看一下 Pod 中的容器所处的状态。这些容器的状态都是 ​`Running` ​吗？最近有没有重启过？

后面的调试都是要依靠 Pod 的状态的。

### Pod 停滞在 Pending 状态

如果一个 Pod 停滞在 ​`Pending` ​状态，表示 Pod 没有被调度到节点上。通常这是因为 某种类型的资源不足导致无法调度。 查看上面的 ​`kubectl describe ...`​ 命令的输出，其中应该显示了为什么没被调度的原因。 常见原因如下：

*   资源不足: 你可能耗尽了集群上所有的 CPU 或内存。此时，你需要删除 Pod、调整资源请求或者为集群添加节点。
*   使用了 ​`hostPort`​: 如果绑定 Pod 到 ​`hostPort`​，那么能够运行该 Pod 的节点就有限了。 多数情况下，​`hostPort` ​是非必要的，而应该采用 Service 对象来暴露 Pod。 如果确实需要使用 ​`hostPort`​，那么集群中节点的个数就是所能创建的 Pod 的数量上限。

### Pod 停滞在 Waiting 状态

如果 Pod 停滞在 ​`Waiting` ​状态，则表示 Pod 已经被调度到某工作节点，但是无法在该节点上运行。 同样，​`kubectl describe ...`​ 命令的输出可能很有用。 ​`Waiting` ​状态的最常见原因是拉取镜像失败。要检查的有三个方面：

*   确保镜像名字拼写正确
*   确保镜像已被推送到镜像仓库
*   尝试手动是否能拉取镜像。例如，如果你在你的 PC 上使用 Docker，请运行 ​`docker pull <镜像>`​。

### Pod 处于 Crashing 或别的不健康状态

一旦 Pod 被调度，就可以采用 调试运行中的 Pod 中的方法来进一步调试。

### Pod 处于 Running 态但是没有正常工作

如果 Pod 行为不符合预期，很可能 Pod 描述（例如你本地机器上的 ​`mypod.yaml`​）中有问题， 并且该错误在创建 Pod 时被忽略掉，没有报错。 通常，Pod 的定义中节区嵌套关系错误、字段名字拼错的情况都会引起对应内容被忽略掉。 例如，如果你误将 ​`command` ​写成 ​`commnd`​，Pod 虽然可以创建，但它不会执行 你期望它执行的命令行。

可以做的第一件事是删除你的 Pod，并尝试带有 ​`--validate`​ 选项重新创建。 例如，运行 ​`kubectl apply --validate -f mypod.yaml`​。 如果 ​`command` ​被误拼成 ​`commnd`​，你将会看到下面的错误信息：

`I0805 10:43:25.129850   46757 schema.go:126] unknown field: commnd I0805 10:43:25.129973   46757 schema.go:129] this may be a false alarm, see https://github.com/kubernetes/kubernetes/issues/6842 pods/mypod`

接下来就要检查的是 API 服务器上的 Pod 与你所期望创建的是否匹配 （例如，你原本使用本机上的一个 YAML 文件来创建 Pod）。 例如，运行 ​`kubectl get pods/mypod -o yaml > mypod-on-apiserver.yaml`​，之后 手动比较 ​`mypod.yaml`​ 与从 API 服务器取回的 Pod 描述。 从 API 服务器处获得的 YAML 通常包含一些创建 Pod 所用的 YAML 中不存在的行，这是正常的。 不过，如果如果源文件中有些行在 API 服务器版本中不存在，则意味着 Pod 规约是有问题的。

调试副本控制器 
--------

副本控制器相对比较简单直接。它们要么能创建 Pod，要么不能。 如果不能创建 Pod，请参阅上述说明调试 Pod。

你也可以使用 ​`kubectl describe rc ${CONTROLLER_NAME}`​ 命令来检视副本控制器相关的事件。

调试 Service 
-----------

服务支持在多个 Pod 间负载均衡。 有一些常见的问题可以造成服务无法正常工作。 以下说明将有助于调试服务的问题。

首先，验证服务是否有端点。对于每一个 Service 对象，API 服务器为其提供 对应的 ​`endpoints` ​资源。

通过如下命令可以查看 endpoints 资源：

`kubectl get endpoints ${SERVICE_NAME}`

确保 Endpoints 与服务成员 Pod 个数一致。 例如，如果你的 Service 用来运行 3 个副本的 nginx 容器，你应该会在 Service 的 Endpoints 中看到 3 个不同的 IP 地址。

### 服务缺少 Endpoints

如果没有 Endpoints，请尝试使用 Service 所使用的标签列出 Pod。 假定你的服务包含如下标签选择算符：

`... spec:   - selector:      name: nginx      type: frontend`

你可以使用如下命令列出与选择算符相匹配的 Pod，并验证这些 Pod 是否归属于创建的服务：

`kubectl get pods --selector=name=nginx,type=frontend`

验证 Pod 的 ​`containerPort` ​与服务的 ​`targetPort` ​是否匹配。

##  2.  Kubernetes 调试Service
在 Pod 中运行命令
-----------

对于这里的许多步骤，你可能希望知道运行在集群中的 Pod 看起来是什么样的。 最简单的方法是运行一个交互式的 busybox Pod：

`kubectl run -it --rm --restart=Never busybox --image=gcr.io/google-containers/busybox sh`

> Note: 如果没有看到命令提示符，请按回车。

如果你已经有了你想使用的正在运行的 Pod，则可以运行以下命令去进入：

`kubectl exec <POD-NAME> -c <CONTAINER-NAME> -- <COMMAND>`

设置 
---

为了完成本次实践的任务，我们先运行几个 Pod。 由于你可能正在调试自己的 Service，所以，你可以使用自己的信息进行替换， 或者你也可以跟着教程并开始下面的步骤来获得第二个数据点。

`kubectl  create deployment hostnames --image=k8s.gcr.io/serve_hostname` 

`deployment.apps/hostnames created`

​`kubectl` ​命令将打印创建或变更的资源的类型和名称，它们可以在后续命令中使用。 让我们将这个 deployment 的副本数扩至 3。

`kubectl scale deployment hostnames --replicas=3`

`deployment.apps/hostnames scaled`

请注意这与你使用以下 YAML 方式启动 Deployment 类似：

`apiVersion: apps/v1 kind: Deployment metadata:   labels:     app: hostnames   name: hostnames spec:   selector:     matchLabels:       app: hostnames   replicas: 3   template:     metadata:       labels:         app: hostnames     spec:       containers:       - name: hostnames         image: k8s.gcr.io/serve_hostname`

"app" 标签是 ​`kubectl create deployment`​ 根据 Deployment 名称自动设置的。

确认你的 Pods 是运行状态:

`kubectl get pods -l app=hostnames`

`NAME                        READY     STATUS    RESTARTS   AGE hostnames-632524106-bbpiw   1/1       Running   0          2m hostnames-632524106-ly40y   1/1       Running   0          2m hostnames-632524106-tlaok   1/1       Running   0          2m`

你还可以确认你的 Pod 是否正在提供服务。你可以获取 Pod IP 地址列表并直接对其进行测试。

`kubectl get pods -l app=hostnames \     -o go-template='{{range .items}}{{.status.podIP}}{{"\n"}}{{end}}'`

`10.244.0.5 10.244.0.6 10.244.0.7`

用于本教程的示例容器通过 HTTP 在端口 9376 上提供其自己的主机名， 但是如果要调试自己的应用程序，则需要使用你的 Pod 正在侦听的端口号。

在 Pod 内运行：

`for ep in 10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376; do     wget -qO- $ep done`

输出类似这样：

`hostnames-632524106-bbpiw hostnames-632524106-ly40y hostnames-632524106-tlaok`

如果此时你没有收到期望的响应，则你的 Pod 状态可能不健康，或者可能没有在你认为正确的端口上进行监听。 你可能会发现 ​`kubectl logs`​ 命令对于查看正在发生的事情很有用， 或者你可能需要通过​`kubectl exec`​ 直接进入 Pod 中并从那里进行调试。

假设到目前为止一切都已按计划进行，那么你可以开始调查为何你的 Service 无法正常工作。

Service 是否存在？
-------------

细心的读者会注意到我们实际上尚未创建 Service -这是有意而为之。 这一步有时会被遗忘，这是首先要检查的步骤。

那么，如果我尝试访问不存在的 Service 会怎样？ 假设你有另一个 Pod 通过名称匹配到 Service ，你将得到类似结果：

`wget -O- hostnames`

`Resolving hostnames (hostnames)... failed: Name or service not known. wget: unable to resolve host address 'hostnames'`

首先要检查的是该 Service 是否真实存在：

`kubectl get svc hostnames`

`No resources found. Error from server (NotFound): services "hostnames" not found`

让我们创建 Service。 和以前一样，在这次实践中 - 你可以在此处使用自己的 Service 的内容。

`kubectl expose deployment hostnames --port=80 --target-port=9376`

`service/hostnames exposed`

重新运行查询命令：

`kubectl get svc hostnames`

`NAME        TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE hostnames   ClusterIP   10.0.1.175   <none>        80/TCP    5s`

现在你知道了 Service 确实存在。

同前，此步骤效果与通过 YAML 方式启动 'Service' 一样：

`apiVersion: v1 kind: Service metadata:   name: hostnames spec:   selector:     app: hostnames   ports:   - name: default     protocol: TCP     port: 80     targetPort: 9376`

为了突出配置范围的完整性，你在此处创建的 Service 使用的端口号与 Pods 不同。 对于许多真实的 Service，这些值可以是相同的。

是否存在影响目标 Pod 的网络策略入站规则？
-----------------------

如果你部署了任何可能影响到 ​`hostnames-*`​ Pod 的传入流量的网络策略入站规则， 则需要对其进行检查。

Service 是否可通过 DNS 名字访问？ 
------------------------

通常客户端通过 DNS 名称来匹配到 Service。

从相同命名空间下的 Pod 中运行以下命令：

`nslookup hostnames`

`Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local  Name:      hostnames Address 1: 10.0.1.175 hostnames.default.svc.cluster.local`

如果失败，那么你的 Pod 和 Service 可能位于不同的命名空间中， 请尝试使用限定命名空间的名称（同样在 Pod 内运行）：

`nslookup hostnames.default`

`Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local  Name:      hostnames.default Address 1: 10.0.1.175 hostnames.default.svc.cluster.local`

如果成功，那么需要调整你的应用，使用跨命名空间的名称去访问它， 或者在相同的命名空间中运行应用和 Service。如果仍然失败，请尝试一个完全限定的名称：

`nslookup hostnames.default.svc.cluster.local`

`Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local  Name:      hostnames.default.svc.cluster.local Address 1: 10.0.1.175 hostnames.default.svc.cluster.local`

注意这里的后缀："default.svc.cluster.local"。"default" 是我们正在操作的命名空间。 "svc" 表示这是一个 Service。"cluster.local" 是你的集群域，在你自己的集群中可能会有所不同。

你也可以在集群中的节点上尝试此操作：

> Note: 10.0.0.10 是集群的 DNS 服务 IP，你的可能有所不同。

`nslookup hostnames.default.svc.cluster.local 10.0.0.10`

`Server:         10.0.0.10 Address:        10.0.0.10#53  Name:   hostnames.default.svc.cluster.local Address: 10.0.1.175`

如果你能够使用完全限定的名称查找，但不能使用相对名称，则需要检查你 Pod 中的 ​`/etc/resolv.conf`​ 文件是否正确。在 Pod 中运行以下命令：

`cat /etc/resolv.conf`

你应该可以看到类似这样的输出：

`nameserver 10.0.0.10 search default.svc.cluster.local svc.cluster.local cluster.local example.com options ndots:5`

​`nameserver` ​行必须指示你的集群的 DNS Service， 它是通过 ​`--cluster-dns`​ 标志传递到 kubelet 的。

​`search` ​行必须包含一个适当的后缀，以便查找 Service 名称。 在本例中，它查找本地命名空间（​`default.svc.cluster.local`​）中的服务和 所有命名空间（​`svc.cluster.local`​）中的服务，最后在集群（​`cluster.local`​）中查找 服务的名称。根据你自己的安装情况，可能会有额外的记录（最多 6 条）。 集群后缀是通过 ​`--cluster-domain`​ 标志传递给 ​`kubelet` ​的。 本文中，我们假定后缀是 “cluster.local”。 你的集群配置可能不同，这种情况下，你应该在上面的所有命令中更改它。

​`options` ​行必须设置足够高的 ​`ndots`​，以便 DNS 客户端库考虑搜索路径。 在默认情况下，Kubernetes 将这个值设置为 5，这个值足够高，足以覆盖它生成的所有 DNS 名称。

### 是否存在 Service 能通过 DNS 名称访问？

如果上面的方式仍然失败，DNS 查找不到你需要的 Service ，你可以后退一步， 看看还有什么其它东西没有正常工作。 Kubernetes 主 Service 应该一直是工作的。在 Pod 中运行如下命令：

`nslookup kubernetes.default`

`Server:    10.0.0.10 Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local  Name:      kubernetes.default Address 1: 10.0.0.1 kubernetes.default.svc.cluster.local`

如果失败，你可能需要转到本文的 kube-proxy 节， 或者甚至回到文档的顶部重新开始，但不是调试你自己的 Service ，而是调试 DNS Service。

### Service 能够通过 IP 访问么？ 

假设你已经确认 DNS 工作正常，那么接下来要测试的是你的 Service 能否通过它的 IP 正常访问。 从集群中的一个 Pod，尝试访问 Service 的 IP（从上面的 ​`kubectl get`​ 命令获取）。

`for i in $(seq 1 3); do      wget -qO- 10.0.1.175:80 done`

输出应该类似这样：

`hostnames-632524106-bbpiw hostnames-632524106-ly40y hostnames-632524106-tlaok`

如果 Service 状态是正常的，你应该得到正确的响应。如果没有，有很多可能出错的地方，请继续阅读。

Service 的配置是否正确？
----------------

这听起来可能很愚蠢，但你应该两次甚至三次检查你的 Service 配置是否正确，并且与你的 Pod 匹配。 查看你的 Service 配置并验证它：

`kubectl get service hostnames -o json`

`{     "kind": "Service",     "apiVersion": "v1",     "metadata": {         "name": "hostnames",         "namespace": "default",         "uid": "428c8b6c-24bc-11e5-936d-42010af0a9bc",         "resourceVersion": "347189",         "creationTimestamp": "2015-07-07T15:24:29Z",         "labels": {             "app": "hostnames"         }     },     "spec": {         "ports": [             {                 "name": "default",                 "protocol": "TCP",                 "port": 80,                 "targetPort": 9376,                 "nodePort": 0             }         ],         "selector": {             "app": "hostnames"         },         "clusterIP": "10.0.1.175",         "type": "ClusterIP",         "sessionAffinity": "None"     },     "status": {         "loadBalancer": {}     } }`

*   你想要访问的 Service 端口是否在 ​`spec.ports[]`​ 中列出？
*   ​`targetPort` ​对你的 Pod 来说正确吗（许多 Pod 使用与 Service 不同的端口）？
*   如果你想使用数值型端口，那么它的类型是一个数值（9376）还是字符串 “9376”？
*   如果你想使用名称型端口，那么你的 Pod 是否暴露了一个同名端口？
*   端口的 ​`protocol` ​和 Pod 的是否对应？

Service 有 Endpoints 吗？
----------------------

如果你已经走到了这一步，你已经确认你的 Service 被正确定义，并能通过 DNS 解析。 现在，让我们检查一下，你运行的 Pod 确实是被 Service 选中的。

早些时候，我们已经看到 Pod 是运行状态。我们可以再检查一下：

`kubectl get pods -l app=hostnames`

`NAME                        READY     STATUS    RESTARTS   AGE hostnames-632524106-bbpiw   1/1       Running   0          1h hostnames-632524106-ly40y   1/1       Running   0          1h hostnames-632524106-tlaok   1/1       Running   0          1h`

​`-l app=hostnames`​ 参数是在 Service 上配置的标签选择器。

"AGE" 列表明这些 Pod 已经启动一个小时了，这意味着它们运行良好，而未崩溃。

"RESTARTS" 列表明 Pod 没有经常崩溃或重启。经常性崩溃可能导致间歇性连接问题。 如果重启次数过大，通过调试 Pod 了解相关技术。

在 Kubernetes 系统中有一个控制回路，它评估每个 Service 的选择算符，并将结果保存到 Endpoints 对象中。

`kubectl get endpoints hostnames`

`NAME        ENDPOINTS hostnames   10.244.0.5:9376,10.244.0.6:9376,10.244.0.7:9376`

这证实 Endpoints 控制器已经为你的 Service 找到了正确的 Pods。 如果 ​`ENDPOINTS` ​列的值为 ​`<none>`​，则应检查 Service 的 ​`spec.selector`​ 字段， 以及你实际想选择的 Pod 的 ​`metadata.labels`​ 的值。 常见的错误是输入错误或其他错误，例如 Service 想选择 ​`app=hostnames`​，但是 Deployment 指定的是 ​`run=hostnames`​。在 1.18之前的版本中 ​`kubectl run`​ 也可以被用来创建 Deployment。

Pod 正常工作吗？
----------

至此，你知道你的 Service 已存在，并且已匹配到你的Pod。在本实验的开始，你已经检查了 Pod 本身。 让我们再次检查 Pod 是否确实在工作 - 你可以绕过 Service 机制并直接转到 Pod，如上面的 Endpoint 所示。

> Note: 这些命令使用的是 Pod 端口（9376），而不是 Service 端口（80）。

在 Pod 中运行：

`for ep in 10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376; do     wget -qO- $ep done`

输出应该类似这样：

`hostnames-632524106-bbpiw hostnames-632524106-ly40y hostnames-632524106-tlaok`

你希望 Endpoint 列表中的每个 Pod 都返回自己的主机名。 如果情况并非如此（或你自己的 Pod 的正确行为是什么），你应调查发生了什么事情。

kube-proxy 正常工作吗？
-----------------

如果你到达这里，则说明你的 Service 正在运行，拥有 Endpoints，Pod 真正在提供服务。 此时，整个 Service 代理机制是可疑的。让我们一步一步地确认它没问题。

Service 的默认实现（在大多数集群上应用的）是 kube-proxy。 这是一个在每个节点上运行的程序，负责配置用于提供 Service 抽象的机制之一。 如果你的集群不使用 kube-proxy，则以下各节将不适用，你将必须检查你正在使用的 Service 的实现方式。

### kube-proxy 正常运行吗？

确认 ​`kube-proxy`​ 正在节点上运行。 在节点上直接运行，你将会得到类似以下的输出：

`ps auxw | grep kube-proxy`

`root  4194  0.4  0.1 101864 17696 ?    Sl Jul04  25:43 /usr/local/bin/kube-proxy --master=https://kubernetes-master --kubeconfig=/var/lib/kube-proxy/kubeconfig --v=2`

下一步，确认它并没有出现明显的失败，比如连接主节点失败。要做到这一点，你必须查看日志。 访问日志的方式取决于你节点的操作系统。 在某些操作系统上日志是一个文件，如 /var/log/messages kube-proxy.log， 而其他操作系统使用 ​`journalctl` ​访问日志。你应该看到输出类似于：

`I1027 22:14:53.995134    5063 server.go:200] Running in resource-only container "/kube-proxy" I1027 22:14:53.998163    5063 server.go:247] Using iptables Proxier. I1027 22:14:53.999055    5063 server.go:255] Tearing down userspace rules. Errors here are acceptable. I1027 22:14:54.038140    5063 proxier.go:352] Setting endpoints for "kube-system/kube-dns:dns-tcp" to [10.244.1.3:53] I1027 22:14:54.038164    5063 proxier.go:352] Setting endpoints for "kube-system/kube-dns:dns" to [10.244.1.3:53] I1027 22:14:54.038209    5063 proxier.go:352] Setting endpoints for "default/kubernetes:https" to [10.240.0.2:443] I1027 22:14:54.038238    5063 proxier.go:429] Not syncing iptables until Services and Endpoints have been received from master I1027 22:14:54.040048    5063 proxier.go:294] Adding new service "default/kubernetes:https" at 10.0.0.1:443/TCP I1027 22:14:54.040154    5063 proxier.go:294] Adding new service "kube-system/kube-dns:dns" at 10.0.0.10:53/UDP I1027 22:14:54.040223    5063 proxier.go:294] Adding new service "kube-system/kube-dns:dns-tcp" at 10.0.0.10:53/TCP`

如果你看到有关无法连接主节点的错误消息，则应再次检查节点配置和安装步骤。

​`kube-proxy`​ 无法正确运行的可能原因之一是找不到所需的 ​`conntrack` ​二进制文件。 在一些 Linux 系统上，这也是可能发生的，这取决于你如何安装集群， 例如，你是手动开始一步步安装 Kubernetes。如果是这样的话，你需要手动安装 ​`conntrack` ​包（例如，在 Ubuntu 上使用 ​`sudo apt install conntrack`​），然后重试。

Kube-proxy 可以以若干模式之一运行。在上述日志中，​`Using iptables Proxier`​ 行表示 kube-proxy 在 "iptables" 模式下运行。 最常见的另一种模式是 "ipvs"。先前的 "userspace" 模式已经被这些所代替。

#### Iptables 模式

在 "iptables" 模式中, 你应该可以在节点上看到如下输出:

`iptables-save | grep hostnames`

`-A KUBE-SEP-57KPRZ3JQVENLNBR -s 10.244.3.6/32 -m comment --comment "default/hostnames:" -j MARK --set-xmark 0x00004000/0x00004000 -A KUBE-SEP-57KPRZ3JQVENLNBR -p tcp -m comment --comment "default/hostnames:" -m tcp -j DNAT --to-destination 10.244.3.6:9376 -A KUBE-SEP-WNBA2IHDGP2BOBGZ -s 10.244.1.7/32 -m comment --comment "default/hostnames:" -j MARK --set-xmark 0x00004000/0x00004000 -A KUBE-SEP-WNBA2IHDGP2BOBGZ -p tcp -m comment --comment "default/hostnames:" -m tcp -j DNAT --to-destination 10.244.1.7:9376 -A KUBE-SEP-X3P2623AGDH6CDF3 -s 10.244.2.3/32 -m comment --comment "default/hostnames:" -j MARK --set-xmark 0x00004000/0x00004000 -A KUBE-SEP-X3P2623AGDH6CDF3 -p tcp -m comment --comment "default/hostnames:" -m tcp -j DNAT --to-destination 10.244.2.3:9376 -A KUBE-SERVICES -d 10.0.1.175/32 -p tcp -m comment --comment "default/hostnames: cluster IP" -m tcp --dport 80 -j KUBE-SVC-NWV5X2332I4OT4T3 -A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment "default/hostnames:" -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-WNBA2IHDGP2BOBGZ -A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment "default/hostnames:" -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-X3P2623AGDH6CDF3 -A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment "default/hostnames:" -j KUBE-SEP-57KPRZ3JQVENLNBR`

对于每个 Service 的每个端口，应有 1 条 ​`KUBE-SERVICES`​ 规则、一个 ​`KUBE-SVC-<hash>`​ 链。 对于每个 Pod 末端，在那个 ​`KUBE-SVC-<hash>`​ 链中应该有一些规则与之对应，还应该 有一个 ​`KUBE-SEP-<hash>`​ 链与之对应，其中包含为数不多的几条规则。 实际的规则数量可能会根据你实际的配置（包括 NodePort 和 LoadBalancer 服务）有所不同。

#### IPVS 模式

在 "ipvs" 模式中, 你应该在节点下看到如下输出：

`ipvsadm -ln`

`Prot LocalAddress:Port Scheduler Flags   -> RemoteAddress:Port           Forward Weight ActiveConn InActConn ... TCP  10.0.1.175:80 rr   -> 10.244.0.5:9376               Masq    1      0          0   -> 10.244.0.6:9376               Masq    1      0          0   -> 10.244.0.7:9376               Masq    1      0          0 ...`

对于每个 Service 的每个端口，还有 NodePort，External IP 和 LoadBalancer 类型服务 的 IP，kube-proxy 将创建一个虚拟服务器。 对于每个 Pod 末端，它将创建相应的真实服务器。 在此示例中，服务主机名（​`10.0.1.175:80`​）拥有 3 个末端（​`10.244.0.5:9376`​、 ​`10.244.0.6:9376`​ 和 ​`10.244.0.7:9376`​）。

#### Userspace 模式

在极少数情况下，你可能会用到 "userspace" 模式。在你的节点上运行：

`iptables-save | grep hostnames`

`-A KUBE-PORTALS-CONTAINER -d 10.0.1.175/32 -p tcp -m comment --comment "default/hostnames:default" -m tcp --dport 80 -j REDIRECT --to-ports 48577 -A KUBE-PORTALS-HOST -d 10.0.1.175/32 -p tcp -m comment --comment "default/hostnames:default" -m tcp --dport 80 -j DNAT --to-destination 10.240.115.247:48577`

对于 Service （本例中只有一个）的每个端口，应当有 2 条规则： 一条 "KUBE-PORTALS-CONTAINER" 和一条 "KUBE-PORTALS-HOST" 规则。

几乎没有人应该再使用 "userspace" 模式，因此你在这里不会花更多的时间。

### kube-proxy 是否在运行?

假设你确实遇到上述情况之一，请重试从节点上通过 IP 访问你的 Service ：

`curl 10.0.1.175:80`

`hostnames-632524106-bbpiw`

如果失败，并且你正在使用用户空间代理，则可以尝试直接访问代理。 如果你使用的是 iptables 代理，请跳过本节。

回顾上面的 ​`iptables-save`​ 输出，并提取 ​`kube-proxy`​ 为你的 Service 所使用的端口号。 在上面的例子中，端口号是 “48577”。现在试着连接它：

`curl localhost:48577`

`hostnames-632524106-tlaok`

如果这步操作仍然失败，请查看 ​`kube-proxy`​ 日志中的特定行，如：

`Setting endpoints for default/hostnames:default to [10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376]`

如果你没有看到这些，请尝试将 ​`-V`​ 标志设置为 4 并重新启动 ​`kube-proxy`​，然后再查看日志。

### 边缘案例: Pod 无法通过 Service IP 连接到它本身 

这听起来似乎不太可能，但是确实可能发生，并且应该可行。

如果网络没有为“发夹模式（Hairpin）”流量生成正确配置， 通常当 ​`kube-proxy`​ 以 ​`iptables` ​模式运行，并且 Pod 与桥接网络连接时，就会发生这种情况。 ​`kubelet` ​提供了 ​`hairpin-mode`​ 标志。 如果 Service 的末端尝试访问自己的 Service VIP，则该端点可以把流量负载均衡回来到它们自身。 ​`hairpin-mode`​ 标志必须被设置为 ​`hairpin-veth`​ 或者 ​`promiscuous-bridge`​。

诊断此类问题的常见步骤如下：

*   确认 ​`hairpin-mode`​ 被设置为 ​`hairpin-veth`​ 或 ​`promiscuous-bridge`​。 你应该可以看到下面这样。本例中 ​`hairpin-mode`​ 被设置为 ​`promiscuous-bridge`​。

`ps auxw | grep kubelet`

`root      3392  1.1  0.8 186804 65208 ?        Sl   00:51  11:11 /usr/local/bin/kubelet --enable-debugging-handlers=true --config=/etc/kubernetes/manifests --allow-privileged=True --v=4 --cluster-dns=10.0.0.10 --cluster-domain=cluster.local --configure-cbr0=true --cgroup-root=/ --system-cgroups=/system --hairpin-mode=promiscuous-bridge --runtime-cgroups=/docker-daemon --kubelet-cgroups=/kubelet --babysit-daemons=true --max-pods=110 --serialize-image-pulls=false --outofdisk-transition-frequency=0`

*   确认有效的 ​`hairpin-mode`​。要做到这一点，你必须查看 kubelet 日志。 访问日志取决于节点的操作系统。在一些操作系统上，它是一个文件，如 /var/log/kubelet.log， 而其他操作系统则使用 ​`journalctl` ​访问日志。请注意，由于兼容性， 有效的 ​`hairpin-mode`​ 可能不匹配 ​`--hairpin-mode`​ 标志。在 kubelet.log 中检查是否有带有关键字 ​`hairpin` ​的日志行。应该有日志行指示有效的 ​`hairpin-mode`​，就像下面这样。

`I0629 00:51:43.648698    3252 kubelet.go:380] Hairpin mode set to "promiscuous-bridge"`       

*   如果有效的发夹模式是 ​`hairpin-veth`​, 要保证 ​`Kubelet` ​有操作节点上 ​`/sys`​ 的权限。 如果一切正常，你将会看到如下输出:

`for intf in /sys/devices/virtual/net/cbr0/brif/*; do cat $intf/hairpin_mode; done`

`1 1 1 1`

*   如果有效的发卡模式是 ​`promiscuous-bridge`​, 要保证 ​`Kubelet` ​有操作节点上 Linux 网桥的权限。如果 ​`cbr0` ​桥正在被使用且被正确设置，你将会看到如下输出:

`ifconfig cbr0 |grep PROMISC`

`UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1460  Metric:1`

*   如果以上步骤都不能解决问题，请寻求帮助。

寻求帮助
----

如果你走到这一步，那么就真的是奇怪的事情发生了。你的 Service 正在运行，有 Endpoints 存在， 你的 Pods 也确实在提供服务。你的 DNS 正常，​`iptables` ​规则已经安装，​`kube-proxy`​ 看起来也正常。 然而 Service 还是没有正常工作。这种情况下，请告诉我们，以便我们可以帮助调查！

通过 [Forum](https://discuss.kubernetes.io/) 或者 [GitHub](https://github.com/kubernetes/kubernetes) 联系我们。

##  3.  Kubernetes 调试StatefulSet
在开始之前
-----

*   你需要有一个 Kubernetes 集群，已配置好的 kubectl 命令行工具与你的集群进行通信。
*   你应该有一个运行中的 StatefulSet，以便用于调试。

调试 StatefulSet 
---------------

StatefulSet 在创建 Pod 时为其设置了 ​`app=myapp`​ 标签，列出仅属于某 StatefulSet 的所有 Pod 时，可以使用以下命令：

`kubectl get pods -l app=myapp`

如果你发现列出的任何 Pod 长时间处于 ​`Unknown` ​或 ​`Terminating` ​状态，请参阅 删除 StatefulSet Pod 了解如何处理它们的说明。 你可以参考调试 Pod 来调试 StatefulSet 中的各个 Pod。

##  4.  Kubernetes 调试Init容器
调试 Init 容器
----------

此页显示如何核查与 Init 容器执行相关的问题。 下面的示例命令行将 Pod 称为 ​`<pod-name>`​，而 Init 容器称为 ​`<init-container-1>`​ 和 ​`<init-container-2>`​。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

要检查版本，请输入 ​`kubectl version`​。

*   你应该熟悉 Init 容器的基础知识。
*   你应该已经配置好一个 Init 容器。

检查 Init 容器的状态
-------------

显示你的 Pod 的状态：

`kubectl get pod <pod-name>`

例如，状态 ​`Init:1/2`​ 表明两个 Init 容器中的一个已经成功完成：

`NAME         READY     STATUS     RESTARTS   AGE <pod-name>   0/1       Init:1/2   0          7s`

获取 Init 容器详情 
-------------

查看 Init 容器运行的更多详情：

`kubectl describe pod <pod-name>`

例如，对于包含两个 Init 容器的 Pod 可能显示如下信息：

`Init Containers:   <init-container-1>:     Container ID:    ...     ...     State:           Terminated       Reason:        Completed       Exit Code:     0       Started:       ...       Finished:      ...     Ready:           True     Restart Count:   0     ...   <init-container-2>:     Container ID:    ...     ...     State:           Waiting       Reason:        CrashLoopBackOff     Last State:      Terminated       Reason:        Error       Exit Code:     1       Started:       ...       Finished:      ...     Ready:           False     Restart Count:   3     ...`

你还可以通过编程方式读取 Pod Spec 上的 ​`status.initContainerStatuses`​ 字段，了解 Init 容器的状态：

`kubectl get pod nginx --template '{{.status.initContainerStatuses}}'`

此命令将返回与原始 JSON 中相同的信息.

通过 Init 容器访问日志 
---------------

与 Pod 名称一起传递 Init 容器名称，以访问容器的日志。

`kubectl logs <pod-name> -c <init-container-2>`

运行 Shell 脚本的 Init 容器在执行 Shell 脚本时输出命令本身。 例如，你可以在 Bash 中通过在脚本的开头运行 ​`set -x`​ 来实现。

理解 Pod 的状态 
-----------

以 ​`Init:`​ 开头的 Pod 状态汇总了 Init 容器执行的状态。 下表介绍调试 Init 容器时可能看到的一些状态值示例。

状态

含义

`Init:N/M`

Pod 包含 `M` 个 Init 容器，其中 `N` 个已经运行完成。

`Init:Error`

Init 容器已执行失败。

`Init:CrashLoopBackOff`

Init 容器执行总是失败。

`Pending`

Pod 还没有开始执行 Init 容器。

`PodInitializing` or `Running`

Pod 已经完成执行 Init 容器。

##  5.  Kubernetes 确定Pod失败的原因
确定 Pod 失败的原因
------------

本文介绍如何编写和读取容器的终止消息。

终止消息为容器提供了一种方法，可以将有关致命事件的信息写入某个位置， 在该位置可以通过仪表板和监控软件等工具轻松检索和显示致命事件。 在大多数情况下，你放入终止消息中的信息也应该写入 常规 Kubernetes 日志。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

要检查版本，请输入 ​`kubectl version`​。

读写终止消息
------

在本练习中，你将创建运行一个容器的 Pod。 配置文件指定在容器启动时要运行的命令。

`apiVersion: v1 kind: Pod metadata:   name: termination-demo spec:   containers:   - name: termination-demo-container     image: debian     command: ["/bin/sh"]     args: ["-c", "sleep 10 && echo Sleep expired > /dev/termination-log"]`

1.  基于 YAML 配置文件创建 Pod：

 `kubectl apply -f https://k8s.io/examples/debug/termination.yaml`   

YAML 文件中，在 ​`command` ​和 ​`args` ​字段，你可以看到容器休眠 10 秒然后将 "Sleep expired" 写入 ​`/dev/termination-log`​ 文件。 容器写完 "Sleep expired" 消息后就终止了。

4.  显示 Pod 的信息：

 `kubectl get pod termination-demo`

重复前面的命令直到 Pod 不再运行。

7.  显示 Pod 的详细信息：

 `kubectl get pod termination-demo --output=yaml`

输出结果包含 "Sleep expired" 消息：

 `apiVersion: v1  kind: Pod  ...      lastState:        terminated:          containerID: ...          exitCode: 0          finishedAt: ...          message: |            Sleep expired          ...`

11.  使用 Go 模板过滤输出结果，使其只含有终止消息：

 `kubectl get pod termination-demo -o go-template="{{range .status.containerStatuses}}{{.lastState.terminated.message}}{{end}}"`

如果你正在运行多容器 Pod，则可以使用 Go 模板来包含容器的名称。这样，你可以发现哪些容器出现故障:

`kubectl get pod multi-container-pod -o go-template='{{range .status.containerStatuses}}{{printf "%s:\n%s\n\n" .name .lastState.terminated.message}}{{end}}'`

定制终止消息
------

Kubernetes 从容器的 ​`terminationMessagePath` ​字段中指定的终止消息文件中检索终止消息， 默认值为 ​`/dev/termination-log`​。 通过定制这个字段，你可以告诉 Kubernetes 使用不同的文件。 Kubernetes 使用指定文件中的内容在成功和失败时填充容器的状态消息。

在下例中，容器将终止消息写入 ​`/tmp/my-log`​ 给 Kubernetes 来接收：

`apiVersion: v1 kind: Pod metadata:   name: msg-path-demo spec:   containers:   - name: msg-path-demo-container     image: debian     terminationMessagePath: "/tmp/my-log"`

此外，用户可以设置容器的 ​`terminationMessagePolicy` ​字段，以便进一步自定义。 此字段默认为 "​`File`​"，这意味着仅从终止消息文件中检索终止消息。 通过将 ​`terminationMessagePolicy` ​设置为 "​`FallbackToLogsOnError`​"，你就可以告诉 Kubernetes，在容器因错误退出时，如果终止消息文件为空，则使用容器日志输出的最后一块作为终止消息。 日志输出限制为 2048 字节或 80 行，以较小者为准。

##  6.  Kubernetes 获取正在运行容器的Shell
在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

要检查版本，请输入 ​​`kubectl version`​​。

获取容器的 Shell 
------------

在本练习中，你将创建包含一个容器的 Pod。容器运行 nginx 镜像。下面是 Pod 的配置文件：

`apiVersion: v1 kind: Pod metadata:   name: shell-demo spec:   volumes:   - name: shared-data     emptyDir: {}   containers:   - name: nginx     image: nginx     volumeMounts:     - name: shared-data       mountPath: /usr/share/nginx/html   hostNetwork: true   dnsPolicy: Default`

创建 Pod：

`kubectl create -f https://k8s.io/examples/application/shell-demo.yaml`

检查容器是否运行正常：

`kubectl get pod shell-demo`

获取正在运行容器的 Shell：

`kubectl exec -it shell-demo -- /bin/bash`

> Note:  
> 双破折号 "--" 用于将要传递给命令的参数与 kubectl 的参数分开。

在 shell 中，打印根目录：

`root@shell-demo:/# ls /`

在 shell 中，实验其他命令。下面是一些示例：

`root@shell-demo:/# ls / root@shell-demo:/# cat /proc/mounts root@shell-demo:/# cat /proc/1/maps root@shell-demo:/# apt-get update root@shell-demo:/# apt-get install -y tcpdump root@shell-demo:/# tcpdump root@shell-demo:/# apt-get install -y lsof root@shell-demo:/# lsof root@shell-demo:/# apt-get install -y procps root@shell-demo:/# ps aux root@shell-demo:/# ps aux | grep nginx`

编写 nginx 的根页面
-------------

再看一下 Pod 的配置文件。该 Pod 有个 ​`emptyDir` ​卷，容器将该卷挂载到了 ​`/usr/share/nginx/html`​。

在 shell 中，在 ​`/usr/share/nginx/html`​ 目录创建一个 ​`index.html`​ 文件：

`root@shell-demo:/# echo Hello shell demo > /usr/share/nginx/html/index.html`

在 shell 中，向 nginx 服务器发送 GET 请求：

`root@shell-demo:/# apt-get update root@shell-demo:/# apt-get install curl root@shell-demo:/# curl localhost`

输出结果显示了你在 ​`index.html`​ 中写入的文本。

`Hello shell demo`

当用完 shell 后，输入 ​`exit` ​退出。

在容器中运行单个命令
----------

在普通的命令窗口（而不是 shell）中，打印环境运行容器中的变量：

`kubectl exec shell-demo env`

实验运行其他命令。下面是一些示例：

`kubectl exec shell-demo ps aux kubectl exec shell-demo ls / kubectl exec shell-demo cat /proc/1/mounts`

当 Pod 包含多个容器时打开 shell
---------------------

如果 Pod 有多个容器，​`--container`​ 或者 ​`-c`​ 可以在 ​`kubectl exec`​ 命令中指定容器。 例如，你有个名为 my-pod 的 Pod，该 Pod 有两个容器分别为 main-app 和 healper-app。 下面的命令将会打开一个 shell 访问 main-app 容器。

`kubectl exec -it my-pod --container main-app -- /bin/bash`

##  7.  Kubernetes 调试运行中的Pod
在开始之前
-----

*   你的 Pod 应该已经被调度并正在运行中， 如果你的 Pod 还没有运行，请参阅[调试 Pod](https://www.w3cschool.cn/kubernetes/kubernetes-gyhr3o7u.html?RECACHE=1)。
*   对于一些高级调试步骤，你应该知道 Pod 具体运行在哪个节点上，并具有在该节点上运行命令的 shell 访问权限。 你不需要任何访问权限就可以使用 ​`kubectl` ​去运行一些标准调试步骤。

使用 kubectl describe pod 命令获取 Pod 详情
-----------------------------------

与之前的例子类似，我们使用一个 Deployment 来创建两个 Pod。

`apiVersion: apps/v1 kind: Deployment metadata:   name: nginx-deployment spec:   selector:     matchLabels:       app: nginx   replicas: 2   template:     metadata:       labels:         app: nginx     spec:       containers:       - name: nginx         image: nginx         resources:           limits:             memory: "128Mi"             cpu: "500m"         ports:         - containerPort: 80`

使用如下命令创建 Deployment：

`kubectl apply -f https://k8s.io/examples/application/nginx-with-request.yaml`

`deployment.apps/nginx-deployment created`

使用如下命令查看 Pod 状态：

`kubectl get pods`

`NAME                                READY   STATUS    RESTARTS   AGE nginx-deployment-67d4bdd6f5-cx2nz   1/1     Running   0          13s nginx-deployment-67d4bdd6f5-w6kd7   1/1     Running   0          13s`

我们可以使用 ​`kubectl describe pod`​ 命令来查询每个 Pod 的更多信息，比如：

`kubectl describe pod nginx-deployment-67d4bdd6f5-w6kd7`

`Name:         nginx-deployment-67d4bdd6f5-w6kd7 Namespace:    default Priority:     0 Node:         kube-worker-1/192.168.0.113 Start Time:   Thu, 17 Feb 2022 16:51:01 -0500 Labels:       app=nginx               pod-template-hash=67d4bdd6f5 Annotations:  <none> Status:       Running IP:           10.88.0.3 IPs:   IP:           10.88.0.3   IP:           2001:db8::1 Controlled By:  ReplicaSet/nginx-deployment-67d4bdd6f5 Containers:   nginx:     Container ID:   containerd://5403af59a2b46ee5a23fb0ae4b1e077f7ca5c5fb7af16e1ab21c00e0e616462a     Image:          nginx     Image ID:       docker.io/library/nginx@sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767     Port:           80/TCP     Host Port:      0/TCP     State:          Running       Started:      Thu, 17 Feb 2022 16:51:05 -0500     Ready:          True     Restart Count:  0     Limits:       cpu:     500m       memory:  128Mi     Requests:       cpu:        500m       memory:     128Mi     Environment:  <none>     Mounts:       /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-bgsgp (ro) Conditions:   Type              Status   Initialized       True    Ready             True    ContainersReady   True    PodScheduled      True  Volumes:   kube-api-access-bgsgp:     Type:                    Projected (a volume that contains injected data from multiple sources)     TokenExpirationSeconds:  3607     ConfigMapName:           kube-root-ca.crt     ConfigMapOptional:       <nil>     DownwardAPI:             true QoS Class:                   Guaranteed Node-Selectors:              <none> Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s                              node.kubernetes.io/unreachable:NoExecute op=Exists for 300s Events:   Type    Reason     Age   From               Message   ----    ------     ----  ----               -------   Normal  Scheduled  34s   default-scheduler  Successfully assigned default/nginx-deployment-67d4bdd6f5-w6kd7 to kube-worker-1   Normal  Pulling    31s   kubelet            Pulling image "nginx"   Normal  Pulled     30s   kubelet            Successfully pulled image "nginx" in 1.146417389s   Normal  Created    30s   kubelet            Created container nginx   Normal  Started    30s   kubelet            Started container nginx`

在这里，你可以看到有关容器和 Pod 的配置信息（标签、资源需求等）， 以及有关容器和 Pod 的状态信息（状态、就绪、重启计数、事件等） 。

容器状态是 Waiting、Running 和 Terminated 之一。 根据状态的不同，还有对应的额外的信息 —— 在这里你可以看到， 对于处于运行状态的容器，系统会告诉你容器的启动时间。

Ready 指示是否通过了最后一个就绪态探测。 (在本例中，容器没有配置就绪态探测；如果没有配置就绪态探测，则假定容器已经就绪。)

Restart Count 告诉你容器已重启的次数； 这些信息对于定位配置了 “Always” 重启策略的容器持续崩溃问题非常有用。

目前，唯一与 Pod 有关的状态是 Ready 状况，该状况表明 Pod 能够为请求提供服务， 并且应该添加到相应服务的负载均衡池中。

最后，你还可以看到与 Pod 相关的近期事件。 系统通过指示第一次和最后一次看到事件以及看到该事件的次数来压缩多个相同的事件。 “From” 标明记录事件的组件， “SubobjectPath” 告诉你引用了哪个对象（例如 Pod 中的容器）， “Reason” 和 “Message” 告诉你发生了什么。

例子: 调试 Pending 状态的 Pod
----------------------

可以使用事件来调试的一个常见的场景是，你创建 Pod 无法被调度到任何节点。 比如，Pod 请求的资源比较多，没有任何一个节点能够满足，或者它指定了一个标签，没有节点可匹配。 假定我们创建之前的 Deployment 时指定副本数是 5（不再是 2），并且请求 600 毫核（不再是 500）， 对于一个 4 个节点的集群，若每个节点只有 1 个 CPU，这时至少有一个 Pod 不能被调度。 （需要注意的是，其他集群插件 Pod，比如 fluentd、skydns 等等会在每个节点上运行， 如果我们需求 1000 毫核，将不会有 Pod 会被调度。）

`kubectl get pods`

`NAME                                READY     STATUS    RESTARTS   AGE nginx-deployment-1006230814-6winp   1/1       Running   0          7m nginx-deployment-1006230814-fmgu3   1/1       Running   0          7m nginx-deployment-1370807587-6ekbw   1/1       Running   0          1m nginx-deployment-1370807587-fg172   0/1       Pending   0          1m nginx-deployment-1370807587-fz9sd   0/1       Pending   0          1m`

为了查找 Pod nginx-deployment-1370807587-fz9sd 没有运行的原因，我们可以使用 ​`kubectl describe pod`​ 命令描述 Pod，查看其事件：

`kubectl describe pod nginx-deployment-1370807587-fz9sd`

  `Name:		nginx-deployment-1370807587-fz9sd   Namespace:	default   Node:		/   Labels:		app=nginx,pod-template-hash=1370807587   Status:		Pending   IP:   Controllers:	ReplicaSet/nginx-deployment-1370807587   Containers:     nginx:       Image:	nginx       Port:	80/TCP       QoS Tier:         memory:	Guaranteed         cpu:	Guaranteed       Limits:         cpu:	1         memory:	128Mi       Requests:         cpu:	1         memory:	128Mi       Environment Variables:   Volumes:     default-token-4bcbi:       Type:	Secret (a volume populated by a Secret)       SecretName:	default-token-4bcbi   Events:     FirstSeen	LastSeen	Count	From			        SubobjectPath	Type		Reason			    Message     ---------	--------	-----	----			        -------------	--------	------			    -------     1m		    48s		    7	    {default-scheduler }			        Warning		FailedScheduling	pod (nginx-deployment-1370807587-fz9sd) failed to fit in any node   fit failure on node (kubernetes-node-6ta5): Node didn't have enough resource: CPU, requested: 1000, used: 1420, capacity: 2000   fit failure on node (kubernetes-node-wul5): Node didn't have enough resource: CPU, requested: 1000, used: 1100, capacity: 2000`

这里你可以看到由调度器记录的事件，它表明了 Pod 不能被调度的原因是 ​`FailedScheduling`​（也可能是其他值）。 其 message 部分表明没有任何节点拥有足够多的资源。

要纠正这种情况，可以使用 ​`kubectl scale`​ 更新 Deployment，以指定 4 个或更少的副本。 (或者你可以让 Pod 继续保持这个状态，这是无害的。)

你在 ​`kubectl describe pod`​ 结尾处看到的事件都保存在 etcd 中， 并提供关于集群中正在发生的事情的高级信息。 如果需要列出所有事件，可使用命令：

`kubectl get events`

但是，需要注意的是，事件是区分名字空间的。 如果你对某些名字空间域的对象（比如 ​`my-namespace`​ 名字下的 Pod）的事件感兴趣, 你需要显式地在命令行中指定名字空间：

`kubectl get events --namespace=my-namespace`

查看所有 namespace 的事件，可使用 ​`--all-namespaces`​ 参数。

除了 ​`kubectl describe pod`​ 以外，另一种获取 Pod 额外信息（除了 ​`kubectl get pod`​）的方法 是给 ​`kubectl get pod`​ 增加 ​`-o yaml`​ 输出格式参数。 该命令将以 YAML 格式为你提供比 ​`kubectl describe pod`​ 更多的信息 —— 实际上是系统拥有的关于 Pod 的所有信息。 在这里，你将看到注解（没有标签限制的键值元数据，由 Kubernetes 系统组件在内部使用）、 重启策略、端口和卷等。

`kubectl get pod nginx-deployment-1006230814-6winp -o yaml`

`apiVersion: v1 kind: Pod metadata:   creationTimestamp: "2022-02-17T21:51:01Z"   generateName: nginx-deployment-67d4bdd6f5-   labels:     app: nginx     pod-template-hash: 67d4bdd6f5   name: nginx-deployment-67d4bdd6f5-w6kd7   namespace: default   ownerReferences:   - apiVersion: apps/v1     blockOwnerDeletion: true     controller: true     kind: ReplicaSet     name: nginx-deployment-67d4bdd6f5     uid: 7d41dfd4-84c0-4be4-88ab-cedbe626ad82   resourceVersion: "1364"   uid: a6501da1-0447-4262-98eb-c03d4002222e spec:   containers:   - image: nginx     imagePullPolicy: Always     name: nginx     ports:     - containerPort: 80       protocol: TCP     resources:       limits:         cpu: 500m         memory: 128Mi       requests:         cpu: 500m         memory: 128Mi     terminationMessagePath: /dev/termination-log     terminationMessagePolicy: File     volumeMounts:     - mountPath: /var/run/secrets/kubernetes.io/serviceaccount       name: kube-api-access-bgsgp       readOnly: true   dnsPolicy: ClusterFirst   enableServiceLinks: true   nodeName: kube-worker-1   preemptionPolicy: PreemptLowerPriority   priority: 0   restartPolicy: Always   schedulerName: default-scheduler   securityContext: {}   serviceAccount: default   serviceAccountName: default   terminationGracePeriodSeconds: 30   tolerations:   - effect: NoExecute     key: node.kubernetes.io/not-ready     operator: Exists     tolerationSeconds: 300   - effect: NoExecute     key: node.kubernetes.io/unreachable     operator: Exists     tolerationSeconds: 300   volumes:   - name: kube-api-access-bgsgp     projected:       defaultMode: 420       sources:       - serviceAccountToken:           expirationSeconds: 3607           path: token       - configMap:           items:           - key: ca.crt             path: ca.crt           name: kube-root-ca.crt       - downwardAPI:           items:           - fieldRef:               apiVersion: v1               fieldPath: metadata.namespace             path: namespace status:   conditions:   - lastProbeTime: null     lastTransitionTime: "2022-02-17T21:51:01Z"     status: "True"     type: Initialized   - lastProbeTime: null     lastTransitionTime: "2022-02-17T21:51:06Z"     status: "True"     type: Ready   - lastProbeTime: null     lastTransitionTime: "2022-02-17T21:51:06Z"     status: "True"     type: ContainersReady   - lastProbeTime: null     lastTransitionTime: "2022-02-17T21:51:01Z"     status: "True"     type: PodScheduled   containerStatuses:   - containerID: containerd://5403af59a2b46ee5a23fb0ae4b1e077f7ca5c5fb7af16e1ab21c00e0e616462a     image: docker.io/library/nginx:latest     imageID: docker.io/library/nginx@sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767     lastState: {}     name: nginx     ready: true     restartCount: 0     started: true     state:       running:         startedAt: "2022-02-17T21:51:05Z"   hostIP: 192.168.0.113   phase: Running   podIP: 10.88.0.3   podIPs:   - ip: 10.88.0.3   - ip: 2001:db8::1   qosClass: Guaranteed   startTime: "2022-02-17T21:51:01Z"`

检查 Pod 的日志
----------

首先，查看受到影响的容器的日志：

`kubectl logs ${POD_NAME} ${CONTAINER_NAME}`

如果你的容器之前崩溃过，你可以通过下面命令访问之前容器的崩溃日志：

`kubectl logs --previous ${POD_NAME} ${CONTAINER_NAME}`

使用容器 exec 进行调试
--------------

如果 容器镜像 包含调试程序， 比如从 Linux 和 Windows 操作系统基础镜像构建的镜像，你可以使用 ​`kubectl exec`​ 命令 在特定的容器中运行一些命令：

`kubectl exec ${POD_NAME} -c ${CONTAINER_NAME} -- ${CMD} ${ARG1} ${ARG2} ... ${ARGN}`

> Note: ​`-c ${CONTAINER_NAME}`​ 是可选择的。如果Pod中仅包含一个容器，就可以忽略它。

例如，要查看正在运行的 Cassandra pod中的日志，可以运行：

`kubectl exec cassandra -- cat /var/log/cassandra/system.log`

你可以在 ​`kubectl exec`​ 命令后面加上 ​`-i`​ 和 ​`-t`​ 来运行一个连接到你的终端的 Shell，比如：

`kubectl exec -it cassandra -- sh`

使用临时调试容器来进行调试
-------------

FEATURE STATE: Kubernetes v1.23 \[beta\]

当由于容器崩溃或容器镜像不包含调试程序（例如[无发行版镜像](https://github.com/GoogleContainerTools/distroless)等） 而导致 ​`kubectl exec`​ 无法运行时，临时容器对于排除交互式故障很有用。

使用临时容器来调试的例子
------------

你可以使用 ​`kubectl debug`​ 命令来给正在运行中的 Pod 增加一个临时容器。 首先，像示例一样创建一个 pod：

`kubectl run ephemeral-demo --image=k8s.gcr.io/pause:3.1 --restart=Never`

> Note: 本节示例中使用 ​`pause` ​容器镜像，因为它不包含调试程序，但是这个方法适用于所有容器镜像。

如果你尝试使用 ​`kubectl exec`​ 来创建一个 shell，你将会看到一个错误，因为这个容器镜像中没有 shell。

`kubectl exec -it ephemeral-demo -- sh`

`OCI runtime exec failed: exec failed: container_linux.go:346: starting container process caused "exec: \"sh\": executable file not found in $PATH": unknown`

你可以改为使用 ​`kubectl debug`​ 添加调试容器。 如果你指定 ​`-i`​ 或者 ​`--interactive`​ 参数，​`kubectl` ​将自动挂接到临时容器的控制台。

`kubectl debug -it ephemeral-demo --image=busybox:1.28 --target=ephemeral-demo`

`Defaulting debug container name to debugger-8xzrl. If you don't see a command prompt, try pressing enter. / #`

此命令添加一个新的 busybox 容器并将其挂接到该容器。​`--target`​ 参数指定另一个容器的进程命名空间。 这是必需的，因为 ​`kubectl run`​ 不能在它创建的pod中启用 共享进程命名空间。

> Note: 容器运行时必须支持 ​`--target`​ 参数。 如果不支持，则临时容器可能不会启动，或者可能使用隔离的进程命名空间启动， 以便 ​`ps` ​不显示其他容器内的进程。

你可以使用 ​`kubectl describe`​ 查看新创建的临时容器的状态：

`kubectl describe pod ephemeral-demo`

`... Ephemeral Containers:   debugger-8xzrl:     Container ID:   docker://b888f9adfd15bd5739fefaa39e1df4dd3c617b9902082b1cfdc29c4028ffb2eb     Image:          busybox     Image ID:       docker-pullable://busybox@sha256:1828edd60c5efd34b2bf5dd3282ec0cc04d47b2ff9caa0b6d4f07a21d1c08084     Port:           <none>     Host Port:      <none>     State:          Running       Started:      Wed, 12 Feb 2020 14:25:42 +0100     Ready:          False     Restart Count:  0     Environment:    <none>     Mounts:         <none> ...`

使用 ​`kubectl delete`​ 来移除已经结束掉的 Pod：

`kubectl delete pod ephemeral-demo`

通过 Pod 副本调试
-----------

有些时候 Pod 的配置参数使得在某些情况下很难执行故障排查。 例如，在容器镜像中不包含 shell 或者你的应用程序在启动时崩溃的情况下， 就不能通过运行 ​`kubectl exec`​ 来排查容器故障。 在这些情况下，你可以使用 ​`kubectl debug`​ 来创建 Pod 的副本，通过更改配置帮助调试。

### 在添加新的容器时创建 Pod 副本

当应用程序正在运行但其表现不符合预期时，你会希望在 Pod 中添加额外的调试工具， 这时添加新容器是很有用的。

例如，应用的容器镜像是建立在 ​`busybox` ​的基础上， 但是你需要 ​`busybox` ​中并不包含的调试工具。 你可以使用 ​`kubectl run`​ 模拟这个场景:

`kubectl run myapp --image=busybox:1.28 --restart=Never -- sleep 1d`

通过运行以下命令，建立 ​`myapp` ​的一个名为 ​`myapp-debug`​ 的副本， 新增了一个用于调试的 Ubuntu 容器，

`kubectl debug myapp -it --image=ubuntu --share-processes --copy-to=myapp-debug`

`Defaulting debug container name to debugger-w7xmf. If you don't see a command prompt, try pressing enter. root@myapp-debug:/#`

> Note:  
> 
> *   如果你没有使用 ​`--container`​ 指定新的容器名，​`kubectl debug`​ 会自动生成的。
> *   默认情况下，​`-i`​ 标志使 ​`kubectl debug`​ 附加到新容器上。 你可以通过指定 --attach=false 来防止这种情况。 如果你的会话断开连接，你可以使用 ​`kubectl attach`​ 重新连接。
> *   ​`--share-processes`​ 允许在此 Pod 中的其他容器中查看该容器的进程。

不要忘了清理调试 Pod：

`kubectl delete pod myapp myapp-debug`

### 在改变 Pod 命令时创建 Pod 副本 

有时更改容器的命令很有用，例如添加调试标志或因为应用崩溃。

为了模拟应用崩溃的场景，使用 ​`kubectl run`​ 命令创建一个立即退出的容器：

`kubectl run --image=busybox:1.28 myapp -- false`

使用 ​`kubectl describe pod myapp`​ 命令，你可以看到容器崩溃了：

`Containers:   myapp:     Image:         busybox     ...     Args:       false     State:          Waiting       Reason:       CrashLoopBackOff     Last State:     Terminated       Reason:       Error       Exit Code:    1`

你可以使用 ​`kubectl debug`​ 命令创建该 Pod 的一个副本， 在该副本中命令改变为交互式 shell：

`kubectl debug myapp -it --copy-to=myapp-debug --container=myapp -- sh`

`If you don't see a command prompt, try pressing enter. / #`

现在你有了一个可以执行类似检查文件系统路径或者手动运行容器命令的交互式 shell。

> Note:  
> 
> *   要更改指定容器的命令，你必须用 ​`--container`​ 命令指定容器的名字， 否则 ​`kubectl debug`​ 将建立一个新的容器运行你指定的命令。
> *   默认情况下，标志 ​`-i`​ 使 ​`kubectl debug`​ 附加到容器。 你可通过指定 ​`--attach=false`​ 来防止这种情况。 如果你的断开连接，可以使用 ​`kubectl attach`​ 重新连接。

不要忘了清理调试 Pod：

`kubectl delete pod myapp myapp-debug`

### 在更改容器镜像时创建 Pod 副本

在某些情况下，你可能想从正常生产容器镜像中 把行为异常的 Pod 改变为包含调试版本或者附加应用的镜像。

下面的例子，用 ​`kubectl run`​创建一个 Pod：

`kubectl run myapp --image=busybox:1.28 --restart=Never -- sleep 1d`

现在可以使用 ​`kubectl debug`​ 创建一个副本 并改变容器镜像为 ​`ubuntu`​：

`kubectl debug myapp --copy-to=myapp-debug --set-image=*=ubuntu`

​`--set-image`​ 与 ​`container_name=image`​ 使用相同的 ​`kubectl set image`​ 语法。 ​`*=ubuntu`​ 表示把所有容器的镜像改为 ​`ubuntu`​。

`kubectl delete pod myapp myapp-debug`

在节点上通过 shell 来进行调试
------------------

如果这些方法都不起作用，你可以找到运行 Pod 的节点，然后在节点上部署一个运行在宿主名字空间的特权 Pod。

你可以通过​`kubectl debug`​ 在节点上创建一个交互式 shell：

`kubectl debug node/mynode -it --image=ubuntu`

`Creating debugging pod node-debugger-mynode-pdx84 with container debugger on node mynode. If you don't see a command prompt, try pressing enter. root@ek8s:/#`

当在节点上创建调试会话，注意以下要点：

*   ​`kubectl debug`​ 基于节点的名字自动生成新的 Pod 的名字。
*   新的调试容器运行在宿主命名空间里（IPC, 网络 还有PID命名空间）。
*   节点的根文件系统会被挂载在 ​`/host`​。

当你完成节点调试时，不要忘记清理调试 Pod：

`kubectl delete pod node-debugger-mynode-pdx84`

#  18.  Kubernetes 集群故障排查

##  1.  Kubernetes 资源指标管道
资源指标管道
------

对于 Kubernetes，Metrics API 提供了一组基本的指标，以支持自动伸缩和类似的用例。 该 API 提供有关节点和 Pod 的资源使用情况的信息， 包括 CPU 和内存的指标。如果将 Metrics API 部署到集群中， 那么 Kubernetes API 的客户端就可以查询这些信息，并且可以使用 Kubernetes 的访问控制机制来管理权限。

​`HorizontalPodAutoscaler` ​(HPA) 和 ​`[VerticalPodAutoscaler](https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler target=)` ​(VPA) 使用 metrics API 中的数据调整工作负载副本和资源，以满足客户需求。

你也可以通过 ​`kubectl top`​ 命令来查看资源指标。

> Note:  
> Metrics API 及其启用的指标管道仅提供最少的 CPU 和内存指标，以启用使用 HPA 和/或 VPA 的自动扩展。 如果你想提供更完整的指标集，你可以通过部署使用 Custom Metrics API 的第二个 指标管道来作为简单的 Metrics API 的补充。

图 1 说明了资源指标管道的架构。

![](https://atts.w3cschool.cn/attachments/image/20220530/1653872801778408.png)  

图 1. 资源指标管道

图中从右到左的架构组件包括以下内容：

*   ​`[cAdvisor](https://github.com/google/cadvisor)`​: 用于收集、聚合和公开 Kubelet 中包含的容器指标的守护程序。
*   ​`kubelet`​: 用于管理容器资源的节点代理。 可以使用 /metrics/resource 和 /stats kubelet API 端点访问资源指标。
*   ​`Summary API`​: kubelet 提供的 API，用于发现和检索可通过 /stats 端点获得的每个节点的汇总统计信息。
*   ​`metrics-server`​: 集群插件组件，用于收集和聚合从每个 kubelet 中提取的资源指标。 API 服务器提供 Metrics API 以供 HPA、VPA 和 kubectl top 命令使用。 Metrics Server 是 Metrics API 的参考实现。
*   ​`Metrics API`​: Kubernetes API 支持访问用于工作负载自动缩放的 CPU 和内存。 要在你的集群中进行这项工作，你需要一个提供 Metrics API 的 API 扩展服务器。

> Note: cAdvisor 支持从 cgroups 读取指标，它适用于 Linux 上的典型容器运行时。 如果你使用基于其他资源隔离机制的容器运行时，例如虚拟化，那么该容器运行时必须支持 [CRI 容器指标](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/cri-container-stats.md) 以便 kubelet 可以使用指标。

Metrics API 
------------

FEATURE STATE: Kubernetes 1.8 \[beta\]

metrics-server 实现了 Metrics API。此 API 允许你访问集群中节点和 Pod 的 CPU 和内存使用情况。 它的主要作用是将资源使用指标提供给 K8s 自动缩放器组件。

下面是一个 ​`minikube` ​节点的 Metrics API 请求示例，通过 ​`jq` ​管道处理以便于阅读：

`kubectl get --raw "/apis/metrics.k8s.io/v1beta1/nodes/minikube" | jq '.'`

这是使用 ​`curl` ​来执行的相同 API 调用：

`curl http://localhost:8080/apis/metrics.k8s.io/v1beta1/nodes/minikube`

响应示例：

`{   "kind": "NodeMetrics",   "apiVersion": "metrics.k8s.io/v1beta1",   "metadata": {     "name": "minikube",     "selfLink": "/apis/metrics.k8s.io/v1beta1/nodes/minikube",     "creationTimestamp": "2022-01-27T18:48:43Z"   },   "timestamp": "2022-01-27T18:48:33Z",   "window": "30s",   "usage": {     "cpu": "487558164n",     "memory": "732212Ki"   } }`

下面是一个 ​`kube-system`​ 命名空间中的 ​`kube-scheduler-minikube`​ Pod 的 Metrics API 请求示例， 通过 ​`jq`​ 管道处理以便于阅读：

`kubectl get --raw "/apis/metrics.k8s.io/v1beta1/namespaces/kube-system/pods/kube-scheduler-minikube" | jq '.'`

这是使用 ​`curl` ​来完成的相同 API 调用：

`curl http://localhost:8080/apis/metrics.k8s.io/v1beta1/namespaces/kube-system/pods/kube-scheduler-minikube`

响应示例：

`{   "kind": "PodMetrics",   "apiVersion": "metrics.k8s.io/v1beta1",   "metadata": {     "name": "kube-scheduler-minikube",     "namespace": "kube-system",     "selfLink": "/apis/metrics.k8s.io/v1beta1/namespaces/kube-system/pods/kube-scheduler-minikube",     "creationTimestamp": "2022-01-27T19:25:00Z"   },   "timestamp": "2022-01-27T19:24:31Z",   "window": "30s",   "containers": [     {       "name": "kube-scheduler",       "usage": {         "cpu": "9559630n",         "memory": "22244Ki"       }     }   ] }`

Metrics API 在 [k8s.io/metrics](https://github.com/kubernetes/metrics) 代码库中定义。 你必须启用 API 聚合层并为 ​`metrics.k8s.io`​ API 注册一个 APIService。

要了解有关 Metrics API 的更多信息， 请参阅资源 [Resource Metrics API Design](https://github.com/kubernetes/design-proposals-archive/blob/main/instrumentation/resource-metrics-api.md)、 [metrics-server 代码库](https://github.com/kubernetes-sigs/metrics-server) 和 [Resource Metrics API](https://github.com/kubernetes/metrics target=)。

> Note: 你必须部署提供 Metrics API 服务的 metrics-server 或其他适配器才能访问它。

度量资源用量 
-------

### CPU 

CPU 报告为以 cpu 为单位测量的平均核心使用率。在 Kubernetes 中， 一个 cpu 相当于云提供商的 1 个 vCPU/Core，以及裸机 Intel 处理器上的 1 个超线程。

该值是通过对内核提供的累积 CPU 计数器（在 Linux 和 Windows 内核中）取一个速率得出的。 用于计算 CPU 的时间窗口显示在 Metrics API 的窗口字段下。

### 内存 

内存报告为在收集度量标准的那一刻的工作集大小，以字节为单位。

在理想情况下，“工作集”是在内存压力下无法释放的正在使用的内存量。 然而，工作集的计算因主机操作系统而异，并且通常大量使用启发式算法来产生估计。

Kubernetes 模型中，容器工作集是由容器运行时计算的与相关容器关联的匿名内存。 工作集指标通常还包括一些缓存（文件支持）内存，因为主机操作系统不能总是回收页面。

Metrics 服务器 
------------

metrics-server 从 kubelet 中获取资源指标，并通过 Metrics API 在 Kubernetes API 服务器中公开它们，以供 HPA 和 VPA 使用。 你还可以使用 ​`kubectl top`​ 命令查看这些指标。

metrics-server 使用 Kubernetes API 来跟踪集群中的节点和 Pod。metrics-server 服务器通过 HTTP 查询每个节点以获取指标。 metrics-server 还构建了 Pod 元数据的内部视图，并维护 Pod 健康状况的缓存。 缓存的 Pod 健康信息可通过 metrics-server 提供的扩展 API 获得。

例如，对于 HPA 查询，metrics-server 需要确定哪些 Pod 满足 Deployment 中的标签选择器。

metrics-server 调用 kubelet API 从每个节点收集指标。根据它使用的度量服务器版本：

*   版本 v0.6.0+ 中，使用指标资源端点 ​`/metrics/resource` ​
*   旧版本中使用 Summary API 端点 ​`/stats/summary`​

### Summary API 来源

Kubelet 在节点、卷、Pod 和容器级别收集统计信息， 并在[Summary API](https://github.com/kubernetes/kubernetes/blob/7d309e0104fedb57280b261e5677d919cb2a0e2d/staging/src/k8s.io/kubelet/pkg/apis/stats/v1alpha1/types.go) 中提供它们的统计信息供消费者阅读。

下面是一个 ​`minikube` ​节点的 Summary API 请求示例：

`kubectl get --raw "/api/v1/nodes/minikube/proxy/stats/summary"`

这是使用 ​`curl` ​来执行的相同 API 调用：

`curl http://localhost:8080/api/v1/nodes/minikube/proxy/stats/summary`

> Note:  
> 从 metrics-server 0.6.x 开始，Summary API ​`/stats/summary`​ 端点被 ​`/metrics/resource`​ 端点替换。

##  2.  Kubernetes 节点健康监测
节点健康监测
------

节点问题检测器（Node Problem Detector） 是一个守护程序，用于监视和报告节点的健康状况。 你可以将节点问题探测器以 ​`DaemonSet` ​或独立守护程序运行。 节点问题检测器从各种守护进程收集节点问题，并以 ​`NodeCondition` ​和 ​`Event` ​的形式报告给 API 服务器。

要了解如何安装和使用节点问题检测器，请参阅 [节点问题探测器项目文档](https://github.com/kubernetes/node-problem-detector)。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

局限性 
----

*   节点问题检测器只支持基于文件类型的内核日志。 它不支持像 journald 这样的命令行日志工具。
*   节点问题检测器使用内核日志格式来报告内核问题。

启用节点问题检测器
---------

一些云供应商将节点问题检测器以插件形式启用。 你还可以使用 ​`kubectl` ​或创建插件 Pod 来启用节点问题探测器。

使用 kubectl 启用节点问题检测器
--------------------

​`kubectl` ​提供了节点问题探测器最灵活的管理。 你可以覆盖默认配置使其适合你的环境或检测自定义节点问题。例如：

1.  创建类似于 ​`node-strought-detector.yaml`​ 的节点问题检测器配置：

`apiVersion: apps/v1 kind: DaemonSet metadata:   name: node-problem-detector-v0.1   namespace: kube-system   labels:     k8s-app: node-problem-detector     version: v0.1     kubernetes.io/cluster-service: "true" spec:   selector:     matchLabels:       k8s-app: node-problem-detector         version: v0.1       kubernetes.io/cluster-service: "true"   template:     metadata:       labels:         k8s-app: node-problem-detector         version: v0.1         kubernetes.io/cluster-service: "true"     spec:       hostNetwork: true       containers:       - name: node-problem-detector         image: k8s.gcr.io/node-problem-detector:v0.1         securityContext:           privileged: true         resources:           limits:             cpu: "200m"             memory: "100Mi"           requests:             cpu: "20m"             memory: "20Mi"         volumeMounts:         - name: log           mountPath: /log           readOnly: true       volumes:       - name: log         hostPath:           path: /var/log/`

> Note: 你应该检查系统日志目录是否适用于操作系统发行版本。

4.  使用 ​`kubectl` ​启动节点问题检测器：

`kubectl apply -f https://k8s.io/examples/debug/node-problem-detector.yaml`

### 使用插件 pod 启用节点问题检测器

如果你使用的是自定义集群引导解决方案，不需要覆盖默认配置， 可以利用插件 Pod 进一步自动化部署。

创建 ​`node-strick-detector.yaml`​，并在控制平面节点上保存配置到插件 Pod 的目录 ​`/etc/kubernetes/addons/node-problem-detector`​。

覆盖配置文件
------

构建节点问题检测器的 docker 镜像时，会嵌入 [默认配置](https://github.com/kubernetes/node-problem-detector/tree/v0.1/config)。

不过，你可以像下面这样使用 ​`ConfigMap` ​将其覆盖：

1.  更改 ​`config/`​ 中的配置文件
2.  创建 ​`ConfigMap` ​​`node-strick-detector-config`​：

`kubectl create configmap node-problem-detector-config --from-file=config/`

4.  更改 ​`node-problem-detector.yaml`​ 以使用 ConfigMap:

`apiVersion: apps/v1 kind: DaemonSet metadata:   name: node-problem-detector-v0.1   namespace: kube-system   labels:     k8s-app: node-problem-detector     version: v0.1     kubernetes.io/cluster-service: "true" spec:   selector:     matchLabels:       k8s-app: node-problem-detector         version: v0.1       kubernetes.io/cluster-service: "true"   template:     metadata:       labels:         k8s-app: node-problem-detector         version: v0.1         kubernetes.io/cluster-service: "true"     spec:       hostNetwork: true       containers:       - name: node-problem-detector         image: k8s.gcr.io/node-problem-detector:v0.1         securityContext:           privileged: true         resources:           limits:             cpu: "200m"             memory: "100Mi"           requests:             cpu: "20m"             memory: "20Mi"         volumeMounts:         - name: log           mountPath: /log           readOnly: true         - name: config # Overwrite the config/ directory with ConfigMap volume           mountPath: /config           readOnly: true       volumes:       - name: log         hostPath:           path: /var/log/       - name: config # Define ConfigMap volume         configMap:           name: node-problem-detector-config`

6.  使用新的配置文件重新创建节点问题检测器：

`# 如果你正在运行节点问题检测器，请先删除，然后再重新创建 kubectl delete -f https://k8s.io/examples/debug/node-problem-detector.yaml kubectl apply -f https://k8s.io/examples/debug/node-problem-detector-configmap.yaml`

> Note: 此方法仅适用于通过 ​`kubectl` ​启动的节点问题检测器。

如果节点问题检测器作为集群插件运行，则不支持覆盖配置。 插件管理器不支持 ​`ConfigMap`​。

内核监视器
-----

内核监视器（Kernel Monitor） 是节点问题检测器中支持的系统日志监视器守护进程。 内核监视器观察内核日志并根据预定义规则检测已知的内核问题。

内核监视器根据 ​`[config/kernel-monitor.json](https://github.com/kubernetes/node-problem-detector/blob/v0.1/config/kernel-monitor.json)`​ 中的一组预定义规则列表匹配内核问题。 规则列表是可扩展的，你始终可以通过覆盖配置来扩展它。

### 添加新的 NodeCondition

要支持新的 ​`NodeCondition`​，请在 ​`config/kernel-monitor.json`​ 中的 ​`conditions` ​字段中创建一个条件定义：

`{   "type": "NodeConditionType",   "reason": "CamelCaseDefaultNodeConditionReason",   "message": "arbitrary default node condition message" }`

### 检测新的问题 

你可以使用新的规则描述来扩展 ​`config/kernel-monitor.json`​ 中的 ​`rules` ​字段以检测新问题：

`{   "type": "temporary/permanent",   "condition": "NodeConditionOfPermanentIssue",   "reason": "CamelCaseShortReason",   "message": "regexp matching the issue in the kernel log" }`

### 配置内核日志设备的路径

检查你的操作系统（OS）发行版本中的内核日志路径位置。 Linux 内核日志设备 通常呈现为 ​`/dev/kmsg`​。 但是，日志路径位置因 OS 发行版本而异。 ​`config/kernel-monitor.json`​ 中的 ​`log` ​字段表示容器内的日志路径。 你可以配置 ​`log` ​字段以匹配节点问题检测器所示的设备路径。

### 添加对其它日志格式的支持 

内核监视器使用 ​`Translator` ​插件转换内核日志的内部数据结构。 你可以为新的日志格式实现新的转换器。

建议和限制
-----

建议在集群中运行节点问题检测器以监控节点运行状况。 运行节点问题检测器时，你可以预期每个节点上的额外资源开销。 通常这是可接受的，因为：

*   内核日志增长相对缓慢。
*   已经为节点问题检测器设置了资源限制。
*   即使在高负载下，资源使用也是可接受的。有关更多信息，请参阅节点问题检测器 [基准结果](https://github.com/kubernetes/node-problem-detector/issues/2.suecomment-220255629)。

##  3.  Kubernetes 使用crictl对Kubernetes节点进行调试
使用 crictl 对 Kubernetes 节点进行调试
-----------------------------

FEATURE STATE: Kubernetes v1.11 \[stable\]

​`crictl` ​是 CRI 兼容的容器运行时命令行接口。 你可以使用它来检查和调试 Kubernetes 节点上的容器运行时和应用程序。 ​`crictl` ​和它的源代码在 [cri-tools](https://github.com/kubernetes-sigs/cri-tools) 代码库。

在开始之前
-----

​`crictl` ​需要带有 CRI 运行时的 Linux 操作系统。

安装 crictl 
----------

你可以从 cri-tools [发布页面](https://github.com/kubernetes-sigs/cri-tools/releases) 下载一个压缩的 ​`crictl` ​归档文件，用于几种不同的架构。 下载与你的 kubernetes 版本相对应的版本。 提取它并将其移动到系统路径上的某个位置，例如​`/usr/local/bin/`​。

一般用法 
-----

​`crictl` ​命令有几个子命令和运行时参数。 有关详细信息，请使用 ​`crictl help`​ 或 ​`crictl <subcommand> help`​ 获取帮助信息。

你可以用以下方法之一来为 ​`crictl` ​设置端点：

*   设置参数 ​`--runtime-endpoint`​ 和 ​`--image-endpoint`​。
*   设置环境变量 ​`CONTAINER_RUNTIME_ENDPOINT` ​和 ​`IMAGE_SERVICE_ENDPOINT`​。
*   在配置文件 ​`--config=/etc/crictl.yaml`​ 中设置端点。 要设置不同的文件，可以在运行 ​`crictl` ​时使用 ​`--config=PATH_TO_FILE`​ 标志。

你还可以在连接到服务器并启用或禁用调试时指定超时值，方法是在配置文件中指定 ​`timeout` ​或 ​`debug` ​值，或者使用 ​`--timeout`​ 和 ​`--debug`​ 命令行参数。

要查看或编辑当前配置，请查看或编辑 ​`/etc/crictl.yaml`​ 的内容。 例如，使用 ​`containerd` ​容器运行时的配置会类似于这样：

`runtime-endpoint: unix:///var/run/containerd/containerd.sock image-endpoint: unix:///var/run/containerd/containerd.sock timeout: 10 debug: true`

要进一步了解 ​`crictl`​，参阅 ​[`crictl` ​文档](https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md)。

crictl 命令示例 
------------

> Warning:  
> 如果使用 ​`crictl` ​在正在运行的 Kubernetes 集群上创建 Pod 沙盒或容器， kubelet 最终将删除它们。 ​`crictl` ​不是一个通用的工作流工具，而是一个对调试有用的工具。

### 打印 Pod 清单 

打印所有 Pod 的清单：

`crictl pods`

输出类似于：

`POD ID              CREATED              STATE               NAME                         NAMESPACE           ATTEMPT 926f1b5a1d33a       About a minute ago   Ready               sh-84d7dcf559-4r2gq          default             0 4dccb216c4adb       About a minute ago   Ready               nginx-65899c769f-wv2gp       default             0 a86316e96fa89       17 hours ago         Ready               kube-proxy-gblk4             kube-system         0 919630b8f81f1       17 hours ago         Ready               nvidia-device-plugin-zgbbv   kube-system         0`

根据名称打印 Pod 清单：

`crictl pods --name nginx-65899c769f-wv2gp`

输出类似于这样：

`POD ID              CREATED             STATE               NAME                     NAMESPACE           ATTEMPT 4dccb216c4adb       2 minutes ago       Ready               nginx-65899c769f-wv2gp   default             0`

根据标签打印 Pod 清单：

`crictl pods --label run=nginx`

输出类似于这样：

`POD ID              CREATED             STATE               NAME                     NAMESPACE           ATTEMPT 4dccb216c4adb       2 minutes ago       Ready               nginx-65899c769f-wv2gp   default             0`

### 打印镜像清单 

打印所有镜像清单：

`crictl images`

输出类似于这样：

`IMAGE                                     TAG                 IMAGE ID            SIZE busybox                                   latest              8c811b4aec35f       1.15MB k8s-gcrio.azureedge.net/hyperkube-amd64   v1.10.3             e179bbfe5d238       665MB k8s-gcrio.azureedge.net/pause-amd64       3.1                 da86e6ba6ca19       742kB nginx                                     latest              cd5239a0906a6       109MB`

根据仓库打印镜像清单：

`crictl images nginx`

输出类似于这样：

`IMAGE               TAG                 IMAGE ID            SIZE nginx               latest              cd5239a0906a6       109MB`

只打印镜像 ID：

`crictl images -q`

输出类似于这样：

`sha256:8c811b4aec35f259572d0f79207bc0678df4c736eeec50bc9fec37ed936a472a sha256:e179bbfe5d238de6069f3b03fccbecc3fb4f2019af741bfff1233c4d7b2970c5 sha256:da86e6ba6ca197bf6bc5e9d900febd906b133eaa4750e6bed647b0fbe50ed43e sha256:cd5239a0906a6ccf0562354852fae04bc5b52d72a2aff9a871ddb6bd57553569`

### 打印容器清单 

打印所有容器清单：

`crictl ps -a`

输出类似于这样：

`CONTAINER ID        IMAGE                                                                                                             CREATED             STATE               NAME                       ATTEMPT 1f73f2d81bf98       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   7 minutes ago       Running             sh                         1 9c5951df22c78       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   8 minutes ago       Exited              sh                         0 87d3992f84f74       nginx@sha256:d0a8828cccb73397acb0073bf34f4d7d8aa315263f1e7806bf8c55d8ac139d5f                                     8 minutes ago       Running             nginx                      0 1941fb4da154f       k8s-gcrio.azureedge.net/hyperkube-amd64@sha256:00d814b1f7763f4ab5be80c58e98140dfc69df107f253d7fdd714b30a714260a   18 hours ago        Running             kube-proxy                 0`

打印正在运行的容器清单：

`crictl ps`

输出类似于这样：

`CONTAINER ID        IMAGE                                                                                                             CREATED             STATE               NAME                       ATTEMPT 1f73f2d81bf98       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   6 minutes ago       Running             sh                         1 87d3992f84f74       nginx@sha256:d0a8828cccb73397acb0073bf34f4d7d8aa315263f1e7806bf8c55d8ac139d5f                                     7 minutes ago       Running             nginx                      0 1941fb4da154f       k8s-gcrio.azureedge.net/hyperkube-amd64@sha256:00d814b1f7763f4ab5be80c58e98140dfc69df107f253d7fdd714b30a714260a   17 hours ago        Running             kube-proxy                 0`

### 在正在运行的容器上执行命令 

`crictl exec -i -t 1f73f2d81bf98 ls`

输出类似于这样：

`bin   dev   etc   home  proc  root  sys   tmp   usr   var`

### 获取容器日志 

获取容器的所有日志：

`crictl logs 87d3992f84f74`

输出类似于这样：

`10.240.0.96 - - [06/Jun/2018:02:45:49 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.47.0" "-" 10.240.0.96 - - [06/Jun/2018:02:45:50 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.47.0" "-" 10.240.0.96 - - [06/Jun/2018:02:45:51 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.47.0" "-"`

获取最近的 ​`N`​ 行日志：

`crictl logs --tail=1 87d3992f84f74`

输出类似于这样：

`10.240.0.96 - - [06/Jun/2018:02:45:51 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.47.0" "-"`

### 运行 Pod 沙盒 

用 ​`crictl` ​运行 Pod 沙盒对容器运行时排错很有帮助。 在运行的 Kubernetes 集群中，沙盒会随机地被 kubelet 停止和删除。

1.  编写下面的 JSON 文件：

`{     "metadata": {         "name": "nginx-sandbox",         "namespace": "default",         "attempt": 1,         "uid": "hdishd83djaidwnduwk28bcsb"     },     "logDirectory": "/tmp",     "linux": {     } }`

3.  使用 ​`crictl runp`​ 命令应用 JSON 文件并运行沙盒。

`crictl runp pod-config.json`

返回了沙盒的 ID。

### 创建容器

用 ​`crictl` ​创建容器对容器运行时排错很有帮助。 在运行的 Kubernetes 集群中，沙盒会随机的被 kubelet 停止和删除。

1.  拉取 busybox 镜像

`crictl pull busybox`

`Image is up to date for busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47`

4.  创建 Pod 和容器的配置：

Pod 配置：

`{     "metadata": {         "name": "nginx-sandbox",         "namespace": "default",         "attempt": 1,         "uid": "hdishd83djaidwnduwk28bcsb"     },     "log_directory": "/tmp",     "linux": {     } }`

容器配置：

`{   "metadata": {     "name": "busybox"   },   "image":{     "image": "busybox"   },   "command": [     "top"   ],   "log_path":"busybox.log",   "linux": {   } }`

9.  创建容器，传递先前创建的 Pod 的 ID、容器配置文件和 Pod 配置文件。返回容器的 ID。

`crictl create f84dd361f8dc51518ed291fbadd6db537b0496536c1d2d6c05ff943ce8c9a54f container-config.json pod-config.json`

11.  查询所有容器并确认新创建的容器状态为 ​`Created`​。

`crictl ps -a`

输出类似于这样：

`CONTAINER ID        IMAGE               CREATED             STATE               NAME                ATTEMPT 3e025dd50a72d       busybox             32 seconds ago      Created             busybox             0`

### 启动容器

要启动容器，要将容器 ID 传给 ​`crictl start`​：

`crictl start 3e025dd50a72d956c4f14881fbb5b1080c9275674e95fb67f965f6478a957d60`

输出类似于这样：

`3e025dd50a72d956c4f14881fbb5b1080c9275674e95fb67f965f6478a957d60`

确认容器的状态为 ​`Running`​。

`crictl ps`

输出类似于这样：

`CONTAINER ID   IMAGE    CREATED              STATE    NAME     ATTEMPT 3e025dd50a72d  busybox  About a minute ago   Running  busybox  0`

##  4.  Kubernetes Windows调试提示
节点级故障排除
-------

1.  我的 Pod 卡在“Container Creating”或一遍又一遍地重新启动

确保您的pause image与您的 Windows 操作系统版本兼容。

> Note: 如果使用 containerd 作为容器运行时，则暂停图像在 config.toml 配置文件的 ​`plugins.plugins.cri.sandbox_image`​ 字段中指定。

4.  我的 pod 显示状态为ErrImgPull或ImagePullBackOff

确保您的 Pod 被安排到[兼容](https://docs.microsoft.com/zh-cn/virtualization/windowscontainers/deploy-containers/version-compatibility?tabs=windows-server-2022%2Cwindows-11-21H2)的Windows 节点。

网络故障排除
------

1.  我的 Windows Pod 没有网络连接

如果您使用的是虚拟机，请确保在所有 VM 网络适配器上启用MAC spoofing。

3.  我的 Windows Pod 无法 ping 外部资源

Windows Pod 没有为 ICMP 协议编程的出站规则。但是，支持 TCP/UDP。在尝试演示与集群外部资源的连接时，请​使用相应的​`curl <IP>`​命令替换`ping <IP>`​。

如果您仍然遇到问题，很可能您在 [cni.conf](https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf)中的网络配置 值得特别注意。您可以随时编辑此静态文件。配置更新将适用于任何新的 Kubernetes 资源。

Kubernetes 网络要求之一（请参阅Kubernetes 模型）是在内部没有 NAT 的情况下进行集群通信。为了满足这一要求， 对于您不希望发生出站 NAT 的所有通信，都有一个[ExceptionList](https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf target=) 。但是，这也意味着您需要从​`ExceptionList`​. 只有这样，来自您的 Windows pod 的流量才会被正确 SNAT 以接收来自外部世界的响应。在这方面，您在 ​`cni.conf`​ 中的 ​`ExceptionList` ​应如下所示：

`"ExceptionList": [                 "10.244.0.0/16",  # Cluster subnet                 "10.96.0.0/12",   # Service subnet                 "10.127.130.0/24" # Management (host) subnet             ]`

8.  我的 Windows 节点无法访问 ​`NodePort` ​类型的服务

从节点本身访问本地 NodePort 失败。 这是一个已知的限制。 NodePort 访问可从其他节点或外部客户端进行。

10.  正在删除容器的 vNIC 和 HNS 端点

当没有将 ​`hostname-override`​ 参数传递给 kube-proxy 时，可能会导致此问题。 要解决它，用户需要将主机名传递给 kube-proxy，如下所示：

`C:\k\kube-proxy.exe --hostname-override=$(hostname)`

13.  我的 Windows 节点无法使用服务 IP 访问我的服务

这是 Windows 上网络堆栈的已知限制。 但是，Windows Pod 可以访问服务 IP。

15.  启动kubelet时找不到网卡

Windows 网络堆栈需要一个虚拟适配器才能使 Kubernetes 网络工作。 如果以下命令未返回任何结果（在管理 shell 中），则虚拟网络创建（kubelet 工作的必要先决条件）失败：

`Get-HnsNetwork | ? Name -ieq "cbr0" Get-NetAdapter | ? Name -Like "vEthernet (Ethernet*"`

在主机的网络适配器不是“以太网”的情况下，通常值得修改 ​`start.ps1`​ 脚本的 [InterfaceName](https://github.com/microsoft/SDN/blob/master/Kubernetes/flannel/start.ps1 target=) 参数。 否则，请查阅 ​`start-kubelet.ps1`​ 脚本的输出以查看虚拟网络创建过程中是否有错误。

19.  DNS 解析无法正常工作

在本节中检查 Windows 的 DNS 限制。

21.  ​`kubectl port-forward`​失败并显示“无法进行端口转发：未找到 wincat”

这是在 Kubernetes 1.15 中通过将 ​`wincat.exe`​ 包含在暂停基础架构容器 ​`mcr.microsoft.com/oss/kubernetes/pause:3.6`​ 中实现的。 请务必使用受支持的 Kubernetes 版本。 如果您想构建自己的暂停基础架构容器，请确保包含 [wincat](https://github.com/kubernetes/kubernetes/tree/master/build/pause/windows/wincat)。

23.  我的 Kubernetes 安装失败，因为我的 Windows Server 节点位于代理后面

如果您在代理后面，则必须定义以下 PowerShell 环境变量：

`[Environment]::SetEnvironmentVariable("HTTP_PROXY", "http://proxy.example.com:80/", [EnvironmentVariableTarget]::Machine) [Environment]::SetEnvironmentVariable("HTTPS_PROXY", "http://proxy.example.com:443/", [EnvironmentVariableTarget]::Machine)`

### Flannel 故障排除

1.  使用 Flannel，我的节点在重新加入集群后出现问题

每当以前删除的节点重新加入集群时，flannelD 都会尝试为该节点分配一个新的 pod 子网。 用户应删除以下路径中的旧 pod 子网配置文件：

`Remove-Item C:\k\SourceVip.json Remove-Item C:\k\SourceVipRequest.json`

4.  Flanneld 卡在“Waiting for the Network to be created”中

有很多关于这个[问题](https://github.com/flannel-io/flannel/issues/1066)的报告； 很可能是设置 flannel 网络的管理 IP 的时间问题。 一种解决方法是重新启动 ​`start.ps1`​ 或手动重新启动它，如下所示：

`[Environment]::SetEnvironmentVariable("NODE_NAME", "<Windows_Worker_Hostname>") C:\flannel\flanneld.exe --kubeconfig-file=c:\k\config --iface=<Windows_Worker_Node_IP> --ip-masq=1 --kube-subnet-mgr=1`

7.  由于缺少 ​`/run/flannel/subnet.env`​，我的 Windows Pod 无法启动

这表明 Flannel 没有正确启动。 您可以尝试重新启动 ​`flanneld.exe`​，也可以手动将文件从 Kubernetes 主节点上的 ​`/run/flannel/subnet.env`​ 复制到 Windows 工作节点上的 ​`C:\run\flannel\subnet.env`​ 并修改 ​`FLANNEL_SUBNET`​ 行到不同的数字。 例如，如果需要节点子网 10.244.4.1/24：

`FLANNEL_NETWORK=10.244.0.0/16 FLANNEL_SUBNET=10.244.4.1/24 FLANNEL_MTU=1500 FLANNEL_IPMASQ=true`

### 进一步的调查

如果这些步骤不能解决您的问题，您可以通过以下方式获得在 Kubernetes 的 Windows 节点上运行 Windows 容器的帮助：

*   StackOverflow [Windows Server Container](https://stackoverflow.com/questions/tagged/windows-server-container) 主题

*   Kubernetes 官方论坛 [Discussion.kubernetes.io](https://discuss.kubernetes.io/)
*   Kubernetes Slack [#SIG-Windows Channel](https://kubernetes.slack.com/?redir=%2Fmessages%2Fsig-windows)

##  5.  Kubernetes 使用telepresence在本地开发和调试服务
使用 telepresence 在本地开发和调试服务
--------------------------

Kubernetes 应用程序通常由多个独立的服务组成，每个服务都在自己的容器中运行。 在远端的 Kubernetes 集群上开发和调试这些服务可能很麻烦， 需要在运行的容器上打开 Shell， 以运行调试工具。

​`telepresence` ​是一个工具，用于简化本地开发和调试服务的过程，同时可以将服务代理到远程 Kubernetes 集群。 ​`telepresence` ​允许你使用使用自定义工具（例如：调试器 和 IDE）调试服务， 并提供对 Configmap、Secret 和远程集群上运行的服务的完全访问。

本文档描述如何在本地使用 ​`telepresence` ​开发和调试远程集群上运行的服务。

在开始之前
-----

*   Kubernetes 集群安装完毕
*   配置好 ​`kubectl` ​与集群交互
*   [Telepresence](https://www.telepresence.io/docs/latest/install/) 安装完毕

从本机连接到远程 Kubernetes 集群
----------------------

安装 ​`telepresence` ​后，运行 ​`telepresence connect`​ 来启动它的守护进程并将本地工作站连接到远程 Kubernetes 集群。

`$ telepresence connect   Launching Telepresence Daemon ... Connected to context default (https://<cluster public IP>)`

你可以通过 curl 使用 Kubernetes 语法访问服务，例如：​`curl -ik https://kubernetes.default` ​

开发和调试现有的服务
----------

在 Kubernetes 上开发应用程序时，通常对单个服务进行编程或调试。 服务可能需要访问其他服务以进行测试和调试。 一种选择是使用连续部署流水线，但即使最快的部署流水线也会在程序或调试周期中引入延迟。

使用 ​`telepresence intercept $SERVICE_NAME --port $LOCAL_PORT:REMOTE_PORT`​ 命令创建一个 "拦截器" 用于重新路由远程服务流量。

环境变量：

*   ​`$SERVICE_NAME`​ 是本地服务名称
*   ​`$LOCAL_PORT`​ 是服务在本地工作站上运行的端口
*   ​`$REMOTE_PORT`​ 是服务在集群中侦听的端口

运行此命令会告诉 Telepresence 将远程流量发送到的本地服务，而不是远程 Kubernetes 集群中的服务中。 在本地编辑保存服务源代码，并在访问远程应用时查看相应变更会立即生效。 还可以使用调试器或任何其他本地开发工具运行本地服务。

Telepresence 是如何工作的？
--------------------

Telepresence 会在远程集群中运行的现有应用程序容器旁边安装流量代理 sidecar。 当它捕获进入 Pod 的所有流量请求时，不是将其转发到远程集群中的应用程序， 而是路由所有流量（当创建[全局拦截器](https://www.getambassador.io/docs/telepresence/latest/concepts/intercepts/ target=)时） 或流量的一个子集（当创建[自定义拦截器](https://www.getambassador.io/docs/telepresence/latest/concepts/intercepts/ target=)时） 到本地开发环境。

##  6.  Kubernetes 审计
审计
--

FEATURE STATE: Kubernetes v1.24 \[beta\]

Kubernetes 审计（Auditing） 功能提供了与安全相关的、按时间顺序排列的记录集， 记录每个用户、使用 Kubernetes API 的应用以及控制面自身引发的活动。

审计功能使得集群管理员能够回答以下问题：

*   发生了什么？
*   什么时候发生的？
*   谁触发的？
*   活动发生在哪个（些）对象上？
*   在哪观察到的？
*   它从哪触发的？
*   活动的后续处理行为是什么？

审计记录最初产生于 kube-apiserver 内部。每个请求在不同执行阶段都会生成审计事件；这些审计事件会根据特定策略 被预处理并写入后端。策略确定要记录的内容和用来存储记录的后端。 当前的后端支持日志文件和 webhook。

每个请求都可被记录其相关的 阶段（stage）。已定义的阶段有：

*   ​`RequestReceived` ​- 此阶段对应审计处理器接收到请求后，并且在委托给 其余处理器之前生成的事件。
*   ​`ResponseStarted` ​- 在响应消息的头部发送后，响应消息体发送前生成的事件。 只有长时间运行的请求（例如 watch）才会生成这个阶段。
*   ​`ResponseComplete` ​- 当响应消息体完成并且没有更多数据需要传输的时候。
*   ​`Panic` ​- 当 panic 发生时生成。

> Note: 审计事件配置 的配置与 Event API 对象不同。

审计日志记录功能会增加 API server 的内存消耗，因为需要为每个请求存储审计所需的某些上下文。 此外，内存消耗取决于审计日志记录的配置。

审计策略 
-----

审计政策定义了关于应记录哪些事件以及应包含哪些数据的规则。 审计策略对象结构定义在 ​`audit.k8s.io`​ API 组 处理事件时，将按顺序与规则列表进行比较。第一个匹配规则设置事件的 审计级别（Audit Level）。已定义的审计级别有：

*   ​`None` ​- 符合这条规则的日志将不会记录。
*   ​`Metadata` ​- 记录请求的元数据（请求的用户、时间戳、资源、动词等等）， 但是不记录请求或者响应的消息体。
*   ​`Request` ​- 记录事件的元数据和请求的消息体，但是不记录响应的消息体。 这不适用于非资源类型的请求。
*   ​`RequestResponse` ​- 记录事件的元数据，请求和响应的消息体。这不适用于非资源类型的请求。

你可以使用 ​`--audit-policy-file`​ 标志将包含策略的文件传递给 ​`kube-apiserver`​。 如果不设置该标志，则不记录事件。 注意 ​`rules` ​字段 必须 在审计策略文件中提供。没有（0）规则的策略将被视为非法配置。

以下是一个审计策略文件的示例：

`apiVersion: audit.k8s.io/v1 # This is required. kind: Policy # Don't generate audit events for all requests in RequestReceived stage. omitStages:   - "RequestReceived" rules:   # Log pod changes at RequestResponse level   - level: RequestResponse     resources:     - group: ""       # Resource "pods" doesn't match requests to any subresource of pods,       # which is consistent with the RBAC policy.       resources: ["pods"]   # Log "pods/log", "pods/status" at Metadata level   - level: Metadata     resources:     - group: ""       resources: ["pods/log", "pods/status"]    # Don't log requests to a configmap called "controller-leader"   - level: None     resources:     - group: ""       resources: ["configmaps"]       resourceNames: ["controller-leader"]    # Don't log watch requests by the "system:kube-proxy" on endpoints or services   - level: None     users: ["system:kube-proxy"]     verbs: ["watch"]     resources:     - group: "" # core API group       resources: ["endpoints", "services"]    # Don't log authenticated requests to certain non-resource URL paths.   - level: None     userGroups: ["system:authenticated"]     nonResourceURLs:     - "/api*" # Wildcard matching.     - "/version"    # Log the request body of configmap changes in kube-system.   - level: Request     resources:     - group: "" # core API group       resources: ["configmaps"]     # This rule only applies to resources in the "kube-system" namespace.     # The empty string "" can be used to select non-namespaced resources.     namespaces: ["kube-system"]    # Log configmap and secret changes in all other namespaces at the Metadata level.   - level: Metadata     resources:     - group: "" # core API group       resources: ["secrets", "configmaps"]    # Log all other resources in core and extensions at the Request level.   - level: Request     resources:     - group: "" # core API group     - group: "extensions" # Version of group should NOT be included.    # A catch-all rule to log all other requests at the Metadata level.   - level: Metadata     # Long-running requests like watches that fall under this rule will not     # generate an audit event in RequestReceived.     omitStages:       - "RequestReceived"`

你可以使用最低限度的审计策略文件在 ​`Metadata` ​级别记录所有请求：

`# 在 Metadata 级别为所有请求生成日志 apiVersion: audit.k8s.io/v1beta1 kind: Policy rules: - level: Metadata`

如果你在打磨自己的审计配置文件，你可以使用为 Google Container-Optimized OS 设计的审计配置作为出发点。你可以参考 [configure-helper.sh](https://github.com/kubernetes/kubernetes/blob/master/cluster/gce/gci/configure-helper.sh) 脚本，该脚本能够生成审计策略文件。你可以直接在脚本中看到审计策略的绝大部份内容。

你也可以参考 ​`Policy` ​配置参考 以获取有关已定义字段的详细信息。

审计后端 
-----

审计后端实现将审计事件导出到外部存储。​`Kube-apiserver`​ 默认提供两个后端：

*   Log 后端，将事件写入到文件系统
*   Webhook 后端，将事件发送到外部 HTTP API

在这所有情况下，审计事件均遵循 Kubernetes API 在 ​`audit.k8s.io`​ API 组 中定义的结构。

> Note:  
> 对于 patch 请求，请求的消息体需要是设定 patch 操作的 JSON 所构成的一个串， 而不是一个完整的 Kubernetes API 对象 JSON 串。 例如，以下的示例是一个合法的 patch 请求消息体，该请求对应 ​`/apis/batch/v1/namespaces/some-namespace/jobs/some-job-name`​。
> 
> `[   {     "op": "replace",     "path": "/spec/parallelism",     "value": 0   },   {     "op": "remove",     "path": "/spec/template/spec/containers/0/terminationMessagePolicy"   } ]`

### Log 后端 

Log 后端将审计事件写入 [JSONlines](https://jsonlines.org/) 格式的文件。 你可以使用以下 ​`kube-apiserver`​ 标志配置 Log 审计后端：

*   ​`--audit-log-path`​ 指定用来写入审计事件的日志文件路径。不指定此标志会禁用日志后端。​`-`​ 意味着标准化
*   ​`--audit-log-maxage`​ 定义保留旧审计日志文件的最大天数
*   ​`--audit-log-maxbackup`​ 定义要保留的审计日志文件的最大数量
*   ​`--audit-log-maxsize`​ 定义审计日志文件的最大大小（兆字节）

如果你的集群控制面以 Pod 的形式运行 kube-apiserver，记得要通过 ​`hostPath` ​卷来访问策略文件和日志文件所在的目录，这样审计记录才会持久保存下来。例如：

  `--audit-policy-file=/etc/kubernetes/audit-policy.yaml   --audit-log-path=/var/log/kubernetes/audit/audit.log`

接下来挂载数据卷：

`volumeMounts:   - mountPath: /etc/kubernetes/audit-policy.yaml     name: audit     readOnly: true   - mountPath: /var/log/kubernetes/audit/     name: audit-log     readOnly: false`

最后配置 ​`hostPath`​：

`... volumes: - name: audit   hostPath:     path: /etc/kubernetes/audit-policy.yaml     type: File  - name: audit-log   hostPath:     path: /var/log/kubernetes/audit/     type: DirectoryOrCreate`

### Webhook 后端 

Webhook 后端将审计事件发送到远程 Web API，该远程 API 应该暴露与 ​`kube-apiserver`​ 形式相同的 API，包括其身份认证机制。你可以使用如下 kube-apiserver 标志来配置 Webhook 审计后端：

*   ​`--audit-webhook-config-file`​ 设置 Webhook 配置文件的路径。Webhook 配置文件实际上是一个 kubeconfig 文件。
*   ​`--audit-webhook-initial-backoff`​ 指定在第一次失败后重发请求等待的时间。随后的请求将以指数退避重试。

Webhook 配置文件使用 kubeconfig 格式指定服务的远程地址和用于连接它的凭据。

事件批处理 
------

日志和 Webhook 后端都支持批处理。以 Webhook 为例，以下是可用参数列表。要获取日志 后端的同样参数，请在参数名称中将 ​`webhook` ​替换为 ​`log`​。 默认情况下，在 ​`webhook` ​中批处理是被启用的，在 ​`log` ​中批处理是被禁用的。 同样，默认情况下，在 ​`webhook` ​中启用带宽限制，在 ​`log` ​中禁用带宽限制。

*   ​`--audit-webhook-mode`​ 定义缓存策略，可选值如下：

*   ​`batch`​ - 以批处理缓存事件和异步的过程。这是默认值。
*   ​`blocking`​ - 在 API 服务器处理每个单独事件时，阻塞其响应。
*   ​`blocking-strict`​ - 与 ​`blocking` ​相同，不过当审计日志在 RequestReceived 阶段 失败时，整个 API 服务请求会失效。

以下参数仅用于 ​`batch` ​模式。

*   ​`--audit-webhook-batch-buffer-size`​ 定义 batch 之前要缓存的事件数。 如果传入事件的速率溢出缓存区，则会丢弃事件。
*   ​`--audit-webhook-batch-max-size`​ 定义一个 batch 中的最大事件数。
*   ​`--audit-webhook-batch-max-wait`​ 无条件 batch 队列中的事件前等待的最大事件。
*   ​`--audit-webhook-batch-throttle-qps`​ 每秒生成的最大批次数。
*   ​`--audit-webhook-batch-throttle-burst`​ 在达到允许的 QPS 前，同一时刻允许存在的最大 batch 生成数。

参数调整 
-----

需要设置参数以适应 API 服务器上的负载。

例如，如果 kube-apiserver 每秒收到 100 个请求，并且每个请求仅在 ​`ResponseStarted` ​和 ​`ResponseComplete` ​阶段进行审计，则应该考虑每秒生成约 200 个审计事件。 假设批处理中最多有 100 个事件，则应将限制级别设置为每秒至少 2 个查询。 假设后端最多需要 5 秒钟来写入事件，你应该设置缓冲区大小以容纳最多 5 秒的事件， 即 10 个 batch，即 1000 个事件。

但是，在大多数情况下，默认参数应该足够了，你不必手动设置它们。 你可以查看 kube-apiserver 公开的以下 Prometheus 指标，并在日志中监控审计子系统的状态。

*   ​`apiserver_audit_event_total` ​包含所有暴露的审计事件数量的指标。
*   ​`apiserver_audit_error_total` ​在暴露时由于发生错误而被丢弃的事件的数量。

### 日志条目截断 

日志后端和 Webhook 后端都支持限制所输出的事件的尺寸。 例如，下面是可以为日志后端配置的标志列表：

*   ​`audit-log-truncate-enabled`​：是否弃用事件和批次的截断处理。
*   ​`audit-log-truncate-max-batch-size`​：向下层后端发送的各批次的最大尺寸字节数。
*   ​`audit-log-truncate-max-event-size`​：向下层后端发送的审计事件的最大尺寸字节数。

默认情况下，截断操作在 ​`webhook` ​和 ​`log` ​后端都是被禁用的，集群管理员需要设置 ​`audit-log-truncate-enabled`​ 或 ​`audit-webhook-truncate-enabled`​ 标志来启用此操作。

##  7.  Kubernetes 资源监控工具
资源监控工具
------

要扩展应用程序并提供可靠的服务，你需要了解应用程序在部署时的行为。 你可以通过检测容器检查 Kubernetes 集群中的应用程序性能， Pods, 服务 和整个集群的特征。 Kubernetes 在每个级别上提供有关应用程序资源使用情况的详细信息。 此信息使你可以评估应用程序的性能，以及在何处可以消除瓶颈以提高整体性能。

在 Kubernetes 中，应用程序监控不依赖单个监控解决方案。 在新集群上，你可以使用资源度量或 完整度量管道来收集监视统计信息。

资源度量管道 
-------

资源指标管道提供了一组与集群组件，例如 Horizontal Pod Autoscaler 控制器以及 ​`kubectl top`​ 实用程序相关的有限度量。 这些指标是由轻量级的、短期、内存存储的 [metrics-server](https://github.com/kubernetes-sigs/metrics-server) 收集的， 通过 ​`metrics.k8s.io`​ 公开。

度量服务器发现集群中的所有节点，并且查询每个节点的 kubelet 以获取 CPU 和内存使用情况。 Kubelet 充当 Kubernetes 主节点与节点之间的桥梁，管理机器上运行的 Pod 和容器。 kubelet 将每个 Pod 转换为其组成的容器，并在容器运行时通过容器运行时接口 获取各个容器使用情况统计信息。 kubelet 从集成的 cAdvisor 获取此信息，以进行旧式 Docker 集成。 然后，它通过 metrics-server Resource Metrics API 公开聚合的 pod 资源使用情况统计信息。 该 API 在 kubelet 的经过身份验证和只读的端口上的 ​`/metrics/resource/v1beta1`​ 中提供。

完整度量管道 
-------

一个完整度量管道可以让你访问更丰富的度量。 Kubernetes 还可以根据集群的当前状态，使用 Pod 水平自动扩缩器等机制， 通过自动调用扩展或调整集群来响应这些度量。 监控管道从 kubelet 获取度量值，然后通过适配器将它们公开给 Kubernetes， 方法是实现 ​`custom.metrics.k8s.io`​ 或 ​`external.metrics.k8s.io`​ API。

[Prometheus](https://prometheus.io/) 是一个 CNCF 项目，可以原生监控 Kubernetes、 节点和 Prometheus 本身。 完整度量管道项目不属于 CNCF 的一部分，不在 Kubernetes 文档的范围之内。

#  19.  Kubernetes 从dockershim迁移

##  1.  Kubernetes 将节点上的容器运行时从Docker Engine改为containerd
腾空节点
----

`kubectl drain <node-to-drain> --ignore-daemonsets`

将 ​`<node-to-drain>`​ 替换为你所要腾空的节点的名称

停止 Docker 守护进程 
---------------

`systemctl stop kubelet systemctl disable docker.service --now`

安装 Containerd 
--------------

*   Linux

1.  从官方的 Docker 仓库安装 ​`containerd.io`​ 包。关于为你所使用的 Linux 发行版来设置 Docker 仓库，以及安装 ​`containerd.io`​ 包的详细说明，可参见 [开始使用 containerd](https://github.com/containerd/containerd/blob/main/docs/getting-started.md)。
2.  配置 containerd：

`sudo mkdir -p /etc/containerd containerd config default | sudo tee /etc/containerd/config.toml`

4.  重启 containerd：

`sudo systemctl restart containerd`

*   Windows(PowerShell)

启动一个 Powershell 会话，将 ​`$Version`​ 设置为期望的版本（例如：​`$Version="1.4.3"`​）， 之后运行下面的命令：

1.  下载 containerd：

`curl.exe -L https://github.com/containerd/containerd/releases/download/v$Version/containerd-$Version-windows-amd64.tar.gz -o containerd-windows-amd64.tar.gz tar.exe xvf .\containerd-windows-amd64.tar.gz`

3.  解压缩并执行配置：

`Copy-Item -Path ".\bin\" -Destination "$Env:ProgramFiles\containerd" -Recurse -Force cd $Env:ProgramFiles\containerd\ .\containerd.exe config default | Out-File config.toml -Encoding ascii  # 请审查配置信息。取决于你的安装环境，你可能需要调整： # - the sandbox_image （Kubernetes pause 镜像） # - cni bin_dir 和 conf_dir 的位置 Get-Content config.toml  # （可选步骤，但强烈建议执行）将 containerd 排除在 Windows Defender 扫描之外 Add-MpPreference -ExclusionProcess "$Env:ProgramFiles\containerd\containerd.exe"`

5.  启动 containerd：

`.\containerd.exe --register-service Start-Service containerd`

配置 kubelet 使用 containerd 作为其容器运行时
---------------------------------

编辑文件 ​`/var/lib/kubelet/kubeadm-flags.env`​，将 containerd 运行时添加到标志中： ​`--container-runtime=remote`​ 和 ​`--container-runtime-endpoint=unix:///run/containerd/containerd.sock"`​。

对于使用 kubeadm 的用户，可以考虑下面的问题：

​`kubeadm` ​工具将每个主机的 CRI 套接字保存在该主机对应的 Node 对象的注解中。 使用 ​`kubeadm` ​的用户应该知道，​`kubeadm` ​工具将每个主机的 CRI 套接字保存在该主机对应的 Node 对象的注解中。 要更改这一注解信息，你可以在一台包含 kubeadm ​`/etc/kubernetes/admin.conf`​ 文件的机器上执行以下命令：

`kubectl edit no <node-name>`

这一命令会打开一个文本编辑器，供你在其中编辑 Node 对象。 要选择不同的文本编辑器，你可以设置 ​`KUBE_EDITOR` ​环境变量。

*   更改 ​`kubeadm.alpha.kubernetes.io/cri-socket`​ 值，将其从 ​`/var/run/dockershim.sock`​ 改为你所选择的 CRI 套接字路径 （例如：​`unix:///run/containerd/containerd.sock`​）。

注意新的 CRI 套接字路径必须带有 ​`unix://`​ 前缀。

*   保存文本编辑器中所作的修改，这会更新 Node 对象。

重启 kubelet 
-----------

`systemctl start kubelet`

验证节点处于健康状态 
-----------

运行 ​`kubectl get nodes -o wide`​，containerd 会显示为我们所更改的节点上的运行时。

最后，在一切顺利时删除 Docker。

*   CentOS

`sudo yum remove docker-ce docker-ce-cli`

*   Debian

`sudo apt-get purge docker-ce docker-ce-cli`

*   Fedora

`sudo dnf remove docker-ce docker-ce-cli`

*   Ubuntu

`sudo apt-get purge docker-ce docker-ce-cli`

##  2.  Kubernetes 将Docker Engine节点从dockershim迁移到cri-dockerd
将 Docker Engine 节点从 dockershim 迁移到 cri-dockerd
----------------------------------------------

本页面为你展示如何迁移你的 Docker Engine 节点，使之使用 ​`cri-dockerd`​ 而不是 dockershim。 在以下场景中，你可以遵从这里的步骤执行操作：

*   你期望不再使用 dockershim，但仍然使用 Docker Engine 来在 Kubernetes 中运行容器。
*   你希望升级到 Kubernetes v1.24 且你的现有集群依赖于 dockershim， 因此你必须放弃 dockershim，而 ​`cri-dockerd`​ 是你的一种选项。

cri-dockerd 是什么？
----------------

在 Kubernetes v1.24 及更早版本中，你可以在 Kubernetes 中使用 Docker Engine， 依赖于一个称作 dockershim 的内置 Kubernetes 组件。 dockershim 组件在 Kubernetes v1.24 发行版本中已被移除；不过，一种来自第三方的替代品， ​`cri-dockerd`​ 是可供使用的。​`cri-dockerd`​ 适配器允许你通过 容器运行时接口（Container Runtime Interface，CRI） 来使用 Docker Engine。

> Note:  
> 如果你已经在使用 ​`cri-dockerd`​，那么你不会被 dockershim 的移除影响到。

如果你想要迁移到 ​`cri-dockerd`​ 以便继续使用 Docker Engine 作为你的容器运行时， 你需要在所有被影响的节点上执行以下操作：

1.  安装 cri-dockerd；
2.  隔离（Cordon）并腾空（Drain）该节点；
3.  配置 kubelet 使用 ​`cri-dockerd`​；
4.  重新启动 kubelet；
5.  验证节点处于健康状态。

首先在非关键节点上测试这一迁移过程。

你应该针对所有希望迁移到 ​`cri-dockerd`​ 的节点执行以下步骤。

在开始之前
-----

*   安装了 [cri-dockerd](https://github.com/mirantis/cri-dockerd target=) 并且该服务已经在各节点上启动；
*   一个网络插件。

隔离并腾空节点 
--------

1.  隔离节点，阻止新的 Pod 被调度到节点上：

`kubectl cordon <NODE_NAME>`

将 ​`<NODE_NAME>`​ 替换为节点名称。

4.  腾空节点以安全地逐出所有运行中的 Pod：

`kubectl drain <NODE_NAME> --ignore-daemonsets`

配置 kubelet 使用 cri-dockerd 
--------------------------

下面的步骤适用于用 kubeadm 工具安装的集群。如果你使用不同的工具， 你需要使用针对该工具的配置指令来修改 kubelet。

1.  在每个被影响的节点上，打开 ​`/var/lib/kubelet/kubeadm-flags.env`​ 文件；
2.  将 ​`--container-runtime-endpoint`​ 标志，将其设置为 ​`unix:///var/run/cri-dockerd.sock`​。

kubeadm 工具将节点上的套接字存储为控制面上 ​`Node` ​对象的注解。 要为每个被影响的节点更改此套接字：

1.  编辑 ​`Node` ​对象的 YAML 表示：

`KUBECONFIG=/path/to/admin.conf kubectl edit no <NODE_NAME>`

根据下面的说明执行替换：

*   ​`/path/to/admin.conf`​：指向 kubectl 配置文件 ​`admin.conf`​ 的路径；
*   ​`<NODE_NAME>`​：你要修改的节点的名称。

5.  将 ​`kubeadm.alpha.kubernetes.io/cri-socket`​ 标志从 ​`/var/run/dockershim.sock`​ 更改为 ​`unix:///var/run/cri-dockerd.sock`​；
6.  保存所作更改。保存时，​`Node` ​对象被更新

重启 kubelet 
-----------

`systemctl restart kubelet`

验证节点处于健康状态 
-----------

要检查节点是否在使用 ​`cri-dockerd`​ 端点， 按照[查明节点上所使用的容器运行时](https://www.w3cschool.cn/kubernetes/kubernetes-jle73o9l.html?RECACHE=1)页面所给的指令操作。 kubelet 的 ​`--container-runtime-endpoint`​ 标志取值应该是 ​`unix:///var/run/cri-dockerd.sock`​。

解除节点隔离 
-------

`kubectl uncordon <NODE_NAME>`

##  3.  Kubernetes CNI插件相关错误故障排除
CNI 插件相关错误故障排除
--------------

为避免与 CNI 插件相关的错误，请确认您正在使用或升级到经过测试可与您的 Kubernetes 版本一起正常工作的容器运行时。

例如，以下容器运行时正在或已经为 Kubernetes v1.24 准备好：

*   containerd v1.6.4 及更高版本，v1.5.11 及更高版本
*   CRI-O v1.24.0 及更高版本

关于“CNI 版本不兼容”和“无法为沙盒销毁网络”错误
---------------------------

当 CNI 插件尚未升级和/或 CNI 配置版本未在 CNI 配置文件中声明时，在 containerd v1.6.0-v1.6.3 中存在 pod CNI 网络设置和拆除的服务问题。 containerd 团队报告说，“这些问题在 containerd v1.6.4 中得到解决。”

使用 containerd v1.6.0-v1.6.3，如果您不升级 CNI 插件和/或声明 CNI 配置版本，您可能会遇到以下“不兼容的 CNI 版本”或“无法为沙盒销毁网络”的错误情况。

### CNI 版本不兼容错误

如果您的 CNI 插件版本与配置中的插件版本不正确匹配，因为配置版本晚于插件版本，则容器日志可能会在 pod 启动时显示类似于以下内容的错误消息：

`incompatible CNI versions; config is \"1.0.0\", plugin supports [\"0.1.0\" \"0.2.0\" \"0.3.0\" \"0.3.1\" \"0.4.0\"]"`

### 沙盒错误导致网络破坏失败

如果 CNI 插件配置中缺少插件的版本，则 pod 可能会运行。 但是，停止 pod 会产生类似于以下内容的错误：

`ERRO[2022-04-26T00:43:24.518165483Z] StopPodSandbox for "b" failed error="failed to destroy network for sandbox \"bbc85f891eaf060c5a879e27bba9b6b06450210161dfdecfbb2732959fb6500a\": invalid version \"\": the version is empty"`

此错误使 pod 处于未就绪状态，但仍附加网络命名空间。 要从此问题中恢复，请编辑 CNI 配置文件以添加缺少的版本信息。 下一次停止 pod 的尝试应该会成功。

### 更新 CNI 插件和 CNI 配置文件

如果您使用 containerd v1.6.0-v1.6.3 并遇到“不兼容的 CNI 版本”或“无法为沙盒销毁网络”错误，请考虑更新您的 CNI 插件并编辑 CNI 配置文件。

以下是每个节点的典型步骤的概述：

1.  安全地排空并封锁节点。
2.  停止容器运行时和 kubelet 服务后，执行以下升级操作：

*   如果您正在运行 CNI 插件，请将它们升级到最新版本。
*   如果您使用的是非 CNI 插件，请将它们替换为 CNI 插件。 使用最新版本的插件。
*   更新插件配置文件以指定或匹配插件支持的 CNI 规范版本，如以下“容器配置文件示例”部分所示。
*   对于 ​`containerd`​，请确保您已安装 CNI 环回插件的最新版本（v1.0.0 或更高版本）。
*   将节点组件（例如 kubelet）升级到 Kubernetes v1.24
*   升级到或安装最新版本的容器运行时。

4.  通过重新启动容器运行时和 kubelet 将节点带回集群。 取消封锁节点（​`kubectl uncordon <nodename>`​）。

一个示例容器配置文件
----------

以下示例显示了 ​`containerd` ​运行时 v1.6.x 的配置，它支持最新版本的 CNI 规范 (v1.0.0)。

有关配置系统的更多说明，请参阅您的插件和网络提供商的文档。

在 Kubernetes 上，containerd 运行时将环回接口 ​`lo` ​作为默认行为添加到 pod。 containerd 运行时通过 CNI 插件 ​`loopback` ​配置环回接口。 ​`loopback` ​插件作为具有 cni 名称的 ​`containerd` ​发布包的一部分分发。 ​`containerd` ​v1.6.0 及更高版本包括与 CNI v1.0.0 兼容的环回插件以及其他默认 ​`CNI` ​插件。 loopback 插件的配置由 containerd 内部完成，并设置为使用 CNI v1.0.0。这也意味着当这个更新版本的 ​`containerd` ​启动时，​`loopback` ​插件的版本必须是 v1.0.0 或更高版本。

以下 bash 命令生成示例 CNI 配置。在这里，配置版本的 1.0.0 值分配给 ​`cniVersion` ​字段，以供 ​`containerd` ​调用 CNI 桥接插件时使用。

`cat << EOF | tee /etc/cni/net.d/10-containerd-net.conflist {  "cniVersion": "1.0.0",  "name": "containerd-net",  "plugins": [    {      "type": "bridge",      "bridge": "cni0",      "isGateway": true,      "ipMasq": true,      "promiscMode": true,      "ipam": {        "type": "host-local",        "ranges": [          [{            "subnet": "10.88.0.0/16"          }],          [{            "subnet": "2001:db8:4860::/64"          }]        ],        "routes": [          { "dst": "0.0.0.0/0" },          { "dst": "::/0" }        ]      }    },    {      "type": "portmap",      "capabilities": {"portMappings": true}    }  ] } EOF`

使用基于您的用例和网络寻址计划的 IP 地址范围更新前面示例中的 IP 地址范围。

##  4.  Kubernetes 查明节点上所使用的容器运行时
查明节点上所使用的容器运行时
--------------

取决于你运行集群的方式，节点所使用的容器运行时可能是事先配置好的， 也可能需要你来配置。如果你在使用托管的 Kubernetes 服务， 可能存在特定于厂商的方法来检查节点上配置的容器运行时。 本页描述的方法应该在能够执行 ​`kubectl` ​的场合下都可以工作。

在开始之前
-----

安装并配置 ​`kubectl`​。参见[安装工具](https://www.w3cschool.cn/kubernetes/kubernetes-84tm3nsh.html?RECACHE=1) 节了解详情。

查明节点所使用的容器运行时
-------------

使用 ​`kubectl` ​来读取并显示节点信息：

`kubectl get nodes -o wide`

输出如下面所示。​`CONTAINER-RUNTIME`​ 列给出容器运行时及其版本。

对于 Docker Engine，输出类似于：

`NAME         STATUS   VERSION    CONTAINER-RUNTIME node-1       Ready    v1.16.15   docker://19.3.1 node-2       Ready    v1.16.15   docker://19.3.1 node-3       Ready    v1.16.15   docker://19.3.1`

如果你的容器运行时显示为 Docker Engine，你仍然可能不会被 1.24 中 dockershim 的移除所影响。 通过检查运行时端点，可以查看你是否在使用 dockershim。 如果你没有使用 dockershim，你就不会被影响。 看下是否是使用的 dockershim，如何是 dockershim 则会受到在 Kubernetes 1.24 中移除 dockershim 的影响。 反之则不会受到影响。

对于 containerd，输出类似于这样：

`# For containerd NAME         STATUS   VERSION   CONTAINER-RUNTIME node-1       Ready    v1.19.6   containerd://1.4.1 node-2       Ready    v1.19.6   containerd://1.4.1 node-3       Ready    v1.19.6   containerd://1.4.1`

检查当前使用的运行时端点 
-------------

容器运行时使用 Unix Socket 与 kubelet 通信，这一通信使用基于 gRPC 框架的 CRI 协议。kubelet 扮演客户端，运行时扮演服务器端。 在某些情况下，你可能想知道你的节点使用的是哪个 socket。 如若集群是 Kubernetes 1.24 及以后的版本， 或许你想知道当前运行时是否是使用 dockershim 的 Docker Engine。

> Note: 如果你的节点在通过 ​`cri-dockerd`​ 使用 Docker Engine， 那么集群不会受到 Kubernetes 移除 dockershim 的影响。  

可以通过检查 kubelet 的参数得知当前使用的是哪个 socket。

1.  查看 kubelet 进程的启动命令

 `tr \\0 ' ' < /proc/"$(pgrep kubelet)"/cmdline`

如有节点上没有 ​`tr` ​或者 ​`pgrep`​，就需要手动检查 kubelet 的启动命令

4.  在命令的输出中，查找 ​`--container-runtime`​ 和 ​`--container-runtime-endpoint`​ 标志。

*   如果 Kubernetes 集群版本是 v1.23 或者更早的版本，并且这两个参数不存在， 或者 ​`container-runtime`​ 标志值不是 ​`remote`​，则你在通过 dockershim 套接字使用 Docker Engine。 或者如果集群使用的 Docker engine 和 dockershim socket，则输出结果中 ​`--container-runtime`​ 不是 ​`remote`​,
*   如果设置了 ​`--container-runtime-endpoint`​ 参数，查看套接字名称即可得知当前使用的运行时。 如若套接字 ​`unix:///run/containerd/containerd.sock`​ 是 containerd 的端点。

如果你通过 dockershim 来使用 Docker Engine，可在 [迁移到不同的运行时](https://www.w3cschool.cn/kubernetes/kubernetes-t4623o9i.html?RECACHE=1) 找到更多信息。或者，如果你想在 Kubernetes v1.24 及以后的版本仍使用 Docker Engine， 可以安装 CRI 兼容的适配器实现，如 ​`[cri-dockerd](https://github.com/Mirantis/cri-dockerd)`​。

##  5.  Kubernetes 检查弃用Dockershim是否对你有影响
检查弃用 Dockershim 是否对你有影响
-----------------------

Kubernetes 的 ​`dockershim` ​组件使得你可以把 Docker 用作 Kubernetes 的 容器运行时。 在 Kubernetes v1.24 版本中，内建组件 ​`dockershim` ​被移除。

本页讲解你的集群把 Docker 用作容器运行时的运作机制， 并提供使用 ​`dockershim` ​时，它所扮演角色的详细信息， 继而展示了一组操作，可用来检查弃用 ​`dockershim` ​对你的工作负载是否有影响。

检查你的应用是否依赖于 Docker 
-------------------

即使你是通过 Docker 创建的应用容器，也不妨碍你在其他任何容器运行时上运行这些容器。 这种使用 Docker 的方式并不构成对 Docker 作为一个容器运行时的依赖。

当用了别的容器运行时之后，Docker 命令可能不工作，或者产生意外的输出。 下面是判定你是否依赖于 Docker 的方法。

1.  确认没有特权 Pod 执行 Docker 命令（如 ​`docker ps`​）、重新启动 Docker 服务（如 ​`systemctl restart docker.service`​）或修改 Docker 配置文件 ​`/etc/docker/daemon.json`​。
2.  检查 Docker 配置文件（如 ​`/etc/docker/daemon.json`​）中容器镜像仓库的镜像（mirror）站点设置。 这些配置通常需要针对不同容器运行时来重新设置。
3.  检查确保在 Kubernetes 基础设施之外的节点上运行的脚本和应用程序没有执行 Docker 命令。 可能的情况有：

*   SSH 到节点排查故障；
*   节点启动脚本；
*   直接安装在节点上的监控和安全代理。

5.  检查执行上述特权操作的第三方工具。 
6.  确认没有对 dockershim 行为的间接依赖。这是一种极端情况，不太可能影响你的应用。 一些工具很可能被配置为使用了 Docker 特性，比如，基于特定指标发警报， 或者在故障排查指令的一个环节中搜索特定的日志信息。 如果你有此类配置的工具，需要在迁移之前，在测试集群上测试这类行为。

Docker 依赖详解
-----------

容器运行时是一个软件， 用来运行组成 Kubernetes Pod 的容器。 Kubernetes 负责编排和调度 Pod；在每一个节点上，kubelet 使用抽象的容器运行时接口，所以你可以任意选用兼容的容器运行时。

在早期版本中，Kubernetes 提供的兼容性支持一个容器运行时：Docker。 在 Kubernetes 后来的发展历史中，集群运营人员希望采用别的容器运行时。 于是 CRI 被设计出来满足这类灵活性需求 - 而 kubelet 亦开始支持 CRI。 然而，因为 Docker 在 CRI 规范创建之前就已经存在，Kubernetes 就创建了一个适配器组件 dockershim。 dockershim 适配器允许 kubelet 与 Docker 交互，就好像 Docker 是一个 CRI 兼容的运行时一样。

![](https://atts.w3cschool.cn/attachments/image/20220602/1654134451700355.png)  

切换到 Containerd 容器运行时可以消除掉中间环节。 所有相同的容器都可由 Containerd 这类容器运行时来运行。 但是现在，由于直接用容器运行时调度容器，它们对 Docker 是不可见的。 因此，你以前用来检查这些容器的 Docker 工具或漂亮的 UI 都不再可用。

你不能再使用 ​`docker ps`​ 或 ​`docker inspect`​ 命令来获取容器信息。 由于你不能列出容器，因此你不能获取日志、停止容器，甚至不能通过 ​`docker exec`​ 在容器中执行命令。

> Note:  
> 如果你在用 Kubernetes 运行工作负载，最好通过 Kubernetes API 停止容器， 而不是通过容器运行时来停止它们 （此建议适用于所有容器运行时，不仅仅是针对 Docker）。

你仍然可以下载镜像，或者用 ​`docker build`​ 命令创建它们。 但用 Docker 创建、下载的镜像，对于容器运行时和 Kubernetes，均不可见。 为了在 Kubernetes 中使用，需要把镜像推送（push）到某镜像仓库。

##  6.  Kubernetes 从dockershim迁移遥测和安全代理
从 dockershim 迁移遥测和安全代理
----------------------

Kubernetes 对与 Docker Engine 直接集成的支持已被弃用并将被删除。 大多数应用程序不直接依赖于托管容器的运行时。但是，仍然有大量的遥测和监控代理依赖 docker 来收集容器元数据、日志和指标。 本文汇总了一些信息和链接：信息用于阐述如何探查这些依赖，链接用于解释如何迁移这些代理去使用通用的工具或其他容器运行。

遥测和安全代理
-------

在 Kubernetes 集群中，有几种不同的方式来运行遥测或安全代理。 一些代理在以 DaemonSet 的形式运行或直接在节点上运行时，直接依赖于 Docker Engine。

### 为什么有些遥测代理会与 Docker Engine 通信？ 

从历史上看，Kubernetes 是专门为与 Docker Engine 一起工作而编写的。 Kubernetes 负责网络和调度，依靠 Docker Engine 在节点上启动并运行容器（在 Pod 内）。一些与遥测相关的信息，例如 pod 名称， 只能从 Kubernetes 组件中获得。其他数据，例如容器指标，不是容器运行时的责任。 早期遥测代理需要查询容器运行时和 Kubernetes 以报告准确的信息。 随着时间的推移，Kubernetes 获得了支持多种运行时的能力，现在支持任何兼容容器运行时接口的运行时。

一些代理和 Docker 工具紧密绑定。比如代理会用到 ​[`docker ps`​](https://docs.docker.com/engine/reference/commandline/ps/) 或 ​`[docker top](https://docs.docker.com/engine/reference/commandline/top/)`​ 这类命令来列出容器和进程，用 ​`[docker logs](https://docs.docker.com/engine/reference/commandline/logs/)`​ 订阅 Docker 的日志。 如果现有集群中的节点使用 Docker Engine，在你切换到其它容器运行时的时候， 这些命令将不再起作用。

### 识别依赖于 Docker Engine 的 DaemonSet

如果某 Pod 想调用运行在节点上的 ​`dockerd`​，该 Pod 必须满足以下两个条件之一：

*   将包含 Docker 守护进程特权套接字的文件系统挂载为一个卷；或
*   直接以卷的形式挂载 Docker 守护进程特权套接字的特定路径。

举例来说：在 COS 镜像中，Docker 通过 ​`/var/run/docker.sock`​ 开放其 Unix 域套接字。 这意味着 Pod 的规约中需要包含 ​`hostPath` ​卷以挂载 ​`/var/run/docker.sock`​。

下面是一个 shell 示例脚本，用于查找包含直接映射 Docker 套接字的挂载点的 Pod。 你也可以删掉 ​`grep '/var/run/docker.sock'`​ 这一代码片段以查看其它挂载信息。

`kubectl get pods --all-namespaces \ -o=jsonpath='{range .items[*]}{"\n"}{.metadata.namespace}{":\t"}{.metadata.name}{":\t"}{range .spec.volumes[*]}{.hostPath.path}{", "}{end}{end}' \ | sort \ | grep '/var/run/docker.sock'`

> Note: 对于 Pod 来说，访问宿主机上的 Docker 还有其他方式。 例如，可以挂载 ​`/var/run`​ 的父目录而非其完整路径 （就像[这个例子](https://gist.github.com/itaysk/7bc3e56d69c4d72a549286d98fd557dd)）。 上述脚本只检测最常见的使用方式。

### 检测节点代理对 Docker 的依赖性

在你的集群节点被定制、且在各个节点上均安装了额外的安全和遥测代理的场景下， 一定要和代理的供应商确认：该代理是否依赖于 Docker。

### 遥测和安全代理的供应商

我们通过 [谷歌文档](https://docs.google.com/document/d/1ZFi4uKit63ga5sxEiZblfb-c23lFhvy6RXVPikS8wf0/edit target=) 提供了为各类遥测和安全代理供应商准备的持续更新的迁移指导。 请与供应商联系，获取从 dockershim 迁移的最新说明。

#  20.  Kubernetes 用kubeadm进行管理

##  1.  Kubernetes 使用kubeadm进行证书管理
使用 kubeadm 进行证书管理
-----------------

FEATURE STATE: Kubernetes v1.15 \[stable\]

由 kubeadm 生成的客户端证书在 1 年后到期。 本页说明如何使用 kubeadm 管理证书续订，同时也涵盖其他与 kubeadm 证书管理相关的说明。

在开始之前
-----

你应该熟悉 [Kubernetes 中的 PKI 证书和要求](https://www.w3cschool.cn/kubernetes/kubernetes-xmrv3oag.html)。

使用自定义的证书
--------

默认情况下，kubeadm 会生成运行一个集群所需的全部证书。 你可以通过提供你自己的证书来改变这个行为策略。

如果要这样做，你必须将证书文件放置在通过 ​`--cert-dir`​ 命令行参数或者 kubeadm 配置中的 ​`certificatesDir` ​配置项指明的目录中。默认的值是 ​`/etc/kubernetes/pki`​。

如果在运行 ​`kubeadm init`​ 之前存在给定的证书和私钥对，kubeadm 将不会重写它们。 例如，这意味着你可以将现有的 CA 复制到 ​`/etc/kubernetes/pki/ca.crt`​ 和 ​`/etc/kubernetes/pki/ca.key`​ 中，而 kubeadm 将使用此 CA 对其余证书进行签名。

外部 CA 模式
--------

只提供了 ​`ca.crt`​ 文件但是不提供 ​`ca.key`​ 文件也是可以的 （这只对 CA 根证书可用，其它证书不可用）。 如果所有的其它证书和 kubeconfig 文件已就绪，kubeadm 检测到满足以上条件就会激活 "外部 CA" 模式。kubeadm 将会在没有 CA 密钥文件的情况下继续执行。

否则，kubeadm 将独立运行 controller-manager，附加一个 ​`--controllers=csrsigner`​ 的参数，并且指明 CA 证书和密钥。

[PKI 证书和要求](https://www.w3cschool.cn/kubernetes/kubernetes-xmrv3oag.html)包括集群使用外部 CA 的设置指南。

检查证书是否过期
--------

你可以使用 ​`check-expiration`​ 子命令来检查证书何时过期

`kubeadm certs check-expiration`

输出类似于以下内容：

`CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED admin.conf                 Dec 30, 2020 23:36 UTC   364d                                    no apiserver                  Dec 30, 2020 23:36 UTC   364d            ca                      no apiserver-etcd-client      Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no apiserver-kubelet-client   Dec 30, 2020 23:36 UTC   364d            ca                      no controller-manager.conf    Dec 30, 2020 23:36 UTC   364d                                    no etcd-healthcheck-client    Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no etcd-peer                  Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no etcd-server                Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no front-proxy-client         Dec 30, 2020 23:36 UTC   364d            front-proxy-ca          no scheduler.conf             Dec 30, 2020 23:36 UTC   364d                                    no  CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED ca                      Dec 28, 2029 23:36 UTC   9y              no etcd-ca                 Dec 28, 2029 23:36 UTC   9y              no front-proxy-ca          Dec 28, 2029 23:36 UTC   9y              no`

该命令显示 ​`/etc/kubernetes/pki`​ 文件夹中的客户端证书以及 kubeadm（​`admin.conf`​、​`controller-manager.conf`​ 和 ​`scheduler.conf`​） 使用的 KUBECONFIG 文件中嵌入的客户端证书的到期时间/剩余时间。

另外，kubeadm 会通知用户证书是否由外部管理； 在这种情况下，用户应该小心的手动/使用其他工具来管理证书更新。

> Warning: ​`kubeadm` ​不能管理由外部 CA 签名的证书

> Note: 上面的列表中没有包含 ​`kubelet.conf`​，因为 kubeadm 将 kubelet 配置为 自动更新证书。 轮换的证书位于目录 ​`/var/lib/kubelet/pki`​。

> Warning:  
> 在通过 ​`kubeadm init`​ 创建的节点上，在 kubeadm 1.17 版本之前有一个 [缺陷](https://github.com/kubernetes/kubeadm/issues/1753)，该缺陷 使得你必须手动修改 ​`kubelet.conf`​ 文件的内容。 ​`kubeadm init`​ 操作结束之后，你必须更新 ​`kubelet.conf`​ 文件 将 ​`client-certificate-data`​ 和 ​`client-key-data`​ 改为如下所示的内容 以便使用轮换后的 kubelet 客户端证书：
> 
> `client-certificate: /var/lib/kubelet/pki/kubelet-client-current.pem client-key: /var/lib/kubelet/pki/kubelet-client-current.pem`

自动更新证书
------

kubeadm 会在控制面 升级 的时候更新所有证书。

这个功能旨在解决最简单的用例；如果你对此类证书的更新没有特殊要求， 并且定期执行 Kubernetes 版本升级（每次升级之间的间隔时间少于 1 年）， 则 kubeadm 将确保你的集群保持最新状态并保持合理的安全性。

> Note: 最佳的做法是经常升级集群以确保安全。  

如果你对证书更新有更复杂的需求，则可通过将 ​`--certificate-renewal=false`​ 传递给 ​`kubeadm upgrade apply`​ 或者 ​`kubeadm upgrade node`​，从而选择不采用默认行为。

> Warning: kubeadm 在 1.17 版本之前有一个[缺陷](https://github.com/kubernetes/kubeadm/issues/1818)， 该缺陷导致 ​`kubeadm update node`​ 执行时 ​`--certificate-renewal`​ 的默认值被设置为 ​`false`​。 在这种情况下，你需要显式地设置 ​`--certificate-renewal=true`​。

手动更新证书
------

你能随时通过 ​`kubeadm certs renew`​ 命令手动更新你的证书。

此命令用 CA（或者 front-proxy-CA ）证书和存储在 ​`/etc/kubernetes/pki`​ 中的密钥执行更新。

执行完此命令之后你需要重启控制面 Pods。因为动态证书重载目前还不被所有组件和证书支持，所有这项操作是必须的。 静态 Pods 是被本地 kubelet 而不是 API Server 管理， 所以 kubectl 不能用来删除或重启他们。 要重启静态 Pod 你可以临时将清单文件从 ​`/etc/kubernetes/manifests/`​ 移除并等待 20 秒。 如果 Pod 不在清单目录里，kubelet 将会终止它。 在另一个 ​`fileCheckFrequency` ​周期之后你可以将文件移回去，为了组件可以完成 kubelet 将重新创建 Pod 和证书更新。

> Warning: 如果你运行了一个 HA 集群，这个命令需要在所有控制面板节点上执行。  

> Note: ​`certs renew`​ 使用现有的证书作为属性（Common Name、Organization、SAN 等）的权威来源， 而不是 kubeadm-config ConfigMap。强烈建议使它们保持同步。

​`kubeadm certs renew`​ 提供以下选项：

Kubernetes 证书通常在一年后到期。

*   ​`--csr-only`​ 可用于经过一个外部 CA 生成的证书签名请求来更新证书（无需实际替换更新证书）。
*   可以更新单个证书而不是全部证书。

用 Kubernetes 证书 API 更新证书
------------------------

本节提供有关如何使用 Kubernetes 证书 API 执行手动证书更新的更多详细信息。

> Caution: 这些是针对需要将其组织的证书基础结构集成到 kubeadm 构建的集群中的用户的高级主题。 如果默认的 kubeadm 配置满足了你的需求，则应让 kubeadm 管理证书。

### 设置一个签名者（Signer）

Kubernetes 证书颁发机构不是开箱即用。你可以配置外部签名者，例如 [cert-manager](https://cert-manager.io/docs/configuration/ca/)， 也可以使用内置签名者。 内置签名者是 ​`kube-controller-manager`​ 的一部分。 要激活内置签名者，请传递 ​`--cluster-signing-cert-file`​ 和 ​`--cluster-signing-key-file`​ 参数。

如果你正在创建一个新的集群，你可以使用 kubeadm 的 配置文件。

`apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration controllerManager:   extraArgs:     cluster-signing-cert-file: /etc/kubernetes/pki/ca.crt     cluster-signing-key-file: /etc/kubernetes/pki/ca.key`

通过外部 CA 更新证书
------------

本节提供有关如何使用外部 CA 执行手动更新证书的更多详细信息。

为了更好的与外部 CA 集成，kubeadm 还可以生成证书签名请求（CSR）。 CSR 表示向 CA 请求客户的签名证书。 在 kubeadm 术语中，通常由磁盘 CA 签名的任何证书都可以作为 CSR 生成。但是，CA 不能作为 CSR 生成。

### 创建证书签名请求 (CSR)

你可以通过 ​`kubeadm certs renew --csr-only`​ 命令创建证书签名请求。

CSR 和随附的私钥都在输出中给出。 你可以传入一个带有 ​`--csr-dir`​ 的目录，将 CRS 输出到指定位置。 如果未指定 ​`--csr-dir`​，则使用默认证书目录（​`/etc/kubernetes/pki`​）。

证书可以通过 ​`kubeadm certs renew --csr-only`​ 来续订。 和 ​`kubeadm init`​ 一样，可以使用 ​`--csr-dir`​ 标志指定一个输出目录。

CSR 签署证书后，必须将证书和私钥复制到 PKI 目录（默认情况下为 ​`/etc/kubernetes/pki`​）。

CSR 中包含一个证书的名字，域和 IP，但是未指定用法。 颁发证书时，CA 有责任指定正确的证书用法

*   在 ​`openssl` ​中，这是通过 [openssl ca 命令](https://superuser.com/questions/738612/openssl-ca-keyusage-extension) 来完成的。
*   在 ​`cfssl` ​中，这是通过 [在配置文件中指定用法](https://github.com/cloudflare/cfssl/blob/master/doc/cmd/cfssl.txt target=) 来完成的。

使用首选方法对证书签名后，必须将证书和私钥复制到 PKI 目录（默认为 ​`/etc/kubernetes/pki`​ ）。

证书机构（CA）轮换
----------

kubeadm 并不直接支持对 CA 证书的轮换或者替换。

启用已签名的 kubelet 服务证书
-------------------

默认情况下，kubeadm 所部署的 kubelet 服务证书是自签名（Self-Signed）。 这意味着从 [metrics-server](https://github.com/kubernetes-sigs/metrics-server) 这类外部服务发起向 kubelet 的链接时无法使用 TLS 来完成保护。

要在新的 kubeadm 集群中配置 kubelet 以使用被正确签名的服务证书， 你必须向 ​`kubeadm init`​ 传递如下最小配置数据：

`apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration --- apiVersion: kubelet.config.k8s.io/v1beta1 kind: KubeletConfiguration serverTLSBootstrap: true`

如果你已经创建了集群，你必须通过执行下面的操作来完成适配：

*   找到 ​`kube-system`​ 名字空间中名为 ​`kubelet-config-1.24`​ 的 ConfigMap 并编辑之。 在该 ConfigMap 中，​`kubelet` ​键下面有一个 KubeletConfiguration 文档作为其取值。编辑该 KubeletConfiguration 文档以设置 ​`serverTLSBootstrap: true`​。
*   在每个节点上，在 ​`/var/lib/kubelet/config.yaml`​ 文件中添加 ​`serverTLSBootstrap: true`​ 字段，并使用 ​`systemctl restart kubelet`​ 来重启 kubelet。

字段 ​`serverTLSBootstrap` ​将允许启动引导 kubelet 的服务证书，方式 是从 ​`certificates.k8s.io`​ API 处读取。这种方式的一种局限在于这些 证书的 CSR（证书签名请求）不能被 kube-controller-manager 中默认的 签名组件 ​`kubernetes.io/kubelet-serving`​ 批准。需要用户或者第三方控制器来执行此操作。

可以使用下面的命令来查看 CSR：

`kubectl get csr`

`NAME        AGE     SIGNERNAME                        REQUESTOR                      CONDITION csr-9wvgt   112s    kubernetes.io/kubelet-serving     system:node:worker-1           Pending csr-lz97v   1m58s   kubernetes.io/kubelet-serving     system:node:control-plane-1    Pending`

你可以执行下面的操作来批准这些请求：

`kubectl certificate approve <CSR-名称>`

默认情况下，这些服务证书上会在一年后过期。 kubeadm 将 ​`KubeletConfiguration` ​的 ​`rotateCertificates` ​字段设置为 ​`true`​；这意味着证书快要过期时，会生成一组针对服务证书的新的 CSR，而 这些 CSR 也要被批准才能完成证书轮换。

如果你在寻找一种能够自动批准这些 CSR 的解决方案，建议你与你的云提供商 联系，询问他们是否有 CSR 签名组件，用来以带外（out-of-band）的方式检查 节点的标识符。

也可以使用第三方定制的控制器：

*   [kubelet-csr-approver](https://github.com/postfinance/kubelet-csr-approver)

除非既能够验证 CSR 中的 CommonName，也能检查请求的 IP 和域名， 这类控制器还算不得安全的机制。 只有完成彻底的检查，才有可能避免有恶意的、能够访问 kubelet 客户端证书的第三方 为任何 IP 或域名请求服务证书。

为其他用户生成 kubeconfig 文件 
----------------------

在集群创建过程中，kubeadm 对 ​`admin.conf`​ 中的证书进行签名时，将其配置为 ​`Subject: O = system:masters, CN = kubernetes-admin`​。 ​`system:masters`​ 是一个例外的超级用户组，可以绕过鉴权层（例如 RBAC）。 强烈建议不要将 ​`admin.conf` ​文件与任何人共享。

你要使用 ​`kubeadm kubeconfig user`​ 命令为其他用户生成 kubeconfig 文件，这个命令支持命令行参数和 kubeadm 配置结构。 以上命令会将 kubeconfig 打印到终端上，也可以使用 ​`kubeadm kubeconfig user ... > somefile.conf`​ 输出到一个文件中。

如下 kubeadm 可以在 ​`--config`​ 后加的配置文件示例：

`# example.yaml apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration # kubernetes 将作为 kubeconfig 中集群名称 clusterName: "kubernetes" # some-dns-address:6443 将作为集群 kubeconfig 文件中服务地址（IP 或者 DNS 名称） controlPlaneEndpoint: "some-dns-address:6443" # 从本地挂载集群的 CA 秘钥和 CA 证书 certificatesDir: "/etc/kubernetes/pki"`

确保这些设置与所需的目标集群设置相匹配。可以使用以下命令查看现有集群的设置：

`kubectl get cm kubeadm-config -n kube-system -o=jsonpath="{.data.ClusterConfiguration}"`

以下示例将为在 ​`appdevs` ​组的 ​`johndoe` ​用户创建一个有效期为 24 小时的 kubeconfig 文件：

`kubeadm kubeconfig user --config example.yaml --org appdevs --client-name johndoe --validity-period 24h`

以下示例将为管理员创建一个有效期有一周的 kubeconfig 文件：

`kubeadm kubeconfig user --config example.yaml --client-name admin --validity-period 168h`

##  2.  Kubernetes 配置cgroup驱动
配置容器运行时 cgroup 驱动
-----------------

[容器运行时](https://www.w3cschool.cn/kubernetes/kubernetes-6voq3oa9.html)页面提到： 由于 kubeadm 把 kubelet 视为一个系统服务来管理，所以对基于 kubeadm 的安装， 我们推荐使用 ​`systemd` ​驱动，不推荐 ​`cgroupfs` ​驱动。

此页还详述了如何安装若干不同的容器运行时，并将 ​`systemd` ​设为其默认驱动。

配置 kubelet 的 cgroup 驱动
----------------------

kubeadm 支持在执行 ​`kubeadm init`​ 时，传递一个 ​`KubeletConfiguration`​ 结构体。 ​`KubeletConfiguration`​ 包含 ​`cgroupDriver` ​字段，可用于控制 kubelet 的 cgroup 驱动。

> Note: 在版本 1.22 中，如果用户没有在 ​`KubeletConfiguration` ​中设置 ​`cgroupDriver` ​字段， ​`kubeadm init`​ 会将它设置为默认值 ​`systemd`​。

这是一个最小化的示例，其中显式的配置了此字段：

`# kubeadm-config.yaml kind: ClusterConfiguration apiVersion: kubeadm.k8s.io/v1beta3 kubernetesVersion: v1.21.0 --- kind: KubeletConfiguration apiVersion: kubelet.config.k8s.io/v1beta1 cgroupDriver: systemd`

这样一个配置文件就可以传递给 kubeadm 命令了：

`kubeadm init --config kubeadm-config.yaml`

> Note:  
> Kubeadm 对集群所有的节点，使用相同的 ​`KubeletConfiguration`​。 ​`KubeletConfiguration` ​存放于 ​`kube-system`​ 命名空间下的某个 ConfigMap 对象中。  
> 执行 ​`init`​、​`join` ​和 ​`upgrade` ​等子命令会促使 kubeadm 将 ​`KubeletConfiguration` ​写入到文件 ​`/var/lib/kubelet/config.yaml`​ 中， 继而把它传递给本地节点的 kubelet。

使用 cgroupfs 驱动 
---------------

正如本指南阐述的：不推荐与 kubeadm 一起使用 ​`cgroupfs` ​驱动。

如仍需使用 ​`cgroupfs`​， 且要防止 ​`kubeadm upgrade`​ 修改现有系统中 ​`KubeletConfiguration` ​的 cgroup 驱动， 你必须显式声明它的值。 此方法应对的场景为：在将来某个版本的 kubeadm 中，你不想使用默认的 ​`systemd` ​驱动。

如果你希望配置容器运行时来使用 ​`cgroupfs` ​驱动， 则必须参考所选容器运行时的文档。

迁移到 systemd 驱动
--------------

要将现有 kubeadm 集群的 cgroup 驱动就地升级为 ​`systemd`​， 需要执行一个与 kubelet 升级类似的过程。 该过程必须包含下面两个步骤：

> Note: 还有一种方法，可以用已配置了 ​`systemd` ​的新节点替换掉集群中的老节点。 按这种方法，在加入新节点、确保工作负载可以安全迁移到新节点、及至删除旧节点这一系列操作之前， 只需执行以下第一个步骤。

### 修改 kubelet 的 ConfigMap

*   运行 ​`kubectl edit cm kubelet-config -n kube-system`​。
*   修改现有 ​`cgroupDriver` ​的值，或者新增如下式样的字段：

`cgroupDriver: systemd`

该字段必须出现在 ConfigMap 的 ​`kubelet:`​ 小节下。

### 更新所有节点的 cgroup 驱动

对于集群中的每一个节点：

*   执行命令 ​`kubectl drain <node-name> --ignore-daemonsets`​，以 腾空节点
*   执行命令 ​`systemctl stop kubelet`​，以停止 kubelet
*   停止容器运行时
*   修改容器运行时 cgroup 驱动为 ​`systemd` ​
*   在文件 ​`/var/lib/kubelet/config.yaml`​ 中添加设置 ​`cgroupDriver: systemd` ​
*   启动容器运行时
*   执行命令 ​`systemctl start kubelet`​，以启动 kubelet
*   执行命令 ​`kubectl uncordon <node-name>`​，以 取消节点隔离

在节点上依次执行上述步骤，确保工作负载有充足的时间被调度到其他节点。

流程完成后，确认所有节点和工作负载均健康如常。

##  3.  Kubernetes 重新配置kubeadm集群
重新配置 kubeadm 集群
---------------

kubeadm 不支持自动重新配置部署在托管节点上的组件的方式。 一种自动化的方法是使用自定义的 operator。

要修改组件配置，你必须手动编辑磁盘上关联的集群对象和文件。 本指南展示了实现 kubeadm 集群重新配置所需执行的正确步骤顺序。

在开始之前
-----

*   你需要一个使用 kubeadm 部署的集群
*   拥有管理员凭据（​`/etc/kubernetes/admin.conf`​） 和从安装了 kubectl 的主机到集群中正在运行的 kube-apiserver 的网络连接
*   在所有主机上安装文本编辑器

重新配置集群
------

kubeadm 在 ConfigMap 和其他对象中写入了一组集群范围的组件配置选项。 这些对象必须手动编辑，可以使用命令 ​`kubectl edit`​。

​`kubectl edit`​ 命令将打开一个文本编辑器，你可以在其中直接编辑和保存对象。 你可以使用环境变量 ​`KUBECONFIG` ​和 ​`KUBE_EDITOR` ​来指定 kubectl 使用的 kubeconfig 文件和首选文本编辑器的位置。

例如：

`KUBECONFIG=/etc/kubernetes/admin.conf KUBE_EDITOR=nano kubectl edit <parameters>`

> Note:  
> 保存对这些集群对象的任何更改后，节点上运行的组件可能不会自动更新。 以下步骤将指导你如何手动执行该操作。

> Warning:  
> ConfigMaps 中的组件配置存储为非结构化数据（YAML 字符串）。 这意味着在更新 ConfigMap 的内容时不会执行验证。 你必须小心遵循特定组件配置的文档化 API 格式， 并避免引入拼写错误和 YAML 缩进错误。

### 应用集群配置更改

#### 更新 ClusterConfiguration

在集群创建和升级期间，kubeadm 将其 ​`ClusterConfiguration` ​写入 ​`kube-system`​ 命名空间中名为 ​`kubeadm-config`​ 的 ConfigMap。

要更改 ​`ClusterConfiguration` ​中的特定选项，你可以使用以下命令编辑 ConfigMap：

`kubectl edit cm -n kube-system kubeadm-config`

配置位于 ​`data.ClusterConfiguration`​ 键下。

> Note:  
> ​`ClusterConfiguration` ​包括各种影响单个组件配置的选项， 例如 kube-apiserver、kube-scheduler、kube-controller-manager、 CoreDNS、etcd 和 kube-proxy。 对配置的更改必须手动反映在节点组件上。

#### 在控制平面节点上反映 ClusterConfiguration 更改

kubeadm 将控制平面组件作为位于 ​`/etc/kubernetes/manifests`​ 目录中的静态 Pod 清单进行管理。 对 ​`apiServer`​、​`controllerManager`​、​`scheduler` ​或 ​`etcd`​键下的 ​`ClusterConfiguration` ​的任何更改都必须反映在控制平面节点上清单目录中的关联文件中。

此类更改可能包括:

*   ​`extraArgs` ​- 需要更新传递给组件容器的标志列表
*   ​`extraMounts` ​- 需要更新组件容器的卷挂载
*   ​`*SANs`​ - 需要使用更新的主题备用名称编写新证书

在继续进行这些更改之前，请确保你已备份目录 ​`/etc/kubernetes/`​。

要编写新证书，你可以使用：

`kubeadm init phase certs <component-name> --config <config-file>`

要在 ​`/etc/kubernetes/manifests`​ 中编写新的清单文件，你可以使用：

`kubeadm init phase control-plane <component-name> --config <config-file>`

​`<config-file>`​ 内容必须与更新后的 ​`ClusterConfiguration` ​匹配。 ​`<component-name>`​ 值必须是组件的名称。

> Note:  
> 更新 ​`/etc/kubernetes/manifests`​ 中的文件将告诉 kubelet 重新启动相应组件的静态 Pod。 尝试一次对一个节点进行这些更改，以在不停机的情况下离开集群。

### 应用 kubelet 配置更改

#### 更新 KubeletConfiguration

在集群创建和升级期间，kubeadm 将其 ​`KubeletConfiguration` ​写入 ​`kube-system`​ 命名空间中名为 ​`kubelet-config`​ 的 ConfigMap。 你可以使用以下命令编辑 ConfigMap：

`kubectl edit cm -n kube-system kubelet-config`

配置位于 ​`data.kubelet`​ 键下。

#### 反映 kubelet 的更改

要反映 kubeadm 节点上的更改，你必须执行以下操作：

*   登录到 kubeadm 节点
*   运行 ​`kubeadm upgrade node phase kubelet-config`​ 下载最新的 ​`kubelet-config`​ ConfigMap 内容到本地文件 ​`/var/lib/kubelet/config.conf` ​
*   编辑文件 ​`/var/lib/kubelet/kubeadm-flags.env`​ 以使用标志来应用额外的配置
*   使用 ​`systemctl restart kubelet`​ 重启 kubelet 服务

> Note:  
> 一次执行一个节点的这些更改，以允许正确地重新安排工作负载。

> Note:  
> 在 ​`kubeadm upgrade`​ 期间，kubeadm 从 ​`kubelet-config`​ ConfigMap 下载 ​`KubeletConfiguration` ​并覆盖 ​`/var/lib/kubelet/config.conf`​ 的内容。 这意味着节点本地配置必须通过​`/var/lib/kubelet/kubeadm-flags.env`​中的标志或在 kubeadm upgrade 后手动更新/var/lib/kubelet/config.conf\`的内容来应用，然后重新启动 kubelet。

### 应用 kube-proxy 配置更改

#### 更新 KubeProxyConfiguration

在集群创建和升级期间，kubeadm 将其写入 ​`KubeProxyConfiguration` ​在名为 ​`kube-proxy`​ 的 ​`kube-system`​ 命名空间中的 ConfigMap 中。

此 ConfigMap 由 ​`kube-system`​ 命名空间中的 ​`kube-proxy`​ DaemonSet 使用。

要更改 ​`KubeProxyConfiguration` ​中的特定选项，你可以使用以下命令编辑 ConfigMap：

`kubectl edit cm -n kube-system kube-proxy`

配置位于 ​`data.config.conf`​ 键下。

#### 反映 kube-proxy 的更改

更新 ​`kube-proxy`​ ConfigMap 后，你可以重新启动所有 kube-proxy Pod：

获取 Pod 名称：

`kubectl get po -n kube-system | grep kube-proxy`

使用以下命令删除 Pod：

`kubectl delete po -n kube-system <pod-name>`

将创建使用更新的 ConfigMap 的新 Pod。

> Note:  
> 由于 kubeadm 将 kube-proxy 部署为 DaemonSet，因此不支持特定于节点的配置。

### 应用 CoreDNS 配置更改

#### 更新 CoreDNS 的 Deployment 和 Service

kubeadm 将 CoreDNS 部署为名为 ​`coredns` ​的 Deployment，并使用 Service ​`kube-dns`​， 两者都在 ​`kube-system`​ 命名空间中。

要更新任何 CoreDNS 设置，你可以编辑 Deployment 和 Service：

`kubectl edit deployment -n kube-system coredns kubectl edit service -n kube-system kube-dns`

#### 反映 CoreDNS 的更改

应用 CoreDNS 更改后，你可以删除 CoreDNS Pod。

获取 Pod 名称：

`kubectl get po -n kube-system | grep coredns`

使用以下命令删除 Pod：

`kubectl delete po -n kube-system <pod-name>`

将创建具有更新的 CoreDNS 配置的新 Pod。

> Note:  
> kubeadm 不允许在集群创建和升级期间配置 CoreDNS。 这意味着如果执行了 ​`kubeadm upgrade apply`​，你对 CoreDNS 对象的更改将丢失并且必须重新应用。

持久化重新配置 
--------

在受管节点上执行 ​`kubeadm upgrade`​ 期间，kubeadm 可能会覆盖在创建集群（重新配置）后应用的配置。

### 持久化 Node 对象重新配置

kubeadm 在特定 Kubernetes 节点的 Node 对象上写入标签、污点、CRI 套接字和其他信息。要更改此 Node 对象的任何内容，你可以使用：

`kubectl edit no <node-name>`

在 ​`kubeadm upgrade`​ 期间，此类节点的内容可能会被覆盖。 如果你想在升级后保留对 Node 对象的修改，你可以准备一个 kubectl patch 并将其应用到 Node 对象：

`kubectl patch no <node-name> --patch-file <patch-file>`

#### 持久化控制平面组件重新配置

控制平面配置的主要来源是存储在集群中的 ​`ClusterConfiguration` ​对象。 要扩展静态 Pod 清单配置，可以使用 patches。

这些补丁文件必须作为文件保留在控制平面节点上，以确保它们可以被 ​`kubeadm upgrade ... --patches <directory>`​ 使用。

如果对 ​`ClusterConfiguration` ​和磁盘上的静态 Pod 清单进行了重新配置，则必须相应地更新节点特定补丁集。

#### 持久化 kubelet 重新配置

对存储在 ​`/var/lib/kubelet/config.conf`​ 中的 ​`KubeletConfiguration` ​所做的任何更改都将在 ​`kubeadm upgrade`​ 时因为下载集群范围内的 ​`kubelet-config`​ ConfigMap 的内容而被覆盖。 要持久保存 kubelet 节点特定的配置，文件​`/var/lib/kubelet/config.conf`​ 必须在升级后手动更新，或者文件​`/var/lib/kubelet/kubeadm-flags.env`​ 可以包含标志。 kubelet 标志会覆盖相关的 ​`KubeletConfiguration` ​选项，但请注意，有些标志已被弃用。

更改 ​`/var/lib/kubelet/config.conf`​ 或 ​`/var/lib/kubelet/kubeadm-flags.env`​ 后需要重启 kubelet。

##  4.  Kubernetes 升级kubeadm集群
在开始之前
-----

*   务必仔细认真阅读[发行说明](https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.24.md)。
*   集群应使用静态的控制平面和 etcd Pod 或者外部 etcd。
*   务必备份所有重要组件，例如存储在数据库中应用层面的状态。 ​`kubeadm upgrade`​ 不会影响你的工作负载，只会涉及 Kubernetes 内部的组件，但备份终究是好的。
*   [必须禁用交换分区](https://serverfault.com/questions/684771/best-way-to-disable-swap-in-linux)。

### 附加信息

*   下述说明了在升级过程中何时腾空每个节点。如果你正在对任何 kubelet 进行小版本升级， 你需要先腾空待升级的节点（或多个节点）。对于控制面节点，其上可能运行着 CoreDNS Pods 或者其它非常重要的负载。
*   升级后，因为容器规约的哈希值已更改，所有容器都会被重新启动。
*   要验证 kubelet 服务在升级后是否成功重启，可以执行 ​`systemctl status kubelet`​ 或 ​`journalctl -xeu kubelet`​ 查看服务日志。
*   不建议使用 ​`kubeadm upgrade`​ 的 \`--config 参数和 kubeadm 配置 API 类型 来重新配置集群，这样会产生意想不到的结果。

确定要升级到哪个版本
----------

使用操作系统的包管理器找到最新的补丁版本 Kubernetes 1.24：

*   Ubuntu、Debian 或 HypriotOS

`apt update apt-cache madison kubeadm # 在列表中查找最新的 1.24 版本 # 它看起来应该是 1.24.x-00，其中 x 是最新的补丁版本`

*   CentOS、RHEL 或 Fedora

`yum list --showduplicates kubeadm --disableexcludes=kubernetes # 在列表中查找最新的 1.24 版本 # 它看起来应该是 1.24.x-0，其中 x 是最新的补丁版本`

升级控制平面节点 
---------

控制面节点上的升级过程应该每次处理一个节点。 首先选择一个要先行升级的控制面节点。该节点上必须拥有 ​`/etc/kubernetes/admin.conf`​ 文件。

### 执行 "kubeadm upgrade"

#### 升级第一个控制面节点

1.  升级 kubeadm：

*   Ubuntu、Debian 或 HypriotOS

`# 用最新的补丁版本号替换 1.24.x-00 中的 x apt-mark unhold kubeadm && \ apt-get update && apt-get install -y kubeadm=1.24.x-00 && \ apt-mark hold kubeadm -`

*   CentOS、RHEL 或 Fedora

`# 用最新的补丁版本号替换 1.24.x-0 中的 x yum install -y kubeadm-1.24.x-0 --disableexcludes=kubernetes`

3.  验证下载操作正常，并且 kubeadm 版本正确：

`kubeadm version`

5.  验证升级计划：

`kubeadm upgrade plan`

此命令检查你的集群是否可被升级，并取回你要升级的目标版本。 命令也会显示一个包含组件配置版本状态的表格。

> Note:  
> ​`kubeadm upgrade`​ 也会自动对 kubeadm 在节点上所管理的证书执行续约操作。 如果需要略过证书续约操作，可以使用标志 ​`--certificate-renewal=false`​。

> Note:  
> 如果 ​`kubeadm upgrade plan`​ 给出任何需要手动升级的组件配置，用户必须 通过 ​`--config`​ 命令行标志向 ​`kubeadm upgrade apply`​ 命令提供替代的配置文件。 如果不这样做，​`kubeadm upgrade apply`​ 会出错并退出，不再执行升级操作。

选择要升级到的目标版本，运行合适的命令。例如：

`# 将 x 替换为你为此次升级所选择的补丁版本号 sudo kubeadm upgrade apply v1.24.x`

一旦该命令结束，你应该会看到：

`[upgrade/successful] SUCCESS! Your cluster was upgraded to "v1.24.x". Enjoy!  [upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets if you haven't already done so.`

14.  手动升级你的 CNI 驱动插件。

你的容器网络接口（CNI）驱动应该提供了程序自身的升级说明。

如果 CNI 驱动作为 DaemonSet 运行，则在其他控制平面节点上不需要此步骤。

#### 对于其它控制面节点

与第一个控制面节点相同，但是使用：

`sudo kubeadm upgrade node`

而不是：

`sudo kubeadm upgrade apply`

此外，不需要执行 ​`kubeadm upgrade plan`​ 和更新 CNI 驱动插件的操作。

### 腾空节点

*   通过将节点标记为不可调度并腾空节点为节点作升级准备：

`# 将 <node-to-drain> 替换为你要腾空的控制面节点名称 kubectl drain <node-to-drain> --ignore-daemonsets`

### 升级 kubelet 和 kubectl 

1.  升级 kubelet 和 kubectl：

*   Ubuntu、Debian 或 HypriotOS

` ```shell # 用最新的补丁版本替换 1.24.x-00 中的 x apt-mark unhold kubelet kubectl && \ apt-get update && apt-get install -y kubelet=1.24.x-00 kubectl=1.24.x-00 && \ apt-mark hold kubelet kubectl ``` `

*   CentOS、RHEL 或 Fedora

` ```shell # 用最新的补丁版本号替换 1.24.x-00 中的 x yum install -y kubelet-1.24.x-0 kubectl-1.24.x-0 --disableexcludes=kubernetes ``` `

3.  重启 kubelet

`sudo systemctl daemon-reload sudo systemctl restart kubelet`

### 解除节点的保护

*   通过将节点标记为可调度，让其重新上线：

`# 将 <node-to-drain> 替换为你的节点名称 kubectl uncordon <node-to-drain>`

升级工作节点 
-------

工作节点上的升级过程应该一次执行一个节点，或者一次执行几个节点， 以不影响运行工作负载所需的最小容量。

### 升级 kubeadm

*   Ubuntu、Debian 或 HypriotOS

`# 将 1.24.x-00 中的 x 替换为最新的补丁版本号 apt-mark unhold kubeadm && \ apt-get update && apt-get install -y kubeadm=1.24.x-00 && \ apt-mark hold kubeadm`

*   CentOS、RHEL 或 Fedora

`# 用最新的补丁版本替换 1.24.x-00 中的 x yum install -y kubeadm-1.24.x-0 --disableexcludes=kubernetes`

### 执行 "kubeadm upgrade"

*   对于工作节点，下面的命令会升级本地的 kubelet 配置：

`sudo kubeadm upgrade node`

### 腾空节点 

*   将节点标记为不可调度并驱逐所有负载，准备节点的维护：

`# 将 <node-to-drain> 替换为你正在腾空的节点的名称 kubectl drain <node-to-drain> --ignore-daemonsets`

### 升级 kubelet 和 kubectl

1.  升级 kubelet 和 kubectl：

*   Ubuntu、Debian 或 HypriotOS

`# 将 1.24.x-00 中的 x 替换为最新的补丁版本 apt-mark unhold kubelet kubectl && \ apt-get update && apt-get install -y kubelet=1.24.x-00 kubectl=1.24.x-00 && \ apt-mark hold kubelet kubectl`

*   CentOS, RHEL or Fedora

`# 将 1.24.x-0 x 替换为最新的补丁版本 yum install -y kubelet-1.24.x-0 kubectl-1.24.x-0 --disableexcludes=kubernetes`

3.  重启 kubelet

`sudo systemctl daemon-reload sudo systemctl restart kubelet`

### 取消对节点的保护

*   通过将节点标记为可调度，让节点重新上线:

`# 将 <node-to-drain> 替换为当前节点的名称 kubectl uncordon <node-to-drain>`

验证集群的状态 
--------

在所有节点上升级 kubelet 后，通过从 kubectl 可以访问集群的任何位置运行以下命令， 验证所有节点是否再次可用：

`kubectl get nodes`

​`STATUS` ​应显示所有节点为 ​`Ready` ​状态，并且版本号已经被更新。

从故障状态恢复
-------

如果 ​`kubeadm upgrade`​ 失败并且没有回滚，例如由于执行期间节点意外关闭， 你可以再次运行 ​`kubeadm upgrade`​。 此命令是幂等的，并最终确保实际状态是你声明的期望状态。 要从故障状态恢复，你还可以运行 ​`kubeadm upgrade --force`​ 而无需更改集群正在运行的版本。

在升级期间，kubeadm 向 ​`/etc/kubernetes/tmp`​ 目录下的如下备份文件夹写入数据：

*   ​`kubeadm-backup-etcd-<date>-<time>` ​
*   ​`kubeadm-backup-manifests-<date>-<time>`​

​`kubeadm-backup-etcd`​ 包含当前控制面节点本地 etcd 成员数据的备份。 如果 etcd 升级失败并且自动回滚也无法修复，则可以将此文件夹中的内容复制到 ​`/var/lib/etcd`​ 进行手工修复。如果使用的是外部的 etcd，则此备份文件夹为空。

​`kubeadm-backup-manifests`​ 包含当前控制面节点的静态 Pod 清单文件的备份版本。 如果升级失败并且无法自动回滚，则此文件夹中的内容可以复制到 ​`/etc/kubernetes/manifests`​ 目录实现手工恢复。 如果由于某些原因，在升级前后某个组件的清单未发生变化，则 kubeadm 也不会为之 生成备份版本。

工作原理 
-----

​`kubeadm upgrade apply`​ 做了以下工作：

*   检查你的集群是否处于可升级状态:

*   API 服务器是可访问的
*   所有节点处于 Ready 状态
*   控制面是健康的

*   强制执行版本偏差策略。
*   确保控制面的镜像是可用的或可拉取到服务器上。
*   如果组件配置要求版本升级，则生成替代配置与/或使用用户提供的覆盖版本配置。
*   升级控制面组件或回滚（如果其中任何一个组件无法启动）。
*   应用新的 ​`CoreDNS` ​和 ​`kube-proxy`​ 清单，并强制创建所有必需的 RBAC 规则。
*   如果旧文件在 180 天后过期，将创建 API 服务器的新证书和密钥文件并备份旧文件。

​`kubeadm upgrade node`​ 在其他控制平节点上执行以下操作：

*   从集群中获取 kubeadm ​`ClusterConfiguration`​。
*   （可选操作）备份 kube-apiserver 证书。
*   升级控制平面组件的静态 Pod 清单。
*   为本节点升级 kubelet 配置

​`kubeadm upgrade node`​ 在工作节点上完成以下工作：

*   从集群取回 kubeadm ​`ClusterConfiguration`​。
*   为本节点升级 kubelet 配置。

##  5.  Kubernetes 添加Windows节点
添加 Windows 节点
-------------

FEATURE STATE: Kubernetes v1.18 \[beta\]

你可以使用 Kubernetes 来混合运行 Linux 和 Windows 节点，这样你就可以 混合使用运行于 Linux 上的 Pod 和运行于 Windows 上的 Pod。 本页面展示如何将 Windows 节点注册到你的集群。

在开始之前
-----

您的 Kubernetes 服务器的版本必须为 1.17 或更高版本。 要检查版本，请输入 ​`kubectl version`​。

*   获取 [Windows Server 2019 或更高版本的授权](https://www.microsoft.com/en-us/windows-server/pricing) 以便配置托管 Windows 容器的 Windows 节点。 如果你在使用 VXLAN/覆盖（Overlay）联网设施，则你还必须安装 [KB4489899](https://support.microsoft.com/zh-cn/topic/2019-%E5%B9%B4-3-%E6%9C%88-12-%E6%97%A5-kb4489899-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E7%89%88%E6%9C%AC-17763-379-2a91a5c5-f351-f181-5501-510308a4030f)。
*   一个利用 kubeadm 创建的基于 Linux 的 Kubernetes 集群；你能访问该集群的控制面。

目标
--

*   将一个 Windows 节点注册到集群上
*   配置网络，以便 Linux 和 Windows 上的 Pod 和 Service 之间能够相互通信。

开始行动：向你的集群添加一个 Windows 节点
-------------------------

### 联网配置 

一旦你有了一个基于 Linux 的 Kubernetes 控制面节点，你就可以为其选择联网方案。 出于简单考虑，本指南展示如何使用 VXLAN 模式的 Flannel。

#### 配置 Flannel 

1.  为 Flannel 准备 Kubernetes 的控制面

在我们的集群中，建议对 Kubernetes 的控制面进行少许准备处理。 建议在使用 Flannel 时为 iptables 链启用桥接方式的 IPv4 流处理， 必须在所有 Linux 节点上执行如下命令：

`sudo sysctl net.bridge.bridge-nf-call-iptables=1`

4.  下载并配置 Linux 版本的 Flannel

下载最新的 Flannel 清单文件：

`wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml`

修改 Flannel 清单中的 ​`net-conf.json`​ 部分，将 VNI 设置为 4096，并将 Port 设置为 4789。 结果看起来像下面这样：

`net-conf.json: |     {       "Network": "10.244.0.0/16",       "Backend": {          "Type": "vxlan",          "VNI": 4096,          "Port": 4789     } }`

> Note: 在 Linux 节点上 VNI 必须设置为 4096，端口必须设置为 4789，这样才能令其与 Windows 上的 Flannel 互操作。关于这些字段的详细说明，请参见 [VXLAN 文档](https://github.com/flannel-io/flannel/blob/master/Documentation/backends.md target=)。

> Note: 如要使用 L2Bridge/Host-gateway 模式，则可将 ​`Type` ​值设置为 "​`host-gw`​"，并忽略 ​`VNI` ​和 ​`Port` ​的设置。  

11.  应用 Flannel 清单并验证

首先应用 Flannel 配置：

`kubectl apply -f kube-flannel.yml`

几分钟之后，如果 Flannel Pod 网络被正确部署，你应该会看到所有 Pods 都处于运行中状态。

`kubectl get pods -n kube-system`

输出中应该包含处于运行中状态的 Linux Flannel DaemonSet：

`NAMESPACE     NAME                                      READY        STATUS    RESTARTS   AGE ... kube-system   kube-flannel-ds-54954                     1/1          Running   0          1m`

18.  添加 Windows Flannel 和 kube-proxy DaemonSet

现在你可以添加 Windows 兼容版本的 Flannel 和 kube-proxy。为了确保你能获得兼容 版本的 kube-proxy，你需要替换镜像中的标签。 下面的例子中展示的是针对 Kubernetes v1.24.0 版本的用法， 不过你应该根据你自己的集群部署调整其中的版本号。

`curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/kube-proxy.yml | sed 's/VERSION/v1.24.0/g' | kubectl apply -f - kubectl apply -f https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-overlay.yml`

> Note: 如果你在使用 host-gateway 模式，则应该使用 [https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-host-gw.yml](https://objects.githubusercontent.com/github-production-release-asset-2e65be/189827036/d6f1e580-3ed7-11eb-8268-7cc17cb28683?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20220602%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20220602T033041Z&X-Amz-Expires=300&X-Amz-Signature=064593912466ba8fef77cdef150cf8e8b30d936ffc7a854832e2f9fcbcbda6bb&X-Amz-SignedHeaders=host&actor_id=47314025&key_id=0&repo_id=189827036&response-content-disposition=attachment%3B%20filename%3Dflannel-host-gw.yml&response-content-type=application%2Foctet-stream) 这一清单。

> Note:  
> 如果你在 Windows 节点上使用的不是以太网（即，"Ethernet0 2"）接口，你需要 修改 ​`flannel-host-gw.yml`​ 或 ​`flannel-overlay.yml`​ 文件中的下面这行：
> 
> `wins cli process run --path /k/flannel/setup.exe --args "--mode=overlay --interface=Ethernet"`
> 
> 在其中根据情况设置要使用的网络接口。
> 
> `# Example curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-overlay.yml | sed 's/Ethernet/Ethernet0 2/g' | kubectl apply -f -`

### 加入 Windows 工作节点 

> Note:  
> Windows 节的所有代码片段都需要在 PowerShell 环境中执行，并且要求在 Windows 工作节点上具有提升的权限（Administrator）。

*   CRI-containerD

#### 安装 containerD

`curl.exe -LO https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/Install-Containerd.ps1 .\Install-Containerd.ps1`

> Note:  
> 要安装特定版本的 containerD，使用参数 -ContainerDVersion 指定版本。
> 
> `# Example .\Install-Containerd.ps1 -ContainerDVersion 1.4.1`
> 
> 如果你在 Windows 节点上使用了与 Ethernet 不同的接口（例如 "Ethernet0 2"），使用参数 ​`-netAdapterName`​ 指定名称。
> 
> `# Example .\Install-Containerd.ps1 -netAdapterName "Ethernet0 2"`

#### 安装 wins、kubelet 和 kubeadm

`curl.exe -LO https://raw.githubusercontent.com/kubernetes-sigs/sig-windows-tools/master/kubeadm/scripts/PrepareNode.ps1 .\PrepareNode.ps1 -KubernetesVersion v1.24.0 -ContainerRuntime containerD`

从 [cri-tools](https://github.com/kubernetes-sigs/cri-tools) 项目安装 ​`crtctl`​。 ​`crictl`​ 是必需的，kubeadm 使用它与 CRI 端点通信。

#### 运行 kubeadm 添加节点

使用当你在控制面主机上运行 ​`kubeadm init`​ 时得到的命令。 如果你找不到这个命令，或者命令中对应的令牌已经过期，你可以（在一个控制面主机上）运行 ​`kubeadm token create --print-join-command`​ 来生成新的令牌和 join 命令。

*   Docker Engine

#### 安装 Docker Engine

安装 ​`Containers` ​功能特性

`Install-WindowsFeature -Name containers`

安装 Docker

操作指南在 [Install Docker Engine - Enterprise on Windows Servers](https://docs.microsoft.com/en-us/virtualization/windowscontainers/quick-start/set-up-environment?tabs=Windows-Server target=)。

[安装 cri-dockerd](https://github.com/Mirantis/cri-dockerd)。kubelet 可以通过 cri-dockerd 在 CRI 兼容的节点上与 Docker 通信。

> Note:  
> Docker Engine 没有实现 CRI， 而 CRI 是容器运行时能够与 Kubernetes 一起工作的要求。 出于这个原因，必须安装一个额外的服务 [cri-dockerd](https://github.com/Mirantis/cri-dockerd)。 cri-dockerd 是一个基于原来的内置 Docker Engine 支持的项目， 而这一支持在 1.24 版本的 kubelet 中已被移除。

从 [cri-tools](https://github.com/kubernetes-sigs/cri-tools) 项目安装 ​`crictl`​。 kubeadm 需要 ​`crictl` ​才能与 CRI 端点通信。

#### 安装 wins、kubelet 和 kubeadm

`curl.exe -LO https://raw.githubusercontent.com/kubernetes-sigs/sig-windows-tools/master/kubeadm/scripts/PrepareNode.ps1 .\PrepareNode.ps1 -KubernetesVersion v1.24.0`

#### 运行 kubeadm 添加节点

当你在控制面主机上运行 ​`kubeadm init`​ 时，输出了一个命令。现在运行这个命令。 如果你找不到这个命令，或者命令中对应的令牌已经过期，你可以（在一个控制面主机上）运行 ​`kubeadm token create --print-join-command`​ 来生成新的令牌和 join 命令。

#### 检查你的安装 

你现在应该能够通过运行下面的命令来查看集群中的 Windows 节点了：

`kubectl get nodes -o wide`

如果你的新节点处于 ​`NotReady` ​状态，很可能的原因是系统仍在下载 Flannel 镜像。 你可以像之前一样，通过检查 ​`kube-system`​ 名字空间中的 Flannel Pods 来了解 安装进度。

`kubectl -n kube-system get pods -l app=flannel`

一旦 Flannel Pod 运行起来，你的节点就应该能进入 ​`Ready` ​状态并可 用来处理负载。

##  6.  Kubernetes 升级Windows节点
在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](http://labs.play-with-k8s.com/)

您的 Kubernetes 服务器的版本必须为 1.17 或更高版本。 要检查版本，请输入 ​`kubectl version`​。

*   熟悉更新 kubeadm 集群中的其余组件。 在升级你的 Windows 节点之前你会想要升级控制面节点。

升级工作节点 
-------

### 升级 kubeadm 

*   在 Windows 节点上升级 kubeadm：

`# 将 v1.24.0 替换为你希望的版本 curl.exe -Lo C:\k\kubeadm.exe https://dl.k8s.io//bin/windows/amd64/kubeadm.exe`

### 腾空节点 

*   在一个能访问到 Kubernetes API 的机器上，将 Windows 节点标记为不可调度并 驱逐其上的所有负载，以便准备节点维护操作：

`# 将 <要腾空的节点> 替换为你要腾空的节点的名称 kubectl drain <要腾空的节点> -ignore-daemonsets`

你应该会看到类似下面的输出：

`node/ip-172-31-85-18 cordoned node/ip-172-31-85-18 drained`

### 升级 kubelet 配置 

*   在 Windows 节点上，执行下面的命令来同步新的 kubelet 配置：

`kubeadm upgrade node`

### 升级 kubelet 

*   在 Windows 节点上升级并重启 kubelet：

`stop-service kubelet curl.exe -Lo C:\k\kubelet.exe https://dl.k8s.io//bin/windows/amd64/kubelet.exe restart-service kubelet`

### 对节点执行 uncordon 操作 

*   从一台能够访问到 Kubernetes API 的机器上，通过将节点标记为可调度，使之 重新上线：

`# 将 <要腾空的节点> 替换为你的节点名称 kubectl uncordon <要腾空的节点>`

### 升级 kube-proxy 

*   在一台可访问 Kubernetes API 的机器上和，将 v1.24.0 替换成你 期望的版本后再次执行下面的命令：

`curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/kube-proxy.yml | sed 's/VERSION/v1.24.0/g' | kubectl apply -f -`

#  21.  Kubernetes 手动生成证书
手动生成证书
------

在使用客户端证书认证的场景下，你可以通过 ​`easyrsa`​、​`openssl` ​或 ​`cfssl` ​等工具以手工方式生成证书。

easyrsa
-------

easyrsa 支持以手工方式为你的集群生成证书。

1.  下载、解压、初始化打过补丁的 easyrsa3。

`curl -LO https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz tar xzf easy-rsa.tar.gz cd easy-rsa-master/easyrsa3 ./easyrsa init-pki`

3.  生成新的证书颁发机构（CA）。参数 ​`--batch`​ 用于设置自动模式； 参数 ​`--req-cn`​ 用于设置新的根证书的通用名称（CN）。

``./easyrsa --batch "--req-cn=${MASTER_IP}@`date +%s`" build-ca nopass``

5.  生成服务器证书和秘钥。 参数 ​`--subject-alt-name`​ 设置 API 服务器的 IP 和 DNS 名称。 ​`MASTER_CLUSTER_IP` ​用于 API 服务器和控制管理器，通常取 CIDR 的第一个 IP，由 ​`--service-cluster-ip-range`​ 的参数提供。 参数 ​`--days`​ 用于设置证书的过期时间。 下面的示例假定你的默认 DNS 域名为 ​`cluster.local`​。

`./easyrsa --subject-alt-name="IP:${MASTER_IP},"\ "IP:${MASTER_CLUSTER_IP},"\ "DNS:kubernetes,"\ "DNS:kubernetes.default,"\ "DNS:kubernetes.default.svc,"\ "DNS:kubernetes.default.svc.cluster,"\ "DNS:kubernetes.default.svc.cluster.local" \ --days=10000 \ build-server-full server nopass`

7.  拷贝文件 ​`pki/ca.crt`​、​`pki/issued/server.crt`​ 和 ​`pki/private/server.key`​ 到你的目录中。
8.  在 API 服务器的启动参数中添加以下参数：

`--client-ca-file=/yourdirectory/ca.crt --tls-cert-file=/yourdirectory/server.crt --tls-private-key-file=/yourdirectory/server.key`

openssl
-------

openssl 支持以手工方式为你的集群生成证书。

1.  生成一个 2048 位的 ca.key 文件

`openssl genrsa -out ca.key 2048`

3.  在 ca.key 文件的基础上，生成 ca.crt 文件（用参数 -days 设置证书有效期）

`openssl req -x509 -new -nodes -key ca.key -subj "/CN=${MASTER_IP}" -days 10000 -out ca.crt`

5.  生成一个 2048 位的 server.key 文件：

`openssl genrsa -out server.key 2048`

7.  创建一个用于生成证书签名请求（CSR）的配置文件。 保存文件（例如：​`csr.conf`​）前，记得用真实值替换掉尖括号中的值（例如：​`<MASTER_IP>`​）。 注意：​`MASTER_CLUSTER_IP` ​就像前一小节所述，它的值是 API 服务器的服务集群 IP。 下面的例子假定你的默认 DNS 域名为 ​`cluster.local`​。

`[ req ] default_bits = 2048 prompt = no default_md = sha256 req_extensions = req_ext distinguished_name = dn  [ dn ] C = <country> ST = <state> L = <city> O = <organization> OU = <organization unit> CN = <MASTER_IP>  [ req_ext ] subjectAltName = @alt_names  [ alt_names ] DNS.1 = kubernetes DNS.2 = kubernetes.default DNS.3 = kubernetes.default.svc DNS.4 = kubernetes.default.svc.cluster DNS.5 = kubernetes.default.svc.cluster.local IP.1 = <MASTER_IP> IP.2 = <MASTER_CLUSTER_IP>  [ v3_ext ] authorityKeyIdentifier=keyid,issuer:always basicConstraints=CA:FALSE keyUsage=keyEncipherment,dataEncipherment extendedKeyUsage=serverAuth,clientAuth subjectAltName=@alt_names`

9.  基于上面的配置文件生成证书签名请求：

`openssl req -new -key server.key -out server.csr -config csr.conf`

11.  基于 ca.key、ca.crt 和 server.csr 等三个文件生成服务端证书：

`openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key \ -CAcreateserial -out server.crt -days 10000 \ -extensions v3_ext -extfile csr.conf`

13.  查看证书签名请求：

`openssl req  -noout -text -in ./server.csr`

15.  查看证书：

`openssl x509  -noout -text -in ./server.crt`

最后，为 API 服务器添加相同的启动参数。

cfssl
-----

cfssl 是另一个用于生成证书的工具。

1.  下载、解压并准备如下所示的命令行工具。 注意：你可能需要根据所用的硬件体系架构和 cfssl 版本调整示例命令。

`curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl_1.5.0_linux_amd64 -o cfssl chmod +x cfssl curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssljson_1.5.0_linux_amd64 -o cfssljson chmod +x cfssljson curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl-certinfo_1.5.0_linux_amd64 -o cfssl-certinfo chmod +x cfssl-certinfo`

3.  创建一个目录，用它保存所生成的构件和初始化 cfssl：

`mkdir cert cd cert ../cfssl print-defaults config > config.json ../cfssl print-defaults csr > csr.json`

5.  创建一个 JSON 配置文件来生成 CA 文件，例如：​`ca-config.json`​：

`{   "signing": {     "default": {       "expiry": "8760h"     },     "profiles": {       "kubernetes": {         "usages": [           "signing",           "key encipherment",           "server auth",           "client auth"         ],         "expiry": "8760h"       }     }   } }`

7.  创建一个 JSON 配置文件，用于 CA 证书签名请求（CSR），例如：​`ca-csr.json`​。 确认用你需要的值替换掉尖括号中的值。

`{   "CN": "kubernetes",   "key": {     "algo": "rsa",     "size": 2048   },   "names":[{     "C": "<country>",     "ST": "<state>",     "L": "<city>",     "O": "<organization>",     "OU": "<organization unit>"   }] }`

9.  生成 CA 秘钥文件（​`ca-key.pem`​）和证书文件（​`ca.pem`​）：

`../cfssl gencert -initca ca-csr.json | ../cfssljson -bare ca`

11.  创建一个 JSON 配置文件，用来为 API 服务器生成秘钥和证书，例如：​`server-csr.json`​。 确认用你需要的值替换掉尖括号中的值。​`MASTER_CLUSTER_IP` ​是为 API 服务器 指定的服务集群 IP，就像前面小节描述的那样。 以下示例假定你的默认 DSN 域名为​`cluster.local`​。

`{   "CN": "kubernetes",   "hosts": [     "127.0.0.1",     "<MASTER_IP>",     "<MASTER_CLUSTER_IP>",     "kubernetes",     "kubernetes.default",     "kubernetes.default.svc",     "kubernetes.default.svc.cluster",     "kubernetes.default.svc.cluster.local"   ],   "key": {     "algo": "rsa",     "size": 2048   },   "names": [{     "C": "<country>",     "ST": "<state>",     "L": "<city>",     "O": "<organization>",     "OU": "<organization unit>"   }] }`

13.  为 API 服务器生成秘钥和证书，默认会分别存储为​`server-key.pem`​ 和 ​`server.pem`​ 两个文件。

`../cfssl gencert -ca=ca.pem -ca-key=ca-key.pem \ --config=ca-config.json -profile=kubernetes \ server-csr.json | ../cfssljson -bare server`

分发自签名的 CA 证书
------------

客户端节点可能不认可自签名 CA 证书的有效性。 对于非生产环境，或者运行在公司防火墙后的环境，你可以分发自签名的 CA 证书到所有客户节点，并刷新本地列表以使证书生效。

在每一个客户节点，执行以下操作：

`sudo cp ca.crt /usr/local/share/ca-certificates/kubernetes.crt sudo update-ca-certificates`

`Updating certificates in /etc/ssl/certs... 1 added, 0 removed; done. Running hooks in /etc/ca-certificates/update.d.... done.`

证书 API
------

你可以通过 ​`certificates.k8s.io`​ API 提供 x509 证书，用来做身份验证。

#  22.  Kubernetes 管理内存，CPU和API资源

##  1.  Kubernetes 为命名空间配置默认的内存请求和限制
为命名空间配置默认的内存请求和限制
-----------------

本章介绍如何为命名空间配置默认的内存请求和限制。

一个 Kubernetes 集群可被划分为多个命名空间。 如果你在具有默认内存限制 的命名空间内尝试创建一个 Pod，并且这个 Pod 中的容器没有声明自己的内存资源限制， 那么控制面会为该容器设定默认的内存限制。

Kubernetes 还为某些情况指定了默认的内存请求，本章后面会进行介绍。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](http://labs.play-with-k8s.com/)

在你的集群里你必须要有创建命名空间的权限。

你的集群中的每个节点必须至少有 2 GiB 的内存。

创建命名空间
------

创建一个命名空间，以便本练习中所建的资源与集群的其余资源相隔离。

`kubectl create namespace default-mem-example`

创建 LimitRange 和 Pod 
--------------------

以下为 LimitRange 的示例清单。 清单中声明了默认的内存请求和默认的内存限制。

`apiVersion: v1 kind: LimitRange metadata:   name: mem-limit-range spec:   limits:   - default:       memory: 512Mi     defaultRequest:       memory: 256Mi     type: Container`

在 default-mem-example 命名空间创建限制范围：

`kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults.yaml --namespace=default-mem-example`

现在如果你在 default-mem-example 命名空间中创建一个 Pod， 并且该 Pod 中所有容器都没有声明自己的内存请求和内存限制， 控制面 会将内存的默认请求值 256MiB 和默认限制值 512MiB 应用到 Pod 上。

以下为只包含一个容器的 Pod 的清单。该容器没有声明内存请求和限制。

`apiVersion: v1 kind: Pod metadata:   name: default-mem-demo spec:   containers:   - name: default-mem-demo-ctr     image: nginx`

创建 Pod

`kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod.yaml --namespace=default-mem-example`

查看 Pod 的详情：

`kubectl get pod default-mem-demo --output=yaml --namespace=default-mem-example`

输出内容显示该 Pod 的容器有 256 MiB 的内存请求和 512 MiB 的内存限制。 这些都是 LimitRange 设置的默认值。

`containers: - image: nginx   imagePullPolicy: Always   name: default-mem-demo-ctr   resources:     limits:       memory: 512Mi     requests:       memory: 256Mi`

删除你的 Pod：

`kubectl delete pod default-mem-demo --namespace=default-mem-example`

声明容器的限制而不声明它的请求会怎么样？ 
---------------------

以下为只包含一个容器的 Pod 的清单。该容器声明了内存限制，而没有声明内存请求。

`apiVersion: v1 kind: Pod metadata:   name: default-mem-demo-2 spec:   containers:   - name: default-mem-demo-2-ctr     image: nginx     resources:       limits:         memory: "1Gi"`

创建 Pod：

`kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod-2.yaml --namespace=default-mem-example`

查看 Pod 的详情：

`kubectl get pod default-mem-demo-2 --output=yaml --namespace=default-mem-example`

输出结果显示容器的内存请求被设置为它的内存限制相同的值。注意该容器没有被指定默认的内存请求值 256MiB。

`resources:   limits:     memory: 1Gi   requests:     memory: 1Gi`

声明容器的内存请求而不声明内存限制会怎么样？
----------------------

以下为只包含一个容器的 Pod 的清单。该容器声明了内存请求，但没有内存限制：

`apiVersion: v1 kind: Pod metadata:   name: default-mem-demo-3 spec:   containers:   - name: default-mem-demo-3-ctr     image: nginx     resources:       requests:         memory: "128Mi"`

创建 Pod：

`kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod-3.yaml --namespace=default-mem-example`

查看 Pod 声明：

`kubectl get pod default-mem-demo-3 --output=yaml --namespace=default-mem-example`

输出结果显示所创建的 Pod 中，容器的内存请求为 Pod 清单中声明的值。 然而同一容器的内存限制被设置为 512MiB，此值是该命名空间的默认内存限制值。

`resources:   limits:     memory: 512Mi   requests:     memory: 128Mi`

设置默认内存限制和请求的动机
--------------

如果你的命名空间设置了内存 资源配额， 那么为内存限制设置一个默认值会很有帮助。 以下是内存资源配额对命名空间的施加的三条限制：

*   命名空间中运行的每个 Pod 中的容器都必须有内存限制。 （如果为 Pod 中的每个容器声明了内存限制， Kubernetes 可以通过将其容器的内存限制相加推断出 Pod 级别的内存限制）。
*   内存限制用来在 Pod 被调度到的节点上执行资源预留。 预留给命名空间中所有 Pod 使用的内存总量不能超过规定的限制。
*   命名空间中所有 Pod 实际使用的内存总量也不能超过规定的限制。

当你添加 LimitRange 时：

如果该命名空间中的任何 Pod 的容器未指定内存限制， 控制面将默认内存限制应用于该容器， 这样 Pod 可以在受到内存 ResourceQuota 限制的命名空间中运行。

清理
--

删除你的命名空间：

`kubectl delete namespace default-mem-example`

##  2.  Kubernetes 为命名空间配置默认的CPU请求和限制
为命名空间配置默认的 CPU 请求和限制
--------------------

本章介绍如何为命名空间配置默认的 CPU 请求和限制。

一个 Kubernetes 集群可被划分为多个命名空间。 如果你在具有默认 CPU限制 的命名空间内创建一个 Pod，并且这个 Pod 中任何容器都没有声明自己的 CPU 限制， 那么控制面会为容器设定默认的 CPU 限制。

Kubernetes 在一些特定情况还可以设置默认的 CPU 请求，本文后续章节将会对其进行解释。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

在你的集群里你必须要有创建命名空间的权限。

创建命名空间
------

创建一个命名空间，以便本练习中创建的资源和集群的其余部分相隔离。

`kubectl create namespace default-cpu-example`

创建 LimitRange 和 Pod
-------------------

以下为 LimitRange 的示例清单。 清单中声明了默认 CPU 请求和默认 CPU 限制。

`apiVersion: v1 kind: LimitRange metadata:   name: cpu-limit-range spec:   limits:   - default:       cpu: 1     defaultRequest:       cpu: 0.5     type: Container`

在命名空间 default-cpu-example 中创建 LimitRange 对象：

`kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults.yaml --namespace=default-cpu-example`

现在如果你在 default-cpu-example 命名空间中创建一个 Pod， 并且该 Pod 中所有容器都没有声明自己的 CPU 请求和 CPU 限制， 控制面会将 CPU 的默认请求值 0.5 和默认限制值 1 应用到 Pod 上。

以下为只包含一个容器的 Pod 的清单。该容器没有声明 CPU 请求和限制。

`apiVersion: v1 kind: Pod metadata:   name: default-cpu-demo spec:   containers:   - name: default-cpu-demo-ctr     image: nginx`

创建 Pod。

`kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod.yaml --namespace=default-cpu-example`

查看该 Pod 的声明：

`kubectl get pod default-cpu-demo --output=yaml --namespace=default-cpu-example`

输出显示该 Pod 的唯一的容器有 500m ​`cpu` ​的 CPU 请求和 1 ​`cpu` ​的 CPU 限制。 这些是 LimitRange 声明的默认值。

`containers: - image: nginx   imagePullPolicy: Always   name: default-cpu-demo-ctr   resources:     limits:       cpu: "1"     requests:       cpu: 500m`

你只声明容器的限制，而不声明请求会怎么样？
---------------------

以下为只包含一个容器的 Pod 的清单。该容器声明了 CPU 限制，而没有声明 CPU 请求。

`apiVersion: v1 kind: Pod metadata:   name: default-cpu-demo-2 spec:   containers:   - name: default-cpu-demo-2-ctr     image: nginx     resources:       limits:         cpu: "1"`

创建 Pod

`kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod-2.yaml --namespace=default-cpu-example`

查看你所创建的 Pod 的规约：

`kubectl get pod default-cpu-demo-2 --output=yaml --namespace=default-cpu-example`

输出显示该容器的 CPU 请求和 CPU 限制设置相同。注意该容器没有被指定默认的 CPU 请求值 0.5 ​`cpu`​：

`resources:   limits:     cpu: "1"   requests:     cpu: "1"`

你只声明容器的请求，而不声明它的限制会怎么样？
-----------------------

这里给出了包含一个容器的 Pod 的示例清单。该容器声明了 CPU 请求，而没有声明 CPU 限制。

`apiVersion: v1 kind: Pod metadata:   name: default-cpu-demo-3 spec:   containers:   - name: default-cpu-demo-3-ctr     image: nginx     resources:       requests:         cpu: "0.75"`

创建 Pod：

`kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod-3.yaml --namespace=default-cpu-example`

查看所你创建的 Pod 的规约:

`kubectl get pod default-cpu-demo-3 --output=yaml --namespace=default-cpu-example`

输出显示你所创建的 Pod 中，容器的 CPU 请求为 Pod 清单中声明的值。 然而同一容器的 CPU 限制被设置为 1 ​`cpu`​，此值是该命名空间的默认 CPU 限制值。

`resources:   limits:     cpu: "1"   requests:     cpu: 750m`

默认 CPU 限制和请求的动机
---------------

如果你的命名空间设置了 CPU 资源配额， 为 CPU 限制设置一个默认值会很有帮助。 以下是 CPU 资源配额对命名空间的施加的两条限制：

*   命名空间中运行的每个 Pod 中的容器都必须有 CPU 限制。
*   CPU 限制用来在 Pod 被调度到的节点上执行资源预留。

预留给命名空间中所有 Pod 使用的 CPU 总量不能超过规定的限制。

当你添加 LimitRange 时：

如果该命名空间中的任何 Pod 的容器未指定 CPU 限制， 控制面将默认 CPU 限制应用于该容器， 这样 Pod 可以在受到 CPU ResourceQuota 限制的命名空间中运行。

清理
--

删除你的命名空间：

`kubectl delete namespace constraints-cpu-example`

##  3.  Kubernetes 配置命名空间的最小和最大内存约束
配置命名空间的最小和最大内存约束
----------------

本页介绍如何设置在命名空间中运行的容器使用的内存的最小值和最大值。 你可以在 [LimitRange](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/ target=) 对象中指定最小和最大内存值。如果 Pod 不满足 LimitRange 施加的约束，则无法在命名空间中创建它。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

在你的集群里你必须要有创建命名空间的权限。

集群中的每个节点都必须至少有 1 GiB 的内存可供 Pod 使用。

创建命名空间
------

创建一个命名空间，以便在此练习中创建的资源与集群的其余资源隔离。

`kubectl create namespace constraints-mem-example`

创建 LimitRange 和 Pod
-------------------

下面是 LimitRange 的示例清单：

`apiVersion: v1 kind: LimitRange metadata:   name: mem-min-max-demo-lr spec:   limits:   - max:       memory: 1Gi     min:       memory: 500Mi     type: Container`

创建 LimitRange:

`kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints.yaml --namespace=constraints-mem-example`

查看 LimitRange 的详情：

`kubectl get limitrange mem-min-max-demo-lr --namespace=constraints-mem-example --output=yaml`

输出显示预期的最小和最大内存约束。 但请注意，即使你没有在 LimitRange 的配置文件中指定默认值，也会自动创建它们。

  `limits:   - default:       memory: 1Gi     defaultRequest:       memory: 1Gi     max:       memory: 1Gi     min:       memory: 500Mi     type: Container`

现在，每当在 constraints-mem-example 命名空间中创建 Pod 时，Kubernetes 就会执行下面的步骤：

*   如果 Pod 中的任何容器未声明自己的内存请求和限制，控制面将为该容器设置默认的内存请求和限制。
*   确保该 Pod 中的每个容器的内存请求至少 500 MiB。
*   确保该 Pod 中每个容器内存请求不大于 1 GiB。

以下为包含一个容器的 Pod 清单。该容器声明了 600 MiB 的内存请求和 800 MiB 的内存限制， 这些满足了 LimitRange 施加的最小和最大内存约束。

`apiVersion: v1 kind: Pod metadata:   name: constraints-mem-demo spec:   containers:   - name: constraints-mem-demo-ctr     image: nginx     resources:       limits:         memory: "800Mi"       requests:         memory: "600Mi"`

创建 Pod：

`kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod.yaml --namespace=constraints-mem-example`

确认 Pod 正在运行，并且其容器处于健康状态：

`kubectl get pod constraints-mem-demo --namespace=constraints-mem-example`

查看 Pod 详情：

`kubectl get pod constraints-mem-demo --output=yaml --namespace=constraints-mem-example`

输出结果显示该 Pod 的容器的内存请求为 600 MiB，内存限制为 800 MiB。 这些满足这个命名空间中 LimitRange 设定的限制范围。

`resources:   limits:      memory: 800Mi   requests:     memory: 600Mi`

删除你创建的 Pod：

`kubectl delete pod constraints-mem-demo --namespace=constraints-mem-example`

尝试创建一个超过最大内存限制的 Pod
-------------------

以下为包含一个容器的 Pod 的清单。这个容器声明了 800 MiB 的内存请求和 1.5 GiB 的内存限制。

`apiVersion: v1 kind: Pod metadata:   name: constraints-mem-demo-2 spec:   containers:   - name: constraints-mem-demo-2-ctr     image: nginx     resources:       limits:         memory: "1.5Gi"       requests:         memory: "800Mi"`

尝试创建 Pod:

`kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-2.yaml --namespace=constraints-mem-example`

输出结果显示 Pod 没有创建成功，因为它定义了一个容器的内存请求超过了允许的值。

`Error from server (Forbidden): error when creating "examples/admin/resource/memory-constraints-pod-2.yaml": pods "constraints-mem-demo-2" is forbidden: maximum memory usage per Container is 1Gi, but limit is 1536Mi.`

尝试创建一个不满足最小内存请求的 Pod
--------------------

以下为只有一个容器的 Pod 的清单。这个容器声明了 100 MiB 的内存请求和 800 MiB 的内存限制。

`apiVersion: v1 kind: Pod metadata:   name: constraints-mem-demo-3 spec:   containers:   - name: constraints-mem-demo-3-ctr     image: nginx     resources:       limits:         memory: "800Mi"       requests:         memory: "100Mi"`

尝试创建 Pod：

`kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-3.yaml --namespace=constraints-mem-example`

输出结果显示 Pod 没有创建成功，因为它定义了一个容器的内存请求小于强制要求的最小值：

`Error from server (Forbidden): error when creating "examples/admin/resource/memory-constraints-pod-3.yaml": pods "constraints-mem-demo-3" is forbidden: minimum memory usage per Container is 500Mi, but request is 100Mi.`

创建一个没有声明内存请求和限制的 Pod
--------------------

以下为只有一个容器的 Pod 清单。该容器没有声明内存请求，也没有声明内存限制。

`apiVersion: v1 kind: Pod metadata:   name: constraints-mem-demo-4 spec:   containers:   - name: constraints-mem-demo-4-ctr     image: nginx`

创建 Pod：

`kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-4.yaml --namespace=constraints-mem-example`

查看 Pod 详情：

`kubectl get pod constraints-mem-demo-4 --namespace=constraints-mem-example --output=yaml`

输出结果显示 Pod 的唯一容器内存请求为 1 GiB，内存限制为 1 GiB。容器怎样获得那些数值呢？

`resources:   limits:     memory: 1Gi   requests:     memory: 1Gi`

因为你的 Pod 没有为容器声明任何内存请求和限制，集群会从 LimitRange 获取默认的内存请求和限制。 应用于容器。

这意味着 Pod 的定义会显示这些值。你可以通过 ​`kubectl describe`​ 查看：

`# 查看输出结果中的 "Requests:" 的值 kubectl describe pod constraints-mem-demo-4 --namespace=constraints-mem-example`

此时，你的 Pod 可能已经运行起来也可能没有运行起来。 回想一下我们本次任务的先决条件是你的每个节点都至少有 1 GiB 的内存。 如果你的每个节点都只有 1 GiB 的内存，那将没有一个节点拥有足够的可分配内存来满足 1 GiB 的内存请求。

删除你的 Pod：

`kubectl delete pod constraints-mem-demo-4 --namespace=constraints-mem-example`

强制执行内存最小和最大限制
-------------

LimitRange 为命名空间设定的最小和最大内存限制只有在 Pod 创建和更新时才会强制执行。 如果你更新 LimitRange，它不会影响此前创建的 Pod。

设置内存最小和最大限制的动因
--------------

作为集群管理员，你可能想规定 Pod 可以使用的内存总量限制。例如：

*   集群的每个节点有 2 GiB 内存。你不想接受任何请求超过 2 GiB 的 Pod，因为集群中没有节点可以满足。
*   集群由生产部门和开发部门共享。你希望允许产品部门的负载最多耗用 8 GiB 内存， 但是开发部门的负载最多可使用 512 MiB。 这时，你可以为产品部门和开发部门分别创建名字空间，并为各个名字空间设置内存约束。

清理
--

删除你的命名空间：

`kubectl delete namespace constraints-mem-example`

##  4.  Kubernetes 为命名空间配置CPU最小和最大约束
为命名空间配置 CPU 最小和最大约束
-------------------

本页介绍如何为命名空间中的容器和 Pod 设置其所使用的 CPU 资源的最小和最大值。 你可以通过 LimitRange 对象声明 CPU 的最小和最大值. 如果 Pod 不能满足 LimitRange 的限制，就无法在该命名空间中被创建。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

在你的集群里你必须要有创建命名空间的权限。

集群中的每个节点都必须至少有 1.0 个 CPU 可供 Pod 使用。

创建命名空间
------

创建一个命名空间，以便本练习中创建的资源和集群的其余资源相隔离。

`kubectl create namespace constraints-cpu-example`

创建 LimitRange 和 Pod
-------------------

以下为 LimitRange 的示例清单：

`apiVersion: v1 kind: LimitRange metadata:   name: cpu-min-max-demo-lr spec:   limits:   - max:       cpu: "800m"     min:       cpu: "200m"     type: Container`

创建 LimitRange:

`kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints.yaml --namespace=constraints-cpu-example`

查看 LimitRange 详情：

`kubectl get limitrange cpu-min-max-demo-lr --output=yaml --namespace=constraints-cpu-example`

输出结果显示 CPU 的最小和最大限制符合预期。但需要注意的是，尽管你在 LimitRange 的配置文件中你没有声明默认值，默认值也会被自动创建。

`limits: - default:     cpu: 800m   defaultRequest:     cpu: 800m   max:     cpu: 800m   min:     cpu: 200m   type: Container`

现在，每当你在 constraints-mem-example 命名空间中创建 Pod 时，或者某些其他的 Kubernetes API 客户端创建了等价的 Pod 时，Kubernetes 就会执行下面的步骤：

*   如果 Pod 中的任何容器未声明自己的 CPU 请求和限制，控制面将为该容器设置默认的 CPU 请求和限制。
*   确保该 Pod 中的每个容器的 CPU 请求至少 200 millicpu。
*   确保该 Pod 中每个容器 CPU 请求不大于 800 millicpu。

> Note: 当创建 LimitRange 对象时，你也可以声明大页面和 GPU 的限制。 当这些资源同时声明了 'default' 和 'defaultRequest' 参数时，两个参数值必须相同。

以下为某个仅包含一个容器的 Pod 的清单。 该容器声明了 CPU 请求 500 millicpu 和 CPU 限制 800 millicpu 。 这些参数满足了 LimitRange 对象规定的 CPU 最小和最大限制。

`apiVersion: v1 kind: Pod metadata:   name: constraints-cpu-demo spec:   containers:   - name: constraints-cpu-demo-ctr     image: nginx     resources:       limits:         cpu: "800m"       requests:         cpu: "500m"`

创建 Pod：

`kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod.yaml --namespace=constraints-cpu-example`

确认 Pod 正在运行，并且其容器处于健康状态：

`kubectl get pod constraints-cpu-demo --namespace=constraints-cpu-example`

查看 Pod 的详情：

`kubectl get pod constraints-cpu-demo --output=yaml --namespace=constraints-cpu-example`

输出结果显示该 Pod 的容器的 CPU 请求为 500 millicpu，CPU 限制为 800 millicpu。 这些参数满足 LimitRange 规定的限制范围。

`resources:   limits:     cpu: 800m   requests:     cpu: 500m`

删除 Pod
------

`kubectl delete pod constraints-cpu-demo --namespace=constraints-cpu-example`

尝试创建一个超过最大 CPU 限制的 Pod
----------------------

这里给出了包含一个容器的 Pod 的配置文件。容器声明了 500 millicpu 的 CPU 请求和 1.5 CPU 的 CPU 限制。

`apiVersion: v1 kind: Pod metadata:   name: constraints-cpu-demo-2 spec:   containers:   - name: constraints-cpu-demo-2-ctr     image: nginx     resources:       limits:         cpu: "1.5"       requests:         cpu: "500m"`

尝试创建 Pod：

`kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-2.yaml --namespace=constraints-cpu-example`

输出结果表明 Pod 没有创建成功，因为其中定义了一个无法被接受的容器。 该容器之所以无法被接受是因为其中设定了过高的 CPU 限制值：

`Error from server (Forbidden): error when creating "examples/admin/resource/cpu-constraints-pod-2.yaml": pods "constraints-cpu-demo-2" is forbidden: maximum cpu usage per Container is 800m, but limit is 1500m.`

尝试创建一个不满足最小 CPU 请求的 Pod
-----------------------

以下为某个只有一个容器的 Pod 的清单。该容器声明了 CPU 请求 100 millicpu 和 CPU 限制 800 millicpu。

`apiVersion: v1 kind: Pod metadata:   name: constraints-cpu-demo-3 spec:   containers:   - name: constraints-cpu-demo-3-ctr     image: nginx     resources:       limits:         cpu: "800m"       requests:         cpu: "100m"`

尝试创建 Pod：

`kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-3.yaml --namespace=constraints-cpu-example`

输出结果显示 Pod 没有创建成功，因为其中定义了一个无法被接受的容器。 该容器无法被接受的原因是其中所设置的 CPU 请求小于最小值的限制：

`Error from server (Forbidden): error when creating "examples/admin/resource/cpu-constraints-pod-3.yaml": pods "constraints-cpu-demo-4" is forbidden: minimum cpu usage per Container is 200m, but request is 100m.`

创建一个没有声明 CPU 请求和 CPU 限制的 Pod
----------------------------

以下为一个只有一个容器的 Pod 的清单。该容器没有声明 CPU 请求，也没有声明 CPU 限制。

`apiVersion: v1 kind: Pod metadata:   name: constraints-cpu-demo-4 spec:   containers:   - name: constraints-cpu-demo-4-ctr     image: vish/stress`

创建 Pod：

`kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-4.yaml --namespace=constraints-cpu-example`

查看 Pod 的详情：

`kubectl get pod constraints-cpu-demo-4 --namespace=constraints-cpu-example --output=yaml`

输出结果显示 Pod 的唯一容器的 CPU 请求为 800 millicpu，CPU 限制为 800 millicpu。

容器是怎样获得这些数值的呢？

`resources:   limits:     cpu: 800m   requests:     cpu: 800m`

因为这一容器没有声明自己的 CPU 请求和限制， 控制面会根据命名空间中配置 LimitRange 设置默认的 CPU 请求和限制。

此时，你的 Pod 可能已经运行起来也可能没有运行起来。 回想一下我们本次任务的先决条件是你的每个节点都至少有 1 CPU。 如果你的每个节点都只有 1 CPU，那将没有一个节点拥有足够的可分配 CPU 来满足 800 millicpu 的请求。 如果你在用的节点恰好有 2 CPU，那么有可能有足够的 CPU 来满足 800 millicpu 的请求。

`kubectl delete pod constraints-cpu-demo-4 --namespace=constraints-cpu-example`

CPU 最小和最大限制的强制执行 
-----------------

只有当 Pod 创建或者更新时，LimitRange 为命名空间规定的 CPU 最小和最大限制才会被强制执行。 如果你对 LimitRange 进行修改，那不会影响此前创建的 Pod。

最小和最大 CPU 限制范围的动机
-----------------

作为集群管理员，你可能想设定 Pod 可以使用的 CPU 资源限制。例如：

*   集群中的每个节点有两个 CPU。你不想接受任何请求超过 2 个 CPU 的 Pod，因为集群中没有节点可以支持这种请求。
*   你的生产和开发部门共享一个集群。你想允许生产工作负载消耗 3 个 CPU， 而开发部门工作负载的消耗限制为 1 个 CPU。 你可以为生产和开发创建不同的命名空间，并且为每个命名空间都应用 CPU 限制。

清理
--

删除你的命名空间：

`kubectl delete namespace constraints-cpu-example`

##  5.  Kubernetes 为命名空间配置内存和CPU配额
为命名空间配置内存和 CPU 配额
-----------------

本文介绍如何为命名空间下运行的所有 Pod 设置总的内存和 CPU 配额。 你可以通过使用 ​`ResourceQuota` ​对象设置配额.

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

在你的集群里你必须要有创建命名空间的权限。

集群中每个节点至少有 1 GiB 的内存。

创建命名空间
------

创建一个命名空间，以便本练习中创建的资源和集群的其余部分相隔离。

`kubectl create namespace quota-mem-cpu-example`

创建 ResourceQuota
----------------

下面是 ResourceQuota 的示例清单：

`apiVersion: v1 kind: ResourceQuota metadata:   name: mem-cpu-demo spec:   hard:     requests.cpu: "1"     requests.memory: 1Gi     limits.cpu: "2"     limits.memory: 2Gi`

创建 ResourceQuota

`kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu.yaml --namespace=quota-mem-cpu-example`

查看 ResourceQuota 详情：

`kubectl get resourcequota mem-cpu-demo --namespace=quota-mem-cpu-example --output=yaml`

ResourceQuota 在 quota-mem-cpu-example 命名空间中设置了如下要求：

*   在该命名空间中的每个 Pod 的所有容器都必须要有内存请求和限制，以及 CPU 请求和限制。
*   在该命名空间中所有 Pod 的内存请求总和不能超过 1 GiB。
*   在该命名空间中所有 Pod 的内存限制总和不能超过 2 GiB。
*   在该命名空间中所有 Pod 的 CPU 请求总和不能超过 1 cpu。
*   在该命名空间中所有 Pod 的 CPU 限制总和不能超过 2 cpu。

创建 Pod
------

以下是 Pod 的示例清单：

`apiVersion: v1 kind: Pod metadata:   name: quota-mem-cpu-demo spec:   containers:   - name: quota-mem-cpu-demo-ctr     image: nginx     resources:       limits:         memory: "800Mi"         cpu: "800m"       requests:         memory: "600Mi"         cpu: "400m"`

创建 Pod：

`kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu-pod.yaml --namespace=quota-mem-cpu-example`

确认 Pod 正在运行，并且其容器处于健康状态：

`kubectl get pod quota-mem-cpu-demo --namespace=quota-mem-cpu-example`

再查看 ResourceQuota 的详情：

`kubectl get resourcequota mem-cpu-demo --namespace=quota-mem-cpu-example --output=yaml`

输出结果显示了配额以及有多少配额已经被使用。你可以看到 Pod 的内存和 CPU 请求值及限制值没有超过配额。

`status:   hard:     limits.cpu: "2"     limits.memory: 2Gi     requests.cpu: "1"     requests.memory: 1Gi   used:     limits.cpu: 800m     limits.memory: 800Mi     requests.cpu: 400m     requests.memory: 600Mi`

如果有 ​`jq`​ 工具的话，你可以通过（使用 ​`JSONPath`​） 直接查询 ​`used` ​字段的值，并且输出整齐的 JSON 格式。

`kubectl get resourcequota mem-cpu-demo --namespace=quota-mem-cpu-example -o jsonpath='{ .status.used }' | jq .`

尝试创建第二个 Pod
-----------

以下为第二个 Pod 的清单：

`apiVersion: v1 kind: Pod metadata:   name: quota-mem-cpu-demo-2 spec:   containers:   - name: quota-mem-cpu-demo-2-ctr     image: redis     resources:       limits:         memory: "1Gi"         cpu: "800m"       requests:         memory: "700Mi"         cpu: "400m"`

在清单中，你可以看到 Pod 的内存请求为 700 MiB。 请注意新的内存请求与已经使用的内存请求之和超过了内存请求的配额： 600 MiB + 700 MiB > 1 GiB。

尝试创建 Pod：

`kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu-pod-2.yaml --namespace=quota-mem-cpu-example`

第二个 Pod 不能被创建成功。输出结果显示创建第二个 Pod 会导致内存请求总量超过内存请求配额。

`Error from server (Forbidden): error when creating "examples/admin/resource/quota-mem-cpu-pod-2.yaml": pods "quota-mem-cpu-demo-2" is forbidden: exceeded quota: mem-cpu-demo, requested: requests.memory=700Mi,used: requests.memory=600Mi, limited: requests.memory=1Gi`

讨论
--

如你在本练习中所见，你可以用 ResourceQuota 限制命名空间中所有 Pod 的内存请求总量。 同样你也可以限制内存限制总量、CPU 请求总量、CPU 限制总量。

除了可以管理命名空间资源使用的总和，如果你想限制单个 Pod，或者限制这些 Pod 中的容器资源， 可以使用 LimitRange 实现这类的功能。

清理
--

删除你的命名空间：

`kubectl delete namespace quota-mem-cpu-example`

##  6.  Kubernetes 配置命名空间下Pod配额
配置命名空间下 Pod 配额
--------------

本文主要介绍如何在命名空间中设置可运行 Pod 总数的配额。 你可以通过使用 ResourceQuota 对象来配置配额。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

在你的集群里你必须要有创建命名空间的权限。

创建一个命名空间
--------

首先创建一个命名空间，这样可以将本次操作中创建的资源与集群其他资源隔离开来。

`kubectl create namespace quota-pod-example`

创建 ResourceQuota
----------------

下面是 ResourceQuota 的示例清单：

`apiVersion: v1 kind: ResourceQuota metadata:   name: pod-demo spec:   hard:     pods: "2"`

创建这个 ResourceQuota：

`kubectl apply -f https://k8s.io/examples/admin/resource/quota-pod.yaml --namespace=quota-pod-example`

查看资源配额的详细信息：

`kubectl get resourcequota pod-demo --namespace=quota-pod-example --output=yaml`

从输出的信息我们可以看到，该命名空间下 Pod 的配额是 2 个，目前创建的 Pod 数为 0， 配额使用率为 0。

`spec:   hard:     pods: "2" status:   hard:     pods: "2"   used:     pods: "0"`

下面是一个 Deployment 的示例清单：

`apiVersion: apps/v1 kind: Deployment metadata:   name: pod-quota-demo spec:   selector:     matchLabels:       purpose: quota-demo   replicas: 3   template:     metadata:       labels:         purpose: quota-demo     spec:       containers:       - name: pod-quota-demo         image: nginx`

在清单中，​`replicas: 3`​ 告诉 Kubernetes 尝试创建三个 Pods， 且运行相同的应用。

创建这个 Deployment：

`kubectl apply -f https://k8s.io/examples/admin/resource/quota-pod-deployment.yaml --namespace=quota-pod-example`

查看 Deployment 的详细信息：

`kubectl get deployment pod-quota-demo --namespace=quota-pod-example --output=yaml`

从输出的信息我们可以看到，尽管尝试创建三个 Pod，但是由于配额的限制，只有两个 Pod 能被成功创建。

`spec:   ...   replicas: 3 ... status:   availableReplicas: 2 ... lastUpdateTime: 2021-04-02T20:57:05Z     message: 'unable to create pods: pods "pod-quota-demo-1650323038-" is forbidden:       exceeded quota: pod-demo, requested: pods=1, used: pods=2, limited: pods=2'`

### 资源的选择

在此任务中，你定义了一个限制 Pod 总数的 ResourceQuota， 你也可以限制其他类型对象的总数。例如， 你可以限制在一个命名空间中可以创建的 CronJobs 的数量。

清理
--

删除命名空间：

`kubectl delete namespace quota-pod-example`

#  23报警，。l.  Kubernetes 安装网络策略驱动

###  1.  Kubernetes 使用Antrea提供NetworkPolicy
使用 Antrea 提供 NetworkPolicy
--------------------------

本页展示了如何在 kubernetes 中安装和使用 Antrea CNI 插件。 要了解 Antrea 项目的背景，请阅读 [Antrea 介绍](https://antrea.io/docs/)。

在开始之前
-----

你需要拥有一个 kuernetes 集群。

使用 kubeadm 部署 Antrea
--------------------

遵循[入门](https://github.com/antrea-io/antrea/blob/main/docs/getting-started.md)指南 为 kubeadm 部署 Antrea 。

###  2.  Kubernetes 使用Calico提供NetworkPolicy
使用 Calico 提供 NetworkPolicy
--------------------------

本页展示了几种在 Kubernetes 上快速创建 Calico 集群的方法。

在开始之前
-----

确定你想部署一个云版本还是本地版本的集群。

在 Google Kubernetes Engine (GKE) 上创建一个 Calico 集群
------------------------------------------------

先决条件: [gcloud](https://cloud.google.com/sdk/docs/install-sdk)

1.  启动一个带有 Calico 的 GKE 集群，需要加上参数 ​`--enable-network-policy`​。

语法

`gcloud container clusters create [CLUSTER_NAME] --enable-network-policy`

示例

`gcloud container clusters create my-calico-cluster --enable-network-policy`

6.  使用如下命令验证部署是否正确。

`kubectl get pods --namespace=kube-system`

Calico 的 pods 名以 ​`calico` ​打头，检查确认每个 pods 状态为 ​`Running`​。

使用 kubeadm 创建一个本地 Calico 集群 
----------------------------

使用 kubeadm 在 15 分钟内得到一个本地单主机 Calico 集群，请参考 [Calico 快速入门](https://projectcalico.docs.tigera.io/getting-started/kubernetes/)。

###  3.  Kubernetes 使用Cilium提供NetworkPolicy
使用 Cilium 提供 NetworkPolicy
--------------------------

本页展示如何使用 Cilium 提供 NetworkPolicy。

关于 Cilium 的背景知识，请阅读 [Cilium 介绍](https://docs.cilium.io/en/stable/intro/)。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](http://labs.play-with-k8s.com/)

要检查版本，请输入 ​`kubectl version`​。

在 Minikube 上部署 Cilium 用于基本测试
----------------------------

为了轻松熟悉 Cilium 你可以根据 [Cilium Kubernetes 入门指南](https://docs.cilium.io/en/stable/gettingstarted/k8s-install-kubeadm/ target=) 在 minikube 中执行一个 cilium 的基本 DaemonSet 安装。

要启动 minikube，需要的最低版本为 1.5.2，使用下面的参数运行：

`minikube version`

`minikube version: v1.5.2`

`minikube start --network-plugin=cni --memory=4096`

对于 minikube 你可以使用 Cilium 的 CLI 工具安装它。 Cilium 将自动检测集群配置并为成功的集群部署选择合适的组件。

`curl -LO https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz sudo tar xzvfC cilium-linux-amd64.tar.gz /usr/local/bin rm cilium-linux-amd64.tar.gz cilium install`

`🔮 Auto-detected Kubernetes kind: minikube ✨ Running "minikube" validation checks ✅ Detected minikube version "1.20.0" ℹ️  Cilium version not set, using default version "v1.10.0" 🔮 Auto-detected cluster name: minikube 🔮 Auto-detected IPAM mode: cluster-pool 🔮 Auto-detected datapath mode: tunnel 🔑 Generating CA... 2021/05/27 02:54:44 [INFO] generate received request 2021/05/27 02:54:44 [INFO] received CSR 2021/05/27 02:54:44 [INFO] generating key: ecdsa-256 2021/05/27 02:54:44 [INFO] encoded CSR 2021/05/27 02:54:44 [INFO] signed certificate with serial number 48713764918856674401136471229482703021230538642 🔑 Generating certificates for Hubble... 2021/05/27 02:54:44 [INFO] generate received request 2021/05/27 02:54:44 [INFO] received CSR 2021/05/27 02:54:44 [INFO] generating key: ecdsa-256 2021/05/27 02:54:44 [INFO] encoded CSR 2021/05/27 02:54:44 [INFO] signed certificate with serial number 3514109734025784310086389188421560613333279574 🚀 Creating Service accounts... 🚀 Creating Cluster roles... 🚀 Creating ConfigMap... 🚀 Creating Agent DaemonSet... 🚀 Creating Operator Deployment... ⌛ Waiting for Cilium to be installed...`

入门指南其余的部分用一个示例应用说明了如何强制执行 L3/L4（即 IP 地址+端口）的安全策略 以及L7 （如 HTTP）的安全策略。

部署 Cilium 用于生产用途
----------------

关于部署 Cilium 用于生产的详细说明，请见 [Cilium Kubernetes 安装指南](https://docs.cilium.io/en/stable/concepts/kubernetes/intro/) 此文档包括详细的需求、说明和生产用途 DaemonSet 文件示例。

了解 Cilium 组件
------------

部署使用 Cilium 的集群会添加 Pods 到 ​`kube-system`​ 命名空间。要查看 Pod 列表，运行：

`kubectl get pods --namespace=kube-system -l k8s-app=cilium`

你将看到像这样的 Pods 列表：

`NAME           READY   STATUS    RESTARTS   AGE cilium-kkdhz   1/1     Running   0          3m23s ...`

你的集群中的每个节点上都会运行一个 ​`cilium` ​Pod，通过使用 Linux BPF 针对该节点上的 Pod 的入站、出站流量实施网络策略控制。

###  4.  Kubernetes 使用kube-router提供NetworkPolicy
使用 kube-router 提供 NetworkPolicy
-------------------------------

本页展示如何使用 [Kube-router](https://github.com/cloudnativelabs/kube-router) 提供 NetworkPolicy。

在开始之前
-----

你需要拥有一个运行中的 Kubernetes 集群。如果你还没有集群，可以使用任意的集群 安装程序如 Kops、Bootkube、Kubeadm 等创建一个。

安装 kube-router 插件
-----------------

kube-router 插件自带一个网络策略控制器，监视来自于 Kubernetes API 服务器的 NetworkPolicy 和 Pod 的变化，根据策略指示配置 iptables 规则和 ipsets 来允许或阻止流量。 请根据 [通过集群安装程序尝试 kube-router](https://www.kube-router.io/docs/user-guide/ target=) 指南安装 kube-router 插件。

###  5.  Kubernetes 使用Romana提供NetworkPolicy
使用 Romana 提供 NetworkPolicy
--------------------------

本页展示如何使用 Romana 作为 NetworkPolicy。

使用 kubeadm 安装 Romana
--------------------

按照[容器化安装指南](https://github.com/romana/romana/tree/master/containerize)， 使用 kubeadm 安装。

应用网络策略
------

使用以下的一种方式应用网络策略：

*   [Romana 网络策略](https://github.com/romana/romana/wiki/Romana-policies)

*   [Romana 网络策略例子](https://github.com/romana/core/blob/master/doc/policy.md)

*   NetworkPolicy API

###  6.  Kubernetes 使用Weave Net提供NetworkPolicy
使用 Weave Net 提供 NetworkPolicy
-----------------------------

本页展示如何使用使用 Weave Net 提供 NetworkPolicy。

安装 Weave Net 插件
---------------

按照[通过插件集成 Kubernetes](https://www.weave.works/docs/net/latest/kubernetes/kube-addon/) 指南执行安装。

Kubernetes 的 Weave Net 插件带有 [网络策略控制器](https://www.weave.works/docs/net/latest/kubernetes/kube-addon/ target=)， 可自动监控 Kubernetes 所有名字空间的 NetworkPolicy 注释， 配置 ​`iptables` ​规则以允许或阻止策略指示的流量。

测试安装
----

验证 weave 是否有效。

输入以下命令：

`kubectl get po -n kube-system -o wide`

输出类似这样：

`NAME                                    READY     STATUS    RESTARTS   AGE       IP              NODE weave-net-1t1qg                         2/2       Running   0          9d        192.168.2.10    worknode3 weave-net-231d7                         2/2       Running   1          7d        10.2.0.17       worknodegpu weave-net-7nmwt                         2/2       Running   3          9d        192.168.2.131   masternode weave-net-pmw8w                         2/2       Running   0          9d        192.168.2.216   worknode2`

每个 Node 都有一个 weave Pod，所有 Pod 都是​`Running` ​和 ​`2/2 READY`​。 （​`2/2`​ 表示每个 Pod 都有 ​`weave` ​和 ​`weave-npc`​）

##  24.  Kubernetes IP Masquerade Agent用户指南
IP Masquerade Agent 用户指南
------------------------

此页面展示如何配置和启用 ​`ip-masq-agent`​。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

要检查版本，请输入 ​`kubectl version`​。

IP Masquerade Agent 用户指南
------------------------

​`ip-masq-agent`​ 配置 iptables 规则以隐藏位于集群节点 IP 地址后面的 Pod 的 IP 地址。 这通常在将流量发送到集群的 Pod [CIDR](https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1) 范围之外的目的地时使用。

### 关键术语

*   NAT (网络地址转译) 是一种通过修改 IP 地址头中的源和/或目标地址信息将一个 IP 地址重新映射 到另一个 IP 地址的方法。通常由执行 IP 路由的设备执行。
*   伪装 NAT 的一种形式，通常用于执行多对一地址转换，其中多个源 IP 地址被隐藏在 单个地址后面，该地址通常是执行 IP 路由的设备。在 Kubernetes 中， 这是节点的 IP 地址。
*   CIDR (无类别域间路由) 基于可变长度子网掩码，允许指定任意长度的前缀。 CIDR 引入了一种新的 IP 地址表示方法，现在通常称为CIDR表示法， 其中地址或路由前缀后添加一个后缀，用来表示前缀的位数，例如 192.168.2.0/24。
*   本地链路 本地链路是仅对网段或主机所连接的广播域内的通信有效的网络地址。 IPv4 的本地链路地址在 CIDR 表示法的地址块 169.254.0.0/16 中定义。

ip-masq-agent 配置 iptables 规则，以便在将流量发送到集群节点的 IP 和集群 IP 范围之外的目标时 处理伪装节点或 Pod 的 IP 地址。这本质上隐藏了集群节点 IP 地址后面的 Pod IP 地址。 在某些环境中，去往“外部”地址的流量必须从已知的机器地址发出。 例如，在 Google Cloud 中，任何到互联网的流量都必须来自 VM 的 IP。 使用容器时，如 Google Kubernetes Engine，从 Pod IP 发出的流量将被拒绝出站。 为了避免这种情况，我们必须将 Pod IP 隐藏在 VM 自己的 IP 地址后面 - 通常称为“伪装”。 默认情况下，代理配置为将 [RFC 1918](https://tools.ietf.org/html/rfc1918) 指定的三个私有 IP 范围视为非伪装 [CIDR](https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1)。 这些范围是 10.0.0.0/8,172.16.0.0/12 和 192.168.0.0/16。 默认情况下，代理还将链路本地地址（169.254.0.0/16）视为非伪装 CIDR。 代理程序配置为每隔 60 秒从 _/etc/config/ip-masq-agent_ 重新加载其配置， 这也是可修改的。  

![](https://atts.w3cschool.cn/attachments/image/20220606/1654482810435236.png)  

代理配置文件必须使用 YAML 或 JSON 语法编写，并且可能包含三个可选值：

*   ​`nonMasqueradeCIDRs`​： [CIDR](https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1) 表示法中的字符串列表，用于指定不需伪装的地址范围。
*   ​`masqLinkLocal`​：布尔值 (true/false)，表示是否为本地链路前缀 169.254.0.0/16 的流量提供伪装。 默认为 false。
*   ​`resyncInterval`​：代理从磁盘重新加载配置的重试时间间隔。 例如 '30s'，其中 's' 是秒，'ms' 是毫秒。

10.0.0.0/8、172.16.0.0/12 和 192.168.0.0/16 范围内的流量不会被伪装。 任何其他流量（假设是互联网）将被伪装。 Pod 访问本地目的地的例子，可以是其节点的 IP 地址、另一节点的地址或集群的 IP 地址范围内的一个 IP 地址。 默认情况下，任何其他流量都将伪装。以下条目展示了 ip-masq-agent 的默认使用的规则：

`iptables -t nat -L IP-MASQ-AGENT`

`RETURN     all  --  anywhere             169.254.0.0/16       /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL RETURN     all  --  anywhere             10.0.0.0/8           /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL RETURN     all  --  anywhere             172.16.0.0/12        /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL RETURN     all  --  anywhere             192.168.0.0/16       /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL MASQUERADE  all  --  anywhere             anywhere             /* ip-masq-agent: outbound traffic should be subject to MASQUERADE (this match must come after cluster-local CIDR matches) */ ADDRTYPE match dst-type !LOCAL`

默认情况下，在 GCE/Google Kubernetes Engine 中，如果启用了网络策略， 或者你使用的集群 CIDR 不在 10.0.0.0/8 范围内， 则 ​`ip-masq-agent`​ 将在你的集群中运行。 如果你在其他环境中运行，可以将 ​`ip-masq-agent`​ DaemonSet 添加到你的集群中。

创建 ip-masq-agent
----------------

通过运行以下 kubectl 指令创建 ip-masq-agent:

`kubectl apply -f https://raw.githubusercontent.com/kubernetes-sigs/ip-masq-agent/master/ip-masq-agent.yaml`

你必须同时将适当的节点标签应用于集群中希望代理运行的任何节点。

`kubectl label nodes my-node beta.kubernetes.io/masq-agent-ds-ready=true`

更多信息可以通过 ip-masq-agent 文档 [这里](https://github.com/kubernetes-sigs/ip-masq-agent) 找到。

在大多数情况下，默认的规则集应该足够；但是，如果你的集群不是这种情况，则可以创建并应用 ConfigMap 来自定义受影响的 IP 范围。 例如，要允许 ip-masq-agent 仅作用于 10.0.0.0/8，你可以在一个名为 “config” 的文件中创建以下 ConfigMap 。

> Note:  
> 重要的是，该文件之所以被称为 config，因为默认情况下，该文件将被用作 ​`ip-masq-agent`​ 查找的主键：
> 
> `nonMasqueradeCIDRs:   - 10.0.0.0/8 resyncInterval: 60s`

运行以下命令将 ConfigMap 添加到你的集群：

`kubectl create configmap ip-masq-agent --from-file=config --namespace=kube-system`

这将更新位于 ​`/etc/config/ip-masq-agent`​ 的一个文件，该文件以 ​`resyncInterval` ​为周期定期检查并应用于集群节点。 重新同步间隔到期后，你应该看到你的更改在 iptables 规则中体现：

`iptables -t nat -L IP-MASQ-AGENT`

`Chain IP-MASQ-AGENT (1 references) target     prot opt source               destination RETURN     all  --  anywhere             169.254.0.0/16       /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL RETURN     all  --  anywhere             10.0.0.0/8           /* ip-masq-agent: cluster-local MASQUERADE  all  --  anywhere             anywhere             /* ip-masq-agent: outbound traffic should be subject to MASQUERADE (this match must come after cluster-local CIDR matches) */ ADDRTYPE match dst-type !LOCAL`

默认情况下，本地链路范围 (169.254.0.0/16) 也由 ip-masq agent 处理， 该代理设置适当的 iptables 规则。 要使 ip-masq-agent 忽略本地链路， 可以在 ConfigMap 中将 ​`masqLinkLocal` ​设置为 true。

`nonMasqueradeCIDRs:   - 10.0.0.0/8 resyncInterval: 60s masqLinkLocal: true`

##  25.  Kubernetes 云管理控制器
Kubernetes 云管理控制器
-----------------

FEATURE STATE: Kubernetes v1.11 \[beta\]

由于云驱动的开发和发布的步调与 Kubernetes 项目不同，将服务提供商专用代码抽象到 ​`cloud-controller-manager`​ 二进制中有助于云服务厂商在 Kubernetes 核心代码之外独立进行开发。

​`cloud-controller-manager`​ 可以被链接到任何满足 [cloudprovider.Interface](https://github.com/kubernetes/cloud-provider/blob/master/cloud.go) 约束的云服务提供商。为了兼容旧版本，Kubernetes 核心项目中提供的 [cloud-controller-manager](https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager) 使用和 ​`kube-controller-manager`​ 相同的云服务类库。 已经在 Kubernetes 核心项目中支持的云服务提供商预计将通过使用 in-tree 的 cloud-controller-manager 过渡为非 Kubernetes 核心代码。

管理
--

### 需求

每个云服务都有一套各自的需求用于系统平台的集成，这不应与运行 ​`kube-controller-manager`​ 的需求有太大差异。作为经验法则，你需要：

*   云服务认证/授权：你的云服务可能需要使用令牌或者 IAM 规则以允许对其 API 的访问
*   kubernetes 认证/授权：cloud-controller-manager 可能需要 RBAC 规则以访问 kubernetes apiserver
*   高可用：类似于 kube-controller-manager，你可能希望通过主节点选举（默认开启）配置一个高可用的云管理控制器。

### 运行云管理控制器

你需要对集群配置做适当的修改以成功地运行云管理控制器：

*   一定不要为 ​`kube-apiserver`​ 和 ​`kube-controller-manager`​ 指定 ​`--cloud-provider`​ 标志。 这将保证它们不会运行任何云服务专用循环逻辑，这将会由云管理控制器运行。未来这个标记将被废弃并去除。
*   ​`kubelet` ​必须使用 ​`--cloud-provider=external`​ 运行。 这是为了保证让 kubelet 知道在执行任何任务前，它必须被云管理控制器初始化。

请记住，设置集群使用云管理控制器将用多种方式更改集群行为：

*   指定了 ​`--cloud-provider=external`​ 的 kubelet 将被添加一个 ​`node.cloudprovider.kubernetes.io/uninitialized`​ 的污点，导致其在初始化过程中不可调度（​`NoSchedule`​）。 这将标记该节点在能够正常调度前，需要外部的控制器进行二次初始化。 请注意，如果云管理控制器不可用，集群中的新节点会一直处于不可调度的状态。 这个污点很重要，因为调度器可能需要关于节点的云服务特定的信息，比如他们的区域或类型 （高端 CPU、GPU 支持、内存较大、临时实例等）。
*   集群中节点的云服务信息将不再能够从本地元数据中获取，取而代之的是所有获取节点信息的 API 调用都将通过云管理控制器。这意味着你可以通过限制到 kubelet 云服务 API 的访问来提升安全性。 在更大的集群中你可能需要考虑云管理控制器是否会遇到速率限制， 因为它现在负责集群中几乎所有到云服务的 API 调用。

云管理控制器可以实现：

*   节点控制器 - 负责使用云服务 API 更新 kubernetes 节点并删除在云服务上已经删除的 kubernetes 节点。
*   服务控制器 - 负责在云服务上为类型为 LoadBalancer 的 service 提供负载均衡器。
*   路由控制器 - 负责在云服务上配置网络路由。
*   如果你使用的是 out-of-tree 提供商，请按需实现其余任意特性。

示例
--

如果当前 Kubernetes 内核支持你使用的云服务，并且想要采用云管理控制器，请参见 [kubernetes 内核中的云管理控制器](https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager)。

对于不在 Kubernetes 核心代码库中的云管理控制器，你可以在云服务厂商或 SIG 领导者的源中找到对应的项目。

*   [DigitalOcean](https://github.com/digitalocean/digitalocean-cloud-controller-manager)
*   [keepalived](https://github.com/munnerz/keepalived-cloud-provider)
*   [Oracle Cloud Infrastructure](https://github.com/oracle/oci-cloud-controller-manager)
*   [Rancher](https://github.com/rancher/rancher-cloud-controller-manager)

对于已经存在于 Kubernetes 内核中的提供商，你可以在集群中将 in-tree 云管理控制器作为守护进程运行。请使用如下指南：

`# 这是一个如何将 cloud-controller-manager 安装为集群中的 Daemonset 的示例。 # 本例假定你的主控节点可以运行 pod 并具有角色 node-role.kubernetes.io/master # 请注意，这里的 Daemonset 不能直接在你的云上工作，此例只是一个指导。  --- apiVersion: v1 kind: ServiceAccount metadata:   name: cloud-controller-manager   namespace: kube-system --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata:   name: system:cloud-controller-manager roleRef:   apiGroup: rbac.authorization.k8s.io   kind: ClusterRole   name: cluster-admin subjects: - kind: ServiceAccount   name: cloud-controller-manager   namespace: kube-system --- apiVersion: apps/v1 kind: DaemonSet metadata:   labels:     k8s-app: cloud-controller-manager   name: cloud-controller-manager   namespace: kube-system spec:   selector:     matchLabels:       k8s-app: cloud-controller-manager   template:     metadata:       labels:         k8s-app: cloud-controller-manager     spec:       serviceAccountName: cloud-controller-manager       containers:       - name: cloud-controller-manager         # 对于树内驱动，我们使用 k8s.gcr.io/cloud-controller-manager，         # 镜像可以替换为其他树外驱动的镜像         image: k8s.gcr.io/cloud-controller-manager:v1.8.0         command:         - /usr/local/bin/cloud-controller-manager         - --cloud-provider=[YOUR_CLOUD_PROVIDER]  # 在此处添加你自己的云驱动！         - --leader-elect=true         - --use-service-account-credentials         # 这些标志因每个云驱动而异         - --allocate-node-cidrs=true         - --configure-cloud-routes=true         - --cluster-cidr=172.17.0.0/16       tolerations:       # 这一设置是必需的，为了让 CCM 可以自行引导       - key: node.cloudprovider.kubernetes.io/uninitialized         value: "true"         effect: NoSchedule       # 这些容忍度使得守护进程能够在控制平面节点上运行       # 如果你的控制平面节点不应该运行 pod，请删除它们       - key: node-role.kubernetes.io/control-plane         operator: Exists         effect: NoSchedule       - key: node-role.kubernetes.io/master         operator: Exists         effect: NoSchedule       # 这是为了限制 CCM 仅在主节点上运行       # 节点选择器可能因你的集群设置而异       nodeSelector:         node-role.kubernetes.io/master: ""`

限制 
---

运行云管理控制器会有一些可能的限制。虽然以后的版本将处理这些限制，但是知道这些生产负载的限制很重要。

### 对 Volume 的支持

云管理控制器未实现 ​`kube-controller-manager`​ 中的任何 volume 控制器，因为和 volume 的集成还需要与 kubelet 协作。由于我们引入了 CSI (容器存储接口，container storage interface) 并对弹性 volume 插件添加了更强大的支持，云管理控制器将添加必要的支持，以使云服务同 volume 更好的集成。请在 [这里](https://github.com/kubernetes/enhancements/issues/178) 了解更多关于 out-of-tree CSI volume 插件的信息。

### 可扩展性

在以前为云服务提供商提供的架构中，我们依赖 kubelet 的本地元数据服务来获取关于它本身的节点信息。通过这个新的架构，现在我们完全依赖云管理控制器来获取所有节点的信息。对于非常大的集群，你需要考虑可能的瓶颈，例如资源需求和 API 速率限制。

### 鸡和蛋的问题

云管理控制器的目标是将云服务特性的开发从 Kubernetes 核心项目中解耦。 不幸的是，Kubernetes 项目的许多方面都假设云服务提供商的特性同项目紧密结合。 因此，这种新架构的采用可能导致某些场景下，当一个请求需要从云服务提供商获取信息时， 在该请求没有完成的情况下云管理控制器不能返回那些信息。

Kubelet 中的 TLS 引导特性是一个很好的例子。 目前，TLS 引导认为 kubelet 有能力从云提供商（或本地元数据服务）获取所有的地址类型（私有、公用等）， 但在被初始化之前，云管理控制器不能设置节点地址类型，而这需要 kubelet 拥有 TLS 证书以和 API 服务器通信。

随着整个动议的演进，将来的发行版中将作出改变来解决这些问题。

##  26.  Kubernetes 验证签名的容器镜像
验证签名的容器镜像
---------

FEATURE STATE: Kubernetes v1.24 \[alpha\]

在开始之前
-----

这些说明适用于 Kubernetes 1.24。 如果要检查不同版本 Kubernetes 的组件完整性，请查看该 Kubernetes 版本的文档。

您将需要安装以下工具：

*   ​`cosign`​（[安装指南](https://docs.sigstore.dev/cosign/installation/)）
*   ​`curl`​（通常由您的操作系统提供）

验证图像签名
------

让我们从该列表中选择一个图像并使用 ​`cosign verify`​ 命令验证其签名：

`COSIGN_EXPERIMENTAL=1 cosign verify k8s.gcr.io/kube-apiserver-amd64:v1.24.0`

> Note：​`COSIGN_EXPERIMENTAL=1`​ 用于允许验证以 ​`KEYLESS` ​模式签名的图像。 要了解有关无密钥签名的更多信息，请参阅[无密钥签名](https://github.com/sigstore/cosign/blob/main/KEYLESS.md target=)。

### 验证所有控制平面组件的映像

要验证所有已签名的控制平面映像，请运行以下命令：

`curl -Ls https://sbom.k8s.io/$(curl -Ls https://dl.k8s.io/release/latest.txt)/release | grep 'PackageName: k8s.gcr.io/' | awk '{print $2}' > images.txt input=images.txt while IFS= read -r image do   COSIGN_EXPERIMENTAL=1 cosign verify "$image" done < "$input"`

验证映像后，请按照以下示例在 Pod 清单中通过其摘要指定该映像：​`registry-url/image-name@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2`​。

使用准入控制器验证图像签名
-------------

对于非控制平面图像（例如一致性图像），签名也可以在部署时使用联合签名准入控制器进行验证。 要开始共同签名，这里有一些有用的资源：

*   [安装](https://github.com/sigstore/helm-charts/tree/main/charts/cosigned)
*   [配置选项](https://github.com/sigstore/cosign/tree/main/config)

##  27.  Kubernetes 运行 etcd 集群
为 Kubernetes 运行 etcd 集群
-----------------------

etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。

你的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。

要了解 etcd 更深层次的信息，请参考 [etcd 文档](https://etcd.io/docs/)。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

要检查版本，请输入 ​`kubectl version`​。

先决条件 
-----

*   运行的 etcd 集群个数成员为奇数。
*   etcd 是一个 leader-based 分布式系统。确保主节点定期向所有从节点发送心跳，以保持集群稳定。
*   确保不发生资源不足。
集群的性能和稳定性对网络和磁盘 I/O 非常敏感。任何资源匮乏都会导致心跳超时， 从而导致集群的不稳定。不稳定的情况表明没有选出任何主节点。 在这种情况下，集群不能对其当前状态进行任何更改，这意味着不能调度新的 pod。*   保持 etcd 集群的稳定对 Kubernetes 集群的稳定性至关重要。 因此，请在专用机器或隔离环境上运行 etcd 集群，以满足 [所需资源需求](https://etcd.io/docs/v3.6/op-guide/hardware/)。
*   在生产中运行的 etcd 的最低推荐版本是 ​`3.2.10+`​。

资源需求 
-----

使用有限的资源运行 etcd 只适合测试目的。为了在生产中部署，需要先进的硬件配置。 在生产中部署 etcd 之前，请查看[所需资源参考文档](https://etcd.io/docs/v3.6/op-guide/hardware/ target=)。

启动 etcd 集群 
-----------

本节介绍如何启动单节点和多节点 etcd 集群。

### 单节点 etcd 集群 

只为测试目的使用单节点 etcd 集群。

1.  运行以下命令：

`etcd --listen-client-urls=http://$PRIVATE_IP:2379 \    --advertise-client-urls=http://$PRIVATE_IP:2379`

3.  使用参数 ​`--etcd-servers=$PRIVATE_IP:2379`​ 启动 Kubernetes API 服务器。

确保将 ​`PRIVATE_IP` ​设置为etcd客户端 IP。

### 多节点 etcd 集群 

出于耐用性和高可用性考量，在生产环境中应以多节点集群的方式运行 etcd，并且定期备份。 建议在生产环境中使用五个成员的集群。 有关该内容的更多信息，请参阅[常见问题文档](https://etcd.io/docs/v3.6/faq/ target=)。

可以通过静态成员信息或动态发现的方式配置 etcd 集群。 有关集群的详细信息，请参阅 [etcd 集群文档](https://etcd.io/docs/v3.6/op-guide/clustering/)。

例如，考虑运行以下客户端 URL 的五个成员的 etcd 集群：​`http://$IP1:2379`​、 ​`http://$IP2:2379`​、​`http://$IP3:2379`​、​`http://$IP4:2379`​ 和 ​`http://$IP5:2379`​。 要启动 Kubernetes API 服务器：

1.  运行以下命令：

`etcd --listen-client-urls=http://$IP1:2379,http://$IP2:2379,http://$IP3:2379,http://$IP4:2379,http://$IP5:2379 --advertise-client-urls=http://$IP1:2379,http://$IP2:2379,http://$IP3:2379,http://$IP4:2379,http://$IP5:2379`

3.  使用参数 ​`--etcd-servers=$IP1:2379,$IP2:2379,$IP3:2379,$IP4:2379,$IP5:2379`​ 启动 Kubernetes API 服务器。

确保将 ​`IP<n>`​ 变量设置为客户端 IP 地址。

### 使用负载均衡的多节点 etcd 集群 

要运行负载均衡的 etcd 集群：

1.  建立一个 etcd 集群。
2.  在 etcd 集群前面配置负载均衡器。例如，让负载均衡器的地址为 ​`$LB`​。
3.  使用参数 ​`--etcd-servers=$LB:2379`​ 启动 Kubernetes API 服务器。

加固 etcd 集群 
-----------

对 etcd 的访问相当于集群中的 root 权限，因此理想情况下只有 API 服务器才能访问它。 考虑到数据的敏感性，建议只向需要访问 etcd 集群的节点授予权限。

想要确保 etcd 的安全，可以设置防火墙规则或使用 etcd 提供的安全特性，这些安全特性依赖于 x509 公钥基础设施（PKI）。 首先，通过生成密钥和证书对来建立安全的通信通道。 例如，使用密钥对 ​`peer.key`​ 和 ​`peer.cert`​ 来保护 etcd 成员之间的通信， 而 ​`client.key`​ 和 ​`client.cert`​ 用于保护 etcd 与其客户端之间的通信。 请参阅 etcd 项目提供的 [示例脚本](https://github.com/etcd-io/etcd/tree/main/hack/tls-setup)， 以生成用于客户端身份验证的密钥对和 CA 文件。

### 安全通信 

若要使用安全对等通信对 etcd 进行配置，请指定参数 ​`--peer-key-file=peer.key`​ 和 ​`--peer-cert-file=peer.cert`​，并使用 HTTPS 作为 URL 模式。

类似地，要使用安全客户端通信对 etcd 进行配置，请指定参数 ​`--key-file=k8sclient.key`​ 和 ​`--cert-file=k8sclient.cert`​，并使用 HTTPS 作为 URL 模式。 使用安全通信的客户端命令的示例：

`ETCDCTL_API=3 etcdctl --endpoints 10.2.0.9:2379 \   --cert=/etc/kubernetes/pki/etcd/server.crt \   --key=/etc/kubernetes/pki/etcd/server.key \   --cacert=/etc/kubernetes/pki/etcd/ca.crt \   member list`

### 限制 etcd 集群的访问 

配置安全通信后，限制只有 Kubernetes API 服务器可以访问 etcd 集群。使用 TLS 身份验证来完成此任务。

例如，考虑由 CA ​`etcd.ca`​ 信任的密钥对 ​`k8sclient.key`​ 和 ​`k8sclient.cert`​。 当 etcd 配置为 ​`--client-cert-auth`​ 和 TLS 时，它使用系统 CA 或由 ​`--trusted-ca-file`​ 参数传入的 CA 验证来自客户端的证书。指定参数 ​`--client-cert-auth=true`​ 和 ​`--trusted-ca-file=etcd.ca`​ 将限制对具有证书 ​`k8sclient.cert`​ 的客户端的访问。

一旦正确配置了 etcd，只有具有有效证书的客户端才能访问它。要让 Kubernetes API 服务器访问， 可以使用参数 ​`--etcd-certfile=k8sclient.cert`​、​`--etcd-keyfile=k8sclient.key`​ 和 ​`--etcd-cafile=ca.cert`​ 配置。

> Note: Kubernetes 目前不支持 etcd 身份验证。 想要了解更多信息，请参阅相关的问题 [支持 etcd v2 的基本认证](https://github.com/kubernetes/kubernetes/issues/23398)。  

替换失败的 etcd 成员 
--------------

etcd 集群通过容忍少数成员故障实现高可用性。 但是，要改善集群的整体健康状况，请立即替换失败的成员。当多个成员失败时，逐个替换它们。 替换失败成员需要两个步骤：删除失败成员和添加新成员。

虽然 etcd 在内部保留唯一的成员 ID，但建议为每个成员使用唯一的名称，以避免人为错误。 例如，考虑一个三成员的 etcd 集群。假定 URL 分别为：​`member1=http://10.0.0.1`​、​`member2=http://10.0.0.2`​ 和 ​`member3=http://10.0.0.3`​。当 ​`member1`​ 失败时，将其替换为 ​`member4=http://10.0.0.4`​。

1.  获取失败的 ​`member1`​ 的成员 ID：

`etcdctl --endpoints=http://10.0.0.2,http://10.0.0.3 member list`

显示以下信息：

`8211f1d0f64f3269, started, member1, http://10.0.0.1:2380, http://10.0.0.1:2379 91bc3c398fb3c146, started, member2, http://10.0.0.2:2380, http://10.0.0.2:2379 fd422379fda50e48, started, member3, http://10.0.0.3:2380, http://10.0.0.3:2379`

5.  移除失败的成员

`etcdctl member remove 8211f1d0f64f3269`

显示以下信息：

`Removed member 8211f1d0f64f3269 from cluster`

9.  增加新成员：

`etcdctl member add member4 --peer-urls=http://10.0.0.4:2380`

显示以下信息：

`Member 2be1eb8f84b7f63e added to cluster ef37ad9dc622a7c4`

13.  在 IP 为 ​`10.0.0.4`​ 的机器上启动新增加的成员：

`export ETCD_NAME="member4" export ETCD_INITIAL_CLUSTER="member2=http://10.0.0.2:2380,member3=http://10.0.0.3:2380,member4=http://10.0.0.4:2380" export ETCD_INITIAL_CLUSTER_STATE=existing etcd [flags]`

15.  执行以下操作之一：

*   更新 Kubernetes API 服务器的 ​`--etcd-servers`​ 参数，使 Kubernetes 知道配置已更改，然后重新启动 Kubernetes API 服务器。
*   如果在 deployment 中使用了负载均衡，更新负载均衡配置。

有关集群重新配置的详细信息，请参阅 [etcd 重构文档](https://etcd.io/docs/v3.6/op-guide/runtime-configuration/ target=)。

备份 etcd 集群 
-----------

所有 Kubernetes 对象都存储在 etcd 上。定期备份 etcd 集群数据对于在灾难场景（例如丢失所有控制平面节点）下恢复 Kubernetes 集群非常重要。 快照文件包含所有 Kubernetes 状态和关键信息。为了保证敏感的 Kubernetes 数据的安全，可以对快照文件进行加密。

备份 etcd 集群可以通过两种方式完成：etcd 内置快照和卷快照。

### 内置快照 

etcd 支持内置快照。快照可以从使用 ​`etcdctl snapshot save`​ 命令的活动成员中获取， 也可以通过从 etcd [数据目录](https://etcd.io/docs/v3.6/op-guide/configuration/ target=) 复制 ​`member/snap/db`​ 文件，该 etcd 数据目录目前没有被 etcd 进程使用。获取快照不会影响成员的性能。

下面是一个示例，用于获取 ​`$ENDPOINT`​ 所提供的键空间的快照到文件 ​`snapshotdb`​：

`ETCDCTL_API=3 etcdctl --endpoints $ENDPOINT snapshot save snapshotdb`

验证快照:

`ETCDCTL_API=3 etcdctl --write-out=table snapshot status snapshotdb`

`+----------+----------+------------+------------+ |   HASH   | REVISION | TOTAL KEYS | TOTAL SIZE | +----------+----------+------------+------------+ | fe01cf57 |       10 |          7 | 2.1 MB     | +----------+----------+------------+------------+`

### 卷快照 

如果 etcd 运行在支持备份的存储卷（如 Amazon Elastic Block 存储）上，则可以通过获取存储卷的快照来备份 etcd 数据。

### 使用 etcdctl 选项的快照 

我们还可以使用 etcdctl 提供的各种选项来制作快照。例如：

`ETCDCTL_API=3 etcdctl -h` 

列出 etcdctl 可用的各种选项。例如，你可以通过指定端点、证书等来制作快照，如下所示：

`ETCDCTL_API=3 etcdctl --endpoints=https://127.0.0.1:2379 \   --cacert=<trusted-ca-file> --cert=<cert-file> --key=<key-file> \   snapshot save <backup-file-location>`

可以从 etcd Pod 的描述中获得 ​`trusted-ca-file`​、​`cert-file`​ 和 ​`key-file`​。

为 etcd 集群扩容 
------------

通过交换性能，对 etcd 集群扩容可以提高可用性。缩放不会提高集群性能和能力。 一般情况下不要扩大或缩小 etcd 集群的集合。不要为 etcd 集群配置任何自动缩放组。 强烈建议始终在任何官方支持的规模上运行生产 Kubernetes 集群时使用静态的五成员 etcd 集群。

合理的扩展是在需要更高可靠性的情况下，将三成员集群升级为五成员集群。 请参阅 [etcd 重新配置文档](https://etcd.io/docs/v3.6/op-guide/runtime-configuration/ target=) 以了解如何将成员添加到现有集群中的信息。

恢复 etcd 集群 
-----------

etcd 支持从 [major.minor](https://semver.org/) 或其他不同 patch 版本的 etcd 进程中获取的快照进行恢复。 还原操作用于恢复失败的集群的数据。

在启动还原操作之前，必须有一个快照文件。它可以是来自以前备份操作的快照文件， 也可以是来自剩余[数据目录](https://etcd.io/docs/v3.6/op-guide/configuration/ target=)的快照文件。 例如：

`ETCDCTL_API=3 etcdctl --endpoints 10.2.0.9:2379 snapshot restore snapshotdb`

恢复时也可以指定操作选项，例如：

`ETCDCTL_API=3 etcdctl --data-dir <data-dir-location> snapshot restore snapshotdb`

有关从快照文件还原集群的详细信息和示例，请参阅 [etcd 灾难恢复文档](https://etcd.io/docs/v3.6/op-guide/recovery/ target=)。

如果还原的集群的访问 URL 与前一个集群不同，则必须相应地重新配置 Kubernetes API 服务器。 在本例中，使用参数 ​`--etcd-servers=$NEW_ETCD_CLUSTER`​ 而不是参数 ​`--etcd-servers=$OLD_ETCD_CLUSTER`​ 重新启动 Kubernetes API 服务器。 用相应的 IP 地址替换 ​`$NEW_ETCD_CLUSTER`​ 和 ​`$OLD_ETCD_CLUSTER`​。如果在 etcd 集群前面使用负载平衡，则可能需要更新负载均衡器。

如果大多数 etcd 成员永久失败，则认为 etcd 集群失败。在这种情况下，Kubernetes 不能对其当前状态进行任何更改。 虽然已调度的 pod 可能继续运行，但新的 pod 无法调度。在这种情况下，恢复 etcd 集群并可能需要重新配置 Kubernetes API 服务器以修复问题。

> Note:  
> 如果集群中正在运行任何 API 服务器，则不应尝试还原 etcd 的实例。相反，请按照以下步骤还原 etcd：  
> 
> *   停止所有 API 服务实例
> *   在所有 etcd 实例中恢复状态
> *   重启所有 API 服务实例
> 
> 我们还建议重启所有组件（例如 ​`kube-scheduler`​、​`kube-controller-manager`​、​`kubelet`​），以确保它们不会 依赖一些过时的数据。请注意，实际中还原会花费一些时间。 在还原过程中，关键组件将丢失领导锁并自行重启。

升级 etcd 集群 
-----------

有关 etcd 升级的更多详细信息，请参阅 [etcd 升级](https://etcd.io/docs/v3.5/upgrades/)文档。

> Note: 在开始升级之前，请先备份你的 etcd 集群。

##  28.  Kubernetes 为系统守护进程预留计算资源
为系统守护进程预留计算资源
-------------

Kubernetes 的节点可以按照 ​`Capacity` ​调度。默认情况下 pod 能够使用节点全部可用容量。 这是个问题，因为节点自己通常运行了不少驱动 OS 和 Kubernetes 的系统守护进程。 除非为这些系统守护进程留出资源，否则它们将与 pod 争夺资源并导致节点资源短缺问题。

​`kubelet` ​公开了一个名为 'Node Allocatable' 的特性，有助于为系统守护进程预留计算资源。 Kubernetes 推荐集群管理员按照每个节点上的工作负载密度配置 “Node Allocatable”。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

您的 Kubernetes 服务器的版本必须为 1.8 或更高版本。 要检查版本，请输入 ​`kubectl version`​。

你的 kubernetes 服务器版本必须至少是 1.17 版本，才能使用 kubelet 命令行选项 ​`--reserved-cpus`​ 设置 显式预留 CPU 列表。

节点可分配
-----

![](https://atts.w3cschool.cn/attachments/image/20220606/1654485904535457.svg)  

Kubernetes 节点上的 'Allocatable' 被定义为 pod 可用计算资源量。 调度器不会超额申请 'Allocatable'。 目前支持 'CPU'、'memory' 和 'ephemeral-storage' 这几个参数。

可分配的节点暴露为 API 中 ​`v1.Node`​ 对象的一部分，也是 CLI 中 ​`kubectl describe node`​ 的一部分。

在 ​`kubelet` ​中，可以为两类系统守护进程预留资源。

### 启用 QoS 和 Pod 级别的 cgroups 

为了恰当的在节点范围实施节点可分配约束，你必须通过 ​`--cgroups-per-qos`​ 标志启用新的 cgroup 层次结构。这个标志是默认启用的。 启用后，​`kubelet` ​将在其管理的 cgroup 层次结构中创建所有终端用户的 Pod。

### 配置 cgroup 驱动 

​`kubelet` ​支持在主机上使用 cgroup 驱动操作 cgroup 层次结构。 驱动通过 ​`--cgroup-driver`​ 标志配置。

支持的参数值如下：

*   ​`cgroupfs` ​是默认的驱动，在主机上直接操作 cgroup 文件系统以对 cgroup 沙箱进行管理。
*   ​`systemd` ​是可选的驱动，使用 init 系统支持的资源的瞬时切片管理 cgroup 沙箱。

取决于相关容器运行时的配置，操作员可能需要选择一个特定的 cgroup 驱动 来保证系统正常运行。 例如，如果操作员使用 ​`containerd` ​运行时提供的 ​`systemd` ​cgroup 驱动时， 必须配置 ​`kubelet` ​使用 ​`systemd` ​cgroup 驱动。

### Kube 预留值 

*   Kubelet 标志: ​`--kube-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]` ​
*   Kubelet 标志: ​`--kube-reserved-cgroup=`​

​`kube-reserved`​ 用来给诸如 ​`kubelet`​、容器运行时、节点问题监测器等 kubernetes 系统守护进程记述其资源预留值。 该配置并非用来给以 Pod 形式运行的系统守护进程保留资源。​`kube-reserved`​ 通常是节点上 ​`pod`​ 密度 的函数。

除了 ​`cpu`​，内存 和 ​`ephemeral-storage`​ 之外，​`pid` ​可用来指定为 kubernetes 系统守护进程预留指定数量的进程 ID。

要选择性地对 kubernetes 系统守护进程上执行 ​`kube-reserved`​ 保护，需要把 kubelet 的 ​`--kube-reserved-cgroup`​ 标志的值设置为 kube 守护进程的父控制组。

推荐将 kubernetes 系统守护进程放置于顶级控制组之下（例如 systemd 机器上的 ​`runtime.slice`​）。 理想情况下每个系统守护进程都应该在其自己的子控制组中运行。 请参考 [这个设计方案](https://github.com/kubernetes/design-proposals-archive/blob/main/node/node-allocatable.md target=)， 进一步了解关于推荐控制组层次结构的细节。

请注意，如果 ​`--kube-reserved-cgroup`​ 不存在，Kubelet 将 不会 创建它。 如果指定了一个无效的 cgroup，Kubelet 将会失败。

### 系统预留值 

*   Kubelet 标志: ​`--system-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]` ​
*   Kubelet 标志: ​`--system-reserved-cgroup=`​

​`system-reserved`​ 用于为诸如 ​`sshd`​、​`udev` ​等系统守护进程记述其资源预留值。 ​`system-reserved`​ 也应该为 ​`kernel` ​预留 内存，因为目前 ​`kernel` ​使用的内存并不记在 Kubernetes 的 Pod 上。 同时还推荐为用户登录会话预留资源（systemd 体系中的 ​`user.slice`​）。

除了 ​`cpu`​，内存 和 ​`ephemeral-storage`​ 之外，​`pid` ​可用来指定为 kubernetes 系统守护进程预留指定数量的进程 ID。

要想为系统守护进程上可选地实施 ​`system-reserved`​ 约束，请指定 kubelet 的 ​`--system-reserved-cgroup`​ 标志值为 OS 系统守护进程的父级控制组。

推荐将 OS 系统守护进程放在一个顶级控制组之下（例如 systemd 机器上的 ​`system.slice`​）。

请注意，如果 ​`--system-reserved-cgroup`​ 不存在，​`kubelet` ​不会 创建它。 如果指定了无效的 cgroup，​`kubelet` ​将会失败。

### 显式保留的 CPU 列表

FEATURE STATE: Kubernetes v1.17 \[stable\]

Kubelet 标志：​`--reserved-cpus=0-3` ​

​`reserved-cpus`​ 旨在为操作系统守护程序和 kubernetes 系统守护程序保留一组明确指定编号的 CPU。​`reserved-cpus`​ 适用于不打算针对 cpuset 资源为操作系统守护程序和 kubernetes 系统守护程序定义独立的顶级 cgroups 的系统。 如果 Kubelet 没有 指定参数 ​`--system-reserved-cgroup`​ 和 ​`--kube-reserved-cgroup`​， 则 ​`reserved-cpus`​ 的设置将优先于 ​`--kube-reserved`​ 和 ​`--system-reserved`​ 选项。

此选项是专门为电信/NFV 用例设计的，在这些用例中不受控制的中断或计时器可能会 影响其工作负载性能。 你可以使用此选项为系统或 kubernetes 守护程序以及中断或计时器显式定义 cpuset， 这样系统上的其余 CPU 可以专门用于工作负载，因不受控制的中断或计时器的影响得以 降低。 要将系统守护程序、kubernetes 守护程序和中断或计时器移动到此选项定义的显式 cpuset 上，应使用 Kubernetes 之外的其他机制。 例如：在 Centos 系统中，可以使用 tuned 工具集来执行此操作。

### 驱逐阈值 

Kubelet 标志：​`--eviction-hard=[memory.available<500Mi]` ​

节点级别的内存压力将导致系统内存不足，这将影响到整个节点及其上运行的所有 Pod。 节点可以暂时离线直到内存已经回收为止。 为了防止（或减少可能性）系统内存不足，kubelet 提供了 资源不足管理。 驱逐操作只支持 ​`memory` ​和 ​`ephemeral-storage`​。 通过 ​`--eviction-hard`​ 标志预留一些内存后，当节点上的可用内存降至保留值以下时， ​`kubelet` ​将尝试驱逐 Pod。 如果节点上不存在系统守护进程，Pod 将不能使用超过 ​`capacity-eviction-hard`​ 所 指定的资源量。因此，为驱逐而预留的资源对 Pod 是不可用的。

### 实施节点可分配约束 

Kubelet 标志：​`--enforce-node-allocatable=pods[,][system-reserved][,][kube-reserved]` ​

调度器将 'Allocatable' 视为 Pod 可用的 ​`capacity`​（资源容量）。

​`kubelet` ​默认对 Pod 执行 'Allocatable' 约束。 无论何时，如果所有 Pod 的总用量超过了 'Allocatable'，驱逐 Pod 的措施将被执行。 有关驱逐策略的更多细节可以在 节点压力驱逐页找到。 可通过设置 kubelet ​`--enforce-node-allocatable`​ 标志值为 ​`pods` ​控制这个措施。

可选地，通过在同一标志中同时指定 ​`kube-reserved`​ 和 ​`system-reserved`​ 值， 可以使 ​`kubelet` ​强制实施 ​`kube-reserved`​ 和 ​`system-reserved`​ 约束。 请注意，要想执行 ​`kube-reserved`​ 或者 ​`system-reserved`​ 约束， 需要对应设置 ​`--kube-reserved-cgroup`​ 或者 ​`--system-reserved-cgroup`​。

一般原则 
-----

系统守护进程一般会被按照类似 Guaranteed pods 一样对待。 系统守护进程可以在与其对应的控制组中出现突发资源用量，这一行为要作为 kubernetes 部署的一部分进行管理。 例如，​`kubelet` ​应该有它自己的控制组并和容器运行时共享 ​`kube-reserved`​ 资源。 不过，如果执行了 ​`kube-reserved`​ 约束，则 kubelet 不可出现突发负载并用光 节点的所有可用资源。

在执行 ​`system-reserved`​ 预留策略时请加倍小心，因为它可能导致节点上的 关键系统服务出现 CPU 资源短缺、因为内存不足而被终止或者无法在节点上创建进程。 建议只有当用户详尽地描述了他们的节点以得出精确的估计值， 并且对该组中进程因内存不足而被杀死时，有足够的信心将其恢复时， 才可以强制执行 ​`system-reserved`​ 策略。

*   作为起步，可以先针对 ​`pods` ​上执行 'Allocatable' 约束。
*   一旦用于追踪系统守护进程的监控和告警的机制到位，可尝试基于用量估计的 方式执行 ​`kube-reserved`​ 策略。
*   随着时间推进，在绝对必要的时候可以执行 ​`system-reserved`​ 策略。

随着时间推进和越来越多特性被加入，kube 系统守护进程对资源的需求可能也会增加。 以后 kubernetes 项目将尝试减少对节点系统守护进程的利用，但目前这件事的优先级 并不是最高。 所以，将来的发布版本中 ​`Allocatable` ​容量是有可能降低的。

示例场景 
-----

这是一个用于说明节点可分配（Node Allocatable）计算方式的示例：

*   节点拥有 32Gi memeory，16 CPU 和 100Gi Storage 资源
*   ​`--kube-reserved`​ 被设置为 cpu=1,memory=2Gi,ephemeral-storage=1Gi
*   ​`--system-reserved`​ 被设置为 cpu=500m,memory=1Gi,ephemeral-storage=1Gi
*   ​`--eviction-hard`​ 被设置为 memory.available<500Mi,nodefs.available<10%

在这个场景下，'Allocatable' 将会是 14.5 CPUs、28.5Gi 内存以及 88Gi 本地存储。 调度器保证这个节点上的所有 Pod 的内存 ​`requests` ​总量不超过 28.5Gi， 存储不超过 '88Gi'。 当 Pod 的内存使用总量超过 28.5Gi 或者磁盘使用总量超过 88Gi 时， kubelet 将会驱逐它们。 如果节点上的所有进程都尽可能多地使用 CPU，则 Pod 加起来不能使用超过 14.5 CPUs 的资源。

当没有执行 ​`kube-reserved`​ 或 ​`system-reserved`​ 策略且系统守护进程 使用量超过其预留时，如果节点内存用量高于 31.5Gi 或 ​`storage` ​大于 90Gi， kubelet 将会驱逐 Pod。

##  29.  Kubernetes 为节点发布扩展资源
为节点发布扩展资源
---------

本文展示了如何为节点指定扩展资源（Extended Resource）。 扩展资源允许集群管理员发布节点级别的资源，这些资源在不进行发布的情况下无法被 Kubernetes 感知。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

要检查版本，请输入 ​`kubectl version`​。

获取你的节点名称
--------

`kubectl get nodes`

选择一个节点用于此练习。

在你的一个节点上发布一种新的扩展资源 
-------------------

为在一个节点上发布一种新的扩展资源，需要发送一个 HTTP PATCH 请求到 Kubernetes API server。 例如：假设你的一个节点上带有四个 dongle 资源。 下面是一个 PATCH 请求的示例，该请求为你的节点发布四个 dongle 资源。

`PATCH /api/v1/nodes/<your-node-name>/status HTTP/1.1 Accept: application/json Content-Type: application/json-patch+json Host: k8s-master:8080  [   {     "op": "add",     "path": "/status/capacity/example.com~1dongle",     "value": "4"   } ]`

注意：Kubernetes 不需要了解 dongle 资源的含义和用途。 前面的 PATCH 请求告诉 Kubernetes 你的节点拥有四个你称之为 dongle 的东西。

启动一个代理（proxy），以便你可以很容易地向 Kubernetes API server 发送请求：

`kubectl proxy`

在另一个命令窗口中，发送 HTTP PATCH 请求。 用你的节点名称替换 ​`<your-node-name>`​：

`curl --header "Content-Type: application/json-patch+json" \   --request PATCH \   --data '[{"op": "add", "path": "/status/capacity/example.com~1dongle", "value": "4"}]' \   http://localhost:8001/api/v1/nodes/<your-node-name>/status`

> Note: 在前面的请求中，​`~1`​ 为 patch 路径中 “/” 符号的编码。 JSON-Patch 中的操作路径值被解析为 JSON 指针。 更多细节，请查看 [IETF RFC 6901](https://datatracker.ietf.org/doc/html/rfc6901) 的第 3 节。

输出显示该节点的 dongle 资源容量（capacity）为 4：

`"capacity": {   "cpu": "2",   "memory": "2049008Ki",   "example.com/dongle": "4",`

描述你的节点：

`kubectl describe node <your-node-name>`

输出再次展示了 dongle 资源：

`Capacity:  cpu:  2  memory:  2049008Ki  example.com/dongle:  4`

现在，应用开发者可以创建请求一定数量 dongle 资源的 Pod 了。

讨论
--

扩展资源类似于内存和 CPU 资源。例如，正如一个节点拥有一定数量的内存和 CPU 资源， 它们被节点上运行的所有组件共享，该节点也可以拥有一定数量的 dongle 资源， 这些资源同样被节点上运行的所有组件共享。 此外，正如应用开发者可以创建请求一定数量的内存和 CPU 资源的 Pod， 他们也可以创建请求一定数量 dongle 资源的 Pod。

扩展资源对 Kubernetes 是不透明的。Kubernetes 不知道扩展资源含义相关的任何信息。 Kubernetes 只了解一个节点拥有一定数量的扩展资源。 扩展资源必须以整形数量进行发布。 例如，一个节点可以发布 4 个 dongle 资源，但是不能发布 4.5 个。

### 存储示例

假设一个节点拥有一种特殊类型的磁盘存储，其容量为 800 GiB。 你可以为该特殊存储创建一个名称，如 ​`example.com/special-storage`​。 然后你就可以按照一定规格的块（如 100 GiB）对其进行发布。 在这种情况下，你的节点将会通知它拥有八个 ​`example.com/special-storage`​ 类型的资源。

`Capacity:  ...  example.com/special-storage: 8`

如果你想要允许针对特殊存储任意（数量）的请求，你可以按照 1 字节大小的块来发布特殊存储。 在这种情况下，你将会发布 800Gi 数量的 example.com/special-storage 类型的资源。

`Capacity:  ...  example.com/special-storage:  800Gi`

然后，容器就能够请求任意数量（多达 800Gi）字节的特殊存储。

`Capacity:  ...  example.com/special-storage:  800Gi`

清理
--

这里是一个从节点移除 dongle 资源发布的 PATCH 请求。

`PATCH /api/v1/nodes/<your-node-name>/status HTTP/1.1 Accept: application/json Content-Type: application/json-patch+json Host: k8s-master:8080  [   {     "op": "remove",     "path": "/status/capacity/example.com~1dongle",   } ]`

启动一个代理，以便你可以很容易地向 Kubernetes API 服务器发送请求：

`kubectl proxy`

在另一个命令窗口中，发送 HTTP PATCH 请求。用你的节点名称替换 ​`<your-node-name>`​：

`curl --header "Content-Type: application/json-patch+json" \ --request PATCH \ --data '[{"op": "remove", "path": "/status/capacity/example.com~1dongle"}]' \ http://localhost:8001/api/v1/nodes/<your-node-name>/status`

验证 dongle 资源的发布已经被移除：

`kubectl describe node <your-node-name> | grep dongle`

(你应该看不到任何输出)

##  30.  Kubernetes 以非root用户身份运行Kubernetes节点组件
以非root用户身份运行 Kubernetes 节点组件  

FEATURE STATE: Kubernetes v1.22 \[alpha\]

这个文档描述了怎样不使用 root 特权，而是通过使用 用户命名空间 去运行 Kubernetes 节点组件（例如 kubelet、CRI、OCI、CNI）。

这种技术也叫做 rootless 模式（Rootless mode）。

在开始之前
-----

您的 Kubernetes 服务器的版本必须为 1.22 或更高版本。 要检查版本，请输入 kubectl version。

*   [启用 Cgroup v2](https://rootlesscontaine.rs/getting-started/common/cgroup2/)
*   [在 systemd 中启用 user session](https://rootlesscontaine.rs/getting-started/common/login/)
*   [根据不同的 Linux 发行版，配置 sysctl 的值](https://rootlesscontaine.rs/getting-started/common/sysctl/)
*   [确保你的非特权用户被列在 /etc/subuid 和 /etc/subgid 文件中](https://rootlesscontaine.rs/getting-started/common/subuid/)
*   启用 ​`KubeletInUserNamespace` ​特性门控

使用 Rootless 模式的 Docker/Podman 运行 Kubernetes
-------------------------------------------

### kind

[kind](https://kind.sigs.k8s.io/) 支持使用 Rootless 模式的 Docker 或者 Podman 运行 Kubernetes。

请参阅[使用 Rootless 模式的 Docker 运行 kind](https://kind.sigs.k8s.io/docs/user/rootless/)。

### minikube

[minikube](https://minikube.sigs.k8s.io/) 也支持使用 Rootless 模式的 Docker 运行 Kubernetes。

请参阅 Minikube 文档中的 [docker](https://minikube.sigs.k8s.io/docs/drivers/docker/) 驱动页面。

它不支持 Rootless 模式的 Podman。

在非特权容器内运行 Kubernetes 
---------------------

### sysbox

[Sysbox](https://github.com/nestybox/sysbox) 是一个开源容器运行时 (类似于 “runc”），支持在 Linux 用户命名空间隔离的非特权容器内运行系统级工作负载， 比如 Docker 和 Kubernetes。

查看 [Sysbox 快速入门指南: Kubernetes-in-Docker](https://github.com/nestybox/sysbox/blob/master/docs/quickstart/kind.md) 了解更多细节。

Sysbox 支持在非特权容器内运行 Kubernetes， 而不需要 Cgroup v2 和 “KubeletInUserNamespace” 特性门控。 Sysbox 通过在容器内暴露特定的 ​`/proc`​ 和 ​`/sys`​ 文件系统， 以及其它一些先进的操作系统虚拟化技术来实现。

直接在主机上运行 Rootless 模式的 Kubernetes 
---------------------------------

### K3s

[K3s](https://k3s.io/) 实验性支持了 Rootless 模式。

请参阅使用 [Rootless 模式运行 K3s](https://rancher.com/docs/k3s/latest/en/advanced/ target=) 页面中的用法.

### Usernetes

[Usernetes](https://github.com/rootless-containers/usernetes) 是 Kubernetes 的一个参考发行版， 它可以在不使用 root 特权的情况下安装在 ​`$HOME`​ 目录下。

Usernetes 支持使用 containerd 和 CRI-O 作为 CRI 运行时。 Usernetes 支持配置了 Flannel (VXLAN)的多节点集群。

关于用法，请参阅 [Usernetes 仓库](https://github.com/rootless-containers/usernetes)。

手动部署一个在用户命名空间运行 kubelet 的节点
---------------------------

本节提供在用户命名空间手动运行 Kubernetes 的注意事项。

> Note: 本节是面向 Kubernetes 发行版的开发者，而不是最终用户。  

### 创建用户命名空间

第一步是创建一个 用户命名空间。

如果你正在尝试使用用户命名空间的容器（例如 Rootless 模式的 Docker/Podman 或 LXC/LXD） 运行 Kubernetes，那么你已经准备就绪，可以直接跳到下一小节。

否则你需要通过传递参数 ​`CLONE_NEWUSER` ​调用 ​`unshare(2)`​，自己创建一个命名空间。

用户命名空间也可以通过如下所示的命令行工具取消共享：

*   [unshare(1)](https://man7.org/linux/man-pages/man1/unshare.1.html)
*   [RootlessKit](https://github.com/rootless-containers/rootlesskit)
*   [become-root](https://github.com/giuseppe/become-root)

在取消命名空间的共享之后，你也必须对其它的命名空间例如 mount 命名空间取消共享。

在取消 mount 命名空间的共享之后，你不需要调用 ​`chroot()`​ 或者 ​`pivot_root()`​， 但是你必须在这个命名空间内挂载可写的文件系统到几个目录上。

请确保这个命名空间内(不是这个命名空间外部)至少以下几个目录是可写的：

*   ​`/etc` ​
*   ​`/run` ​
*   ​`/var/logs` ​
*   ​`/var/lib/kubelet` ​
*   ​`/var/lib/cni` ​
*   ​`/var/lib/containerd`​ (参照 containerd )
*   ​`/var/lib/containers`​ (参照 CRI-O )

### 创建委派 cgroup 树

除了用户命名空间，你也需要有一个版本为 cgroup v2 的可写 cgroup 树。

> Note: Kubernetes 需要 cgroup v2 才支持在用户命名空间运行节点组件。 cgroup v1 是不支持的。  

如果你在一个采用 systemd 机制的主机上使用用户命名空间的容器（例如 Rootless 模式的 Docker/Podman 或 LXC/LXD）来运行 Kubernetes，那么你已经准备就绪。

否则你必须创建一个具有 ​`Delegate=yes`​ 属性的 systemd 单元，来委派一个具有可写权限的 cgroup 树。

在你的节点上，systemd 必须已经配置为允许委派。更多细节请参阅 Rootless 容器文档的 [cgroup v2](https://rootlesscontaine.rs/getting-started/common/cgroup2/) 部分。

### 配置网络

节点组件的网络命名空间必须有一个非本地回路的网卡。它可以使用 [slirp4netns](https://github.com/rootless-containers/slirp4netns)、 [VPNKit](https://github.com/moby/vpnkit)、 [lxc-user-nic(1)](https://www.man7.org/linux/man-pages/man1/lxc-user-nic.1.html) 等工具进行配置。

Pod 的网络命名空间可以使用常规的 CNI 插件配置。对于多节点的网络，已知 Flannel (VXLAN、8472/UDP) 可以正常工作。

诸如 kubelet 端口（10250/TCP）和 ​`NodePort` ​服务端口之类的端口必须通过外部端口转发器 （例如 RootlessKit、 slirp4netns 或 [socat(1)](https://linux.die.net/man/1/socat)) 从节点网络命名空间暴露给主机。

你可以使用 K3s 的端口转发器。更多细节请参阅 [在 Rootless 模式下运行 K3s](https://rancher.com/docs/k3s/latest/en/advanced/ target=)。

### 配置 CRI 

kubelet 依赖于容器运行时。你需要部署一个容器运行时（例如 containerd 或 CRI-O）， 并确保它在 kubelet 启动之前已经在用户命名空间内运行。

*   ​`containerd`​

containerd 1.4 开始支持在用户命名空间运行 containerd 的 CRI 插件。

在用户命名空间运行 containerd 需要在 ​`/etc/containerd/containerd-config.toml`​ 文件包含以下配置：

`version = 2  [plugins."io.containerd.grpc.v1.cri"] # 禁用 AppArmor   disable_apparmor = true # 忽略配置 oom_score_adj 时的错误   restrict_oom_score_adj = true # 禁用 hugetlb cgroup v2 控制器（因为 systemd 不支持委派 hugetlb controller）   disable_hugetlb_controller = true  [plugins."io.containerd.grpc.v1.cri".containerd] # 如果内核 >= 5.11 , 也可以使用 non-fuse overlayfs， 但需要禁用 SELinux   snapshotter = "fuse-overlayfs"  [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options] # 我们使用的 cgroupfs 已经被 systemd 委派，所以我们不使用 SystemdCgroup 驱动 # (除非你在命名空间内运行了另一个 systemd)   SystemdCgroup = false`

*   ​`CRI-O`​

CRI-O 1.22 开始支持在用户命名空间运行 CRI-O。

CRI-O 必须配置一个环境变量 ​`_CRIO_ROOTLESS=1`​。

也推荐使用 ​`/etc/crio/crio.conf`​ 文件内的以下配置：

`[crio]   storage_driver = "overlay" # 如果内核 >= 5.11 , 也可以使用 non-fuse overlayfs， 但需要禁用 SELinux   storage_option = ["overlay.mount_program=/usr/local/bin/fuse-overlayfs"]  [crio.runtime] # 我们使用的 cgroupfs 已经被 systemd 委派，所以我们不使用 "systemd" 驱动 # (除非你在命名空间内运行了另一个 systemd)   cgroup_manager = "cgroupfs"`

### 配置 kubelet

在用户命名空间运行 kubelet 必须进行如下配置：

`apiVersion: kubelet.config.k8s.io/v1beta1 kind: KubeletConfiguration featureGates:   KubeletInUserNamespace: true # 我们使用的 cgroupfs 已经被 systemd 委派，所以我们不使用 "systemd" 驱动 # (除非你在命名空间内运行了另一个 systemd) cgroupDriver: "cgroupfs"`

当 ​`KubeletInUserNamespace` ​特性门控被启用时， kubelet 会忽略节点内由于配置如下几个 sysctl 参数值而可能产生的错误。

*   ​`vm.overcommit_memory` ​
*   ​`vm.panic_on_oom` ​
*   ​`kernel.panic` ​
*   ​`kernel.panic_on_oops` ​
*   ​`kernel.keys.root_maxkeys` ​
*   ​`kernel.keys.root_maxbytes`​

在用户命名空间内， kubelet 也会忽略任何由于打开 ​`/dev/kmsg`​ 而产生的错误。 这个特性门控也允许 kube-proxy 忽略由于配置 ​`RLIMIT_NOFILE` ​而产生的一个错误。

​`KubeletInUserNamespace` ​特性门控从 Kubernetes v1.22 被引入， 标记为 "alpha" 状态。

通过挂载特制的 proc 文件系统 （比如 [Sysbox](https://github.com/nestybox/sysbox)）， 也可以在不使用这个特性门控的情况下在用户命名空间运行 kubelet，但这不受官方支持。

### 配置 kube-proxy

在用户命名空间运行 kube-proxy 需要进行以下配置：

`apiVersion: kubeproxy.config.k8s.io/v1alpha1 kind: KubeProxyConfiguration mode: "iptables" # or "userspace" conntrack: # 跳过配置 sysctl 的值 "net.netfilter.nf_conntrack_max"   maxPerCore: 0 # 跳过配置 "net.netfilter.nf_conntrack_tcp_timeout_established"   tcpEstablishedTimeout: 0s # 跳过配置 "net.netfilter.nf_conntrack_tcp_timeout_close"   tcpCloseWaitTimeout: 0s`

注意事项 
-----

*   大部分“非本地”的卷驱动（例如 ​`nfs` ​和 ​`iscsi`​）不能正常工作。 已知诸如 ​`local`​、​`hostPath`​、​`emptyDir`​、​`configMap`​、​`secret` ​和 ​`downwardAPI` ​这些本地卷是能正常工作的。
*   一些 CNI 插件可能不正常工作。已知 Flannel (VXLAN) 是能正常工作的。

更多细节请参阅 rootlesscontaine.rs 站点的 [Caveats and Future work](https://rootlesscontaine.rs/caveats/) 页面。

##  31.  Kubernetes 使用CoreDNS进行服务发现
使用 CoreDNS 进行服务发现
-----------------

此页面介绍了 CoreDNS 升级过程以及如何安装 CoreDNS 而不是 kube-dns。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

您的 Kubernetes 服务器必须是 v1.9 或更高版本。 要检查版本，请输入 ​`kubectl version`​。

关于 CoreDNS
----------

[CoreDNS](https://coredns.io/) 是一个灵活可扩展的 DNS 服务器，可以作为 Kubernetes 集群 DNS。 与 Kubernetes 一样，CoreDNS 项目由 CNCF 托管。

通过替换现有集群部署中的 kube-dns，或者使用 kubeadm 等工具来为你部署和升级集群， 可以在你的集群中使用 CoreDNS 而非 kube-dns。

安装 CoreDNS 
-----------

有关手动部署或替换 kube-dns，请参阅 [CoreDNS GitHub 项目](https://github.com/coredns/deployment/tree/master/kubernetes)。

迁移到 CoreDNS
-----------

### 使用 kubeadm 升级现有集群

在 Kubernetes 1.21 版本中，kubeadm 移除了对将 ​`kube-dns`​ 作为 DNS 应用的支持。 对于 ​`kubeadm` ​v1.24，所支持的唯一的集群 DNS 应用是 CoreDNS。

当你使用 ​`kubeadm` ​升级使用 ​`kube-dns`​ 的集群时，你还可以执行到 CoreDNS 的迁移。 在这种场景中，​`kubeadm` ​将基于 ​`kube-dns`​ ConfigMap 生成 CoreDNS 配置（"Corefile"）， 保存存根域和上游名称服务器的配置。

升级 CoreDNS 
-----------

你可以在 [CoreDNS version in Kubernetes](https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md) 页面查看 kubeadm 为不同版本 Kubernetes 所安装的 CoreDNS 版本。

如果你只想升级 CoreDNS 或使用自己的定制镜像，也可以手动升级 CoreDNS。 参看[指南和演练](https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md) 文档了解如何平滑升级。 在升级你的集群过程中，请确保现有 CoreDNS 的配置（"Corefile"）被保留下来。

如果使用 ​`kubeadm` ​工具来升级集群，则 ​`kubeadm` ​可以自动处理保留现有 CoreDNS 配置这一事项。

CoreDNS 调优
----------

当资源利用方面有问题时，优化 CoreDNS 的配置可能是有用的。 有关详细信息，请参阅有关[扩缩 CoreDNS 的文档](https://github.com/coredns/deployment/blob/master/kubernetes/Scaling_CoreDNS.md)。

##  32.  Kubernetes 使用KMS驱动进行数据加密
使用 KMS 驱动进行数据加密
---------------

本页展示了如何配置秘钥管理服务—— Key Management Service (KMS) 驱动和插件以启用 Secret 数据加密。

在开始之前
-----

*   你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

要检查版本，请输入 ​`kubectl version`​

*   需要 Kubernetes 1.10.0 或更新版本
*   需要 etcd v3 或更新版本

FEATURE STATE: Kubernetes v1.12 \[beta\]

KMS 加密驱动使用封套加密模型来加密 etcd 中的数据。 数据使用数据加密秘钥（DEK）加密；每次加密都生成一个新的 DEK。 这些 DEK 经一个秘钥加密秘钥（KEK）加密后在一个远端的 KMS 中存储和管理。 KMS 驱动使用 gRPC 与一个特定的 KMS 插件通信。这个 KMS 插件作为一个 gRPC 服务器被部署在 Kubernetes 主服务器的同一个主机上，负责与远端 KMS 的通信。

配置 KMS 驱动
---------

为了在 API 服务器上配置 KMS 驱动，在加密配置文件中的驱动数组中加入一个类型为 ​`kms` ​的驱动，并设置下列属性：

*   ​`name`​: KMS 插件的显示名称。
*   ​`endpoint`​: gRPC 服务器（KMS 插件）的监听地址。该端点是一个 UNIX 域套接字。
*   ​`cachesize`​: 以明文缓存的数据加密秘钥（DEKs）的数量。一旦被缓存， 就可以直接使用 DEKs 而无需另外调用 KMS；而未被缓存的 DEKs 需要调用一次 KMS 才能解包。
*   ​`timeout`​: 在返回一个错误之前，kube-apiserver 等待 kms-plugin 响应的时间（默认是 3 秒）。

实现 KMS 插件
---------

为实现一个 KMS 插件，你可以开发一个新的插件 gRPC 服务器或启用一个由你的云服务驱动提供的 KMS 插件。 你可以将这个插件与远程 KMS 集成，并把它部署到 Kubernetes 的主服务器上。

### 启用由云服务驱动支持的 KMS

有关启用云服务驱动特定的 KMS 插件的说明，请咨询你的云服务驱动商。

### 开发 KMS 插件 gRPC 服务器

你可以使用 Go 语言的存根文件开发 KMS 插件 gRPC 服务器。 对于其他语言，你可以用 proto 文件创建可以用于开发 gRPC 服务器代码的存根文件。

*   使用 Go：使用存根文件 [service.pb.go](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/value/encrypt/envelope/v1beta1/service.pb.go) 中的函数和数据结构开发 gRPC 服务器代码。
*   使用 Go 以外的其他语言：用 protoc 编译器编译 proto 文件： [service.proto](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/value/encrypt/envelope/v1beta1/service.proto) 为指定语言生成存根文件。

然后使用存根文件中的函数和数据结构开发服务器代码。

注意：

*   kms 插件版本：​`v1beta1` ​

作为对过程调用 Version 的响应，兼容的 KMS 插件应把 v1beta1 作为 VersionResponse.version 返回

*   消息版本：​`v1beta1` ​

所有来自 KMS 驱动的消息都把 version 字段设置为当前版本 v1beta1

*   协议：UNIX 域套接字 (​`unix`​)

gRPC 服务器应监听 UNIX 域套接字

### 将 KMS 插件与远程 KMS 整合

KMS 插件可以用任何受 KMS 支持的协议与远程 KMS 通信。 所有的配置数据，包括 KMS 插件用于与远程 KMS 通信的认证凭据，都由 KMS 插件独立地存储和管理。 KMS 插件可以用额外的元数据对密文进行编码，这些元数据是在把它发往 KMS 进行解密之前可能要用到的。

### 部署 KMS 插件 

确保 KMS 插件与 Kubernetes 主服务器运行在同一主机上。

使用 KMS 驱动加密数据
-------------

为了加密数据：

1.  使用 ​`kms` ​驱动的相应的属性创建一个新的加密配置文件：

`kind: EncryptionConfiguration apiVersion: apiserver.config.k8s.io/v1 resources:   - resources:     - secrets     providers:     - kms:         name: myKmsPlugin         endpoint: unix:///tmp/socketfile.sock         cachesize: 100         timeout: 3s     - identity: {}`

3.  设置 kube-apiserver 的 ​`--encryption-provider-config`​ 参数指向配置文件的位置。
4.  重启 API 服务器。

验证数据已经加密 
---------

写入 etcd 时数据被加密。重启 kube-apiserver 后，任何新建或更新的 Secret 在存储时应该已被加密。 要验证这点，你可以用 etcdctl 命令行程序获取 Secret 内容。

1.  在默认的命名空间里创建一个名为 secret1 的 Secret：

`kubectl create secret generic secret1 -n default --from-literal=mykey=mydata`

3.  用 etcdctl 命令行，从 etcd 读取出 Secret：

`ETCDCTL_API=3 etcdctl get /kubernetes.io/secrets/default/secret1 [...] | hexdump -C`

其中 ​`[...]`​ 是用于连接 etcd 服务器的额外参数。

6.  验证保存的 Secret 是否是以 ​`k8s:enc:kms:v1:`​ 开头的，这表明 ​`kms` ​驱动已经对结果数据加密。
7.  验证 Secret 在被 API 获取时已被正确解密：

`kubectl describe secret secret1 -n default`

结果应该是 ​`mykey: mydata`​。

确保所有 Secret 都已被加密
-----------------

因为 Secret 是在写入时被加密的，所以在更新 Secret 时也会加密该内容。

下列命令读取所有 Secret 并更新它们以便应用服务器端加密。如果因为写入冲突导致错误发生， 请重试此命令。对较大的集群，你可能希望根据命名空间或脚本更新去细分 Secret 内容。

`kubectl get secrets --all-namespaces -o json | kubectl replace -f -`

从本地加密驱动切换到 KMS 驱动 
------------------

为了从本地加密驱动切换到 ​`kms` ​驱动并重新加密所有 Secret 内容：

1.  在配置文件中加入 ​`kms` ​驱动作为第一个条目，如下列样例所示

`kind: EncryptionConfiguration apiVersion: apiserver.config.k8s.io/v1 resources:   - resources:     - secrets     providers:     - kms:         name : myKmsPlugin         endpoint: unix:///tmp/socketfile.sock         cachesize: 100     - aescbc:          keys:          - name: key1            secret: <BASE 64 ENCODED SECRET>`

3.  重启所有 kube-apiserver 进程。
4.  运行下列命令使用 ​`kms` ​驱动强制重新加密所有 Secret。

`kubectl get secrets --all-namespaces -o json| kubectl replace -f -`

禁用静态数据加密
--------

要禁用静态数据加密：

1.  将 ​`identity` ​驱动作为配置文件中的第一个条目：

`kind: EncryptionConfiguration apiVersion: apiserver.config.k8s.io/v1 resources:   - resources:     - secrets     providers:     - identity: {}     - kms:         name : myKmsPlugin         endpoint: unix:///tmp/socketfile.sock         cachesize: 100`

3.  重启所有 kube-apiserver 进程。
4.  运行下列命令强制重新加密所有 Secret。

`kubectl get secrets --all-namespaces -o json | kubectl replace -f -`

##  33.  Kubernetes 使用Kubernetes API访问集群
使用 Kubernetes API 访问集群
----------------------

本页展示了如何使用 Kubernetes API 访问集群

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

要检查版本，请输入 ​`kubectl version`​。

访问集群 API
--------

### 使用 kubectl 进行首次访问

首次访问 Kubernetes API 时，请使用 Kubernetes 命令行工具 ​`kubectl` ​。

要访问集群，你需要知道集群位置并拥有访问它的凭证。 通常，当你完成入门指南时，这会自动设置完成，或者由其他人设置好集群并将凭证和位置提供给你。

使用此命令检查 kubectl 已知的位置和凭证：

`kubectl config view`

许多[样例](https://github.com/kubernetes/examples/tree/master/) 提供了使用 kubectl 的介绍。

### 直接访问 REST API

kubectl 处理对 API 服务器的定位和身份验证。如果你想通过 http 客户端（如 ​`curl` ​或 ​`wget`​，或浏览器）直接访问 REST API，你可以通过多种方式对 API 服务器进行定位和身份验证：

1.  以代理模式运行 kubectl（推荐）。 推荐使用此方法，因为它用存储的 apiserver 位置并使用自签名证书验证 API 服务器的标识。 使用这种方法无法进行中间人（MITM）攻击。
2.  另外，你可以直接为 HTTP 客户端提供位置和身份认证。 这适用于被代理混淆的客户端代码。 为防止中间人攻击，你需要将根证书导入浏览器。

使用 Go 或 Python 客户端库可以在代理模式下访问 kubectl。

#### 使用 kubectl 代理

下列命令使 kubectl 运行在反向代理模式下。它处理 API 服务器的定位和身份认证。

像这样运行它：

`kubectl proxy --port=8080 &`

参见 [kubectl 代理](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=) 获取更多细节。

然后你可以通过 curl，wget，或浏览器浏览 API，像这样：

`curl http://localhost:8080/api/`

输出类似如下：

`{   "versions": [     "v1"   ],   "serverAddressByClientCIDRs": [     {       "clientCIDR": "0.0.0.0/0",       "serverAddress": "10.0.1.149:443"     }   ] }`

#### 不使用 kubectl 代理

通过将身份认证令牌直接传给 API 服务器，可以避免使用 kubectl 代理，像这样：

使用 ​`grep/cut`​ 方式：

`# 查看所有的集群，因为你的 .kubeconfig 文件中可能包含多个上下文 kubectl config view -o jsonpath='{"Cluster name\tServer\n"}{range .clusters[*]}{.name}{"\t"}{.cluster.server}{"\n"}{end}'  # 从上述命令输出中选择你要与之交互的集群的名称 export CLUSTER_NAME="some_server_name"  # 指向引用该集群名称的 API 服务器 APISERVER=$(kubectl config view -o jsonpath="{.clusters[?(@.name==\"$CLUSTER_NAME\")].cluster.server}")  # 创建一个 secret 来保存默认服务账户的令牌 kubectl apply -f - <<EOF apiVersion: v1 kind: Secret metadata:   name: default-token   annotations:     kubernetes.io/service-account.name: default type: kubernetes.io/service-account-token EOF  # 等待令牌控制器使用令牌填充 secret: while ! kubectl describe secret default-token | grep -E '^token' >/dev/null; do   echo "waiting for token..." >&2   sleep 1 done  # 获取令牌 TOKEN=$(kubectl get secret default-token -o jsonpath='{.data.token}' | base64 --decode)  # 使用令牌玩转 API curl -X GET $APISERVER/api --header "Authorization: Bearer $TOKEN" --insecure`

输出类似如下：

`{   "kind": "APIVersions",   "versions": [     "v1"   ],   "serverAddressByClientCIDRs": [     {       "clientCIDR": "0.0.0.0/0",       "serverAddress": "10.0.1.149:443"     }   ] }`

上面例子使用了 ​`--insecure`​ 标志位。这使它易受到 MITM 攻击。 当 kubectl 访问集群时，它使用存储的根证书和客户端证书访问服务器。 （已安装在 ​`~/.kube`​ 目录下）。 由于集群认证通常是自签名的，因此可能需要特殊设置才能让你的 http 客户端使用根证书。

在一些集群中，API 服务器不需要身份认证；它运行在本地，或由防火墙保护着。 对此并没有一个标准。

### 编程方式访问 API

Kubernetes 官方支持 ​`Go`​、​`Python`​、​`Java`​、 ​`dotnet`​、​`JavaScript` ​和 ​`Haskell` ​语言的客户端库。还有一些其他客户端库由对应作者而非 Kubernetes 团队提供并维护。

#### Go 客户端 

*   要获取库，运行下列命令：​`go get k8s.io/client-go/kubernetes-<kubernetes 版本号>`​， 参见 [https://github.com/kubernetes/client-go/releases](https://github.com/kubernetes/client-go/releases) 查看受支持的版本。
*   基于 client-go 客户端编写应用程序。

> Note: 注意 client-go 定义了自己的 API 对象，因此如果需要，请从 client-go 而不是主仓库导入 API 定义，例如 ​`import "k8s.io/client-go/kubernetes"`​ 是正确做法。

Go 客户端可以使用与 kubectl 命令行工具相同的 kubeconfig 文件 定位和验证 API 服务器。参见这个 [例子](https://git.k8s.io/client-go/examples/out-of-cluster-client-configuration/main.go)：

`package main  import (    "context"    "fmt"    "k8s.io/apimachinery/pkg/apis/meta/v1"    "k8s.io/client-go/kubernetes"    "k8s.io/client-go/tools/clientcmd" )  func main() {   // uses the current context in kubeconfig   // path-to-kubeconfig -- for example, /root/.kube/config   config, _ := clientcmd.BuildConfigFromFlags("", "<path-to-kubeconfig>")   // creates the clientset   clientset, _ := kubernetes.NewForConfig(config)   // access the API to list pods   pods, _ := clientset.CoreV1().Pods("").List(context.TODO(), v1.ListOptions{})   fmt.Printf("There are %d pods in the cluster\n", len(pods.Items)) }`

#### Python 客户端 

要使用 [Python 客户端](https://github.com/kubernetes-client/python)，运行下列命令： ​`pip install kubernetes`​。 参见 [Python 客户端库主页](https://github.com/kubernetes-client/python) 了解更多安装选项。

Python 客户端可以使用与 kubectl 命令行工具相同的 kubeconfig 文件 定位和验证 API 服务器。参见这个 [例子](https://github.com/kubernetes-client/python/blob/master/examples/out_of_cluster_config.py)：

`from kubernetes import client, config  config.load_kube_config()  v1=client.CoreV1Api() print("Listing pods with their IPs:") ret = v1.list_pod_for_all_namespaces(watch=False) for i in ret.items:     print("%s\t%s\t%s" % (i.status.pod_ip, i.metadata.namespace, i.metadata.name))`

#### Java 客户端 

要安装 [Java 客户端](https://github.com/kubernetes-client/java)，运行：

`# 克隆 Java 库 git clone --recursive https://github.com/kubernetes-client/java  # 安装项目文件、POM 等 cd java mvn install`

参阅[https://github.com/kubernetes-client/java/releases](https://github.com/kubernetes-client/java/releases) 了解当前支持的版本。

Java 客户端可以使用 kubectl 命令行所使用的 kubeconfig 文件 以定位 API 服务器并向其认证身份。 参看此[示例](https://github.com/kubernetes-client/java/blob/master/examples/src/main/java/io/kubernetes/client/examples/KubeConfigFileClientExample.java)：

`package io.kubernetes.client.examples;  import io.kubernetes.client.ApiClient; import io.kubernetes.client.ApiException; import io.kubernetes.client.Configuration; import io.kubernetes.client.apis.CoreV1Api; import io.kubernetes.client.models.V1Pod; import io.kubernetes.client.models.V1PodList; import io.kubernetes.client.util.ClientBuilder; import io.kubernetes.client.util.KubeConfig; import java.io.FileReader; import java.io.IOException;  /**  * A simple example of how to use the Java API from an application outside a kubernetes cluster  *  * <p>Easiest way to run this: mvn exec:java  * -Dexec.mainClass="io.kubernetes.client.examples.KubeConfigFileClientExample"  *  */ public class KubeConfigFileClientExample {   public static void main(String[] args) throws IOException, ApiException {      // file path to your KubeConfig     String kubeConfigPath = "~/.kube/config";      // loading the out-of-cluster config, a kubeconfig from file-system     ApiClient client =         ClientBuilder.kubeconfig(KubeConfig.loadKubeConfig(new FileReader(kubeConfigPath))).build();      // set the global default api-client to the in-cluster one from above     Configuration.setDefaultApiClient(client);      // the CoreV1Api loads default api-client from global configuration.     CoreV1Api api = new CoreV1Api();      // invokes the CoreV1Api client     V1PodList list = api.listPodForAllNamespaces(null, null, null, null, null, null, null, null, null);     System.out.println("Listing all pods: ");     for (V1Pod item : list.getItems()) {       System.out.println(item.getMetadata().getName());     }   } }`

#### .Net 客户端 

要使用[.Net 客户端](https://github.com/kubernetes-client/csharp)，运行下面的命令： ​`dotnet add package KubernetesClient --version 1.6.1`​。 参见[.Net 客户端库页面](https://github.com/kubernetes-client/csharp)了解更多安装选项。 关于可支持的版本，参见[https://github.com/kubernetes-client/csharp/releases](https://github.com/kubernetes-client/csharp/releases)。

.Net 客户端可以使用与 kubectl CLI 相同的 kubeconfig 文件 来定位并验证 API 服务器。 参见[样例](https://github.com/kubernetes-client/csharp/blob/master/examples/simple/PodList.cs):

`using System; using k8s;  namespace simple {     internal class PodList     {         private static void Main(string[] args)         {             var config = KubernetesClientConfiguration.BuildDefaultConfig();             IKubernetes client = new Kubernetes(config);             Console.WriteLine("Starting Request!");              var list = client.ListNamespacedPod("default");             foreach (var item in list.Items)             {                 Console.WriteLine(item.Metadata.Name);             }             if (list.Items.Count == 0)             {                 Console.WriteLine("Empty!");             }         }     } }`

#### JavaScript 客户端 

要安装 [JavaScript 客户端](https://github.com/kubernetes-client/javascript)，运行下面的命令： ​`npm install @kubernetes/client-node`​。 参考[https://github.com/kubernetes-client/javascript/releases](https://github.com/kubernetes-client/javascript/releases)了解可支持的版本。

JavaScript 客户端可以使用 kubectl 命令行所使用的 kubeconfig 文件 以定位 API 服务器并向其认证身份。 参见[此例](https://github.com/kubernetes-client/javascript/blob/master/examples/example.js)：

`const k8s = require('@kubernetes/client-node');  const kc = new k8s.KubeConfig(); kc.loadFromDefault();  const k8sApi = kc.makeApiClient(k8s.CoreV1Api);  k8sApi.listNamespacedPod('default').then((res) => {     console.log(res.body); });`

#### Haskell 客户端 

参考 [https://github.com/kubernetes-client/haskell/releases](https://github.com/kubernetes-client/haskell/releases) 了解支持的版本。

[Haskell 客户端](https://github.com/kubernetes-client/haskell) 可以使用 kubectl 命令行所使用的 kubeconfig 文件 以定位 API 服务器并向其认证身份。 参见[此例](https://github.com/kubernetes-client/haskell/blob/master/kubernetes-client/example/App.hs)：

`exampleWithKubeConfig :: IO () exampleWithKubeConfig = do     oidcCache <- atomically $ newTVar $ Map.fromList []     (mgr, kcfg) <- mkKubeClientConfig oidcCache $ KubeConfigFile "/path/to/kubeconfig"     dispatchMime             mgr             kcfg             (CoreV1.listPodForAllNamespaces (Accept MimeJSON))         >>= print`

##  34.  Kubernetes 使用NUMA感知的内存管理器
使用 NUMA 感知的内存管理器
----------------

FEATURE STATE: Kubernetes v1.22 \[beta\]

Kubernetes 内存管理器（Memory Manager）为 ​`Guaranteed` ​QoS 类 的 Pods 提供可保证的内存（及大页面）分配能力。

内存管理器使用提示生成协议来为 Pod 生成最合适的 NUMA 亲和性配置。 内存管理器将这类亲和性提示输入给中央管理器（即 Topology Manager）。 基于所给的提示和 Topology Manager（拓扑管理器）的策略设置，Pod 或者会被某节点接受，或者被该节点拒绝。

此外，内存管理器还确保 Pod 所请求的内存是从尽量少的 NUMA 节点分配而来。

内存管理器仅能用于 Linux 主机。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](http://labs.play-with-k8s.com/)

您的 Kubernetes 服务器必须是 v1.21 或更高版本。 要检查版本，请输入 ​`kubectl version`​。

为了使得内存资源与 Pod 规约中所请求的其他资源对齐：

*   CPU 管理器应该被启用，并且在节点（Node）上要配置合适的 CPU 管理器策略。
*   拓扑管理器要被启用，并且要在节点上配置合适的拓扑管理器策略。

从 v1.22 开始，内存管理器通过 特性门控 ​`MemoryManager` ​默认启用。

在 v1.22 之前，​`kubelet` ​必须在启动时设置如下标志：

​`--feature-gates=MemoryManager=true` ​

这样内存管理器特性才会被启用。

内存管理器如何运作？
----------

内存管理器目前为 Guaranteed QoS 类中的 Pod 提供可保证的内存（和大页面）分配能力。 若要立即将内存管理器启用，可参照本节的指南， 之后按本节中所展示的，准备并部署一个 ​`Guaranteed`​ Pod。

内存管理器是一个提示驱动组件（Hint Provider），负责为拓扑管理器提供拓扑提示， 后者根据这些拓扑提示对所请求的资源执行对齐操作。 内存管理器也会为 Pods 应用 ​`cgroups` ​设置（即 ​`cpuset.mems`​）。 与 Pod 准入和部署流程相关的完整流程图在[Memory Manager KEP: Design Overview](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager target=) 和下面。

![](https://atts.w3cschool.cn/attachments/image/20220607/1654568767339360.svg)  

在这个过程中，内存管理器会更新其内部存储于[节点映射和内存映射](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager target=)中的计数器， 从而管理有保障的内存分配。

内存管理器在启动和运行期间按下述逻辑更新节点映射（Node Map）。

### 启动 

当节点管理员应用 ​`--reserved-memory`​ 预留内存标志时执行此逻辑。 这时，节点映射会被更新以反映内存的预留，如 [Memory Manager KEP: Memory Maps at start-up (with examples)](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager target=) 所说明。

当配置了 ​`Static` ​策略时，管理员必须提供 ​`--reserved-memory`​ 标志设置。

### 运行时 

参考文献 [Memory Manager KEP: Memory Maps at runtime (with examples)](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager target=) 中说明了成功的 Pod 部署是如何影响节点映射的，该文档也解释了可能发生的内存不足 （Out-of-memory，OOM）情况是如何进一步被 Kubernetes 或操作系统处理的。

在内存管理器运作的语境中，一个重要的话题是对 NUMA 分组的管理。 每当 Pod 的内存请求超出单个 NUMA 节点容量时，内存管理器会尝试创建一个包含多个 NUMA 节点的分组，从而扩展内存容量。解决这个问题的详细描述在文档 [Memory Manager KEP: How to enable the guaranteed memory allocation over many NUMA nodes?](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager target=) 中。同时，关于 NUMA 分组是如何管理的，你还可以参考文档 [Memory Manager KEP: Simulation - how the Memory Manager works? (by examples)](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager target=)。

内存管理器配置 
--------

其他管理器也要预先配置。接下来，内存管理器特性需要被启用， 并且采用 ​`Static` ​策略（静态策略）运行。 作为可选操作，可以预留一定数量的内存给系统或者 kubelet 进程以增强节点的 稳定性（预留内存标志）。

### 策略 

内存管理器支持两种策略。你可以通过 ​`kubelet` ​标志 ​`--memory-manager-policy`​ 来 选择一种策略：

*   ​`None` ​（默认）
*   ​`Static`​

#### None 策略 

这是默认的策略，并且不会以任何方式影响内存分配。该策略的行为好像内存管理器不存在一样。

​`None` ​策略返回默认的拓扑提示信息。这种特殊的提示会表明拓扑驱动组件（Hint Provider） （在这里是内存管理器）对任何资源都没有与 NUMA 亲和性关联的偏好。

#### Static 策略 

对 ​`Guaranteed` ​Pod 而言，​`Static` ​内存管理器策略会返回拓扑提示信息，该信息 与内存分配有保障的 NUMA 节点集合有关，并且内存管理器还通过更新内部的 [节点映射](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager target=) 对象来完成内存预留。

对 ​`BestEffort` ​或 ​`Burstable` ​Pod 而言，因为不存在对有保障的内存资源的请求， ​`Static` ​内存管理器策略会返回默认的拓扑提示，并且不会通过内部的[节点映射](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager target=)对象 来预留内存。

### 预留内存标志 

节点可分配机制通常 被节点管理员用来为 kubelet 或操作系统进程预留 K8S 节点上的系统资源，目的是提高节点稳定性。 有一组专用的标志可用于这个目的，为节点设置总的预留内存量。 此预配置的值接下来会被用来计算节点上对 Pods “可分配的”内存。

Kubernetes 调度器在优化 Pod 调度过程时，会考虑“可分配的”内存。 前面提到的标志包括 ​`--kube-reserved`​、​`--system-reserved`​ 和 ​`--eviction-threshold`​。 这些标志值的综合计作预留内存的总量。

为内存管理器而新增加的 ​`--reserved-memory`​ 标志可以（让节点管理员）将总的预留内存进行划分， 并完成跨 NUMA 节点的预留操作。

标志设置的值是一个按 NUMA 节点的不同内存类型所给的内存预留的值的列表，用逗号分开。 可以使用分号作为分隔符来指定跨多个 NUMA 节点的内存预留。 只有在内存管理器特性被启用的语境下，这个参数才有意义。 内存管理器不会使用这些预留的内存来为容器负载分配内存。

例如，如果你有一个可用内存为 10Gi 的 NUMA 节点 "NUMA0"，而参数 ​`--reserved-memory`​ 被设置成要在 "NUMA0" 上预留 1Gi 的内存，那么内存管理器会假定节点上只有 9Gi 内存可用于容器负载。

你也可以忽略此参数，不过这样做时，你要清楚，所有 NUMA 节点上预留内存的数量要等于 节点可分配特性 所设定的内存量。如果至少有一个节点可分配参数值为非零，你就需要至少为一个 NUMA 节点设置 ​`--reserved-memory`​。实际上，​`eviction-hard`​ 阈值默认为 100Mi， 所以当使用 ​`Static` ​策略时，​`--reserved-memory`​ 是必须设置的。

此外，应尽量避免如下配置：

1.  重复的配置，即同一 NUMA 节点或内存类型被设置不同的取值；
2.  为某种内存类型设置约束值为零；
3.  使用物理硬件上不存在的 NUMA 节点 ID；
4.  使用名字不是 ​`memory` ​或 ​`hugepages-<size>`​ 的内存类型名称 （特定的 ​`<size>`​ 的大页面也必须存在）。

语法：

​`--reserved-memory N:memory-type1=value1,memory-type2=value2,...`​

*   ​`N`​（整数）- NUMA 节点索引，例如，​`0`​
*   ​`memory-type`​（字符串）- 代表内存类型：

*   ​`memory` ​- 常规内存；
*   ​`hugepages-2Mi`​ 或 ​`hugepages-1Gi`​ - 大页面

*   ​`value`​（字符串） - 预留内存的量，例如 ​`1Gi`​

用法示例：

​`--reserved-memory 0:memory=1Gi,hugepages-1Gi=2Gi`​

或者

​`--reserved-memory 0:memory=1Gi --reserved-memory 1:memory=2Gi`​

当你为 ​`--reserved-memory`​ 标志指定取值时，必须要遵从之前通过节点可分配特性标志所设置的值。 换言之，对每种内存类型而言都要遵从下面的规则：

​`sum(reserved-memory(i)) = kube-reserved + system-reserved + eviction-threshold` ​

其中，​`i`​ 是 NUMA 节点的索引。

如果你不遵守上面的公示，内存管理器会在启动时输出错误信息。

换言之，上面的例子我们一共要预留 ​`3Gi`​ 的常规内存（​`type=memory`​），即：

​`sum(reserved-memory(i)) = reserved-memory(0) + reserved-memory(1) = 1Gi + 2Gi = 3Gi` ​

下面的例子中给出与节点可分配配置相关的 kubelet 命令行参数：

*   ​`--kube-reserved=cpu=500m,memory=50Mi` ​
*   ​`--system-reserved=cpu=123m,memory=333Mi` ​
*   ​`--eviction-hard=memory.available<500Mi`​

> Note:  
> 默认的硬性驱逐阈值是 100MiB，不是零。 请记得在使用 ​`--reserved-memory`​ 设置要预留的内存量时，加上这个硬性驱逐阈值。 否则 kubelet 不会启动内存管理器，而会输出一个错误信息。

下面是一个正确配置的示例：

`--feature-gates=MemoryManager=true  --kube-reserved=cpu=4,memory=4Gi  --system-reserved=cpu=1,memory=1Gi  --memory-manager-policy=Static  --reserved-memory '0:memory=3Gi;1:memory=2148Mi'`

我们对上面的配置做一个检查：

1.  ​`kube-reserved + system-reserved + eviction-hard(default) = reserved-memory(0) + reserved-memory(1)` ​
2.  ​`4GiB + 1GiB + 100MiB = 3GiB + 2148MiB` ​
3.  ​`5120MiB + 100MiB = 3072MiB + 2148MiB` ​
4.  ​`5220MiB = 5220MiB`​ （这是对的）

将 Pod 放入 Guaranteed QoS 类 
--------------------------

若所选择的策略不是 ​`None`​，则内存管理器会辨识处于 ​`Guaranteed` ​QoS 类中的 Pod。 内存管理器为每个 ​`Guaranteed` ​Pod 向拓扑管理器提供拓扑提示信息。 对于不在 ​`Guaranteed` ​QoS 类中的其他 Pod，内存管理器向拓扑管理器提供默认的 拓扑提示信息。

下面的来自 Pod 清单的片段将 Pod 加入到 ​`Guaranteed` ​QoS 类中。

当 Pod 的 CPU ​`requests` ​等于 ​`limits` ​且为整数值时，Pod 将运行在 ​`Guaranteed` ​QoS 类中。

`spec:   containers:   - name: nginx     image: nginx     resources:       limits:         memory: "200Mi"         cpu: "2"         example.com/device: "1"       requests:         memory: "200Mi"         cpu: "2"         example.com/device: "1"`

此外，共享 CPU 的 Pods 在 ​`requests` ​等于 ​`limits` ​值时也运行在 ​`Guaranteed` ​QoS 类中。

`spec:   containers:   - name: nginx     image: nginx     resources:       limits:         memory: "200Mi"         cpu: "300m"         example.com/device: "1"       requests:         memory: "200Mi"         cpu: "300m"         example.com/device: "1"`

要注意的是，只有 CPU 和内存请求都被设置时，Pod 才会进入 Guaranteed QoS 类。

故障排查 
-----

下面的方法可用来排查为什么 Pod 无法被调度或者被节点拒绝：

*   Pod 状态 - 可表明拓扑亲和性错误
*   系统日志 - 包含用来调试的有价值的信息，例如，关于所生成的提示信息
*   状态文件 - 其中包含内存管理器内部状态的转储（包含[节点映射和内存映射](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager target=)）
*   从 v1.22 开始，设备插件资源 API 可以用来 检索关于为容器预留的内存的信息

### Pod 状态 （TopologyAffinityError） 

这类错误通常在以下情形出现：

*   节点缺少足够的资源来满足 Pod 请求
*   Pod 的请求因为特定的拓扑管理器策略限制而被拒绝

错误信息会出现在 Pod 的状态中：

`kubectl get pods`

`NAME         READY   STATUS                  RESTARTS   AGE guaranteed   0/1     TopologyAffinityError   0          113s`

使用 ​`kubectl describe pod <id>`​ 或 ​`kubectl get events`​ 可以获得详细的错误信息。

`Warning  TopologyAffinityError  10m   kubelet, dell8  Resources cannot be allocated with Topology locality`

### 系统日志 

针对特定的 Pod 搜索系统日志。

内存管理器为 Pod 所生成的提示信息可以在日志中找到。 此外，日志中应该也存在 CPU 管理器所生成的提示信息。

拓扑管理器将这些提示信息进行合并，计算得到唯一的最合适的提示数据。 此最佳提示数据也应该出现在日志中。

最佳提示表明要在哪里分配所有的资源。拓扑管理器会用当前的策略来测试此数据， 并基于得出的结论或者接纳 Pod 到节点，或者将其拒绝。

此外，你可以搜索日志查找与内存管理器相关的其他条目，例如 ​`cgroups`​ 和 ​`cpuset.mems`​ 的更新信息等。

### 检查节点上内存管理器状态

我们首先部署一个 ​`Guaranteed` ​Pod 示例，其规约如下所示：

`apiVersion: v1 kind: Pod metadata:   name: guaranteed spec:   containers:   - name: guaranteed     image: consumer     imagePullPolicy: Never     resources:       limits:         cpu: "2"         memory: 150Gi       requests:         cpu: "2"         memory: 150Gi     command: ["sleep","infinity"]`

接下来，我们登录到 Pod 运行所在的节点，检查位于 ​`/var/lib/kubelet/memory_manager_state`​ 的状态文件：

`{    "policyName":"Static",    "machineState":{       "0":{          "numberOfAssignments":1,          "memoryMap":{             "hugepages-1Gi":{                "total":0,                "systemReserved":0,                "allocatable":0,                "reserved":0,                "free":0             },             "memory":{                "total":134987354112,                "systemReserved":3221225472,                "allocatable":131766128640,                "reserved":131766128640,                "free":0             }          },          "nodes":[             0,             1          ]       },       "1":{          "numberOfAssignments":1,          "memoryMap":{             "hugepages-1Gi":{                "total":0,                "systemReserved":0,                "allocatable":0,                "reserved":0,                "free":0             },             "memory":{                "total":135286722560,                "systemReserved":2252341248,                "allocatable":133034381312,                "reserved":29295144960,                "free":103739236352             }          },          "nodes":[             0,             1          ]       }    },    "entries":{       "fa9bdd38-6df9-4cf9-aa67-8c4814da37a8":{          "guaranteed":[             {                "numaAffinity":[                   0,                   1                ],                "type":"memory",                "size":161061273600             }          ]       }    },    "checksum":4142013182 }`

从这个状态文件，可以推断 Pod 被同时绑定到两个 NUMA 节点，即：

`"numaAffinity":[    0,    1 ],`

术语绑定（pinned）意味着 Pod 的内存使用被（通过 ​`cgroups` ​配置）限制到 这些 NUMA 节点。

这也直接意味着内存管理器已经创建了一个 NUMA 分组，由这两个 NUMA 节点组成， 即索引值分别为 ​`0`​ 和 ​`1`​ 的 NUMA 节点。

注意 NUMA 分组的管理是有一个相对复杂的管理器处理的，相关逻辑的进一步细节可在内存管理器的 KEP 中[示例1](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager target=)和[跨 NUMA 节点](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager target=)节找到。

为了分析 NUMA 组中可用的内存资源，必须对分组内 NUMA 节点对应的条目进行汇总。

例如，NUMA 分组中空闲的“常规”内存的总量可以通过将分组内所有 NUMA 节点上空闲内存加和来计算，即将 NUMA 节点 ​`0`​ 和 NUMA 节点 ​`1`​ 的 ​`"memory"`​ 节 （分别是 ​`"free":0`​ 和 ​`"free": 103739236352`​）相加，得到此分组中空闲的“常规” 内存总量为 ​`0 + 103739236352`​ 字节。

​`"systemReserved": 3221225472`​ 这一行表明节点的管理员使用 ​`--reserved-memory`​ 为 NUMA 节点 ​`0`​ 上运行的 kubelet 和系统进程预留了 ​`3221225472` ​字节 （即 ​`3Gi`​）。

### 设备插件资源 API 

通过使用此 API， 可以获得每个容器的预留内存信息，该信息位于 protobuf 协议的 ​`ContainerMemory` ​消息中。 只能针对 Guaranteed QoS 类中的 Pod 来检索此信息。

##  35.  Kubernetes 保护集群
保护集群  

本文档涉及与保护集群免受意外或恶意访问有关的主题，并对总体安全性提出建议。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

要检查版本，请输入 ​`kubectl version`​。

控制对 Kubernetes API 的访问
----------------------

因为 Kubernetes 是完全通过 API 驱动的，所以，控制和限制谁可以通过 API 访问集群， 以及允许这些访问者执行什么样的 API 动作，就成为了安全控制的第一道防线。

### 为所有 API 交互使用传输层安全 （TLS）

Kubernetes 期望集群中所有的 API 通信在默认情况下都使用 TLS 加密， 大多数安装方法也允许创建所需的证书并且分发到集群组件中。 请注意，某些组件和安装方法可能使用 HTTP 来访问本地端口， 管理员应该熟悉每个组件的设置，以识别可能不安全的流量。

### API 认证 

安装集群时，选择一个 API 服务器的身份验证机制，去使用与之匹配的公共访问模式。 例如，小型的单用户集群可能希望使用简单的证书或静态承载令牌方法。 更大的集群则可能希望整合现有的、OIDC、LDAP 等允许用户分组的服务器。

所有 API 客户端都必须经过身份验证，即使它是基础设施的一部分，比如节点、代理、调度程序和卷插件。 这些客户端通常使用 服务帐户 或 X509 客户端证书，并在集群启动时自动创建或是作为集群安装的一部分进行设置。

### API 授权

一旦通过身份认证，每个 API 的调用都将通过鉴权检查。 Kubernetes 集成基于角色的访问控制（RBAC）组件， 将传入的用户或组与一组绑定到角色的权限匹配。 这些权限将动作（get、create、delete）和资源（Pod、Service、Node）进行组合，并可在名字空间或者集群范围生效。 Kubernetes 提供了一组可直接使用的角色，这些角色根据客户可能希望执行的操作提供合理的责任划分。 建议你同时使用 Node 和 RBAC 两个鉴权组件，再与 NodeRestriction 准入插件结合使用。

与身份验证一样，简单而广泛的角色可能适合于较小的集群，但是随着更多的用户与集群交互， 可能需要将团队划分到有更多角色限制的、 单独的名字空间中去。

就鉴权而言，很重要的一点是理解对象上的更新操作如何导致在其它地方发生对应行为。 例如，用户可能不能直接创建 Pod，但允许他们通过创建 Deployment 来创建这些 Pod， 这将让他们间接创建这些 Pod。 同样地，从 API 删除一个节点将导致调度到这些节点上的 Pod 被中止，并在其他节点上重新创建。 原生的角色设计代表了灵活性和常见用例之间的平衡，但须限制的角色应该被仔细审查， 以防止意外的权限升级。如果内置的角色无法满足你的需求，则可以根据使用场景需要创建特定的角色。

控制对 Kubelet 的访问 
----------------

Kubelet 公开 HTTPS 端点，这些端点提供了对节点和容器的强大的控制能力。 默认情况下，Kubelet 允许对此 API 进行未经身份验证的访问。

生产级别的集群应启用 Kubelet 身份认证和授权。

控制运行时负载或用户的能力
-------------

Kubernetes 中的授权故意设计成较高抽象级别，侧重于对资源的粗粒度行为。 更强大的控制是 策略 的形式呈现的，根据使用场景限制这些对象如何作用于集群、自身和其他资源。

### 限制集群上的资源使用

资源配额（Resource Quota）限制了赋予命名空间的资源的数量或容量。 资源配额通常用于限制名字空间可以分配的 CPU、内存或持久磁盘的数量， 但也可以控制每个名字空间中存在多少个 Pod、Service 或 Volume。

限制范围（Limit Range） 限制上述某些资源的最大值或者最小值，以防止用户使用类似内存这样的通用保留资源时请求不合理的过高或过低的值， 或者在没有指定的情况下提供默认限制。

### 控制容器运行的特权

Pod 定义包含了一个安全上下文， 用于描述一些访问请求，如以某个节点上的特定 Linux 用户（如 root）身份运行， 以特权形式运行，访问主机网络，以及一些在宿主节点上不受约束地运行的其它控制权限等等。

你可以配置 Pod 安全准入来在某个 名字空间中 强制实施特定的 Pod 安全标准（Pod Security Standard）， 或者检查安全上的缺陷。

一般来说，大多数应用程序需要对主机资源的有限制的访问， 这样它们可以在不访问主机信息的情况下，成功地以 root 账号（UID 0）运行。 但是，考虑到与 root 用户相关的特权，在编写应用程序容器时，你应该使用非 root 用户运行。 类似地，希望阻止客户端应用程序从其容器中逃逸的管理员，应该应用 Baseline 或 Restricted Pod 安全标准。

### 限制网络访问

基于名字空间的网络策略 允许应用程序作者限制其它名字空间中的哪些 Pod 可以访问自身名字空间内的 Pod 和端口。 现在已经有许多支持网络策略的 Kubernetes 网络驱动。

配额（Quota）和限制范围（Limit Range）也可用于控制用户是否可以请求节点端口或负载均衡服务。 在很多集群上，节点端口和负载均衡服务也可控制用户的应用程序是否在集群之外可见。

此外也可能存在一些基于插件或基于环境的网络规则，能够提供额外的保护能力。 例如各节点上的防火墙、物理隔离集群节点以防止串扰或者高级的网络策略等。

### 限制云元数据 API 访问

云平台（AWS, Azure, GCE 等）经常将 metadata 本地服务暴露给实例。 默认情况下，这些 API 可由运行在实例上的 Pod 访问，并且可以包含 该云节点的凭据或配置数据（如 kubelet 凭据）。 这些凭据可以用于在集群内升级或在同一账户下升级到其他云服务。

在云平台上运行 Kubernetes 时，需要限制对实例凭据的权限，使用 网络策略 限制 Pod 对元数据 API 的访问，并避免使用配置数据来传递机密信息。

### 控制 Pod 可以访问的节点 

默认情况下，对 Pod 可以运行在哪些节点上是没有任何限制的。 Kubernetes 给最终用户提供了 一组丰富的策略用于控制 Pod 所放置的节点位置， 以及基于污点的 Pod 放置和驱逐。 对于许多集群，使用这些策略来分离工作负载可以作为一种约定，要求作者遵守或者通过工具强制。

对于管理员，Beta 阶段的准入插件 ​`PodNodeSelector`​ 可用于强制某名字空间中的 Pod 使用默认的或特定的节点选择算符。 如果最终用户无法改变名字空间，这一机制可以有效地限制特定工作负载中所有 Pod 的放置位置。

保护集群组件免受破坏 
-----------

本节描述保护集群免受破坏的一些常用模式。

### 限制访问 etcd

拥有对 API 的 etcd 后端的写访问权限相当于获得了整个集群的 root 权限， 读访问权限也可能被利用，实现相当快速的权限提升。 对于从 API 服务器访问其 etcd 服务器，管理员应该总是使用比较强的凭证，如通过 TLS 客户端证书来实现双向认证。 通常，我们建议将 etcd 服务器隔离到只有 API 服务器可以访问的防火墙后面。

> Caution: 允许集群中其它组件对整个主键空间（keyspace）拥有读或写权限去访问 etcd 实例， 相当于授予这些组件集群管理员的访问权限。 对于非主控组件，强烈推荐使用不同的 etcd 实例，或者使用 etcd 的访问控制列表 来限制这些组件只能读或写主键空间的一个子集。

### 启用审计日志

审计日志是 Beta 特性， 负责记录 API 操作以便在发生破坏时进行事后分析。 建议启用审计日志，并将审计文件归档到安全服务器上。

### 限制使用 alpha 和 beta 特性

Kubernetes 的 alpha 和 beta 特性还在努力开发中，可能存在导致安全漏洞的缺陷或错误。 要始终评估 alpha 和 beta 特性可能给你的安全态势带来的风险。 当你怀疑存在风险时，可以禁用那些不需要使用的特性。

### 经常轮换基础设施证书

一项机密信息或凭据的生命期越短，攻击者就越难使用该凭据。 在证书上设置较短的生命期并实现自动轮换是控制安全的一个好方法。 使用身份验证提供程序时，应该使用那些可以控制所发布令牌的合法时长的提供程序， 并尽可能设置较短的生命期。 如果在外部集成场景中使用服务帐户令牌，则应该经常性地轮换这些令牌。 例如，一旦引导阶段完成，就应该撤销用于配置节点的引导令牌，或者取消它的授权。

### 在启用第三方集成之前，请先审查它们 

许多集成到 Kubernetes 的第三方软件或服务都可能改变你的集群的安全配置。 启用集成时，在授予访问权限之前，你应该始终检查扩展所请求的权限。 例如，许多安全性集成中可能要求查看集群上的所有 Secret 的访问权限， 本质上该组件便成为了集群的管理员。 当有疑问时，如果可能的话，将要集成的组件限制在某指定名字空间中运行。

如果执行 Pod 创建操作的组件能够在 ​`kube-system`​ 这类名字空间中创建 Pod， 则这类组件也可能获得意外的权限，因为这些 Pod 可以访问服务账户的 Secret， 或者，如果对应服务帐户被授权访问宽松的 PodSecurityPolicy， 它们就能以较高的权限运行。

如果你使用 Pod 安全准入， 并且允许任何组件在一个允许执行特权 Pod 的名字空间中创建 Pod，这些 Pod 就可能从所在的容器中逃逸，利用被拓宽的访问权限来实现特权提升。

你不应该允许不可信的组件在任何系统名字空间（名字以 ​`kube-`​ 开头）中创建 Pod， 也不允许它们在访问权限授权可被利用来提升特权的名字空间中创建 Pod。

### 对 Secret 进行静态加密

一般情况下，etcd 数据库包含了通过 Kubernetes API 可以访问到的所有信息， 并且可能为攻击者提供对你的集群的状态的较多的可见性。 你要始终使用经过充分审查的备份和加密方案来加密备份数据， 并考虑在可能的情况下使用全盘加密。

Kubernetes 支持静态数据加密。 该功能在 1.7 版本引入，并在 1.13 版本成为 Beta。 它会加密 etcd 里面的 ​`Secret`​ 资源，以防止某一方通过查看 etcd 的备份文件查看到这些 Secret 的内容。虽然目前该功能还只是 Beta 阶段， 在备份未被加密或者攻击者获取到 etcd 的读访问权限时，它仍能提供额外的防御层级。

### 接收安全更新和报告漏洞的警报

请加入 [kubernetes-announce](https://groups.google.com/g/kubernetes-announce) 组，这样你就能够收到有关安全公告的邮件。

##  36.  Kubernetes 关键插件Pod的调度保证
关键插件 Pod 的调度保证
--------------

Kubernetes 核心组件（如 API 服务器、调度器、控制器管理器）在控制平面节点上运行。 但是插件必须在常规集群节点上运行。 其中一些插件对于功能完备的集群至关重要，例如 Heapster、DNS 和 UI。 如果关键插件被逐出（手动或作为升级等其他操作的副作用）或者变成挂起状态，集群可能会停止正常工作。 关键插件进入挂起状态的例子有：集群利用率过高；被逐出的关键插件 Pod 释放了空间，但该空间被之前悬决的 Pod 占用；由于其它原因导致节点上可用资源的总量发生变化。

注意，把某个 Pod 标记为关键 Pod 并不意味着完全避免该 Pod 被逐出；它只能防止该 Pod 变成永久不可用。 被标记为关键性的静态 Pod 不会被逐出。但是，被标记为关键性的非静态 Pod 总是会被重新调度。

标记关键 Pod 
---------

要将 Pod 标记为关键性（critical），设置 Pod 的 priorityClassName 为 ​`system-cluster-critical`​ 或者 ​`system-node-critical`​。 ​`system-node-critical`​ 是最高级别的可用性优先级，甚至比 ​`system-cluster-critical`​ 更高。

##  37.  Kubernetes 升级集群
升级集群
----

本页概述升级 Kubernetes 集群的步骤。

升级集群的方式取决于你最初部署它的方式、以及后续更改它的方式。

从高层规划的角度看，要执行的步骤是：

*   升级控制平面
*   升级集群中的节点
*   升级 kubectl 之类的客户端
*   根据新 Kubernetes 版本带来的 API 变化，调整清单文件和其他资源

在开始之前
-----

你必须有一个集群。 本页内容涉及从 Kubernetes 1.23 升级到 Kubernetes 1.24。 如果你的集群未运行 Kubernetes 1.23， 那请参考目标 Kubernetes 版本的文档。

升级方法
----

### kubeadm

如果你的集群是使用 ​`kubeadm` ​安装工具部署而来， 那么升级集群的详细信息，请参阅 [升级 kubeadm 集群](https://www.w3cschool.cn/kubernetes/kubernetes-7psi3o9r.html)。

升级集群之后，要记得 安装最新版本的 ​`kubectl`​

### 手动部署

> Caution: 这些步骤不考虑第三方扩展，例如网络和存储插件。  

你应该跟随下面操作顺序，手动更新控制平面：

*   etcd (所有实例)
*   kube-apiserver (所有控制平面的宿主机)
*   kube-controller-manager
*   kube-scheduler
*   cloud controller manager, 在你用到时

现在，你应该 安装最新版本的 ​`kubectl`​.

对于集群中的每个节点， 排空 节点，然后，或者用一个运行了 1.24 kubelet 的新节点替换它； 或者升级此节点的 kubelet，并使节点恢复服务。

### 其他部署方式

参阅你的集群部署工具对应的文档，了解用于维护的推荐设置步骤。

升级后的任务
------

### 切换集群的存储 API 版本

对象序列化到 etcd，是为了提供集群中活动 Kubernetes 资源的内部表示法， 这些对象都使用特定版本的 API 编写。

当底层的 API 更改时，这些对象可能需要用新 API 重写。 如果不能做到这一点，会导致再也不能用 Kubernetes API 服务器解码、使用该对象。

对于每个受影响的对象，用最新支持的 API 获取它，然后再用最新支持的 API 写回来。

### 更新清单 

升级到新版本 Kubernetes 就可以提供新的 API。

你可以使用 ​`kubectl convert`​ 命令在不同 API 版本之间转换清单。 例如：

`kubectl convert -f pod.yaml --output-version v1`

​`kubectl` ​替换了 ​`pod.yaml`​ 的内容， 在新的清单文件中，​`kind` ​被设置为 Pod（未变）， 但 ​`apiVersion` ​则被修订了。

##  38.  Kubernetes 名字空间演练
名字空间演练
------

Kubernetes 名字空间 有助于不同的项目、团队或客户去共享 Kubernetes 集群。

名字空间通过以下方式实现这点：

1.  为名字设置作用域。
2.  为集群中的部分资源关联鉴权和策略的机制。

使用多个名字空间是可选的。

此示例演示了如何使用 Kubernetes 名字空间细分集群。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

要检查版本，请输入 kubectl version。

环境准备  

此示例作如下假设：

1.  你已拥有一个配置好的 Kubernetes 集群。
2.  你已对 Kubernetes 的 Pods、 Services 和 Deployments 有基本理解。

理解默认名字空间
--------

默认情况下，Kubernetes 集群会在配置集群时实例化一个默认名字空间，用以存放集群所使用的默认 Pod、Service 和 Deployment 集合。

假设你有一个新的集群，你可以通过执行以下操作来检查可用的名字空间：

`kubectl get namespaces`

`NAME      STATUS    AGE default   Active    13m`

创建新的名字空间
--------

在本练习中，我们将创建两个额外的 Kubernetes 名字空间来保存我们的内容。

我们假设一个场景，某组织正在使用共享的 Kubernetes 集群来支持开发和生产：

开发团队希望在集群中维护一个空间，以便他们可以查看用于构建和运行其应用程序的 Pod、Service 和 Deployment 列表。在这个空间里，Kubernetes 资源被自由地加入或移除， 对谁能够或不能修改资源的限制被放宽，以实现敏捷开发。

运维团队希望在集群中维护一个空间，以便他们可以强制实施一些严格的规程， 对谁可以或谁不可以操作运行生产站点的 Pod、Service 和 Deployment 集合进行控制。

该组织可以遵循的一种模式是将 Kubernetes 集群划分为两个名字空间：​`development` ​和 ​`production`​。

让我们创建两个新的名字空间来保存我们的工作。

文件 ​`[namespace-dev.json](https://kubernetes.io/examples/admin/namespace-dev.json)`​ 描述了 ​`development` ​名字空间:

`{   "apiVersion": "v1",   "kind": "Namespace",   "metadata": {     "name": "development",     "labels": {       "name": "development"     }   } }`

使用 kubectl 创建 ​`development` ​名字空间。

`kubectl create -f https://k8s.io/examples/admin/namespace-dev.json`

将下列的内容保存到文件 ​`[namespace-prod.json](https://kubernetes.io/examples/admin/namespace-prod.json)`​ 中， 这些内容是对 ​`production` ​名字空间的描述：

`{   "apiVersion": "v1",   "kind": "Namespace",   "metadata": {     "name": "production",     "labels": {       "name": "production"     }   } }`

让我们使用 kubectl 创建 ​`production` ​名字空间。

`kubectl create -f https://k8s.io/examples/admin/namespace-prod.json`

为了确保一切正常，我们列出集群中的所有名字空间。

`kubectl get namespaces --show-labels`

`NAME          STATUS    AGE       LABELS default       Active    32m       <none> development   Active    29s       name=development production    Active    23s       name=production`

在每个名字空间中创建 pod
--------------

Kubernetes 名字空间为集群中的 Pod、Service 和 Deployment 提供了作用域。

与一个名字空间交互的用户不会看到另一个名字空间中的内容。

为了演示这一点，让我们在 development 名字空间中启动一个简单的 Deployment 和 Pod。

我们首先检查一下当前的上下文：

`kubectl config view`

`apiVersion: v1 clusters: - cluster:     certificate-authority-data: REDACTED     server: https://130.211.122.180   name: lithe-cocoa-92103_kubernetes contexts: - context:     cluster: lithe-cocoa-92103_kubernetes     user: lithe-cocoa-92103_kubernetes   name: lithe-cocoa-92103_kubernetes current-context: lithe-cocoa-92103_kubernetes kind: Config preferences: {} users: - name: lithe-cocoa-92103_kubernetes   user:     client-certificate-data: REDACTED     client-key-data: REDACTED     token: 65rZW78y8HbwXXtSXuUw9DbP4FLjHi4b - name: lithe-cocoa-92103_kubernetes-basic-auth   user:     password: h5M0FtUUIflBSdI7     username: admin`

`kubectl config current-context`

`lithe-cocoa-92103_kubernetes`

下一步是为 kubectl 客户端定义一个上下文，以便在每个名字空间中工作。 "cluster" 和 "user" 字段的值将从当前上下文中复制。

`kubectl config set-context dev --namespace=development \   --cluster=lithe-cocoa-92103_kubernetes \   --user=lithe-cocoa-92103_kubernetes  kubectl config set-context prod --namespace=production \   --cluster=lithe-cocoa-92103_kubernetes \   --user=lithe-cocoa-92103_kubernetes`

默认情况下，上述命令会添加两个上下文到 ​`.kube/config`​ 文件中。 你现在可以查看上下文并根据你希望使用的名字空间并在这两个新的请求上下文之间切换。

查看新的上下文：

`kubectl config view`

`apiVersion: v1 clusters: - cluster:     certificate-authority-data: REDACTED     server: https://130.211.122.180   name: lithe-cocoa-92103_kubernetes contexts: - context:     cluster: lithe-cocoa-92103_kubernetes     user: lithe-cocoa-92103_kubernetes   name: lithe-cocoa-92103_kubernetes - context:     cluster: lithe-cocoa-92103_kubernetes     namespace: development     user: lithe-cocoa-92103_kubernetes   name: dev - context:     cluster: lithe-cocoa-92103_kubernetes     namespace: production     user: lithe-cocoa-92103_kubernetes   name: prod current-context: lithe-cocoa-92103_kubernetes kind: Config preferences: {} users: - name: lithe-cocoa-92103_kubernetes   user:     client-certificate-data: REDACTED     client-key-data: REDACTED     token: 65rZW78y8HbwXXtSXuUw9DbP4FLjHi4b - name: lithe-cocoa-92103_kubernetes-basic-auth   user:     password: h5M0FtUUIflBSdI7     username: admin`

让我们切换到 ​`development` ​名字空间进行操作。

`kubectl config use-context dev`

你可以使用下列命令验证当前上下文：

`kubectl config current-context`

`dev`

此时，我们从命令行向 Kubernetes 集群发出的所有请求都限定在 ​`development` ​名字空间中。

让我们创建一些内容。

`apiVersion: apps/v1 kind: Deployment metadata:   labels:     app: snowflake   name: snowflake spec:   replicas: 2   selector:     matchLabels:       app: snowflake   template:     metadata:       labels:         app: snowflake     spec:       containers:       - image: k8s.gcr.io/serve_hostname         imagePullPolicy: Always         name: snowflake`

应用清单文件来创建 Deployment。

我们创建了一个副本大小为 2 的 Deployment，该 Deployment 运行名为 ​`snowflake` ​的 Pod， 其中包含一个仅提供主机名服务的基本容器。

`kubectl get deployment`

`NAME         READY   UP-TO-DATE   AVAILABLE   AGE snowflake    2/2     2            2           2m`

`kubectl get pods -l app=snowflake`

`NAME                         READY     STATUS    RESTARTS   AGE snowflake-3968820950-9dgr8   1/1       Running   0          2m snowflake-3968820950-vgc4n   1/1       Running   0          2m`

这很棒，开发人员可以做他们想要的事情，而不必担心影响 ​`production` ​名字空间中的内容。

让我们切换到 ​`production` ​名字空间，展示一个名字空间中的资源如何对另一个名字空间不可见。

`kubectl config use-context prod`

​`production`​ 名字空间应该是空的，下列命令应该返回的内容为空。

`kubectl get deployment kubectl get pods`

生产环境需要以放牛的方式运维，让我们创建一些名为 ​`cattle` ​的 Pod。

`kubectl create deployment cattle --image=k8s.gcr.io/serve_hostname --replicas=5 kubectl get deployment`

`NAME         READY   UP-TO-DATE   AVAILABLE   AGE cattle       5/5     5            5           10s`

`kubectl get pods -l run=cattle`

`NAME                      READY     STATUS    RESTARTS   AGE cattle-2263376956-41xy6   1/1       Running   0          34s cattle-2263376956-kw466   1/1       Running   0          34s cattle-2263376956-n4v97   1/1       Running   0          34s cattle-2263376956-p5p3i   1/1       Running   0          34s cattle-2263376956-sxpth   1/1       Running   0          34s`

此时，应该很清楚的展示了用户在一个名字空间中创建的资源对另一个名字空间是不可见的。

随着 Kubernetes 中的策略支持的发展，我们将扩展此场景，以展示如何为每个名字空间提供不同的授权规则。

##  39.  Kubernetes 启用/禁用Kubernetes API
启用/禁用 Kubernetes API
--------------------

本页展示怎么用集群的 控制平面. 启用/禁用 API 版本。

通过 API 服务器的命令行参数 ​`--runtime-config=api/<version>`​ ， 可以开启/关闭某个指定的 API 版本。 此参数的值是一个逗号分隔的 API 版本列表。 此列表中，后面的值可以覆盖前面的值。

命令行参数 ​`runtime-config`​ 支持两个特殊的值（keys）：

*   ​`api/all`​：指所有已知的 API
*   ​`api/legacy`​：指过时的 API。过时的 API 就是明确地 弃用 的 API。

例如：为了停用除去 v1 版本之外的全部其他 API 版本， 就用参数 ​`--runtime-config=api/all=false,api/v1=true`​ 启动 ​`kube-apiserver`​。

##  40.  Kubernetes 在Kubernetes集群中使用NodeLocal DNSCache
在 Kubernetes 集群中使用 NodeLocal DNSCache
-------------------------------------

FEATURE STATE: Kubernetes v1.18 \[stable\]

本页概述了 Kubernetes 中的 NodeLocal DNSCache 功能。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](http://labs.play-with-k8s.com/)

要检查版本，请输入 ​`kubectl version`​。

引言
--

NodeLocal DNSCache 通过在集群节点上作为 DaemonSet 运行 DNS 缓存代理来提高集群 DNS 性能。 在当今的体系结构中，运行在 'ClusterFirst' DNS 模式下的 Pod 可以连接到 kube-dns ​`serviceIP`​ 进行 DNS 查询。 通过 kube-proxy 添加的 iptables 规则将其转换为 kube-dns/CoreDNS 端点。 借助这种新架构，Pods 将可以访问在同一节点上运行的 DNS 缓存代理，从而避免 iptables DNAT 规则和连接跟踪。 本地缓存代理将查询 kube-dns 服务以获取集群主机名的缓存缺失（默认为 "​`cluster.local`​" 后缀）。

动机
--

*   使用当前的 DNS 体系结构，如果没有本地 kube-dns/CoreDNS 实例，则具有最高 DNS QPS 的 Pod 可能必须延伸到另一个节点。 在这种场景下，拥有本地缓存将有助于改善延迟。
*   跳过 iptables DNAT 和连接跟踪将有助于减少 [conntrack 竞争](https://github.com/kubernetes/kubernetes/issues/56903) 并避免 UDP DNS 条目填满 conntrack 表。
*   从本地缓存代理到 kube-dns 服务的连接可以升级为 TCP 。 TCP conntrack 条目将在连接关闭时被删除，相反 UDP 条目必须超时 （[默认](https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt) ​`nf_conntrack_udp_timeout`​ 是 30 秒）。
*   将 DNS 查询从 UDP 升级到 TCP 将减少由于被丢弃的 UDP 包和 DNS 超时而带来的尾部等待时间； 这类延时通常长达 30 秒（3 次重试 + 10 秒超时）。 由于 nodelocal 缓存监听 UDP DNS 查询，应用不需要变更。
*   在节点级别对 DNS 请求的度量和可见性。
*   可以重新启用负缓存，从而减少对 kube-dns 服务的查询数量。

架构图
---

启用 NodeLocal DNSCache 之后，DNS 查询所遵循的路径如下：

![](https://atts.w3cschool.cn/attachments/image/20220607/1654572850529336.svg)  

配置
--

> Note: NodeLocal DNSCache 的本地侦听 IP 地址可以是任何地址，只要该地址不和你的集群里现有的 IP 地址发生冲突。 推荐使用本地范围内的地址，例如，IPv4 链路本地区段 '169.254.0.0/16' 内的地址， 或者 IPv6 唯一本地地址区段 'fd00::/8' 内的地址。

可以使用以下步骤启动此功能：

*   根据示例 [nodelocaldns.yaml](https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/dns/nodelocaldns/nodelocaldns.yaml) 准备一个清单，把它保存为 ​`nodelocaldns.yaml`​。
*   如果使用 IPv6，在使用 'IP:Port' 格式的时候需要把 CoreDNS 配置文件里的所有 IPv6 地址用方括号包起来。 如果你使用上述的示例清单，需要把 [配置行 L70](https://github.com/kubernetes/kubernetes/blob/b2ecd1b3a3192fbbe2b9e348e095326f51dc43dd/cluster/addons/dns/nodelocaldns/nodelocaldns.yaml target=) 修改为： "​`health [__PILLAR__LOCAL__DNS__]:8080`​"。
*   把清单里的变量更改为正确的值：

``kubedns=`kubectl get svc kube-dns -n kube-system -o jsonpath={.spec.clusterIP}` domain=<cluster-domain> localdns=<node-local-address>``

​`<cluster-domain>`​ 的默认值是 "​`cluster.local`​"。​`<node-local-address>`​ 是 NodeLocal DNSCache 选择的本地侦听 IP 地址。

*   如果 kube-proxy 运行在 IPTABLES 模式：

`sed -i "s/__PILLAR__LOCAL__DNS__/$localdns/g; s/__PILLAR__DNS__DOMAIN__/$domain/g; s/__PILLAR__DNS__SERVER__/$kubedns/g" nodelocaldns.yaml`

node-local-dns Pods 会设置 ​`__PILLAR__CLUSTER__DNS__`​ 和 ​`__PILLAR__UPSTREAM__SERVERS__`​。 在此模式下, node-local-dns Pods 会同时侦听 kube-dns 服务的 IP 地址和 ​`<node-local-address>`​ 的地址，以便 Pods 可以使用其中任何一个 IP 地址来查询 DNS 记录。

*   如果 kube-proxy 运行在 IPVS 模式：

`sed -i "s/__PILLAR__LOCAL__DNS__/$localdns/g; s/__PILLAR__DNS__DOMAIN__/$domain/g; s/,__PILLAR__DNS__SERVER__//g; s/__PILLAR__CLUSTER__DNS__/$kubedns/g" nodelocaldns.yaml`

在此模式下，node-local-dns Pods 只会侦听 ​`<node-local-address>`​ 的地址。 node-local-dns 接口不能绑定 kube-dns 的集群 IP 地址，因为 IPVS 负载均衡 使用的接口已经占用了该地址。 node-local-dns Pods 会设置 ​`__PILLAR__UPSTREAM__SERVERS__`​。

*   运行 ​`kubectl create -f nodelocaldns.yaml` ​
*   如果 kube-proxy 运行在 IPVS 模式，需要修改 kubelet 的 ​`--cluster-dns`​ 参数 NodeLocal DNSCache 正在侦听的 ​`<node-local-address>`​ 地址。 否则，不需要修改 ​`--cluster-dns`​ 参数，因为 NodeLocal DNSCache 会同时侦听 kube-dns 服务的 IP 地址和 ​`<node-local-address>`​ 的地址。

启用后，​`node-local-dns`​ Pods 将在每个集群节点上的 ​`kube-system`​ 名字空间中运行。 此 Pod 在缓存模式下运行 [CoreDNS](https://github.com/coredns/coredns)， 因此每个节点都可以使用不同插件公开的所有 CoreDNS 指标。

如果要禁用该功能，你可以使用 ​`kubectl delete -f <manifest>`​ 来删除 DaemonSet。 你还应该回滚你对 kubelet 配置所做的所有改动。

StubDomains 和上游服务器配置
--------------------

​`node-local-dns`​ Pod 能够自动读取 ​`kube-system`​ 名字空间中 ​`kube-dns`​ ConfigMap 中保存的 StubDomains 和上游服务器信息。ConfigMap 中的内容需要遵从 此示例 中所给的格式。 ​`node-local-dns`​ ConfigMap 也可被直接修改，使用 Corefile 格式设置 stubDomain 配置。 某些云厂商可能不允许直接修改 ​`node-local-dns`​ ConfigMap 的内容。 在这种情况下，可以更新 ​`kube-dns`​ ConfigMap。

设置内存限制
------

node-local-dns Pod 使用内存来保存缓存项并处理查询。 由于它们并不监视 Kubernetes 对象变化，集群规模或者 Service/Endpoints 的数量都不会直接影响内存用量。内存用量会受到 DNS 查询模式的影响。 根据 [CoreDNS 文档](https://github.com/coredns/deployment/blob/master/kubernetes/Scaling_CoreDNS.md)。

> The default cache size is 10000 entries, which uses about 30 MB when completely filled. （默认的缓存大小是 10000 个表项，当完全填充时会使用约 30 MB 内存）

这一数值是（缓存完全被填充时）每个服务器块的内存用量。 通过设置小一点的缓存大小可以降低内存用量。

并发查询的数量会影响内存需求，因为用来处理查询请求而创建的 Go 协程都需要一定量的内存。 你可以在 forward 插件中使用 ​`max_concurrent` ​选项设置并发查询数量上限。

如果一个 ​`node-local-dns`​ Pod 尝试使用的内存超出可提供的内存量 （因为系统资源总量的，或者所配置的资源约束）的原因， 操作系统可能会关闭这一 Pod 的容器。 发生这种情况时，被终止的（"OOMKilled"）容器不会清理其启动期间所添加的定制包过滤规则。 该 ​`node-local-dns`​ 容器应该会被重启（因其作为 DaemonSet 的一部分被管理）， 但因上述原因可能每次容器失败时都会导致 DNS 有一小段时间不可用： the packet filtering rules direct DNS queries to a local Pod that is unhealthy （包过滤器规则将 DNS 查询转发到本地某个不健康的 Pod）。

通过不带限制地运行 ​`node-local-dns`​ Pod 并度量其内存用量峰值，你可以为其确定一个合适的内存限制值。 你也可以安装并使用一个运行在 “Recommender Mode（建议者模式）” 的 [VerticalPodAutoscaler](https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler)， 并查看该组件输出的建议信息。

##  41.  Kubernetes 在Kubernetes集群中使用sysctl
在 Kubernetes 集群中使用 sysctl
-------------------------

FEATURE STATE: Kubernetes v1.21 \[stable\]

本文档介绍如何通过 sysctl 接口在 Kubernetes 集群中配置和使用内核参数。

> Note: 从 Kubernetes 1.23 版本开始，kubelet 支持使用 / 或 . 作为 sysctl 参数的分隔符。 例如，你可以使用点或者斜线作为分隔符表示相同的 sysctl 参数，以点作为分隔符表示为： ​`kernel.shm_rmid_forced`​， 或者以斜线作为分隔符表示为：​`kernel/shm_rmid_forced`​。 更多 sysctl 参数转换方法详情请参考 Linux man-pages [sysctl.d(5)](https://man7.org/linux/man-pages/man5/sysctl.d.5.html) 。 设置 Pod 的 Sysctl 参数 和 PodSecurityPolicy 功能尚不支持设置包含斜线的 Sysctl 参数。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

对一些步骤，你需要能够重新配置在你的集群里运行的 kubelet 命令行的选项。

获取 Sysctl 的参数列表
---------------

在 Linux 中，管理员可以通过 sysctl 接口修改内核运行时的参数。在 ​`/proc/sys/`​ 虚拟文件系统下存放许多内核参数。这些参数涉及了多个内核子系统，如：

*   内核子系统（通常前缀为: ​`kernel.`​）
*   网络子系统（通常前缀为: ​`net.`​）
*   虚拟内存子系统（通常前缀为: ​`vm.`​）
*   MDADM 子系统（通常前缀为: ​`dev.`​）
*   更多子系统请参见[内核文档](https://www.kernel.org/doc/Documentation/sysctl/README)

若要获取完整的参数列表，请执行以下命令

`sudo sysctl -a`

启用非安全的 Sysctl 参数 
-----------------

sysctl 参数分为 安全 和 非安全的。 安全 sysctl 参数除了需要设置恰当的命名空间外，在同一 node 上的不同 Pod 之间也必须是 相互隔离的。这意味着在 Pod 上设置 安全 sysctl 参数

*   必须不能影响到节点上的其他 Pod
*   必须不能损害节点的健康
*   必须不允许使用超出 Pod 的资源限制的 CPU 或内存资源。

至今为止，大多数 有命名空间的 sysctl 参数不一定被认为是 安全 的。 以下几种 sysctl 参数是 安全的：

*   ​`kernel.shm_rmid_forced` ​
*   ​`net.ipv4.ip_local_port_range` ​
*   ​`net.ipv4.tcp_syncookies` ​
*   ​`net.ipv4.ping_group_range`​ （从 Kubernetes 1.18 开始）
*   ​`net.ipv4.ip_unprivileged_port_start`​ （从 Kubernetes 1.22 开始）

> Note: 示例中的 ​`net.ipv4.tcp_syncookies`​ 在Linux 内核 4.4 或更低的版本中是无命名空间的。  

在未来的 Kubernetes 版本中，若 kubelet 支持更好的隔离机制，则上述列表中将会 列出更多 安全的 sysctl 参数。

所有 安全的 sysctl 参数都默认启用。

所有 非安全的 sysctl 参数都默认禁用，且必须由集群管理员在每个节点上手动开启。 那些设置了不安全 sysctl 参数的 Pod 仍会被调度，但无法正常启动。

参考上述警告，集群管理员只有在一些非常特殊的情况下（如：高可用或实时应用调整）， 才可以启用特定的 非安全的 sysctl 参数。 如需启用 非安全的 sysctl 参数，请你在每个节点上分别设置 kubelet 命令行参数，例如：

`kubelet --allowed-unsafe-sysctls \   'kernel.msg*,net.core.somaxconn' ...`

如果你使用 Minikube，可以通过 ​`extra-config`​ 参数来配置：

`minikube start --extra-config="kubelet.allowed-unsafe-sysctls=kernel.msg*,net.core.somaxconn"...`

只有 有命名空间的 sysctl 参数可以通过该方式启用。

设置 Pod 的 Sysctl 参数
------------------

目前，在 Linux 内核中，有许多的 sysctl 参数都是 有命名空间的 。 这就意味着可以为节点上的每个 Pod 分别去设置它们的 sysctl 参数。 在 Kubernetes 中，只有那些有命名空间的 sysctl 参数可以通过 Pod 的 securityContext 对其进行配置。

以下列出有命名空间的 sysctl 参数，在未来的 Linux 内核版本中，此列表可能会发生变化。

*   ​`kernel.shm*`​
*   ​`kernel.msg*`​
*   ​`kernel.sem`​
*   ​`fs.mqueue.*`​
*   ​`net.*`​（内核中可以在容器命名空间里被更改的网络配置项相关参数）。然而也有一些特例 （例如，​`net.netfilter.nf_conntrack_max`​ 和 ​`net.netfilter.nf_conntrack_expect_max`​ 可以在容器命名空间里被更改，但它们是非命名空间的）

没有命名空间的 sysctl 参数称为 节点级别的 sysctl 参数。 如果需要对其进行设置，则必须在每个节点的操作系统上手动地去配置它们， 或者通过在 DaemonSet 中运行特权模式容器来配置。

可使用 Pod 的 securityContext 来配置有命名空间的 sysctl 参数， securityContext 应用于同一个 Pod 中的所有容器。

此示例中，使用 Pod SecurityContext 来对一个安全的 sysctl 参数 ​`kernel.shm_rmid_forced`​ 以及两个非安全的 sysctl 参数 ​`net.core.somaxconn`​ 和 ​`kernel.msgmax`​ 进行设置。 在 Pod 规约中对 安全的 和 非安全的 sysctl 参数不做区分。

> Warning: 为了避免破坏操作系统的稳定性，请你在了解变更后果之后再修改 sysctl 参数。  

`apiVersion: v1 kind: Pod metadata:   name: sysctl-example spec:   securityContext:     sysctls:     - name: kernel.shm_rmid_forced       value: "0"     - name: net.core.somaxconn       value: "1024"     - name: kernel.msgmax       value: "65536"   ...`

> Warning: 由于 非安全的 sysctl 参数其本身具有不稳定性，在使用 非安全的 sysctl 参数 时可能会导致一些严重问题，如容器的错误行为、机器资源不足或节点被完全破坏， 用户需自行承担风险。

最佳实践方案是将集群中具有特殊 sysctl 设置的节点视为 有污点的，并且只调度 需要使用到特殊 sysctl 设置的 Pod 到这些节点上。 建议使用 Kubernetes 的 [污点和容忍度特性](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=) 来实现它。

设置了 非安全的 sysctl 参数的 Pod 在禁用了这两种 非安全的 sysctl 参数配置 的节点上启动都会失败。与 节点级别的 sysctl 一样，建议开启 [污点和容忍度特性](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands target=) 或 [为节点配置污点](https://www.w3cschool.cn/kubernetes/kubernetes-5axq3o73.html) 以便将 Pod 调度到正确的节点之上。

PodSecurityPolicy
-----------------

FEATURE STATE: Kubernetes v1.21 \[deprecated\]

你可以通过在 PodSecurityPolicy 的 ​`forbiddenSysctls`​ 或 ​`allowedUnsafeSysctls` ​字段中，指定 sysctl 或填写 sysctl 匹配模式来进一步为 Pod 设置 sysctl 参数。 sysctl 参数匹配模式以 ​`*`​ 字符结尾，如 ​`kernel.*`​。 单独的 ​`*`​ 字符匹配所有 sysctl 参数。

所有 安全的 sysctl 参数都默认启用。

​`forbiddenSysctls` ​和 ​`allowedUnsafeSysctls` ​的值都是字符串列表类型， 可以添加 sysctl 参数名称，也可以添加 sysctl 参数匹配模式（以\*结尾）。 只填写 ​`*`​ 则匹配所有的 sysctl 参数。

​`forbiddenSysctls` ​字段用于禁用特定的 sysctl 参数。 你可以在列表中禁用安全和非安全的 sysctl 参数的组合。 要禁用所有的 sysctl 参数，请设置为 ​`*`​。

如果要在 ​`allowedUnsafeSysctls` ​字段中指定一个非安全的 sysctl 参数， 并且它在 ​`forbiddenSysctls` ​字段中未被禁用，则可以在 Pod 中通过 PodSecurityPolicy 启用该 sysctl 参数。 若要在 PodSecurityPolicy 中开启所有非安全的 sysctl 参数， 请设 ​`allowedUnsafeSysctls` ​字段值为 ​`*`​。

​`allowedUnsafeSysctls` ​与 ​`forbiddenSysctls` ​两字段的配置不能重叠， 否则这就意味着存在某个 sysctl 参数既被启用又被禁用。

> Warning: 如果你通过 PodSecurityPolicy 中的 ​`allowedUnsafeSysctls` ​字段将非安全的 sysctl 参数列入白名单，但该 sysctl 参数未通过 kubelet 命令行参数 ​`--allowed-unsafe-sysctls`​ 在节点上将其列入白名单，则设置了这个 sysctl 参数的 Pod 将会启动失败。

以下示例设置启用了以 ​`kernel.msg`​ 为前缀的非安全的 sysctl 参数，同时禁用了 sysctl 参数 ​`kernel.shm_rmid_forced`​。

`apiVersion: policy/v1beta1 kind: PodSecurityPolicy metadata:   name: sysctl-psp spec:   allowedUnsafeSysctls:   - kernel.msg*   forbiddenSysctls:   - kernel.shm_rmid_forced  ...`

##  42.  Kubernetes 在运行中的集群上重新配置节点的kubelet
在运行中的集群上重新配置节点的 kubelet
-----------------------

FEATURE STATE: Kubernetes v1.22 \[deprecated\]

> Caution: [动态 kubelet 配置](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/281-dynamic-kubelet-configuration) 功能在 Kubernetes 1.22 版本弃用，并在 1.24 版本中移除。 请选择其他方法将配置分发到集群中的节点。

[动态 kubelet 配置](https://github.com/kubernetes/enhancements/issues/281) 允许你通过部署并配置节点使用的 ConfigMap， 达到更改正在运行的 Kubernetes 集群的 kubelet 配置的目的。

不再使用动态 Kubelet 配置
-----------------

这里没有跨不同的 Kubernetes 发行版替换这个功能的建议方法。 如果你使用托管 Kubernetes 版本， 请咨询托管 Kubernetes 的供应商，以获得自定义 Kubernetes 的最佳实践。 

为了停止使用动态 Kubelet 配置功能， 应该使用替代机制分发 kubelet 配置文件。 为了使配置生效，必须更新配置文件并重新启动 kubelet。

请注意，从 v1.24 开始 ​`DynamicKubeletConfig` ​特性门控无法在 kubelet 上设置， 因为不会生效。在 v1.26 之前 API 服务器和控制器管理器不会移除该特性门控。 这是专为控制面支持有旧版本 kubelet 的节点以及满足 Kubernetes 版本偏差策略。

##  43.  Kubernetes 在集群中使用级联删除
在集群中使用级联删除
----------

本页面向你展示如何设置在你的集群执行垃圾收集 时要使用的级联删除 类型。

在开始之前
-----

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

*   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
*   [玩转 Kubernetes](https://labs.play-with-k8s.com/)

你还需要创建一个 Deployment 示例 以试验不同类型的级联删除。你需要为每种级联删除类型来重建 Deployment。

检查 Pod 上的属主引用 
--------------

检查确认你的 Pods 上存在 ​`ownerReferences` ​字段：

`kubectl get pods -l app=nginx --output=yaml`

输出中包含 ​`ownerReferences` ​字段，类似这样：

`apiVersion: v1     ...     ownerReferences:     - apiVersion: apps/v1       blockOwnerDeletion: true       controller: true       kind: ReplicaSet       name: nginx-deployment-6b474476c4       uid: 4fdcd81c-bd5d-41f7-97af-3a3b759af9a7     ...`

使用前台级联删除 
---------

默认情况下，Kubernetes 使用后台级联删除 以删除依赖某对象的其他对象。取决于你的集群所运行的 Kubernetes 版本， 你可以使用 kubectl 或者 Kubernetes API 来切换到前台级联删除。要检查版本，请输入 ​`kubectl version`​。

*   Kubernetes 1.20.x 及更新版本

你可以使用 ​`kubectl` ​或者 Kubernetes API 来基于前台级联删除来删除对象。

**使用 kubectl**

运行下面的命令：

`kubectl delete deployment nginx-deployment --cascade=foreground`

**使用 Kubernetes API**

1.  启动一个本地代理会话：

`kubectl proxy --port=8080`

3.  使用 ​`curl` ​来触发删除操作：

`curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment \     -d '{"kind":"DeleteOptions","apiVersion":"v1","propagationPolicy":"Foreground"}' \     -H "Content-Type: application/json"`

输出中包含 ​`foregroundDeletion` ​finalizer， 类似这样：

`"kind": "Deployment", "apiVersion": "apps/v1", "metadata": {     "name": "nginx-deployment",     "namespace": "default",     "uid": "d1ce1b02-cae8-4288-8a53-30e84d8fa505",     "resourceVersion": "1363097",     "creationTimestamp": "2021-07-08T20:24:37Z",     "deletionTimestamp": "2021-07-08T20:27:39Z",     "finalizers": [       "foregroundDeletion"     ]     ...`

*   Kubernetes 1.20.x 之前的版本

你可以通过调用 Kubernetes API 来基于前台级联删除模式删除对象。

1.  启动一个本地代理会话：

`kubectl proxy --port=8080`

3.  使用 ​`curl` ​来触发删除操作：

`curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment \     -d '{"kind":"DeleteOptions","apiVersion":"v1","propagationPolicy":"Foreground"}' \     -H "Content-Type: application/json"`

输出中包含 ​`foregroundDeletion` ​finalizer， 类似这样：

`"kind": "Deployment", "apiVersion": "apps/v1", "metadata": {     "name": "nginx-deployment",     "namespace": "default",     "uid": "d1ce1b02-cae8-4288-8a53-30e84d8fa505",     "resourceVersion": "1363097",     "creationTimestamp": "2021-07-08T20:24:37Z",     "deletionTimestamp": "2021-07-08T20:27:39Z",     "finalizers": [       "foregroundDeletion"     ]     ...`

使用后台级联删除
--------

1.  创建一个 Deployment 示例。
2.  基于你的集群所运行的 Kubernetes 版本，使用 ​`kubectl` ​或者 Kubernetes API 来删除 Deployment。要检查版本，请输入 ​`kubectl version`​。

*   Kubernetes 1.20.x 及更新版本

你可以使用 ​`kubectl` ​或者 Kubernetes API 来执行后台级联删除方式的对象删除操作。

Kubernetes 默认采用后台级联删除方式，如果你在运行下面的命令时不指定 ​`--cascade`​ 标志或者 ​`propagationPolicy` ​参数时，用这种方式来删除对象。

**使用 kubectl**

运行下面的命令：

`kubectl delete deployment nginx-deployment --cascade=background`

**使用 Kubernetes API**

1.  启动一个本地代理会话：

`kubectl proxy --port=8080`

3.  使用 ​`curl` ​来触发删除操作：

`curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment \     -d '{"kind":"DeleteOptions","apiVersion":"v1","propagationPolicy":"Background"}' \     -H "Content-Type: application/json"`

输出类似于：

`"kind": "Status", "apiVersion": "v1", ... "status": "Success", "details": {     "name": "nginx-deployment",     "group": "apps",     "kind": "deployments",     "uid": "cc9eefb9-2d49-4445-b1c1-d261c9396456" }`

*   Kubernetes 1.20.x 之前的版本

Kubernetes 默认采用后台级联删除方式，如果你在运行下面的命令时不指定 ​`--cascade`​ 标志或者 ​`propagationPolicy` ​参数时，用这种方式来删除对象。

**使用 kubectl**

运行下面的命令：

`kubectl delete deployment nginx-deployment --cascade=true`

**使用 Kubernetes API**

1.  启动一个本地代理会话：

`kubectl proxy --port=8080`

3.  使用 ​`curl` ​来触发删除操作：

`curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment \     -d '{"kind":"DeleteOptions","apiVersion":"v1","propagationPolicy":"Background"}' \     -H "Content-Type: application/json"`

输出类似于：

`"kind": "Status", "apiVersion": "v1", ... "status": "Success", "details": {     "name": "nginx-deployment",     "group": "apps",     "kind": "deployments",     "uid": "cc9eefb9-2d49-4445-b1c1-d261c9396456" }`

删除属主对象和孤立的依赖对象 
---------------

默认情况下，当你告诉 Kubernetes 删除某个对象时， 控制器 也会删除依赖该对象 的其他对象。 取决于你的集群所运行的 Kubernetes 版本，你也可以使用 ​`kubectl` ​或者 Kubernetes API 来让 Kubernetes 孤立 这些依赖对象。要检查版本，请输入 ​`kubectl version`​。

*   Kubernetes 1.20.x 及更新版本

**使用 kubectl**

运行下面的命令：

`kubectl delete deployment nginx-deployment --cascade=orphan`

**使用 Kubernetes API**

1.  启动一个本地代理会话：

`kubectl proxy --port=8080`

3.  使用 ​`curl` ​来触发删除操作：

`curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment \     -d '{"kind":"DeleteOptions","apiVersion":"v1","propagationPolicy":"Orphan"}' \     -H "Content-Type: application/json"`

输出中在 ​`finalizers` ​字段中包含 ​`orphan`​，如下所示：

`"kind": "Deployment", "apiVersion": "apps/v1", "namespace": "default", "uid": "6f577034-42a0-479d-be21-78018c466f1f", "creationTimestamp": "2021-07-09T16:46:37Z", "deletionTimestamp": "2021-07-09T16:47:08Z", "deletionGracePeriodSeconds": 0, "finalizers": [   "orphan" ], ...`

*   Kubernetes 1.20.x 之前的版本

**使用 kubectl**

运行下面的命令：

`kubectl delete deployment nginx-deployment --cascade=orphan`

**使用 Kubernetes API**

1.  启动一个本地代理会话：

`kubectl proxy --port=8080`

3.  使用 ​`curl` ​来触发删除操作：

`curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment \     -d '{"kind":"DeleteOptions","apiVersion":"v1","propagationPolicy":"Orphan"}' \     -H "Content-Type: application/json"`

输出中在 ​`finalizers` ​字段中包含 ​`orphan`​，如下所示：

`"kind": "Deployment", "apiVersion": "apps/v1", "namespace": "default", "uid": "6f577034-42a0-479d-be21-78018c466f1f", "creationTimestamp": "2021-07-09T16:46:37Z", "deletionTimestamp": "2021-07-09T16:47:08Z", "deletionGracePeriodSeconds": 0, "finalizers": [   "orphan" ], ...`

你可以检查 Deployment 所管理的 Pods 仍然处于运行状态：

`kubectl get pods -l app=nginx`
