# 信息安全的目标

## 保密性 Confidentiality

数据保密性：对于未授权的个体而言，信息不可用
隐私性：确保个人能控制或确定自身那些信息可以被收集、保存，这些信息可以被谁公开及向谁公开

## 完整性 Integrity

信息的完整性、一致性，分为
数据完整性，未被未授权篡改或者损坏；系统完整性，系统未被非法操纵，按既定的目标运行

## 可用性 Availability

服务连续性，对授权用户不能拒绝服务

## 真实性Authenticity

能够验证用户是他声称的那个人
确保系统的输入来源于可信任的源

## 可追溯性Accountability

实体的行为可以唯一追溯到该实体

# 安全攻击

## 被动攻击：窃听和检测
信息内容泄露攻击——隐藏信息：加密
流量分析
难察觉，关键：预防

## 主动攻击：
伪装：假装别的实体。如：捕获认证信息，进行重播
重播：将获得的信息再次发送以产生非授权效果
消息修改：修改合法消息的一部分或者延迟消息，或改变消息的顺序以获得非授权效果
拒绝服务：阻止或禁止对通信设施的增产使用和管理。

# 安全服务
ITU-T X.800，安全服务目的在于利用一种或者多种安全机制进行反攻击。

## 1）认证

同等实体认证
数据源认证：电子邮件的应用

## 2）访问控制：阻止对资源的非授权使用

## 3）数据保密性：防止被动攻击

数据免于非授权泄露
流量保密性

## 4）数据完整性：
保证收到的数据没有修改、插入、删除或重播

## 5）不可否认性

源不可否认
宿不可否认

## 6)可用性服务

# 安全机制
1. 加密
2. 数字签名
3. 访问控制
4. 数据完整性
5. 认证交换
6. 流量填充
7. 路由控制
8. 公证

# 密码学的基本概念
密码学(Cryptology)：
>研究信息系统安全保密的科学。

密码编码学(Cryptography)：
>研究对信息进行编码,实现对信息的隐蔽。

密码分析学(Cryptanalytics) ：
>研究加密消息的破译或消息的伪造。

消息被称为明文(Plaintext)。
>用某种方法伪装消息以隐藏它的内容的过程称为加密(Encrtption)，被加密的消息称为密文(Ciphertext)，而把密文转变为明文的过程称为解密(Decryption)。 

密码算法：
>用于加密和解密的数学函数。
密码员对明文进行加密操作时所采用的一组规则称作**加密算法(Encryption Algorithm)。**\所传送消息的预定对象称为接收者(Receiver)。接收者对密文解密所采用的一组规则称为\***解密算法(Decryption Algorithm)**。

**加密过程**
密码学的目的：Alice和Bob两个人在不安全的信道上进行通信，而破译者Oscar不能理解他们通信的内容。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190311212317675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
加密和解密算法的操作通常都是在一组密钥的控制下进行的，分别称为加密密钥(Encryption Key) 和解密密钥(Decryption Key)。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190311212343478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

**密码体制**
一个五元组(P,C,K,E,D)满足条件：
1) P是可能明文的有限集；(明文空间)
2) C是可能密文的有限集；(密文空间)
3) K是一切可能密钥构成的有限集；(密钥空间) 
4) 任意k∈K,有一个加密算法ek∈E和相应的解密算法dk∈D，使得ek : P→C和dk : C→P分别为加密解密函数，满足dk(ek(x))=x，其中 x ∈P。 

**加密算法基本原理**
代替：明文中的元素映射成另一个元素
置换 ：重新排列
要求：不允许信息丢失，即算法可逆

**基于密钥的算法，按照密钥的特点分类：**
==对称密码算法(symmetric cipher)==：加密密钥和解密密钥相同，或实质上等同，即从一个易于推出另一个。又称秘密密钥算法或单密钥算法。
==非对称密钥算法(asymmetric cipher)==：加密密钥和解密密钥不相同，从一个很难推出另一个。又称公开密钥算法(public-key cipher) 。

**密码分析破解类型：**
1. 唯密文攻击
密码分析者仅知道有限数量用同一个密钥加密的密文
2. 已知明文攻击
密码分析者除了拥有有限数量的密文外，还有数量限定的一些已知“明文—密文”对
3. 选择明文攻击
密码分析者除了拥有有限数量的密文外，还有机会使用注入了未知密钥的加密机，通过自由选择明文来获取所希望的“明文—密文”对。
4. 选择密文攻击
密码分析者除了拥有有限数量的密文外，还有机会使用注入了未知密钥的解密机，通过自由选择密文来获取所希望的“密文—明文”对。
5. 选择文本攻击

**密码的安全性**
==无条件安全(Unconditionally secure)==
无论破译者有多少密文，他也无法解出对应的明文，即使他解出了，他也无法验证结果的正确性。**（除一次一密钥，都不是无条件安全）**
==计算上安全(Computationally secure)==
破译的代价超出信息本身的价值
破译的时间超出了信息的有效期

**现代密码学基本原则**
设计加密系统时，总假定密码算法是可以公开的，需要保密的是密钥。“**一切秘密在于密钥之中，而加密算法可以公开**” 即Kerckhoff原则。


**密码学的起源和发展三个阶段：**
1949年之前：密码学是一门艺术
>古典密码(classical cryptography)
>**隐写术(steganography)：不同于加密。**
如果把一封信锁在保险柜中，把保险柜藏在纽约的某个地方…，然后告诉你去看这封信。这并不是安全，而是隐藏。

1949～1975年：密码学成为科学
>计算机使得基于复杂计算的密码成为可能
1949年Shannon的“The Communication Theory of Secret Systems” 
1967年David Kahn的《The Codebreakers》
1971-73年IBM Watson实验室的Horst Feistel等的几篇技术报告
Smith,J.L.,The Design of Lucifer, A Cryptographic Device for Data Communication, 1971
Smith,J.L.,…,An Expremental Application of Cryptogrphy to a remotely Accessed Data System, Aug.1972
Feistel,H.,Cryptography and Computer Privacy, May 1973
数据的安全基于密钥而不是算法的保密

1976年以后：密码学的新方向——公钥密码学
>1976年Diffie & Hellman的“New Directions in Cryptography”提出了不对称密钥密码
1977年Rivest,Shamir & Adleman提出了RSA公钥算法
90年代逐步出现椭圆曲线等其他公钥算法
公钥密码使得发送端和接收端无密钥传输的保密通信成为可能！
1977年DES正式成为标准80年代出现“过渡性”的“post DES”算法，如IDEA，RCx，CAST等
90年代对称密钥密码进一步成熟 Rijndael，RC6， MARS，Twofish，Serpent等出现
2001年Rijndael成为DES的替代者

# 经典密码体制

## 代替密码(substitution cipher)
就是明文中的每一个字符被替换成密文中的另一个字符。接收者对密文做反向替换就可以恢复出明文。

**简单代替密码(simple substitution cipher)：**
又称单字母密码(monoalphabetic cipher)，明文的一个字符用相应的一个密文字符代替。

**多字母密码(ployalphabetic cipher)：**
明文中的字符映射到密文空间的字符还依赖于它在上下文的位置。

**恺撒密码(Caesar Cipher)：**
已知的最早（也是最简单的方式）的简单替代密码是朱里斯.恺撒所用的密码。恺撒密码是把字母表中的每个字母用该字母后面第3个字母进行代替。例如：
明文：meet    me  after       the      toga      party
密文：PHHW PH  DIWHU  WKH    WRJD   SDUWS
既然字母表是循环的，因此Z后面的字母是A。能够通过列出所以可能性定义如下所示的变换：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190314162938397.png)

**移位密码(Shift cipher)** 
对每个明文字母p，恺撒加密可转化为移位密码，其中加密算法：
C = E(p) = (p＋k) mod (26)，其中k在1～25之间取值。
解密算法是：p = D(C) = (C－k) mod (26)
如果已知密文是恺撒密码，则使用强行攻击密码分析容易取得结果
直接对所有25个可能的密钥进行尝试。

**模运算**
a＋b mod n ＝ (a mod n＋b mod n) mod n
a－b mod n ＝ (a mod n－b mod n) mod n
a×b mod n ＝ (a mod n×b mod n) mod n

**仿射密码算法：**
P  = C  = Z~26~
K = (a，b) ∈K = Z~26~×Z~26~
加密
y = e~K~(x) = (ax＋b) mod 26
要求唯一解的充要条件：gcd(a,26)=1
解密
d~K~ (y) = (y – b) / a mod 26 = (y – b) a^-1^ mod 26
**仿射密码算法例：**
K = (7，3)，则有7~-1~ mod 26 ＝ 15
因此对任一明文x有：e~k~ (x) = 7x + 3
解密：
d~k~ (y) = 15 * (y – 3) mod 26 =  15y – 19 mod 26
= 15 * (7x + 3) – 19 = 105*x + 45 – 19
= 105x = x mod 26
仿射密码算法讨论：
>首先，a = 1时，即是移位密码 (shift)
其次，如果K随意选择，可能会有问题
比如取K = (8，5) ，即y＝8x＋5 mod 26
明文a和n，记x~1~ = 0 (a)，x~2~  = 13 (n)，则y~1~= 5，y~2~ = 5 (F)
不同的明文被加密成相同的密文，这样在解密时就有歧义
那么，如何避免这种歧义的出现？
合理选取密钥
要求a和26互素，即gcd (a, 26) = 1
如果k = (a,b)中a和26不互素则会有歧义，若a和26有公因子gcd (a, 26)=d>1，则对明文x~1~=0和x~2~ =26/d的就相同密文
因为ax~1~+b≡b mod 26，而ax~2~+b=a×26/d+b=a/d×26+b≡b mod 26
即x1和x2被加密成相同的密文，所以解密时会混淆
这里，是否互素代表了什么性质呢？
互素才有“逆”
逆元，讨论在余数集合上进行
加法逆元：如果a + b≡0 mod n，互为加法逆元
则Zn中都有：0,0    1,n-1   2,n-2   …     n/2,n/2
乘法逆元：如果a×b≡1 mod n，则a、b互为乘法逆元
如6×20≡1 mod 119
定义a的乘法逆元a~-1~，a~-1~a ≡ 1 mod  n，显然可交换
由y = (ax + b) mod 26，
得x = d~K~ (y) = (y - b) / a = a~-1~ (y - b) /a~-1~a  =  a~-1~ (y - b)
即x = a~-1~(ax + b - b) = a~-1~ax = x mod 26，x恢复了
乘法逆元如何构造？
3×9  ≡ 1 mod 26
5×？≡ 1 mod 26
并不是每个元素都有乘法逆元，概括为解方程 ax≡1 mod n

**如何求乘法逆元：**
一次同余方程ax ≡ b (mod m)这个方程有没有解，相当于问有没有那样一个整数x，使得对于某个整数y来说，有ax + my=b
推论：ax≡1 mod n有解 IFF (a, n) | 1，即a、n互素

**欧几里德算法(求最大公约数)：**
基于定理：对于任何非负的整数a和非负的整数b：
gcd (a，b) = gcd (b，a mod b) 
例如： gcd (55，22) = gcd (22，55 mod 22) = gcd (22，11) = 11
扩展欧几里德算法(求乘法逆元)例：
**方式一**
求7关于96的乘法逆元
 |Q	|X1|	X2|	X3| 	  Y1  |    Y2 	  |       Y3|
 |---|---|---|---|---|---|---|
 |    |    1 |               0	|96|	   0	|        1	|                  7|
|13|	 0|	 1|	 7|           1-0*13=1	  |0–1*13= -13|     96-7*13=5|
| 1    	| 1|	-13|	 5           |0-1*1= -1       |  1- 1*(-13)= 14    |7-1*5=2|
 |2	|-1	| 14|	 2     |      1-2*0=1   |        -13-2*14= -41 |   5-2*2=1|
由于Y3=1，所以算法中止，故乘法逆元为-41 mod 96 = 55
即7×55 ≡1 mod 96
**方式二**
求22mod31的逆元
|i|r~i~|q~i~|x~i~|y~i~|
|--|--|--|--|--|
-1|31| |1|0|
0|22|  |0|1|
|1| 9| 1| 1 |-1|
|2 |4| 2 |-2 |3|
|3 |1 |2 |5 |-7|
当r~i~=1，则5x31+（-7）x 22 =1 mod 31
则逆元为（-7）+  31 = 24
（PS:第一行为被除数，默认X~i~Y~i~为 1 0 ，第二行为除数，默认X~i~Y~i~为 0 1 个人觉得方式二好理解一些）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190607095552686.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
**任意的单表代替密码算法：**
设P=C=Z~26~，K是由26个符号0，1，..，25的所有可能置换组成。任意π∈K，定义eπ(x)= π(x)=y 且d~π~(y)=π~-1~(y)=x, π~-1~是π的逆置换。
注：
 密钥空间K很大，|k|=26! ≈ 4×1026，破译者穷举搜索不行的(每微秒搜索加密一次需要6.4×1012年)。移位密码、乘数密码、仿射密码算法都是替换密码的特例。
**任意的单表代替密码算法可由统计的方式破译**

**简单代替密码(simple substitution cipher)：**
又称单字母密码(monoalphabetic cipher)，明文的一个字符用相应的一个密文字符代替。

**多字母密码(ployalphabetic cipher)：**
明文中的字符映射到密文空间的字符还依赖于它在上下文的位置。

**多字母代替密码：Playfair**
Playfair：将明文中的双字母组合作为一个单元对待，并将这些单元转换为密文的双字母组合。
5×5变换矩阵： I与J视为同一字符
加密规则：按成对字母加密
 相同对中的字母加分隔符(如x) 
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190314165721700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
  balloon ->ba lx lo on
 同行取右边: he -> EC
 同列取下边: dm -> MT
 其他取交叉: kt > MQ，OD > TR

**Hill密码：**
基于矩阵的线性变换，由数学家Lester Hill于1929年研制
Z26上的线性变换
例：x＝（x1，x2），y＝（y1，y2）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190314165813773.png)定义：y~1~＝11x~1~＋3x~2~ mod 26，y~2~＝  8x~1~＋7x~2~ mod 26

**Vigenére密码：**
是一种多表移位代替密码
设d为一固定的正整数，d个移位代换π=(π1,π2,…,πd) 由密钥序列K=(k1,k2,…,kd)给定，第i+td个明文字母由表i决定，即密钥ki决定
ek(xi+td) = (xi+td + ki) mod q = y，dk(yi+td) = (xi+td－ki) mod q = x
例子：q=26, x=polyalphabetic cipher, K=RADIO
明文 x= p o lya   l phab  e t i cc    i pher 
密钥 k= R ADIO RADIO  RADIO   RADIO  
密文 y= GOOGO  CPKTP   NTLKQ   ZPKMF

**One-Time Pad一次一密：**
Joseph Mauborgne提出使用与消息一样长且无重复的随机密钥来加密消息，密钥只对一个消息加解密，之后弃之不用；每条新消息都需要与其等长的新密钥，这就是一次一密，它是不可攻破的。
运算基于二进制数据而非字母
加密：ci = pi ⊕ ki, pi是明文第i个二进制位， ki是密钥第i个二进制位，ci是密文第i个二进制位， ⊕是异或运算
密文是通过对明文和密钥的逐位异或而成的，根据异或运算的性质，解密过程为pi = ci ⊕ ki, 
给出任何长度与密文一样的明文，都存在着一个密钥产生这个明文。如果用穷举法搜索所有可能的密钥，会得到大量可读、清楚的明文，但是无法确定哪个才是真正所需的，因而这种密码不可破。
**一次一密的两个限制**
产生大规模随机密钥有实际困难
密钥的分配和保护无法保证
## 置换密码(permutation cipher)
又称换位密码(transposition cipher)，明文的字母保持相同，但顺序被打乱了。

**斯巴达密码棒**
>公元前405年，雅典和斯巴达之间的战争已进入尾声。斯巴达急需摸清波斯帝国的具体行动计划。斯巴达军队捕获了一名从波斯帝国回雅典送信的信使。可他身上除了一条布满希腊字母字样的普通腰带外，什么也没有。
斯巴达统帅把注意力集中到了那条腰带上，他反复琢磨那些乱码似的文字，却怎么也解不出来。最后当他无意中把腰带呈螺旋形缠绕在手中的剑鞘上时，原来腰带上那些杂乱无章的字母，竟组成了一段文字。它告诉雅典，波斯准备在斯巴达发起最后攻击时，突然对斯巴达军队进行袭击。

**栅栏技术：**
在这种密码中最简单的是栅栏技术，在该密码中以对角线顺序写下明文，并以行的顺序读出。
例如：以深度为2的栅栏密码加密消息“meet me  after the toga party”，写出如下形式：
|m |  |e| |m| | a| | t| |r| |h| | t| | g | |p | |r| |y|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
|  |     e| |t| | e| | f| | e| | t| | e| | o| | a| | a| | t|
被加密的消息为：mematrhtgpryetefeteoaat

**置换密码：**
更为复杂的方式是以一个矩形逐行写出消息，再逐列读出该消息。
该方法以行的顺序排列。列的阶则成为该算法的密钥。密钥包含3方面信息:：行宽、列高、读出顺序
例：
|key    | 4|  3|  1|  2|  5|  6|  7|
|--|--|--|--|--|--|--|--|--|
|plaintext:    |a | t |  t | a|  c|  k|  p|
 | |  o|  s |  t|  p | o | n|  e|
 | |  d|  u |  n|  t|   i|   l|   t|
   || w | o | a | m |x | y|  z|
ciphertext ：TTNAAPTMTSUOAODWCOIXPETZ

完全保留字符的统计信息
使用多轮加密可提高安全性

**Rotor Machines转轮密码机：**
在现代密码系统出现之前，转轮密码机是最为广泛使用的多重加密器，尤其是在第二次世界大战中。
代表：German Enigma, Japanese Purple
转轮机使用了一组相互独立的旋转圆筒，可以通过电脉冲，每个圆筒有26个输入和26个输出，每个输入仅与一个输出相连，一个圆筒就定义了一个单表代换。
每按下一个键，圆筒旋转一个位置，内部连线相应改变，就定义了不同的单表代换密码，经过26个明文字母，圆筒回到初始状态，就得到一个周期为26的多表代换密码。
3个圆筒的转轮机就有263=17576个不同的代换字母表

Enigma的使用
>发信人首先要调节三个转子的方向，而这个转子的初始方向就是密钥，是收发双方必须预先约定好的，然后依次键入明文，并把显示器上灯泡闪亮的字母依次记下来，最后把记录下的闪亮字母按照顺序用正常的电报方式发送出去。
收信方收到电文后，只要也使用一台恩尼格玛，按照原来的约定，把转子的方向调整到和发信方相同的初始方向上，然后依次键入收到的密文，显示器上自动闪亮的字母就是明文了。
加密的关键在于转子的初始方向。如果敌人收到了完整的密文，还是可以通过不断试验转动转子方向来找到这个密匙，特别是如果破译者同时使用许多台机器同时进行这项工作，那么所需要的时间就会大大缩短。对付这样暴力破译法(即一个一个尝试所有可能性的方法)，可以通过增加转子的数量来对付，因为只要每增加一个转子，就能使试验的数量乘上26倍！
由于增加转子就会增加机器的体积和成本，恩尼格玛密码机的三个转子是可以拆卸下来并互相交换位置，这样一来初始方向的可能性一下就增加了六倍。假设三个转子的编号为1、2、3，那么它们可以被放成123-132-213-231-312-321这六种不同位置。
恩尼格玛还有一道保障安全的关卡，在键盘和第一个转子之间有块连接板。通过这块连接板可以用一根连线把某个字母和另一个字母连接起来，这样这个字母的信号在进入转子之前就会转变为另一个字母的信号。这种连线最多可以有六根，后期的恩尼格玛甚至达到十根连线，这样就可以使6对字母的信号两两互换，其他没有插上连线的字母则保持不变。当然连接板上的连线状况也是收发双方预先约定好的。
转子的初始方向、转子之间的相互位置以及连接板的连线状况组成了恩尼格玛三道牢不可破的保密防线，其中连接板是一个简单替换密码系统，而不停转动的转子，虽然数量不多，但却使整个系统变成了复式替换系统。

Enigma的破解
>“暴力破译法”还原明文，需要试验多少种可能性：
三个转子不同的方向组成了26ｘ26ｘ26＝17576种可能性；
三个转子间不同的相对位置为6种可能性；
连接板上两两交换6对字母的可能性则是异常庞大，有100391791500种；
于是一共有17576ｘ6ｘ100391791500，其结果大约为10,000,000,000,000,000！即一亿亿种可能性！

**单密钥系统的加密密钥和解密密钥相同，或实质上等同，即从一个易于得出另一个，如下图所示。**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190316123246997.png)

**对称密码算法(symmetric cipher)：**

 - DES(Data Encryption Standard)
 - Triple DES
 - IDEA
 - AES
 - RC5
 - CAST-128
 - 。。。。。。


# 分组密码算法(Block Cipher)

## 特点

 - 明文被分为固定长度的块，即分组，分组一般为64比特，或者128比特
 - 对每个分组用相同的算法和密钥加/解密
 - 密文分组和明文分组同样长

## 分组密码原理

分组密码是将明文消息编码表示后的数字(简称明文数字)序列，划分成长度为n的组(可看成长度为n的矢量)，每组分别在密钥的控制下变换成等长的输出数字(简称密文数字)序列。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190316123631969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

## 分组密码的一般设计原理
- 加密函数：V~n~×K→V~n'~，n是n维矢量空间，K为密钥空间。
- 在相同的密钥k的控制下，加密函数可看成是函数E(ο,K): V~n~→V~n'~，这实质上是对字长为n的数字序列的置换。
- 分组加密器本质上就是一个巨大的替换器，在密钥的控制下，能从一个足够大和足够好的置换子集中简单而迅速地选出一个置换，用来对当前输入的明文数字组进行加密变换。
- 采用了乘积加密器的思想，即轮流使用替代和置换
- Shannon提出的设计密码系统的两种基本方法：扩散和混淆。Shannon认为，在理想密码系统中，密文的所有统计特性都应与使用的密钥独立。

扩散
>要求明文的统计特征消散在密文中。即让明文的每个比特影响到密文的许多比特的取值。尽可能使明文和密文的统计关系变复杂。

   混淆
>使密文与密钥之间的统计关系尽量复杂，以阻止攻击者发现密钥。

- 扩散和混淆的目的都是为了挫败推测出密钥的尝试，从而抗击统计分析。
- 迭代密码是实现混淆和扩散原则的一种有效的方法。
- 迭代密码是实现混淆和扩散原则的一种有效的方法。合理选择的轮函数经过若干次迭代后能够提供必要的混淆和扩散。
- 分组密码由**加密算法、解密算法和密钥扩展算法**三部分组成。解密算法是加密算法的逆，由加密算法惟一确定，因而我们主要讨论加密算法和密钥扩展算法。 

## 分组密码的一般结构--Feistel网络结构
- Feistel网络是由Horst Feistel在设计Lucifer分组密码时基于扩散和扰乱的思想所发明的，并因被DES采用而流行。
- 现在正在使用的几乎所有重要的对称分组密码都使用这种结构，如FEAL、Blowfish等。
- Feistel密码结构的设计动机
   - 分组密码对n比特的明文分组进行操作，产生出一个n比特的密文分组，共有2n个不同的明文分组，每一种都必须产生一个唯一的密文分组，这种变换称为可逆的或非奇异的。
   -  |   可逆映射 |     |      |      |  不可逆映射|
   		|---|----|----|---|---|  	
  		 | 00 | 11   |      |     00        |       11   |   
      |     01       |       10          |  |        01          |     10   |   
      |   10      |        00            | |        10       |        ==01==   |   
    	|     11     |         01         | |      11        |       ==01== |
   -  n = 4时的一个普通代换密码的结构
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190316124926525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

**Feistel网络结构原理**
一个分组长度为n (偶数)比特的L轮Feistel网络的加密过程如下：
- 给定明文P，将P分成左边和右边长度相等的两半并分别记为L~0~    和R~0~，从而P = L~0~R~0~，进行L轮完全类似的迭代运算后，再将左边和右边长度相等的两半合并产生密文分组。 
- 每一轮i从以前一轮得到的L~i-1~和R~i-1~为输入，另外的总输入还有从总的密钥K生成的子密钥K~i~。

其中L~i~和R~i~的计算规则如下：

- L~i~  = R~i-1~； R~i~ = L~i-1~ ⊕F(R~i-1~,K~i~)
- 在第L轮迭代运算后，将L~L~和R~L~再进行交换，输出C = R~L~L~L~
- 其中F是轮函数，K~i~是由种子密钥K生成的子密钥
- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190316125424306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
- 一般结构
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190316125524887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

 **Feistel网络的安全性和软、硬件实现速度取决于下列参数：**
- 分组长度：分组长度越大则安全性越高（其他条件相同时），但加、解密速度也越慢。64比特的分组目前也可用，但最好采用128比特。 
- 密钥长度：密钥长度越大则安全性越高（其他条件相同时），但加、解密速度也越慢。64比特密钥现在已不安全，128比特是一个折中的选择。 
- 循环次数：Feistel网络结构的一个特点是循环次数越多则安全性越高，通常选择16次。

**Feistel网络的安全性和软、硬件实现速度取决于下列参数：**

- 子密钥算法：子密钥算法越复杂则安全性越高。 
- 轮函数：轮函数越复杂则安全性越高。 
- 快速的软件实现：有时候客观条件不允许用硬件实现，算法被镶嵌在应用程序中。此时算法的执行速度是关键。 
- 算法简洁：通常希望算法越复杂越好，但采用容易分析的却很有好处。若算法能被简洁地解释清楚，就能容易通过分析算法而知道算法抗各种攻击的能力，也有助于设计高强度的算法。

**Feistel网络解密过程**
- Feistel网络解密过程与其加密过程实质是相同的。
- 以密文分组作为算法的输入，但以相反的次序使用子密钥，即- 第一轮使用K~L~，第二轮使用K~L-1~，直至第L轮使用K~1~，这意味着可以用同样的算法来进行加、解密。
- 先将密文分组C = R~L~L~L~，分成左边和右边长度相等的两半，分别记为L~0’~和R~0’~，根据下列规则计算 L~i’~ R~i’~
                  L~i’~  = R~i-1’~ ，R~i’~ = L~i-1’~ ⊕ F (R~i-1’~ ，K~i’~)           1≤i≤L
- 最后输出的分组是R~L’~L~L’~


## 数据加密标准(DES)
数据加密标准(Data Encryption Standard，DES)是至 今为止使用最为广泛的加密算法。
>1974年8月27日, NBS开始第二次征集,IBM提交了算法LUCIFER，该算法由IBM的工程师在1971~1972年研制。
1975年3月17日, NBS公开了全部细节1976年,NBS指派了两个小组进行评价。
1976年11月23日，采纳为联邦标准，批准用于非军事场合的各种政府机构。
1977年1月15日,“数据加密标准”FIPS PUB 46发布
规定每隔5年由美国国家保密局(National Security Agency)重新评估它是否继续作为联邦加密标准。
最近的一次评估是在1994年1月，当时决定1998年12月以后，DES不再作为联邦加密标准。新的美国联邦加密标准被称为高级加密标准AES ( Advanced Encryption Standard )。
DES对推动密码理论的发展和应用起到了重大的作用，学习 和研究它，对于掌握分组密码的基本理论、设计思想和实际应用仍然有着重要的参考价值。

# DES加密的主要步骤和操作
DES背景
>数据加密标准(Data Encryption Standard，DES)是至 今为止使用最为广泛的加密算法。
1974年8月27日, NBS开始第二次征集,IBM提交了算法LUCIFER，该算法由IBM的工程师在1971~1972年研制。
1975年3月17日, NBS公开了全部细节1976年,NBS指派了两个小组进行评价。
1976年11月23日，采纳为联邦标准，批准用于非军事场合的各种政府机构。
1977年1月15日,“数据加密标准”FIPS PUB 46发布
规定每隔5年由美国国家保密局(National Security Agency)重新评估它是否继续作为联邦加密标准。
最近的一次评估是在1994年1月，当时决定1998年12月以后，DES不再作为联邦加密标准。新的美国联邦加密标准被称为高级加密标准AES ( Advanced Encryption Standard )。
DES对推动密码理论的发展和应用起到了重大的作用，学习 和研究它，对于掌握分组密码的基本理论、设计思想和实际应用仍然有着重要的参考价值。 

## DES的变形
双重DES
最简单的多次加密形式有两个加密阶段和两个密钥，给定一个明文P和两个加密密钥K1和K2，有：
C = E~K2~(E~K1~(/P)) ←→ P = D~K1~(D~K2~(/C))
对于DES来说，密钥长度56×2＝112
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190331160521973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
**双密钥的三重DES**
一个用于对付中途攻击的明显方法是用3个密钥进行三个阶段的加密，这样要求一个56×3＝168bit的密钥，这个密钥有点过大。
作为一种替代方案，Tuchman提出使用两个密钥的三重加密方法。这个加密函数采用一个加密－解密－加密序列： 
C=E~K1~(D~K2~(E~K1~(/P))) ←→ P=D~K1~(E~K2~( D~K1~(/C)))。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190331160641464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

## 具体细节
https://blog.csdn.net/Caoyang_He/article/details/88868493
# AES加密的主要步骤和操作
AES背景
>1997年4月15日，美国国家标准技术研究(NIST)发起征集高级加密标准(Advanced Encryption Standard)AES的活动，活动目的是确定一个非保密的、可以公开技术细节的、全球免费使用的分组密码算法，作为新的数据加密标准。
1997年9月12日，美国联邦登记处公布了正式征集AES候选算法的通告。基本要求是：比三重DES快、至少与三重DES一样安全、数据分组长度为128比特、密钥长度为128/192/256比特。
1998年8月12日，在首届AES会议上指定了15个候选算法。
1999年3月22日第二次AES会议上，将候选名单减少为5个，这5个算法是RC6，Rijndael，SERPENT，Twofish和MARS。
2000年4月13日，第三次AES会议上，对这5个候选算法的各种分析结果进行了讨论。
2000年10月2日，NIST宣布了获胜者—Rijndael算法，2001年11月出版了最终标准FIPS PUB197

AES的总体描述
>AES具有128bit的分组长度，三种可选的密钥长度，即128bit、192bit和256bit。AES是一个迭代型密码；轮数Nr依赖于密钥长度。密钥为128bit、192bit、256 bit时，轮数分别为：10、12、14。算法执行过程如下：

1.  给定一个明文x，将State初始化为x，并进行AddRoundKey操作，将RoundKey和State异或。
2.  对前Nr－1轮中的每一轮，用S盒对进行一次代换操作，称为SubBytes；对State做一置换ShiftRows；再对State做一次操作MixColumns；然后进行AddRoundKey操作。
3.   依次进行SubBytes、 ShiftRows和AddRoundKey操作。
4.   将State定义为密文。

AES的参数
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019033115593430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

## 具体细节
https://blog.csdn.net/Caoyang_He/article/details/88868493
# 分组密码的工作模式

## 含义
分组密码在加密时明文分组的长度是固定的，而实用中待加密消息的数据量是不定的，数据格式可能是多种多样的。为了能在各种应用场合安全地使用分组密码，通常 对不同的使用目的运用不同的工作模式。
一个分组密 码的工作模式就是以该分组密码为基础构造的一个密码系统。
目前已提出许多种分组密码的工作模式，如电码本(ECB)、密码分组链接(CBC)、密码反馈(CFB)、输 出反馈(OFB)、级连(CM)、计数器、分组链接(BC)、扩散密码分组链接(PCBC)、明文反馈(PFB) 、非 线性函数输出反馈(OFBNLF)等模式。
**PS：提出分组密码的工作模式就是为了让同一个分组的明文加密后的密文不同，从而避免统计攻击**

## ECB(Electronic Codebook)模式
ECB(Electronic Codebook)模式是最简单的运行模式，它一次对一个64比特长的明文分组加密，而且每次的加密密钥都相同

**概念图**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190331154127395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
**优点**
1. 实现简单
2. 不同明文分组的加密可并行实施,尤其是硬件实现时速度很快

**缺点**
不同的明文分组之间的加密独立进行，造成相同明文分组对应相同密文分组，因而不能隐蔽明文分组的统计规律和结构规律，不能抵抗替换攻击。

**典型应用**
1.  用于随机数的加密保护；
2. 用于单分组明文的加密。

**实例**
例: 假设银行A和银行B之间的资金转帐系统所使用报文模式如下
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190331154321322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
敌手C通过截收从A到B的加密消息，只要将第5至第12分组替换为自己的姓名和帐号相对应的密文，即可将别人的存款存入自己的帐号。

## 密码分组链接(CBC-Cipher Block Chaining)模式
每次加密使用同一密钥，加密算法的输入是当前明文前一次密文组的异或。因此加密算法的输入与明文分组之间 不再有固定的关系，所以重复的明文分组不会在密文中暴露。

**概念图**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190331154519652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
**特点**
1. 明文块的统计特性得到了隐蔽。
由于在密文CBC模式中，各密文块不仅与当前明文块有关，而且还与以前的明文块及初始化向量有关，从而使明文的统计规律在密文中得到了较好的隐蔽。
2. 具有有限的(两步)错误传播特性。
一个密文块的错误将导致两个密文块不能正确脱密。
3. 具有自同步功能
密文出现丢块和错块不影响后续密文块的脱密。若从第t块起密文块正确，则第t+1个明文块就能正确求出。
4. 明文分组中一位出错，将影响该分组的密文及其以后的所有密文分组


**典型应用**

1. 数据加密;         
2.  完整性认证和身份认证;

**完整性认证的含义**
>完整性认证是一个“用户”检验它收到的文件是否遭到第三方有意或无意的篡改。

**实例**
例：电脑彩票的防伪技术
方法：
1) 选择一个分组密码算法和一个认证密钥，存于售票机内 
2) 将电脑彩票上的重要信息，如彩票期号、彩票号码、彩票股量、售票单位代号等重要信息按某个约定的规则作为彩票资料明文
3) 对彩票资料明文扩展一个校验码分组后，利用认证密钥和分组密码算法对之加密，并将得到的最后一个分组密文作为认证码打印于彩票上面；

认证过程：
执行3)，并将计算出的认证码与彩票上的认证码比较，二者一致时判定该彩票是真彩票，否则判定该彩票是假彩票。

## CFB(Cipher Feedback)模式：
若待加密消息需按字符、字节或比特处理时，可采用CFB模式。并称待加密消息按 j 比特处理的CFB模式为 j 比特CFB模式。

**适用范围**
适用于每次处理 j比特明文块的特定需求的加密情形,能灵活适应数据各格式的需要。

**概念图**
加密
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190331154947669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
解密
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190331155000183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
**优点**
1. 这是将分组密码当作序列密码（数据以位或者字节形式到达）使用的一种方式，
2. 加密、解密都需要用到分组加密器；
3. 明文发生错误，错误会传播；
4. 如果密文发生传输错误，只会影响它出现在移位寄存器期间解密的8个字节的数据得不到正确解密，8个字节一过，后面明文可以得到正确的解密结果。

**缺点**
比较浪费，因为每轮加解密中都丢弃了大部分结果，通常只保留了的S为为1个字节。

## OFB (Output Feedback)模式
OFB 模式在结构上类似于CFB。不同之处
1. OFB模式将加密算法的输出反馈到移位寄存器，而CFB模式是将密文单元反馈到移位寄存器。 
2.  OFB针对明文和密文分组运算，而CFB仅对S位的子集运算

**概念图**
加密
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190331155139486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
解密
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190331155201205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
**优点**
1. 传输过程中的比特错误不会被传播。
例如C1中出现一比特错误，在解密结果中 只有P1受影响，以后各明文单元则不受影响 。而在CFB中， C1也作为移位寄存器的输入，因此它的一比特错误会影响解 密结果中各明文单元的值。
解密中密文的1比特也只影响明文的1个错误
2. 分组密码转化为流模式;
3. 可以及时加密传送小于分组的数据;

**缺点**
难于检测密文是否被篡改。

**适用于传输语音图像**

## 计数器模式CTR(Counter)
对一系列输入数据块(称为计数)进行加密，产生一系列的输出块，输出块与明文异或得到密文。
应用于ATM网络安全及IPSec中
密码算法产生一个16 字节的伪随机码块流，伪随机码块与输入的明文进行异或运算后产生密文输出。密文与同样的伪随机码进行异或运算后可以重产生明文。 
**概念图**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190331155338819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
**CTR的特点**
- 使用与明文分组规模相同的计数器长度
- 处理效率高（并行计算）
- 预处理可以极大提高吞吐量：算法和加密盒的输出不依靠明文和密文的输入
- 可以随机对任意一个密文分组进行解密处理，对该密文分组的处理与其他密文无关（第i块解密不依赖第i-1块）
- 实现的简单性，只是异或，且无解密算法
- 适用于实时性和速度要求较高的场合
## 总结


模式|描述|典型应用
---|---|----|
电码本（CBC）|用相同的密钥分别对明文分组独立加密|单个数据的安全传输（如一个加密密钥）
密文分组链接（CBC）|加密算法的输入是上一个密文组和下一个明文组的异或| 面向分组的通用传播<br>认证
密文反馈（CFB）| 一次处理s位，上一块密文作为加密算法的输入，产生的伪随机数输出与明文异或作为下一个单元的密文|面向数据流的通用传播<br>认证
输出反馈（OFB）|与CFB类似，只是加密算法的输入是上一次加密的输出，且使用整个分组|噪声信道上的数据流传输（如卫星通信）
计数器（CTR）|每个明文分组都与一个经过加密的计数器相异或。对每个后续分组计数器递增|面向分组的通用传播<br>用于高速需求
# 流密码

 - 每次可加密一个比特或一个字节

- 适合比如远程终端输入加密类的应用

## RC4
**简介**
>RC4由RSA三人组中的头号人物Ronald Rivest在1987年设计的密钥长度可变的流加密算法簇。 
和DES算法一样，是一种对称加密算法。
算法的速度可以达到DES加密的10倍左右，且具有很高级别的非线性 。
可变密钥长度，可变范围为1-256字节(8-2048比特) 
以随机置换为基础。密钥长度是可变的，RC4起初是用于保护商业机密的。但是在1994年9月，它的算法被发布在互联网上，也就不再有什么商业机密了 
用途广泛，常用于SSL/TLS，IEEE 802.11无线语句网标准的一部分WEP（Wired Equivalent Privacy）协议和新Wifi受保护访问协议(WPA)中。

**相关概念**
1. 密钥流：RC4算法的关键是根据明文和密钥生成相应的密钥流，密钥流的长度和明文的长度是对应的，也就是说明文的长度是500字节，那么密钥流也是500字节。当然，加密生成的密文也是500字节，因为密文第i字节=明文第i字节^密钥流第i字节；
2. 状态向量S：长度为256，S[0],S[1].....S[255]。每个单元都是一个字节，算法运行的任何时候，S都包括0-255的8比特数的排列组合，只不过值的位置发生了变换；
3. 临时向量T：长度也为256，每个单元也是一个字节。如果密钥的长度是256字节，就直接把密钥的值赋给T，否则，轮转地将密钥的每个字节赋给T；
4. 密钥K：长度为1-256字节，注意密钥的长度keylen与明文长度、密钥流的长度没有必然关系，通常密钥的长度趣味16字节（128比特）。

**概念图**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190331153635796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
**伪代码**
第一部分：初始化算法（KSA） 
1. 初始化S和T
for i=0 to 255 do
   S[i]=i;
   T[i]=K[ i mod keylen ];
2. 初始排列S
j=0;
for i=0 to 255 do
   j= ( j+S[i]+T[i])mod256;
   swap(S[i],S[j]);
   
 第二部分：伪随机子密钥流生成算法

3.  产生密钥流
i,j=0;
for r=0 to len do  //r为明文长度，r字节
   i=(i+1) mod 256;
   j=(j+S[i])mod 256;
   swap(S[i],S[j]);
   t=(S[i]+S[j])mod 256;
   k[r]=S[t]; 

# 公钥算法和对称钥算法区别

## 对称加密的优点

速度快，处理量大，适用于对应用数据的直接加密。
加密密钥长度相对较短,如40比特～256比特。
可构造各种加密体制，如产生伪随机数，HASH函数等。

## 对称加密的缺点

密钥在双方都要一致、保密，传递较难。
大型网络中密钥量大，难以管理，一般需要TTP（KDC）。
密钥需要经常更换
数字签名的问题：传统加密算法无法实现抗抵赖的需求。
## 公钥加密的优点

只有秘密钥保密，公开钥公开。
密钥生命周期相对较长。
许多公钥方案可以产生数字签名机制。
在大型网络上，所需的密钥相对较少。

## 公钥加密的缺点

速度慢，处理量少，适用于密钥交换。
密钥长度相对较长。
安全性没有得到理论证明。

# 公钥算法的思想

## 公钥密码体制的起源

1976年，Standford Uni. Diffie博士和其导师Hellman 在IEEE Trans. on IT 上发表划时代的文献：
W.Diffie and M.E.Hellman, New Directrions in Cryptography, IEEE Transaction on Information Theory, V.IT-22.No.6, Nov 1976, PP.644-654
这一体制的出现为解决计算机信息网中的安全提供了新的理论和技术基础，被公认为现代够公钥密码学诞生的标志。
1978年，MIT三位数学家R.L.Rivest，A.Shamir和L.Adleman 发明了一种用数论构造双钥体制的方法，称作MIT体制，后来被广泛称之为RSA体制。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190420163209248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

## 公钥密码体制的基本原理
### 公钥算法基于数学函数而不是基于替换和置换
使用两个独立的密钥
公钥密码学的提出是为了解决两个问题：
密钥的分配
数字签名

### 基本思想和要求
用户拥有自己的密钥对(K~U~,K~R~)，即（公开密钥，私有密钥）
公钥K~U~公开，私钥K~R~保密 A->B：Y=EKUb(X)
B：DK~Rb~(Y)= DK~Rb~(EK~Ub~(X))=X
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190420163539617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
### 公钥体制的主要特点
- 加密和解密能力分开
- 多个用户加密的消息只能由一个用户解读，（用于公共网络中实现保密通信）
- 只能由一个用户加密消息而使多个用户可以解读（可用于认证系统中对消息进行数字签字）。
- 无需事先分配密钥
- 密钥持有量大大减少
- 提供了对称密码技术无法或很难提供的服务：如与哈希函数联合运用可生成数字签名，可证明的安全伪随机数发生器的构造，零知识证明等
### 基本思想和要求
- 涉及到各方：发送方、接收方、攻击者
 - 涉及到数据：公钥、私钥、明文、密文
 - 公钥算法的条件：
    -  产生一对密钥是计算可行的
    - 已知公钥和明文，产生密文是计算可行的
     - 接收方利用私钥来解密密文是计算可行的
   -  对于攻击者，利用公钥来推断私钥是计算不可行的
    - 已知公钥和密文，恢复明文是计算不可行的
    - (可选)加密和解密的顺序可交换

### 如何设计一个公钥算法
- 公钥和私钥必须相关，而且从公钥到私钥不可推断
必须要找到一个难题，从一个方向走是容易的，从另一个方向走是困难的
如何把这个难题跟加解密结合起来
- 一个实用的公开密钥方案的发展依赖于找到一个陷阱门单向函数。

### 陷门单向函数
- 单向陷门函数是满足下列条件的函数f：
(1)给定x，计算y=fk(x)是容易的；
(2)给定y，计算x使x=fk-1(y)是不可行的。
(3)存在k，已知k时,对给定的任何y，若相应的x存在，则计算x使fk-1(y)是容易的。
### 非对称密钥加密的原理
- 使用数学上的理论；
- 数学上某些复杂的计算问题：正向计算容易，反向计算困难。计算机不可能在有效的时间内算出反向结果（从而不可能破解密码）。
- 例如：
     - 计算两个大数的乘积，非常容易。
     - 分解一个很大的数（如200多位）非常困难，假如这个大数只含有两个非常大的素数（各100多位）作为因子。
     - 背包问题
     - 大整数分解问题（The Integer Factorization Problem, RSA体制）
     - 二次剩余问题
     - 模n的平方根问题
     - 离散对数问题：
     - 有限域的乘法群上的离散对数问题（The Discrete Logarithm Problem, ELGamal体制）
     - 定义在有限域的椭圆曲线上的离散对数问题（The Elliptic Curve Discrete Logarithm Problem，类比的ELGamal体制）

### 公钥密钥的应用范围
加密/解密
 数字签名(身份鉴别)
 密钥交换
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190420164432267.png)
# Diffie-Hellman密钥协商协议
## Diffie-Hellman密钥交换算法
允许两个用户可以安全地交换一个秘密信息，用于后续的通讯过程

算法的安全性依赖于计算离散对数的难度

## Diffie-Hellman算法
1) 双方选择素数p以及p的一个原根a
2) 用户A选择一个随机数X~a~ < p，计算Y~a~=a^Xa^ mod  p
3) 用户B选择一个随机数X~b~ < p，计算Y~b~=a^Xb^ mod  p
4) 每一方保密X值，而将Y值交换给对方
5) 用户A计算出 K=Y~b~X~a~ mod p
6) 用户B计算出 K=Y~a~X~b~ mod p
7) 双方获得一个共享密钥(a^XaXb^mod p)
注：素数p以及p的原根a可由一方选择后发给对方
## Diffie-Hellman算法例：
密钥交换基于素数q = 97和97的一个原根，在这里是a = 5。A和B分别选择秘密密钥X~a~ = 36和X~b~ = 58。每人计算其公开密钥如下：
Y~a~ = 536 = 50 mod 97
Y~b~ = 558 = 44 mod 97
在他们交换了公开密钥以后，每人计算共享的秘密密钥如下：
A : K = (Y~b~)X~a~ mod 97 = 4436 = 75 mod 97
B : K = (Y~a~)X~b~ mod 97 = 5058 = 75 mod 97
从{50，44}出发，攻击者要计算出75很不容易

# RSA算法的数学原理
## RSA密码体制的建立：
### 产生密钥对
1、选择两个大素数p,q, p ≠q          （p、q 私有，选定）
2、计算n=pq(n<2^1024^ )                （n 公开，计算出）
3、选择整数e，使得gcd(e,Φ(n))=1     （e公开，选定的）
4、计算d ≡ e^-1^ mod Φ(n)              (d保密，计算得出的）                          
### 公钥: KU={e,n},  私钥: KR={d,n}
### 使用
加密: 明文M<n, C = M^e^ mod n
解密:          M = C^d^ mod n

### RSA的正确性：
加密：C = Me mod n (M<n)
解密：M = Cd mod n

### RSA的实例：
选p = 7，q = 17，则
n = pq = 119，φ(n) = (p-1)(q-1) = 6×16 = 96
取e = 5，它小于96，并且与96互为素数
则d = 77   ( ∵5×77 = 385 = 4×96＋1≡1 mod 96 )
公钥（5，119），私钥（77，119） 
加密M = 19
则C = Me mod n = 195 mod 119 = 66 mod 119
解密C = 66
M = Cd mod n = 6677mod 119 = 19 mod 119

### DES和RSA性能比较(同等强度)：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190420165728787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

## 基础：IFP(Integer Factorization Problem)

## 加/解密、密钥交换、数字签名

## 使用最广泛

# ElGamal
### ElGamal加密算法：
ElGamal加密算法是在密码协议中有着大量应用的一类公钥密码算法，由ElGamal[1984,1985]提出，是除了RSA密码之外最有代表性的公开密钥密码。
是一种基于有限域GF(P)上的离散对数问题的公钥密码体制
既可用于加密，又可用于签名。
选择：一个素数p，p的一个原根(本原元)r，一个整数a(0≦a≦p-2)，令s = r ^a^ mod P，公开{p, r, s}，保密a。
对于明文信息x，加密：秘密选择随机数k(0≦k≦p-2)，计算(y1，y2)作为密文，其中：y~1~ = r ^k^ mod p， y2 = x s ^k^ mod p
解密: y~2~(y~1~^a^)^-1^ mod P
即：( xs^k^ ) ( ( r^k^ ) ^a^ )^ -1^ ≡ xr^ak^  r ^- ak^ ≡ x mod p 

ElGamal加密算法是非确定性的，因为每次加密都要选择一个随机数，相同的明文随着加密前随机数k的不同产生不同的密文
## 基础: DLP(Discrete Logarithm Problem)

## 加/解密、密钥交换、数字签名
# 一些数学基础
## 数论简介：
数论是密码学特别是公钥密码学的基本工具。研究“离散数字集合”的相关问题。
## 素数和互素数
称整数p(p>1)是素数，如果p的因子只有±1，±p。
若满足下面2个条件，则称c是两个整数a、b的最大公因子，表示为c=gcd(a, b)。
① c是a的因子也是b的因子，即c是a、b的公因子。
② a和b的任一公因子，也是c的因子。
如果gcd(a,b)=1，则称a和b互素。

### 模运算：
设n是一正整数，a是整数，如果用n除a，得商为q，余数为r，用a mod n表示余数r。
如果(a mod n)=(b mod n)，则称两整数a和b模n同余，记为a≡b mod n。
称与a模n同余的数的全体为a的同余类，记为[a]，称a为这个同余类的表示元素。
注意： 如果a≡0(mod n)，则n|a。

同余有以下性质： 
① 若n|(a-b)，则a≡b mod n。
② (a mod n)≡(b mod n)，则a≡b mod n。
③ a≡b mod n,则b≡a mod n。
④ a≡b mod n,b≡c mod n,则a≡c mod n。

求余数运算（简称求余运算）a mod n将整数a映射到集合{0,1, …,n-1}，称求余运算在这个集合上的算术运算为模运算
模运算有以下性质： 
[(a mod n)+(b mod n)] mod n = (a+b) mod n
[(a mod n)- (b mod n)] mod n = (a-b) mod n
[(a mod n)×(b mod n)] mod n = (a×b) mod n

费马(Fermat)定理：
p素数，a是整数且不能被p整除，则：ap-1 ≡ 1 mod p
例：a = 7，p = 19，则a^p-1^ = 7^18^ ≡ 1 mod p 

欧拉(Euler)函数Φ(n)：
Φ(n)表示小于n且与n互素的正整数个数。例：Φ(6) = 2
p是素数，Φ(p) = p－1 。例：Φ(7) = 6
若n的因子分解为n=∏Piai, ai>0,Pi互不相同,则Φ(n) = ΦPiaiΦ(1－1/Pi)
若gcd(m,n) = 1，则Φ(mn) = Φ(m)Φ(n)，特别地,若pφq，且都是素数，φ(pq)=(p-1)(q-1)。如： φ(21) = 12 = φ(3)× φ(7) = 2×6

Euler定理：
若a与n为互素的正整数,则a^φ(n)^ ≡ 1 mod n
例：a＝3，n＝10，φ(10)＝4，3^4^＝81 ≡ 1 mod 10
 Euler定理的等价形式： 
a^φ(n)＋1^ ≡ a mod n
推论: 若n=pq, p≠q都是素数, k是任意整数,则
mkφ(n) + 1＝mk(p-1)(q-1)+1 ≡ m mod n, 对任意0≤m≤n

原根(Primitive root)
Euler定理表明：对两个互素的整数a，n
a^φ(n)^ ≡ 1 mod n
定义：存在最小正整数m≤φ(n) (m|φ(n))，使得a^m^ ≡ 1 mod n，若对某个a，m=φ(n)，则称a是n的一个原根

#### 离散对数
若a是素数p的一个原根,则对任意整数b，b≠0 mod p，存在唯一的整数i， 1≤i≤(p-1)，使得：b ≡ a^i^ mod p，i称为b以(a mod p)的指数(离散对数)，记作ind~a,p~(b)。
两个性质：
ind~a,p~(xy) = [ind~a,p~(x)+ind~a,p~(y)] mod φ(p)
ind~a,p~(xr) = [r x ind~a,p~(x)] mod φ(p)
离散对数的计算：y ≡ g^x^ mod p，
已知g，x，p，计算y是容易的
已知y，g，p，计算x是困难的

# 消息认证
消息认证 (Message Authentication)：是一个证实收到的消息来自可信的源点且未被篡改的过程。 
## 鉴别的目的
鉴别的主要目的有二：
第一，验证信息的发送者是真正的，而不是冒充的，此为信源识别；
第二，验证信息的完整性，在传送或存储过程中未被篡改，重放或延迟等。

## 鉴别模型
一个单纯鉴别系统的模型
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426200107925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
## 鉴别系统的组成
鉴别编码器和鉴别译码器可抽象为鉴别函数。一个安全的鉴别系统，需满足
1) 接收者能够检验和证实消息的合法性、真实性和完整性
2) 消息的发送者和接收者不能抵赖
3) 除了合法的消息发送者，其它人不能伪造合法的消息

首先要选好恰当的鉴别函数，该函数产生一个鉴别标识，然后在此基础上，给出合理的鉴别协议(Authentication Protocol)，使接收者完成消息的鉴别。

## 鉴别函数
可用来做鉴别的函数分为三类：
1) 消息加密函数(Message encryption)：用完整信息的密文作为对信息的鉴别。
2) 消息鉴别码MAC(Message Authentication Code)：公开函数+密钥产生一个固定长度的值作为鉴别标识
3) 散列函数(Hash Function)：是一个公开的函数，它将任意长的信息映射成一个固定长度的信息。


## 加密认证
用完整信息的密文作为对信息的鉴别
### 对称密码体制加密认证
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426200342670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
### 公钥密码体制加密认证
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426200508176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426200527417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426200543446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
公钥密码体制加密认证
- 使用公开密钥加密信息的明文只能提供保密而不能提供认证。为了提供认证，发送者A用私钥对信息的明文进行加密，任意接收者都可以用A的公钥解密。
- 采用这样的结构既可提供了认证，也可提供数字签名。因为只有A 能够产生该密文，其它任何一方都不能产生该密文。
     - 从效果上看A 已经用私钥对信息的明文进行了签名。
     - 应当注意只用私钥加密不能提供保密性。因为，任何人只要有A的公开密钥就能够对该密文进行解密。
- 保密性与真实性是两个不同的概念。根本上，信息加密提供的是保密性而非真实性。
- 加密代价大(公钥算法代价更大)。
- 鉴别函数与保密函数的分离能提供功能上的灵活性。
广播的信息难以使用加密(信息量大)
某些信息只需要真实性,不需要保密性
## 消息认证码
带密钥的hash函数

适用于：通信双方基于共享的同一密钥来认证彼此之间交互的信息。

MAC 函数将密钥和数据块作为输入，产生hash值作为MAC码。

设M是变长的消息，K是仅由收发双方共享的密钥，则M的MAC由如下的函数C生成：MAC = C~k~(M )
这里的C~k~(M )是定长的。发送者每次将MAC附加到消息中，接收者通过重新计算MAC来对消息进行认证。
如果收到的MAC与计算得出的MAC相同，则接收者可以认为：
- 消息未被更改过
- 消息来自与他共享密钥的发送者

MAC函数类似于加密函数，主要区别在于MAC 函数不需要可逆性，而加密函数必须是可逆的，因此认证函数比加密函数更不易破解。

因为收发双方共享相同的密钥，上述过程只提供认证而不提供保密，也不能提供数字签名
### MAC的基本用法
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426200932938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426200939217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426200944908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
#### HMAC简介
ash函数用来构造MAC：HMAC为其中之一
# 散列函数：
## 概念
散列函数 (Hash Functions)：一个散列函数以一个变长的报文作为输入，并产生一个定长的散列码，有时也称报文摘要，作为输出。

散列函数(又称杂凑函数)是对不定长的输入产生定长输出的一种特殊函数：h = H(M)
其中M是变长的消息
h=H(M)是定长的散列值或称为消息摘要。

散列函数H是公开的，散列值在信源处被附加在消息上，接收方通过重新计算散列值来保证消息未被篡改。

由于函数本身公开，传送过程中对散列值需要另外的加密保护(如果没有对散列值的保护，篡改者可以在修改消息的同时修改散列值，从而使散列值的认证功能失效)。
## 散列函数的基本用法：消息认证
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426093437730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426093515385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
## 散列函数的基本用法：数字签名
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426093527401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426093620468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
## 散列函数的基本用法：其他应用
单向口令文件

入侵检测和病毒检测

构建随机函数或伪随机函数

## 两个简单的Hash函数
 分组对应位异或
  移位分组对应位异或
##  Hash函数的安全需求（重点）
散列函数的目的是为文件、消息或其他的分组数据产生“指纹”。用于消息认证的散列函数H必须具有如下性质：
1. 输入长度可变：H能用于任何大小的数据分组
2. 输出长度固定：H都能产生定长的输出
3. 效率：对于任何给定的x，H(x)要相对易于计算
4. 抗原像攻击：对任何给定的散列码h，寻找x使得H(x)=h在计算上不可行
5. 抗第二原像攻击：对任何给定的分组x，寻找不等于x的y，使得H(x)=H(y)在计算上不可行(弱抗冲突)
6. 抗强抗攻击：寻找任何的(x，y)，使得H(x)=H(y)在计算上不可行(强抗冲突)
7. 伪随机性：H的输入输出满足伪随机性测试标准

### 散列(Hash)函数的安全性需求
Oscar以一个x开始。首先他计算Z=h(x)，并企图找到一个x’满足h(x’)=h(x)。若他做到这一点，x‘也将为有效。为防止这一点，要求函数h具有无碰撞特性。

- 定义1(弱无碰撞)，散列函数h称为是弱无碰撞的，是指对给定消息x∈X，在计算上几乎找不到不等于x的x’∈X，使h(x)=h(x’)。

- 定义2(强无碰撞)，散列函数h被称为是强无碰撞的，是指在计算上几乎不可能找到任意的相异的x，x’，使得h(x)=h(x’)。
注：强无碰撞自然含弱无碰撞！

前两条要求具有实用性
第2条和第3条是单向性质，即给定消息可以产生一个散列码，而给定散列码不可能产生对应的消息
第4条性质是保证一个给定的消息的散列码不能找到与之相同的另外的消息，即防止伪造
第6条是对已知的生日攻击方法的防御能力。

### 散列函数的生日攻击
假定使用64位的散列码，是否安全?

如果采用传输加密的散列码和不加密的报文M，对手需要找到M '，使得H(M')=H(M)，以便使用替代报文来欺骗接收者。
一种基于生日悖论的攻击可能做到这一点。

生日问题：一个教室中，最少应有多少学生，才使至少有两人具有相同生日的概率不小于1/2？

生日问题：
假定一年按365天计算。每人生日在一年365天中的任何一天是等可能的，即都等于1/365
他们生日各不相同的概率为：
365\*364\*363\*…\*(365-n+1)/365~n~
因而，n个人中至少有两个人生日相同的概率为：
P = 1 - 365\*364\*363\*…*(365-n+1)/365~n~
若要使P≥0.5，n = 23即可，在64人的班级中，“至少两人生日相同”的概率为0.997（n=46，p>=94.15%)


给定一个散列函数，有n个可能的输出（m位），输出值为H(x)，如果H有k个随机输入，k必须为多大才能使至少存在一个输入y使得H(y)=H(x)的概率大于0.5。
对单个y，H(y) = H(x)的概率为1/n，H(y) ≠ H(x)的概率为1-(1/n)。
如果产生k个随机值y，他们之间两两不等的概率等于每个个体不匹配概率的乘积，即[1-(1/n)]^k^。
这样，至少有一个匹配的概率为1-[1-(1/n)]^k^≈1-[1-(k/n)]=k/n。要概率等于0.5，只需k=n/2=2^m-1^。
对长度为m位的散列码，共有2^m^个可能的散列码，若要使任意的x，y 有H(x)=H(y)的概率为0.5，只需k=2^m/2^。

## 散列函数的结构
由Merkle于1989年提出
Ron Rivest于1990年提出MD4
几乎被所有hash函数使用


具体做法：
把原始消息M分成一些固定长度的块Y~i~
最后一块padding并使其包含消息M长度
设定初始值CV~0~
重复使用压缩函数f，CV~i~ = f(CV~i-1~,Y~i-1~)
最后一个CV~i~为hash值
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426194401839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
## MD5算法、SHA算法
### MD5简介
Merkle于1989年提出hash function模型
Ron Rivest于1990年提出MD4
1992年, MD5 (RFC 1321) developed by Ron Rivest at MIT
MD5把数据分成512-bit块
MD5的hash值是128-bit
在最近数年之前，MD5是最主要的hash算法
美国标准SHA-1以MD5的前身MD4为基础
该算法以一个任意长度的报文作为输入，产生一个128bit的报文摘要作为输出。输入是按512bit的分组进行处理的。
#### [MD5算法](https://blog.csdn.net/Caoyang_He/article/details/89431923)
#### MD5小结
MD5使用小数在前
Dobbertin在1996年找到了两个不同的512-bit块，它们在MD5计算下产生相同的hash
MD5不是足够安全的
MD5在线查询破解 
http://www.md5.org.cn/
http://www.cmd5.com/
http://md5jiami.51240.com/
MD5的32位和16位加密算法
MD5通常是32位的编码，而在不少地方会用到16位的编码。16位就是从32位MD5散列中把中间16位提取出来。
admin 的摘要：
16位：7a57a5a743894a0e
32位：21232f297a57a5a743894a0e4a801fc3 

### SHA简介
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426194500901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
SHA-512逻辑
步骤1 附加填充位：消息长为模1024与896同余
步骤2 附加长度：最后128位：128位无符号整数表明消息的长度
初始化Hash缓冲区：Hash函数的中间结果和最终结果保存在512位的缓冲区中，缓冲区用8个64位寄存器（a,b,c,d,e,f,g,h）
以1024位的分组（128个字节）为单位处理消息
输出

#### [SHA1算法](https://blog.csdn.net/Caoyang_He/article/details/89431966)

#### SHA Summary
- Applications of cryptographic hash functions
Message authentication
Digital signatures
Other applications

- Requirements and security
Security requirements for cryptographic hash functions
Brute-force attacks
Cryptanalysis 

- Hash functions based on cipher block chaining

- Secure hash algorithm (SHA)
SHA-512 logic
SHA-512 round function

- SHA-3
The sponge construction
The SHA-3 Iteration Function f
# 数据签名体制
数字签名(Digital Signature)是一种防止源点或终点抵赖的鉴别技术。

消息认证（Message authentication）保护双方之间的数据交换不被第三方侵犯，但它并不保证双方自身的相互欺骗。

假定A发送一个认证的信息给B，双方之间的争议可能有多种形式：
B伪造一个不同的消息，但声称是从A收到的。
A可以否认发过该消息，B无法证明A确实发了该消息。

例如：股票交易指令亏损后抵赖。



## 数字签名原理
### 一个数字签名至少应满足以下几个条件：
依赖性：数字签名必须是依赖于要签名报文的比特模式(类似于笔迹签名与被签文件的不可分离性)
唯一性：数字签名必须使用对签名者来说是唯一的信息，以防伪造和否认
可验证：数字签名必须是在算法上可验证的
抗伪造：伪造一个数字签名在计算上不可行，无论是通过以后的数字签名来构造新报文，还是对给定的报文构造一个虚假的数字签名(类似笔迹签名不可模仿性)
可用性：数字签名的产生、识别和证实必须相对简单，并且其备份在存储上是可实现的
### 数字签名的类别：
以方式分：
直接数字签名direct digital signature
仲裁数字签名arbitrated digital signature

以安全性分
无条件安全的数字签名
计算上安全的数字签名

 以可签名次数分
一次性的数字签名
多次性的数字签名
## 数字签名算法
### 普通数字签名算法
#### RSA 
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426201934400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
A的公钥私钥对{KUa||KRa}
A对消息M签名: SA=EKRa(M)
问题：
速度慢
信息量大
第三方仲裁时必须暴露明文信息
hash函数的无碰撞性保证了签名的有效性

##### 签名与加密
签名提供真实性(authentication)、加密提供保密性(confidentiality)
 “签名+加密”提供“真实性+保密性”
两种实现方式： (A→B)
1. 先签名，后加密： E~KUb~{M||Sig~A~(M)}
2. 先加密，后签名： {E~KUb~(M)||Sig~A~(E~KUb~(M))}

方式2的问题：
发生争议时，B需要向仲裁者提供自己的私钥
安全漏洞：攻击者E截获消息，把Sig~A~(E~KUb~(M))换成Sig~E~(E~KUb~(M))，让B以为该消息来自E
保存信息多：除了M，Sig~A~(E~KUb~(M))，还要保存E~KUb~(M)
 ∵KUb可能过期
#### EIGamal
EIGamal签名方案由T.ElGamal于1985年提出，其变体用于DSS中，其安全性依赖于有限域上离散对数的困难性上。
构造参数：
全局参数，p：一个大素数，g：Z~p~中乘法群Z~p~\*的一个生成元。
私钥参数，x：用户的私钥，x∈Z~p~\*
公钥参数，y：用户的公钥，y＝g^x^ mod p
算法中常还使用一个随机数k
##### EIGamal签名方案签名过程
给定要签名的明文M：
生成一个随机数k，k∈Zp\* 
计算r：r = g^k^ mod p
计算s：s = (H(M) – xr)k^-1^ mod p – 1，到此，签名结果为(r，s)
 把消息和签名结果(M，r，s)发给接收者
 
##### EIGamal签名方案认证过程
 取得发送方的公钥y；
预查合法性：若1≤r≤p－1，继续；否则，签名不合法
计算v1：v1＝y^r^r^s^ mod p； 
计算v2：v2＝g^H(M)^ mod p；
比较v1和v2 ：如果v1＝v2，表示签名有效；否则，无效

##### EIGamal签名方案证明：
先对s进行处理，有： 
S = (H(M) – xr)k^-1^ mod p – 1
ks = (H(M) – xr)k^-1^k mod p – 1 = (H(M) – xr) mod p – 1
H(M) = xr+ks mod p – 1
考察认证过程中的等式v2 = gH(M) mod p
v2 = g xr+ks mod ( p－1) mod p = (g x)r(g k)s  mod p
v2 = yrrs  mod p
因为v2 = v1所以该算法成立
#### DSS/DSA
数字签名标准
美国国家标准与技术研究所（NIST）公布的联邦信息标准FIPS186，称为数字签名算法（DSA）。

FIPS186-3的最新版本包括三个算法
DSA
基于RSA的数字签名算法RSA-PSS 
椭圆曲线的数字签名算法ECDSA 

与RSA不同，DSA算法是一种密钥方案，但不能用于加密或密钥交换。DSA的安全性建立在离散对数的困难性上。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426212407328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
全局公开密钥分量
p：素数，其中2^L-1^<p<2^L^，512<=L<1024，且L为64的倍数：即比特长度在512到1024之间，长度增量为64比特
q：(p-1)的素因子，其中2^159^<q<2^160^，比特长度为160
g=h^(p-1)^/ q mod p，其中h是一整数，1<h<(p-1)

用户私有密钥
x 随机或伪随机整数，其中0<x<q

用户公开密钥
y=g^x^ mod p

用户每个报文的密数
k随机或伪随机整数，其中0<k<q

签名
r=(g^k^mod p)mod q
s=[k^-1^(H(M)+xr)] mod q
签名=(r，s)

验证
w = (s')^-1^ mod q
u1 = [H(M')w] mod q，u2 = (r') w mod q
v = [(g^u1^y^u2^)mod p] mod q

TEST：v = r '

符号：
M：要签名的消息
H(M)：使用SHA-1生成的M的散列码
M '，r '，s ' ：接收到的M、r、s版本

DSS签名和验证
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426212857613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

DSS的特点
DSS的签名比验证快得多
DSS不能用于加密或者密钥分配
s^-1^ mod q要存在 ∅ s ≠ 0 mod q，如果发生，接收者可拒绝该签名。要求重新构造该签名，实际上，s ≡ 0 mod q的概率非常小。
若p为512位，q为160位，而DSS只需要两个160位，即320位

### 不可否认的数字签名算法
基本思想
一般的数字签名都是由发送方A将消息加密后送给接收方，任何一个只要知道A的公钥者都可以对此签名进行验证。
不可否认的签名是一种特殊的数字签名，它具有一些新颖的特性，没有签名者的合作，接收者就无法验证签名，在某种程度上保护了签名者的利益。
例如，软件开发者可利用不可否认的数字签名对他们的软件进行保护，使得只有付了钱的顾客才能验证签名并相信开发者仍然对软件负责。
### 群签名算法
群签名方案
群中各个成员以群的名义匿名地签发消息.，也称为团体签名
例：在投标中，所有投标公司组成一个团体，每个公司都用群签名方式对标书签名
群签名有如下特性：
只有群成员能代表所在的群签名
接收者能验证签名所在的群,但不知道签名者
需要时,可借助于群成员或者可信机构找到签名者
### 盲签名算法
假定请求签名者A，签名者(仲裁者)B。盲签名就是要求A让B签署一个文件，而不让B知悉文件的内容，仅仅要求以后在需要时B可以对他所签署的文件进行仲裁。
应用：电子货币，电子选举
盲签名的基本思想：求签名者把明文消息盲变换为M’，M’隐藏了明文M的内容；然后把M‘给签名者(仲裁者)进行签名，得到签名结果S(M’)；最后，求签名者取回S(M’)，采用解盲变换处理得到S(M)，就是M的签名
消息->盲变换->签名->接收者->逆盲变换

盲签名协议：
采用分割－选择(Cut - and - Choose)技术，可以使签名者B知道他签署的是哪方面的信息，但是还保留盲签名的特征
例：反间谍人员化名的签名
反间谍组织的成员身份保密，甚至机构头目也不知道。机构头目还要给每个成员一个签字文件，文件的内容是：持有该文件的**人具有外交豁免权。
文件中必须使用反间谍组织的成员的化名，另外机构头目也不能对任意的文件签名。假定成员为A，机构头目是签名者B
## 特殊的数字签名算法

# PGP
作者：Phil Zimmermann
提供可用于电子邮件和文件存储应用的保密与鉴别服务。
支持版本多。PGP支持各种系统平台和不同商业版本。
选择众所周知的算法，避免算法的安全性争议。如公钥加密包括RSA、DSS、Diffie-Hellman，对称加密包括CAST-128、IDEA、3DES、AES，以及SHA-1散列算法。
适用性强，既可用于机构，也可用于个人。
可自主使用，不由政府或标准化组织所控制。

## PGP安全服务
数字签名：DSS/SHA或RSA/SHA
消息加密：CAST-128或IDEA或3DES + Diffie-Hellman或RSA
数据压缩：ZIP
邮件兼容：Radix 64转换

## PGP运行流程 
K~s~：session key
K~Ra~、 K~Ua~：用户A的私钥和用户A的公钥
EP、DP：公钥加密和公钥解密
EC、DC：常规加密和常规加密
H：散列函数
Z：用ZIP算法数据压缩
R64：用radix64转换到ASCII格式

1. 认证 
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426213150652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)
说明：
1、 SHA-1生成消息的160的HASH码
2、SHA-1和RSA结合提供了一个高效的数字签名方案
3、DSS/SHA-1可选替代方案。

3. 加密
发送方
生成消息M并为该消息生成一个随机数作为会话密钥。
用会话密钥加密M（ CAST-128、IDEA或3DES ）
用接收者的公钥加密会话密钥（RSA）并与消息M结合
接收方
用自己的私钥解密恢复会话密钥
用会话密钥解密恢复消息M
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019042621323283.png)
加密：保密与鉴别同时运用
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426213249456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

3. 数据压缩
压缩的位置：发生在签名后、加密前。
压缩之前生成签名：
验证时无须压缩
压缩算法的多样性
在加密前压缩：压缩的报文更难分析
对邮件传输或存储都有节省空间的好处。

4. E-mail兼容性
加密后是任意的8位字节，很多邮件系统需要ASCII正文组成的块，需要转换到ASCII格式。
Radix64将3字节输入转换到4个ASCII字符，并带CRC校验，属盲目转换（即输入流即使是ASCII，算法也会将其转换）
5. 分段与重组
Email常常受限制于最大消息长度（一般限制在最大50000字节）
更长的消息要进行分段，每一段分别邮寄。
PGP自动分段并在接收时自动恢复。
签名只需一次，在第一段中。

## PGP消息的传送与接收
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426213413694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

## 发送消息的格式
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426213429526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

## PGP密钥需求
PGP使用四种类型的密钥：一次性会话的常规密钥，公钥，私钥，基于口令短语的常规密钥。

这些密钥存在三种独立需求：
需要一种生成不可预知的会话密钥的手段
需要某种手段来标识具体的密钥。
一个用户拥有多个公钥/私钥对。（更换，分组）

每个PGP实体需要维护一个文件保存其公钥私钥对，和一个文件保存通信对方的公钥。

## 会话密钥的生成
以CAST-128为例。

128位的随机数是由CAST-128自己生成的。输入包括一个128位的密钥和两个64位的数据块作为加密的输入。使用CFB方式，CAST-128产生两个64位的加密数据块，这两个数据块的结合构成128位的会话密钥。

作为明文输入的两个64位数据块，是从一个128位的随机数流中导出的。这些数基于用户的键盘输入的。键盘输入时间和内容用来产生随机流。因此，如果用户以他通常的步调敲击任意键，将会产生合理的随机性。


## 密钥标识符
一个用户有多个公钥/私钥对时，接收者如何知道发送者是用了哪个公钥来加密会话密钥？
将公钥与消息一起传送。（浪费空间）
将一个标识符与一个公钥关联。对一个用户来说做到一一对应。（管理上带来负担）
PGP给每个公开密钥指定KeyID， KeyID由公开密钥的最低64比特组成， 包括64个有效位：(K~Ua~ mod 2^64^)
PGP数字签名同样也需要KeyID。

## 密钥环
KeyID对于PGP非常关键。
两个keyID包含在任何PGP消息中，提供保密与鉴别功能。
需要一种系统化的方法存储和组织这些key以保证使用。

PGP在每一个节点上提供一对数据结构：
存储该节点拥有的公钥/私钥对；(私钥环)
存储本节点知道的其他用户的公钥；(公钥环)

## 私有密钥环
时间戳：密钥对生成的日期/时间；
密钥ID：公开密钥的低64位
私有密钥：密钥对的私有部分（该字段加密）
用户ID：该字段的典型值是用户的邮件地址，用户也可为每个密钥对选择不同的名字

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426213618347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

## 公开密钥环
UserID：公钥的拥有者。多个UserID可以对应一个公钥。
公钥环可以用UserID或KeyID索引。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426213636577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

## PGP —报文传输过程
签名：
从私钥环中得到私钥，利用userid作为索引
PGP提示输入口令短语，恢复私钥
构造签名部分

加密：
PGP产生一个会话密钥，并加密消息
PGP用接收者userid从公钥环中获取其公钥
构造消息的会话密钥部分

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426213659614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

## PGP —报文接收过程
解密消息
PGP用消息的会话密钥部分中的KeyID作为索引，从私钥环中获取私钥
PGP提示输入口令短语，恢复未加密的私钥
PGP恢复会话密钥，并解密消息

验证消息
用消息的签名部分中的KeyID作为索引，从公钥环中获取发送者的公钥
PGP恢复被传输过来的消息摘要
PGP对于接收到的消息作摘要，并与上一步的结果作比较
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426213731713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70)

## 公钥管理问题
由于PGP重在广泛地在正式或非正式环境下应用，没有建立严格的公钥管理模式。
如果A的公钥环上有一个从BBS上获得B发布的公钥，但已被C替换，这是就存在两条通道。C可以向A发信并冒充B的签名，A以为是来自B；A与B的任何加密消息C都可以读取。